/**
 * @license
 * Copyright 2010-2024 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
const REVISION = "172";
const MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 };
const TOUCH = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 };
const CullFaceNone = 0;
const CullFaceBack = 1;
const CullFaceFront = 2;
const CullFaceFrontBack = 3;
const BasicShadowMap = 0;
const PCFShadowMap = 1;
const PCFSoftShadowMap = 2;
const VSMShadowMap = 3;
const FrontSide = 0;
const BackSide = 1;
const DoubleSide = 2;
const NoBlending = 0;
const NormalBlending = 1;
const AdditiveBlending = 2;
const SubtractiveBlending = 3;
const MultiplyBlending = 4;
const CustomBlending = 5;
const AddEquation = 100;
const SubtractEquation = 101;
const ReverseSubtractEquation = 102;
const MinEquation = 103;
const MaxEquation = 104;
const ZeroFactor = 200;
const OneFactor = 201;
const SrcColorFactor = 202;
const OneMinusSrcColorFactor = 203;
const SrcAlphaFactor = 204;
const OneMinusSrcAlphaFactor = 205;
const DstAlphaFactor = 206;
const OneMinusDstAlphaFactor = 207;
const DstColorFactor = 208;
const OneMinusDstColorFactor = 209;
const SrcAlphaSaturateFactor = 210;
const ConstantColorFactor = 211;
const OneMinusConstantColorFactor = 212;
const ConstantAlphaFactor = 213;
const OneMinusConstantAlphaFactor = 214;
const NeverDepth = 0;
const AlwaysDepth = 1;
const LessDepth = 2;
const LessEqualDepth = 3;
const EqualDepth = 4;
const GreaterEqualDepth = 5;
const GreaterDepth = 6;
const NotEqualDepth = 7;
const MultiplyOperation = 0;
const MixOperation = 1;
const AddOperation = 2;
const NoToneMapping$1 = 0;
const LinearToneMapping = 1;
const ReinhardToneMapping = 2;
const CineonToneMapping = 3;
const ACESFilmicToneMapping = 4;
const CustomToneMapping = 5;
const AgXToneMapping = 6;
const NeutralToneMapping = 7;
const AttachedBindMode = "attached";
const DetachedBindMode = "detached";
const UVMapping = 300;
const CubeReflectionMapping = 301;
const CubeRefractionMapping = 302;
const EquirectangularReflectionMapping = 303;
const EquirectangularRefractionMapping = 304;
const CubeUVReflectionMapping = 306;
const RepeatWrapping = 1e3;
const ClampToEdgeWrapping = 1001;
const MirroredRepeatWrapping = 1002;
const NearestFilter = 1003;
const NearestMipmapNearestFilter = 1004;
const NearestMipMapNearestFilter = 1004;
const NearestMipmapLinearFilter = 1005;
const NearestMipMapLinearFilter = 1005;
const LinearFilter = 1006;
const LinearMipmapNearestFilter = 1007;
const LinearMipMapNearestFilter = 1007;
const LinearMipmapLinearFilter = 1008;
const LinearMipMapLinearFilter = 1008;
const UnsignedByteType = 1009;
const ByteType = 1010;
const ShortType = 1011;
const UnsignedShortType = 1012;
const IntType = 1013;
const UnsignedIntType = 1014;
const FloatType$1 = 1015;
const HalfFloatType = 1016;
const UnsignedShort4444Type = 1017;
const UnsignedShort5551Type = 1018;
const UnsignedInt248Type = 1020;
const UnsignedInt5999Type = 35902;
const AlphaFormat = 1021;
const RGBFormat = 1022;
const RGBAFormat = 1023;
const LuminanceFormat = 1024;
const LuminanceAlphaFormat = 1025;
const DepthFormat = 1026;
const DepthStencilFormat = 1027;
const RedFormat = 1028;
const RedIntegerFormat = 1029;
const RGFormat = 1030;
const RGIntegerFormat = 1031;
const RGBIntegerFormat = 1032;
const RGBAIntegerFormat = 1033;
const RGB_S3TC_DXT1_Format = 33776;
const RGBA_S3TC_DXT1_Format = 33777;
const RGBA_S3TC_DXT3_Format = 33778;
const RGBA_S3TC_DXT5_Format = 33779;
const RGB_PVRTC_4BPPV1_Format = 35840;
const RGB_PVRTC_2BPPV1_Format = 35841;
const RGBA_PVRTC_4BPPV1_Format = 35842;
const RGBA_PVRTC_2BPPV1_Format = 35843;
const RGB_ETC1_Format = 36196;
const RGB_ETC2_Format = 37492;
const RGBA_ETC2_EAC_Format = 37496;
const RGBA_ASTC_4x4_Format = 37808;
const RGBA_ASTC_5x4_Format = 37809;
const RGBA_ASTC_5x5_Format = 37810;
const RGBA_ASTC_6x5_Format = 37811;
const RGBA_ASTC_6x6_Format = 37812;
const RGBA_ASTC_8x5_Format = 37813;
const RGBA_ASTC_8x6_Format = 37814;
const RGBA_ASTC_8x8_Format = 37815;
const RGBA_ASTC_10x5_Format = 37816;
const RGBA_ASTC_10x6_Format = 37817;
const RGBA_ASTC_10x8_Format = 37818;
const RGBA_ASTC_10x10_Format = 37819;
const RGBA_ASTC_12x10_Format = 37820;
const RGBA_ASTC_12x12_Format = 37821;
const RGBA_BPTC_Format = 36492;
const RGB_BPTC_SIGNED_Format = 36494;
const RGB_BPTC_UNSIGNED_Format = 36495;
const RED_RGTC1_Format = 36283;
const SIGNED_RED_RGTC1_Format = 36284;
const RED_GREEN_RGTC2_Format = 36285;
const SIGNED_RED_GREEN_RGTC2_Format = 36286;
const LoopOnce = 2200;
const LoopRepeat = 2201;
const LoopPingPong = 2202;
const InterpolateDiscrete = 2300;
const InterpolateLinear = 2301;
const InterpolateSmooth = 2302;
const ZeroCurvatureEnding = 2400;
const ZeroSlopeEnding = 2401;
const WrapAroundEnding = 2402;
const NormalAnimationBlendMode = 2500;
const AdditiveAnimationBlendMode = 2501;
const TrianglesDrawMode = 0;
const TriangleStripDrawMode = 1;
const TriangleFanDrawMode = 2;
const BasicDepthPacking = 3200;
const RGBADepthPacking = 3201;
const RGBDepthPacking = 3202;
const RGDepthPacking = 3203;
const TangentSpaceNormalMap = 0;
const ObjectSpaceNormalMap = 1;
const NoColorSpace$1 = "";
const SRGBColorSpace$1 = "srgb";
const LinearSRGBColorSpace$1 = "srgb-linear";
const LinearTransfer$1 = "linear";
const SRGBTransfer$1 = "srgb";
const ZeroStencilOp = 0;
const KeepStencilOp = 7680;
const ReplaceStencilOp = 7681;
const IncrementStencilOp = 7682;
const DecrementStencilOp = 7683;
const IncrementWrapStencilOp = 34055;
const DecrementWrapStencilOp = 34056;
const InvertStencilOp = 5386;
const NeverStencilFunc = 512;
const LessStencilFunc = 513;
const EqualStencilFunc = 514;
const LessEqualStencilFunc = 515;
const GreaterStencilFunc = 516;
const NotEqualStencilFunc = 517;
const GreaterEqualStencilFunc = 518;
const AlwaysStencilFunc = 519;
const NeverCompare = 512;
const LessCompare = 513;
const EqualCompare = 514;
const LessEqualCompare = 515;
const GreaterCompare = 516;
const NotEqualCompare = 517;
const GreaterEqualCompare = 518;
const AlwaysCompare = 519;
const StaticDrawUsage$1 = 35044;
const DynamicDrawUsage = 35048;
const StreamDrawUsage = 35040;
const StaticReadUsage = 35045;
const DynamicReadUsage = 35049;
const StreamReadUsage = 35041;
const StaticCopyUsage = 35046;
const DynamicCopyUsage = 35050;
const StreamCopyUsage = 35042;
const GLSL1 = "100";
const GLSL3 = "300 es";
const WebGLCoordinateSystem$1 = 2e3;
const WebGPUCoordinateSystem$1 = 2001;
let EventDispatcher$1 = class EventDispatcher {
  addEventListener(type, listener) {
    if (this._listeners === void 0) this._listeners = {};
    const listeners = this._listeners;
    if (listeners[type] === void 0) {
      listeners[type] = [];
    }
    if (listeners[type].indexOf(listener) === -1) {
      listeners[type].push(listener);
    }
  }
  hasEventListener(type, listener) {
    if (this._listeners === void 0) return false;
    const listeners = this._listeners;
    return listeners[type] !== void 0 && listeners[type].indexOf(listener) !== -1;
  }
  removeEventListener(type, listener) {
    if (this._listeners === void 0) return;
    const listeners = this._listeners;
    const listenerArray = listeners[type];
    if (listenerArray !== void 0) {
      const index = listenerArray.indexOf(listener);
      if (index !== -1) {
        listenerArray.splice(index, 1);
      }
    }
  }
  dispatchEvent(event) {
    if (this._listeners === void 0) return;
    const listeners = this._listeners;
    const listenerArray = listeners[event.type];
    if (listenerArray !== void 0) {
      event.target = this;
      const array = listenerArray.slice(0);
      for (let i = 0, l = array.length; i < l; i++) {
        array[i].call(this, event);
      }
      event.target = null;
    }
  }
};
const _lut$1 = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
let _seed$1 = 1234567;
const DEG2RAD$1 = Math.PI / 180;
const RAD2DEG$1 = 180 / Math.PI;
function generateUUID$1() {
  const d0 = Math.random() * 4294967295 | 0;
  const d1 = Math.random() * 4294967295 | 0;
  const d2 = Math.random() * 4294967295 | 0;
  const d3 = Math.random() * 4294967295 | 0;
  const uuid = _lut$1[d0 & 255] + _lut$1[d0 >> 8 & 255] + _lut$1[d0 >> 16 & 255] + _lut$1[d0 >> 24 & 255] + "-" + _lut$1[d1 & 255] + _lut$1[d1 >> 8 & 255] + "-" + _lut$1[d1 >> 16 & 15 | 64] + _lut$1[d1 >> 24 & 255] + "-" + _lut$1[d2 & 63 | 128] + _lut$1[d2 >> 8 & 255] + "-" + _lut$1[d2 >> 16 & 255] + _lut$1[d2 >> 24 & 255] + _lut$1[d3 & 255] + _lut$1[d3 >> 8 & 255] + _lut$1[d3 >> 16 & 255] + _lut$1[d3 >> 24 & 255];
  return uuid.toLowerCase();
}
function clamp$2(value, min2, max2) {
  return Math.max(min2, Math.min(max2, value));
}
function euclideanModulo$1(n, m) {
  return (n % m + m) % m;
}
function mapLinear$1(x, a1, a2, b1, b2) {
  return b1 + (x - a1) * (b2 - b1) / (a2 - a1);
}
function inverseLerp$1(x, y, value) {
  if (x !== y) {
    return (value - x) / (y - x);
  } else {
    return 0;
  }
}
function lerp$1(x, y, t) {
  return (1 - t) * x + t * y;
}
function damp$1(x, y, lambda, dt) {
  return lerp$1(x, y, 1 - Math.exp(-lambda * dt));
}
function pingpong$1(x, length2 = 1) {
  return length2 - Math.abs(euclideanModulo$1(x, length2 * 2) - length2);
}
function smoothstep$2(x, min2, max2) {
  if (x <= min2) return 0;
  if (x >= max2) return 1;
  x = (x - min2) / (max2 - min2);
  return x * x * (3 - 2 * x);
}
function smootherstep$1(x, min2, max2) {
  if (x <= min2) return 0;
  if (x >= max2) return 1;
  x = (x - min2) / (max2 - min2);
  return x * x * x * (x * (x * 6 - 15) + 10);
}
function randInt$1(low, high) {
  return low + Math.floor(Math.random() * (high - low + 1));
}
function randFloat$1(low, high) {
  return low + Math.random() * (high - low);
}
function randFloatSpread$1(range) {
  return range * (0.5 - Math.random());
}
function seededRandom$1(s) {
  if (s !== void 0) _seed$1 = s;
  let t = _seed$1 += 1831565813;
  t = Math.imul(t ^ t >>> 15, t | 1);
  t ^= t + Math.imul(t ^ t >>> 7, t | 61);
  return ((t ^ t >>> 14) >>> 0) / 4294967296;
}
function degToRad$1(degrees2) {
  return degrees2 * DEG2RAD$1;
}
function radToDeg$1(radians2) {
  return radians2 * RAD2DEG$1;
}
function isPowerOfTwo$1(value) {
  return (value & value - 1) === 0 && value !== 0;
}
function ceilPowerOfTwo$1(value) {
  return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));
}
function floorPowerOfTwo$1(value) {
  return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));
}
function setQuaternionFromProperEuler$1(q, a, b, c, order) {
  const cos2 = Math.cos;
  const sin2 = Math.sin;
  const c2 = cos2(b / 2);
  const s2 = sin2(b / 2);
  const c13 = cos2((a + c) / 2);
  const s13 = sin2((a + c) / 2);
  const c1_3 = cos2((a - c) / 2);
  const s1_3 = sin2((a - c) / 2);
  const c3_1 = cos2((c - a) / 2);
  const s3_1 = sin2((c - a) / 2);
  switch (order) {
    case "XYX":
      q.set(c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13);
      break;
    case "YZY":
      q.set(s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13);
      break;
    case "ZXZ":
      q.set(s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13);
      break;
    case "XZX":
      q.set(c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13);
      break;
    case "YXY":
      q.set(s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13);
      break;
    case "ZYZ":
      q.set(s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13);
      break;
    default:
      console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + order);
  }
}
function denormalize$1(value, array) {
  switch (array.constructor) {
    case Float32Array:
      return value;
    case Uint32Array:
      return value / 4294967295;
    case Uint16Array:
      return value / 65535;
    case Uint8Array:
      return value / 255;
    case Int32Array:
      return Math.max(value / 2147483647, -1);
    case Int16Array:
      return Math.max(value / 32767, -1);
    case Int8Array:
      return Math.max(value / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
}
function normalize$2(value, array) {
  switch (array.constructor) {
    case Float32Array:
      return value;
    case Uint32Array:
      return Math.round(value * 4294967295);
    case Uint16Array:
      return Math.round(value * 65535);
    case Uint8Array:
      return Math.round(value * 255);
    case Int32Array:
      return Math.round(value * 2147483647);
    case Int16Array:
      return Math.round(value * 32767);
    case Int8Array:
      return Math.round(value * 127);
    default:
      throw new Error("Invalid component type.");
  }
}
const MathUtils$1 = {
  DEG2RAD: DEG2RAD$1,
  RAD2DEG: RAD2DEG$1,
  generateUUID: generateUUID$1,
  clamp: clamp$2,
  euclideanModulo: euclideanModulo$1,
  mapLinear: mapLinear$1,
  inverseLerp: inverseLerp$1,
  lerp: lerp$1,
  damp: damp$1,
  pingpong: pingpong$1,
  smoothstep: smoothstep$2,
  smootherstep: smootherstep$1,
  randInt: randInt$1,
  randFloat: randFloat$1,
  randFloatSpread: randFloatSpread$1,
  seededRandom: seededRandom$1,
  degToRad: degToRad$1,
  radToDeg: radToDeg$1,
  isPowerOfTwo: isPowerOfTwo$1,
  ceilPowerOfTwo: ceilPowerOfTwo$1,
  floorPowerOfTwo: floorPowerOfTwo$1,
  setQuaternionFromProperEuler: setQuaternionFromProperEuler$1,
  normalize: normalize$2,
  denormalize: denormalize$1
};
let Vector2$1 = class Vector2 {
  constructor(x = 0, y = 0) {
    Vector2.prototype.isVector2 = true;
    this.x = x;
    this.y = y;
  }
  get width() {
    return this.x;
  }
  set width(value) {
    this.x = value;
  }
  get height() {
    return this.y;
  }
  set height(value) {
    this.y = value;
  }
  set(x, y) {
    this.x = x;
    this.y = y;
    return this;
  }
  setScalar(scalar) {
    this.x = scalar;
    this.y = scalar;
    return this;
  }
  setX(x) {
    this.x = x;
    return this;
  }
  setY(y) {
    this.y = y;
    return this;
  }
  setComponent(index, value) {
    switch (index) {
      case 0:
        this.x = value;
        break;
      case 1:
        this.y = value;
        break;
      default:
        throw new Error("index is out of range: " + index);
    }
    return this;
  }
  getComponent(index) {
    switch (index) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + index);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(v) {
    this.x = v.x;
    this.y = v.y;
    return this;
  }
  add(v) {
    this.x += v.x;
    this.y += v.y;
    return this;
  }
  addScalar(s) {
    this.x += s;
    this.y += s;
    return this;
  }
  addVectors(a, b) {
    this.x = a.x + b.x;
    this.y = a.y + b.y;
    return this;
  }
  addScaledVector(v, s) {
    this.x += v.x * s;
    this.y += v.y * s;
    return this;
  }
  sub(v) {
    this.x -= v.x;
    this.y -= v.y;
    return this;
  }
  subScalar(s) {
    this.x -= s;
    this.y -= s;
    return this;
  }
  subVectors(a, b) {
    this.x = a.x - b.x;
    this.y = a.y - b.y;
    return this;
  }
  multiply(v) {
    this.x *= v.x;
    this.y *= v.y;
    return this;
  }
  multiplyScalar(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    return this;
  }
  divide(v) {
    this.x /= v.x;
    this.y /= v.y;
    return this;
  }
  divideScalar(scalar) {
    return this.multiplyScalar(1 / scalar);
  }
  applyMatrix3(m) {
    const x = this.x, y = this.y;
    const e = m.elements;
    this.x = e[0] * x + e[3] * y + e[6];
    this.y = e[1] * x + e[4] * y + e[7];
    return this;
  }
  min(v) {
    this.x = Math.min(this.x, v.x);
    this.y = Math.min(this.y, v.y);
    return this;
  }
  max(v) {
    this.x = Math.max(this.x, v.x);
    this.y = Math.max(this.y, v.y);
    return this;
  }
  clamp(min2, max2) {
    this.x = clamp$2(this.x, min2.x, max2.x);
    this.y = clamp$2(this.y, min2.y, max2.y);
    return this;
  }
  clampScalar(minVal, maxVal) {
    this.x = clamp$2(this.x, minVal, maxVal);
    this.y = clamp$2(this.y, minVal, maxVal);
    return this;
  }
  clampLength(min2, max2) {
    const length2 = this.length();
    return this.divideScalar(length2 || 1).multiplyScalar(clamp$2(length2, min2, max2));
  }
  floor() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    return this;
  }
  ceil() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    return this;
  }
  round() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    return this;
  }
  roundToZero() {
    this.x = Math.trunc(this.x);
    this.y = Math.trunc(this.y);
    return this;
  }
  negate() {
    this.x = -this.x;
    this.y = -this.y;
    return this;
  }
  dot(v) {
    return this.x * v.x + this.y * v.y;
  }
  cross(v) {
    return this.x * v.y - this.y * v.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    const angle = Math.atan2(-this.y, -this.x) + Math.PI;
    return angle;
  }
  angleTo(v) {
    const denominator = Math.sqrt(this.lengthSq() * v.lengthSq());
    if (denominator === 0) return Math.PI / 2;
    const theta = this.dot(v) / denominator;
    return Math.acos(clamp$2(theta, -1, 1));
  }
  distanceTo(v) {
    return Math.sqrt(this.distanceToSquared(v));
  }
  distanceToSquared(v) {
    const dx = this.x - v.x, dy = this.y - v.y;
    return dx * dx + dy * dy;
  }
  manhattanDistanceTo(v) {
    return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);
  }
  setLength(length2) {
    return this.normalize().multiplyScalar(length2);
  }
  lerp(v, alpha) {
    this.x += (v.x - this.x) * alpha;
    this.y += (v.y - this.y) * alpha;
    return this;
  }
  lerpVectors(v1, v2, alpha) {
    this.x = v1.x + (v2.x - v1.x) * alpha;
    this.y = v1.y + (v2.y - v1.y) * alpha;
    return this;
  }
  equals(v) {
    return v.x === this.x && v.y === this.y;
  }
  fromArray(array, offset = 0) {
    this.x = array[offset];
    this.y = array[offset + 1];
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this.x;
    array[offset + 1] = this.y;
    return array;
  }
  fromBufferAttribute(attribute, index) {
    this.x = attribute.getX(index);
    this.y = attribute.getY(index);
    return this;
  }
  rotateAround(center, angle) {
    const c = Math.cos(angle), s = Math.sin(angle);
    const x = this.x - center.x;
    const y = this.y - center.y;
    this.x = x * c - y * s + center.x;
    this.y = x * s + y * c + center.y;
    return this;
  }
  random() {
    this.x = Math.random();
    this.y = Math.random();
    return this;
  }
  *[Symbol.iterator]() {
    yield this.x;
    yield this.y;
  }
};
let Matrix3$1 = class Matrix3 {
  constructor(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
    Matrix3.prototype.isMatrix3 = true;
    this.elements = [
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ];
    if (n11 !== void 0) {
      this.set(n11, n12, n13, n21, n22, n23, n31, n32, n33);
    }
  }
  set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
    const te = this.elements;
    te[0] = n11;
    te[1] = n21;
    te[2] = n31;
    te[3] = n12;
    te[4] = n22;
    te[5] = n32;
    te[6] = n13;
    te[7] = n23;
    te[8] = n33;
    return this;
  }
  identity() {
    this.set(
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    );
    return this;
  }
  copy(m) {
    const te = this.elements;
    const me = m.elements;
    te[0] = me[0];
    te[1] = me[1];
    te[2] = me[2];
    te[3] = me[3];
    te[4] = me[4];
    te[5] = me[5];
    te[6] = me[6];
    te[7] = me[7];
    te[8] = me[8];
    return this;
  }
  extractBasis(xAxis, yAxis, zAxis) {
    xAxis.setFromMatrix3Column(this, 0);
    yAxis.setFromMatrix3Column(this, 1);
    zAxis.setFromMatrix3Column(this, 2);
    return this;
  }
  setFromMatrix4(m) {
    const me = m.elements;
    this.set(
      me[0],
      me[4],
      me[8],
      me[1],
      me[5],
      me[9],
      me[2],
      me[6],
      me[10]
    );
    return this;
  }
  multiply(m) {
    return this.multiplyMatrices(this, m);
  }
  premultiply(m) {
    return this.multiplyMatrices(m, this);
  }
  multiplyMatrices(a, b) {
    const ae = a.elements;
    const be = b.elements;
    const te = this.elements;
    const a11 = ae[0], a12 = ae[3], a13 = ae[6];
    const a21 = ae[1], a22 = ae[4], a23 = ae[7];
    const a31 = ae[2], a32 = ae[5], a33 = ae[8];
    const b11 = be[0], b12 = be[3], b13 = be[6];
    const b21 = be[1], b22 = be[4], b23 = be[7];
    const b31 = be[2], b32 = be[5], b33 = be[8];
    te[0] = a11 * b11 + a12 * b21 + a13 * b31;
    te[3] = a11 * b12 + a12 * b22 + a13 * b32;
    te[6] = a11 * b13 + a12 * b23 + a13 * b33;
    te[1] = a21 * b11 + a22 * b21 + a23 * b31;
    te[4] = a21 * b12 + a22 * b22 + a23 * b32;
    te[7] = a21 * b13 + a22 * b23 + a23 * b33;
    te[2] = a31 * b11 + a32 * b21 + a33 * b31;
    te[5] = a31 * b12 + a32 * b22 + a33 * b32;
    te[8] = a31 * b13 + a32 * b23 + a33 * b33;
    return this;
  }
  multiplyScalar(s) {
    const te = this.elements;
    te[0] *= s;
    te[3] *= s;
    te[6] *= s;
    te[1] *= s;
    te[4] *= s;
    te[7] *= s;
    te[2] *= s;
    te[5] *= s;
    te[8] *= s;
    return this;
  }
  determinant() {
    const te = this.elements;
    const a = te[0], b = te[1], c = te[2], d = te[3], e = te[4], f = te[5], g = te[6], h = te[7], i = te[8];
    return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;
  }
  invert() {
    const te = this.elements, n11 = te[0], n21 = te[1], n31 = te[2], n12 = te[3], n22 = te[4], n32 = te[5], n13 = te[6], n23 = te[7], n33 = te[8], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13, det = n11 * t11 + n21 * t12 + n31 * t13;
    if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const detInv = 1 / det;
    te[0] = t11 * detInv;
    te[1] = (n31 * n23 - n33 * n21) * detInv;
    te[2] = (n32 * n21 - n31 * n22) * detInv;
    te[3] = t12 * detInv;
    te[4] = (n33 * n11 - n31 * n13) * detInv;
    te[5] = (n31 * n12 - n32 * n11) * detInv;
    te[6] = t13 * detInv;
    te[7] = (n21 * n13 - n23 * n11) * detInv;
    te[8] = (n22 * n11 - n21 * n12) * detInv;
    return this;
  }
  transpose() {
    let tmp2;
    const m = this.elements;
    tmp2 = m[1];
    m[1] = m[3];
    m[3] = tmp2;
    tmp2 = m[2];
    m[2] = m[6];
    m[6] = tmp2;
    tmp2 = m[5];
    m[5] = m[7];
    m[7] = tmp2;
    return this;
  }
  getNormalMatrix(matrix4) {
    return this.setFromMatrix4(matrix4).invert().transpose();
  }
  transposeIntoArray(r) {
    const m = this.elements;
    r[0] = m[0];
    r[1] = m[3];
    r[2] = m[6];
    r[3] = m[1];
    r[4] = m[4];
    r[5] = m[7];
    r[6] = m[2];
    r[7] = m[5];
    r[8] = m[8];
    return this;
  }
  setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {
    const c = Math.cos(rotation);
    const s = Math.sin(rotation);
    this.set(
      sx * c,
      sx * s,
      -sx * (c * cx + s * cy) + cx + tx,
      -sy * s,
      sy * c,
      -sy * (-s * cx + c * cy) + cy + ty,
      0,
      0,
      1
    );
    return this;
  }
  //
  scale(sx, sy) {
    this.premultiply(_m3$1.makeScale(sx, sy));
    return this;
  }
  rotate(theta) {
    this.premultiply(_m3$1.makeRotation(-theta));
    return this;
  }
  translate(tx, ty) {
    this.premultiply(_m3$1.makeTranslation(tx, ty));
    return this;
  }
  // for 2D Transforms
  makeTranslation(x, y) {
    if (x.isVector2) {
      this.set(
        1,
        0,
        x.x,
        0,
        1,
        x.y,
        0,
        0,
        1
      );
    } else {
      this.set(
        1,
        0,
        x,
        0,
        1,
        y,
        0,
        0,
        1
      );
    }
    return this;
  }
  makeRotation(theta) {
    const c = Math.cos(theta);
    const s = Math.sin(theta);
    this.set(
      c,
      -s,
      0,
      s,
      c,
      0,
      0,
      0,
      1
    );
    return this;
  }
  makeScale(x, y) {
    this.set(
      x,
      0,
      0,
      0,
      y,
      0,
      0,
      0,
      1
    );
    return this;
  }
  //
  equals(matrix) {
    const te = this.elements;
    const me = matrix.elements;
    for (let i = 0; i < 9; i++) {
      if (te[i] !== me[i]) return false;
    }
    return true;
  }
  fromArray(array, offset = 0) {
    for (let i = 0; i < 9; i++) {
      this.elements[i] = array[i + offset];
    }
    return this;
  }
  toArray(array = [], offset = 0) {
    const te = this.elements;
    array[offset] = te[0];
    array[offset + 1] = te[1];
    array[offset + 2] = te[2];
    array[offset + 3] = te[3];
    array[offset + 4] = te[4];
    array[offset + 5] = te[5];
    array[offset + 6] = te[6];
    array[offset + 7] = te[7];
    array[offset + 8] = te[8];
    return array;
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
};
const _m3$1 = /* @__PURE__ */ new Matrix3$1();
function arrayNeedsUint32(array) {
  for (let i = array.length - 1; i >= 0; --i) {
    if (array[i] >= 65535) return true;
  }
  return false;
}
const TYPED_ARRAYS = {
  Int8Array,
  Uint8Array,
  Uint8ClampedArray,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array
};
function getTypedArray(type, buffer) {
  return new TYPED_ARRAYS[type](buffer);
}
function createElementNS(name) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", name);
}
function createCanvasElement() {
  const canvas = createElementNS("canvas");
  canvas.style.display = "block";
  return canvas;
}
const _cache = {};
function warnOnce(message) {
  if (message in _cache) return;
  _cache[message] = true;
  console.warn(message);
}
function probeAsync(gl, sync, interval) {
  return new Promise(function(resolve, reject) {
    function probe() {
      switch (gl.clientWaitSync(sync, gl.SYNC_FLUSH_COMMANDS_BIT, 0)) {
        case gl.WAIT_FAILED:
          reject();
          break;
        case gl.TIMEOUT_EXPIRED:
          setTimeout(probe, interval);
          break;
        default:
          resolve();
      }
    }
    setTimeout(probe, interval);
  });
}
function toNormalizedProjectionMatrix(projectionMatrix) {
  const m = projectionMatrix.elements;
  m[2] = 0.5 * m[2] + 0.5 * m[3];
  m[6] = 0.5 * m[6] + 0.5 * m[7];
  m[10] = 0.5 * m[10] + 0.5 * m[11];
  m[14] = 0.5 * m[14] + 0.5 * m[15];
}
function toReversedProjectionMatrix(projectionMatrix) {
  const m = projectionMatrix.elements;
  const isPerspectiveMatrix = m[11] === -1;
  if (isPerspectiveMatrix) {
    m[10] = -m[10] - 1;
    m[14] = -m[14];
  } else {
    m[10] = -m[10];
    m[14] = -m[14] + 1;
  }
}
const LINEAR_REC709_TO_XYZ$1 = /* @__PURE__ */ new Matrix3$1().set(
  0.4123908,
  0.3575843,
  0.1804808,
  0.212639,
  0.7151687,
  0.0721923,
  0.0193308,
  0.1191948,
  0.9505322
);
const XYZ_TO_LINEAR_REC709$1 = /* @__PURE__ */ new Matrix3$1().set(
  3.2409699,
  -1.5373832,
  -0.4986108,
  -0.9692436,
  1.8759675,
  0.0415551,
  0.0556301,
  -0.203977,
  1.0569715
);
function createColorManagement$1() {
  const ColorManagement2 = {
    enabled: true,
    workingColorSpace: LinearSRGBColorSpace$1,
    /**
     * Implementations of supported color spaces.
     *
     * Required:
     *	- primaries: chromaticity coordinates [ rx ry gx gy bx by ]
     *	- whitePoint: reference white [ x y ]
     *	- transfer: transfer function (pre-defined)
     *	- toXYZ: Matrix3 RGB to XYZ transform
     *	- fromXYZ: Matrix3 XYZ to RGB transform
     *	- luminanceCoefficients: RGB luminance coefficients
     *
     * Optional:
     *  - outputColorSpaceConfig: { drawingBufferColorSpace: ColorSpace }
     *  - workingColorSpaceConfig: { unpackColorSpace: ColorSpace }
     *
     * Reference:
     * - https://www.russellcottrell.com/photo/matrixCalculator.htm
     */
    spaces: {},
    convert: function(color2, sourceColorSpace, targetColorSpace) {
      if (this.enabled === false || sourceColorSpace === targetColorSpace || !sourceColorSpace || !targetColorSpace) {
        return color2;
      }
      if (this.spaces[sourceColorSpace].transfer === SRGBTransfer$1) {
        color2.r = SRGBToLinear$1(color2.r);
        color2.g = SRGBToLinear$1(color2.g);
        color2.b = SRGBToLinear$1(color2.b);
      }
      if (this.spaces[sourceColorSpace].primaries !== this.spaces[targetColorSpace].primaries) {
        color2.applyMatrix3(this.spaces[sourceColorSpace].toXYZ);
        color2.applyMatrix3(this.spaces[targetColorSpace].fromXYZ);
      }
      if (this.spaces[targetColorSpace].transfer === SRGBTransfer$1) {
        color2.r = LinearToSRGB$1(color2.r);
        color2.g = LinearToSRGB$1(color2.g);
        color2.b = LinearToSRGB$1(color2.b);
      }
      return color2;
    },
    fromWorkingColorSpace: function(color2, targetColorSpace) {
      return this.convert(color2, this.workingColorSpace, targetColorSpace);
    },
    toWorkingColorSpace: function(color2, sourceColorSpace) {
      return this.convert(color2, sourceColorSpace, this.workingColorSpace);
    },
    getPrimaries: function(colorSpace) {
      return this.spaces[colorSpace].primaries;
    },
    getTransfer: function(colorSpace) {
      if (colorSpace === NoColorSpace$1) return LinearTransfer$1;
      return this.spaces[colorSpace].transfer;
    },
    getLuminanceCoefficients: function(target, colorSpace = this.workingColorSpace) {
      return target.fromArray(this.spaces[colorSpace].luminanceCoefficients);
    },
    define: function(colorSpaces) {
      Object.assign(this.spaces, colorSpaces);
    },
    // Internal APIs
    _getMatrix: function(targetMatrix, sourceColorSpace, targetColorSpace) {
      return targetMatrix.copy(this.spaces[sourceColorSpace].toXYZ).multiply(this.spaces[targetColorSpace].fromXYZ);
    },
    _getDrawingBufferColorSpace: function(colorSpace) {
      return this.spaces[colorSpace].outputColorSpaceConfig.drawingBufferColorSpace;
    },
    _getUnpackColorSpace: function(colorSpace = this.workingColorSpace) {
      return this.spaces[colorSpace].workingColorSpaceConfig.unpackColorSpace;
    }
  };
  const REC709_PRIMARIES = [0.64, 0.33, 0.3, 0.6, 0.15, 0.06];
  const REC709_LUMINANCE_COEFFICIENTS = [0.2126, 0.7152, 0.0722];
  const D65 = [0.3127, 0.329];
  ColorManagement2.define({
    [LinearSRGBColorSpace$1]: {
      primaries: REC709_PRIMARIES,
      whitePoint: D65,
      transfer: LinearTransfer$1,
      toXYZ: LINEAR_REC709_TO_XYZ$1,
      fromXYZ: XYZ_TO_LINEAR_REC709$1,
      luminanceCoefficients: REC709_LUMINANCE_COEFFICIENTS,
      workingColorSpaceConfig: { unpackColorSpace: SRGBColorSpace$1 },
      outputColorSpaceConfig: { drawingBufferColorSpace: SRGBColorSpace$1 }
    },
    [SRGBColorSpace$1]: {
      primaries: REC709_PRIMARIES,
      whitePoint: D65,
      transfer: SRGBTransfer$1,
      toXYZ: LINEAR_REC709_TO_XYZ$1,
      fromXYZ: XYZ_TO_LINEAR_REC709$1,
      luminanceCoefficients: REC709_LUMINANCE_COEFFICIENTS,
      outputColorSpaceConfig: { drawingBufferColorSpace: SRGBColorSpace$1 }
    }
  });
  return ColorManagement2;
}
const ColorManagement$1 = /* @__PURE__ */ createColorManagement$1();
function SRGBToLinear$1(c) {
  return c < 0.04045 ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);
}
function LinearToSRGB$1(c) {
  return c < 31308e-7 ? c * 12.92 : 1.055 * Math.pow(c, 0.41666) - 0.055;
}
let _canvas;
class ImageUtils {
  static getDataURL(image) {
    if (/^data:/i.test(image.src)) {
      return image.src;
    }
    if (typeof HTMLCanvasElement === "undefined") {
      return image.src;
    }
    let canvas;
    if (image instanceof HTMLCanvasElement) {
      canvas = image;
    } else {
      if (_canvas === void 0) _canvas = createElementNS("canvas");
      _canvas.width = image.width;
      _canvas.height = image.height;
      const context2 = _canvas.getContext("2d");
      if (image instanceof ImageData) {
        context2.putImageData(image, 0, 0);
      } else {
        context2.drawImage(image, 0, 0, image.width, image.height);
      }
      canvas = _canvas;
    }
    if (canvas.width > 2048 || canvas.height > 2048) {
      console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", image);
      return canvas.toDataURL("image/jpeg", 0.6);
    } else {
      return canvas.toDataURL("image/png");
    }
  }
  static sRGBToLinear(image) {
    if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
      const canvas = createElementNS("canvas");
      canvas.width = image.width;
      canvas.height = image.height;
      const context2 = canvas.getContext("2d");
      context2.drawImage(image, 0, 0, image.width, image.height);
      const imageData = context2.getImageData(0, 0, image.width, image.height);
      const data = imageData.data;
      for (let i = 0; i < data.length; i++) {
        data[i] = SRGBToLinear$1(data[i] / 255) * 255;
      }
      context2.putImageData(imageData, 0, 0);
      return canvas;
    } else if (image.data) {
      const data = image.data.slice(0);
      for (let i = 0; i < data.length; i++) {
        if (data instanceof Uint8Array || data instanceof Uint8ClampedArray) {
          data[i] = Math.floor(SRGBToLinear$1(data[i] / 255) * 255);
        } else {
          data[i] = SRGBToLinear$1(data[i]);
        }
      }
      return {
        data,
        width: image.width,
        height: image.height
      };
    } else {
      console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied.");
      return image;
    }
  }
}
let _sourceId = 0;
class Source {
  constructor(data = null) {
    this.isSource = true;
    Object.defineProperty(this, "id", { value: _sourceId++ });
    this.uuid = generateUUID$1();
    this.data = data;
    this.dataReady = true;
    this.version = 0;
  }
  set needsUpdate(value) {
    if (value === true) this.version++;
  }
  toJSON(meta) {
    const isRootObject = meta === void 0 || typeof meta === "string";
    if (!isRootObject && meta.images[this.uuid] !== void 0) {
      return meta.images[this.uuid];
    }
    const output = {
      uuid: this.uuid,
      url: ""
    };
    const data = this.data;
    if (data !== null) {
      let url;
      if (Array.isArray(data)) {
        url = [];
        for (let i = 0, l = data.length; i < l; i++) {
          if (data[i].isDataTexture) {
            url.push(serializeImage(data[i].image));
          } else {
            url.push(serializeImage(data[i]));
          }
        }
      } else {
        url = serializeImage(data);
      }
      output.url = url;
    }
    if (!isRootObject) {
      meta.images[this.uuid] = output;
    }
    return output;
  }
}
function serializeImage(image) {
  if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
    return ImageUtils.getDataURL(image);
  } else {
    if (image.data) {
      return {
        data: Array.from(image.data),
        width: image.width,
        height: image.height,
        type: image.data.constructor.name
      };
    } else {
      console.warn("THREE.Texture: Unable to serialize Texture.");
      return {};
    }
  }
}
let _textureId = 0;
class Texture extends EventDispatcher$1 {
  constructor(image = Texture.DEFAULT_IMAGE, mapping = Texture.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = LinearMipmapLinearFilter, format = RGBAFormat, type = UnsignedByteType, anisotropy = Texture.DEFAULT_ANISOTROPY, colorSpace = NoColorSpace$1) {
    super();
    this.isTexture = true;
    Object.defineProperty(this, "id", { value: _textureId++ });
    this.uuid = generateUUID$1();
    this.name = "";
    this.source = new Source(image);
    this.mipmaps = [];
    this.mapping = mapping;
    this.channel = 0;
    this.wrapS = wrapS;
    this.wrapT = wrapT;
    this.magFilter = magFilter;
    this.minFilter = minFilter;
    this.anisotropy = anisotropy;
    this.format = format;
    this.internalFormat = null;
    this.type = type;
    this.offset = new Vector2$1(0, 0);
    this.repeat = new Vector2$1(1, 1);
    this.center = new Vector2$1(0, 0);
    this.rotation = 0;
    this.matrixAutoUpdate = true;
    this.matrix = new Matrix3$1();
    this.generateMipmaps = true;
    this.premultiplyAlpha = false;
    this.flipY = true;
    this.unpackAlignment = 4;
    this.colorSpace = colorSpace;
    this.userData = {};
    this.version = 0;
    this.onUpdate = null;
    this.renderTarget = null;
    this.isRenderTargetTexture = false;
    this.pmremVersion = 0;
  }
  get image() {
    return this.source.data;
  }
  set image(value = null) {
    this.source.data = value;
  }
  updateMatrix() {
    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(source) {
    this.name = source.name;
    this.source = source.source;
    this.mipmaps = source.mipmaps.slice(0);
    this.mapping = source.mapping;
    this.channel = source.channel;
    this.wrapS = source.wrapS;
    this.wrapT = source.wrapT;
    this.magFilter = source.magFilter;
    this.minFilter = source.minFilter;
    this.anisotropy = source.anisotropy;
    this.format = source.format;
    this.internalFormat = source.internalFormat;
    this.type = source.type;
    this.offset.copy(source.offset);
    this.repeat.copy(source.repeat);
    this.center.copy(source.center);
    this.rotation = source.rotation;
    this.matrixAutoUpdate = source.matrixAutoUpdate;
    this.matrix.copy(source.matrix);
    this.generateMipmaps = source.generateMipmaps;
    this.premultiplyAlpha = source.premultiplyAlpha;
    this.flipY = source.flipY;
    this.unpackAlignment = source.unpackAlignment;
    this.colorSpace = source.colorSpace;
    this.renderTarget = source.renderTarget;
    this.isRenderTargetTexture = source.isRenderTargetTexture;
    this.userData = JSON.parse(JSON.stringify(source.userData));
    this.needsUpdate = true;
    return this;
  }
  toJSON(meta) {
    const isRootObject = meta === void 0 || typeof meta === "string";
    if (!isRootObject && meta.textures[this.uuid] !== void 0) {
      return meta.textures[this.uuid];
    }
    const output = {
      metadata: {
        version: 4.6,
        type: "Texture",
        generator: "Texture.toJSON"
      },
      uuid: this.uuid,
      name: this.name,
      image: this.source.toJSON(meta).uuid,
      mapping: this.mapping,
      channel: this.channel,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      internalFormat: this.internalFormat,
      type: this.type,
      colorSpace: this.colorSpace,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      generateMipmaps: this.generateMipmaps,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment
    };
    if (Object.keys(this.userData).length > 0) output.userData = this.userData;
    if (!isRootObject) {
      meta.textures[this.uuid] = output;
    }
    return output;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  transformUv(uv) {
    if (this.mapping !== UVMapping) return uv;
    uv.applyMatrix3(this.matrix);
    if (uv.x < 0 || uv.x > 1) {
      switch (this.wrapS) {
        case RepeatWrapping:
          uv.x = uv.x - Math.floor(uv.x);
          break;
        case ClampToEdgeWrapping:
          uv.x = uv.x < 0 ? 0 : 1;
          break;
        case MirroredRepeatWrapping:
          if (Math.abs(Math.floor(uv.x) % 2) === 1) {
            uv.x = Math.ceil(uv.x) - uv.x;
          } else {
            uv.x = uv.x - Math.floor(uv.x);
          }
          break;
      }
    }
    if (uv.y < 0 || uv.y > 1) {
      switch (this.wrapT) {
        case RepeatWrapping:
          uv.y = uv.y - Math.floor(uv.y);
          break;
        case ClampToEdgeWrapping:
          uv.y = uv.y < 0 ? 0 : 1;
          break;
        case MirroredRepeatWrapping:
          if (Math.abs(Math.floor(uv.y) % 2) === 1) {
            uv.y = Math.ceil(uv.y) - uv.y;
          } else {
            uv.y = uv.y - Math.floor(uv.y);
          }
          break;
      }
    }
    if (this.flipY) {
      uv.y = 1 - uv.y;
    }
    return uv;
  }
  set needsUpdate(value) {
    if (value === true) {
      this.version++;
      this.source.needsUpdate = true;
    }
  }
  set needsPMREMUpdate(value) {
    if (value === true) {
      this.pmremVersion++;
    }
  }
}
Texture.DEFAULT_IMAGE = null;
Texture.DEFAULT_MAPPING = UVMapping;
Texture.DEFAULT_ANISOTROPY = 1;
let Vector4$1 = class Vector4 {
  constructor(x = 0, y = 0, z = 0, w = 1) {
    Vector4.prototype.isVector4 = true;
    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;
  }
  get width() {
    return this.z;
  }
  set width(value) {
    this.z = value;
  }
  get height() {
    return this.w;
  }
  set height(value) {
    this.w = value;
  }
  set(x, y, z, w) {
    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;
    return this;
  }
  setScalar(scalar) {
    this.x = scalar;
    this.y = scalar;
    this.z = scalar;
    this.w = scalar;
    return this;
  }
  setX(x) {
    this.x = x;
    return this;
  }
  setY(y) {
    this.y = y;
    return this;
  }
  setZ(z) {
    this.z = z;
    return this;
  }
  setW(w) {
    this.w = w;
    return this;
  }
  setComponent(index, value) {
    switch (index) {
      case 0:
        this.x = value;
        break;
      case 1:
        this.y = value;
        break;
      case 2:
        this.z = value;
        break;
      case 3:
        this.w = value;
        break;
      default:
        throw new Error("index is out of range: " + index);
    }
    return this;
  }
  getComponent(index) {
    switch (index) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + index);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(v) {
    this.x = v.x;
    this.y = v.y;
    this.z = v.z;
    this.w = v.w !== void 0 ? v.w : 1;
    return this;
  }
  add(v) {
    this.x += v.x;
    this.y += v.y;
    this.z += v.z;
    this.w += v.w;
    return this;
  }
  addScalar(s) {
    this.x += s;
    this.y += s;
    this.z += s;
    this.w += s;
    return this;
  }
  addVectors(a, b) {
    this.x = a.x + b.x;
    this.y = a.y + b.y;
    this.z = a.z + b.z;
    this.w = a.w + b.w;
    return this;
  }
  addScaledVector(v, s) {
    this.x += v.x * s;
    this.y += v.y * s;
    this.z += v.z * s;
    this.w += v.w * s;
    return this;
  }
  sub(v) {
    this.x -= v.x;
    this.y -= v.y;
    this.z -= v.z;
    this.w -= v.w;
    return this;
  }
  subScalar(s) {
    this.x -= s;
    this.y -= s;
    this.z -= s;
    this.w -= s;
    return this;
  }
  subVectors(a, b) {
    this.x = a.x - b.x;
    this.y = a.y - b.y;
    this.z = a.z - b.z;
    this.w = a.w - b.w;
    return this;
  }
  multiply(v) {
    this.x *= v.x;
    this.y *= v.y;
    this.z *= v.z;
    this.w *= v.w;
    return this;
  }
  multiplyScalar(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    this.z *= scalar;
    this.w *= scalar;
    return this;
  }
  applyMatrix4(m) {
    const x = this.x, y = this.y, z = this.z, w = this.w;
    const e = m.elements;
    this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;
    this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;
    this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;
    this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;
    return this;
  }
  divide(v) {
    this.x /= v.x;
    this.y /= v.y;
    this.z /= v.z;
    this.w /= v.w;
    return this;
  }
  divideScalar(scalar) {
    return this.multiplyScalar(1 / scalar);
  }
  setAxisAngleFromQuaternion(q) {
    this.w = 2 * Math.acos(q.w);
    const s = Math.sqrt(1 - q.w * q.w);
    if (s < 1e-4) {
      this.x = 1;
      this.y = 0;
      this.z = 0;
    } else {
      this.x = q.x / s;
      this.y = q.y / s;
      this.z = q.z / s;
    }
    return this;
  }
  setAxisAngleFromRotationMatrix(m) {
    let angle, x, y, z;
    const epsilon = 0.01, epsilon2 = 0.1, te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10];
    if (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {
      if (Math.abs(m12 + m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2) {
        this.set(1, 0, 0, 0);
        return this;
      }
      angle = Math.PI;
      const xx = (m11 + 1) / 2;
      const yy = (m22 + 1) / 2;
      const zz = (m33 + 1) / 2;
      const xy = (m12 + m21) / 4;
      const xz = (m13 + m31) / 4;
      const yz = (m23 + m32) / 4;
      if (xx > yy && xx > zz) {
        if (xx < epsilon) {
          x = 0;
          y = 0.707106781;
          z = 0.707106781;
        } else {
          x = Math.sqrt(xx);
          y = xy / x;
          z = xz / x;
        }
      } else if (yy > zz) {
        if (yy < epsilon) {
          x = 0.707106781;
          y = 0;
          z = 0.707106781;
        } else {
          y = Math.sqrt(yy);
          x = xy / y;
          z = yz / y;
        }
      } else {
        if (zz < epsilon) {
          x = 0.707106781;
          y = 0.707106781;
          z = 0;
        } else {
          z = Math.sqrt(zz);
          x = xz / z;
          y = yz / z;
        }
      }
      this.set(x, y, z, angle);
      return this;
    }
    let s = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12));
    if (Math.abs(s) < 1e-3) s = 1;
    this.x = (m32 - m23) / s;
    this.y = (m13 - m31) / s;
    this.z = (m21 - m12) / s;
    this.w = Math.acos((m11 + m22 + m33 - 1) / 2);
    return this;
  }
  setFromMatrixPosition(m) {
    const e = m.elements;
    this.x = e[12];
    this.y = e[13];
    this.z = e[14];
    this.w = e[15];
    return this;
  }
  min(v) {
    this.x = Math.min(this.x, v.x);
    this.y = Math.min(this.y, v.y);
    this.z = Math.min(this.z, v.z);
    this.w = Math.min(this.w, v.w);
    return this;
  }
  max(v) {
    this.x = Math.max(this.x, v.x);
    this.y = Math.max(this.y, v.y);
    this.z = Math.max(this.z, v.z);
    this.w = Math.max(this.w, v.w);
    return this;
  }
  clamp(min2, max2) {
    this.x = clamp$2(this.x, min2.x, max2.x);
    this.y = clamp$2(this.y, min2.y, max2.y);
    this.z = clamp$2(this.z, min2.z, max2.z);
    this.w = clamp$2(this.w, min2.w, max2.w);
    return this;
  }
  clampScalar(minVal, maxVal) {
    this.x = clamp$2(this.x, minVal, maxVal);
    this.y = clamp$2(this.y, minVal, maxVal);
    this.z = clamp$2(this.z, minVal, maxVal);
    this.w = clamp$2(this.w, minVal, maxVal);
    return this;
  }
  clampLength(min2, max2) {
    const length2 = this.length();
    return this.divideScalar(length2 || 1).multiplyScalar(clamp$2(length2, min2, max2));
  }
  floor() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    this.z = Math.floor(this.z);
    this.w = Math.floor(this.w);
    return this;
  }
  ceil() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    this.z = Math.ceil(this.z);
    this.w = Math.ceil(this.w);
    return this;
  }
  round() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    this.z = Math.round(this.z);
    this.w = Math.round(this.w);
    return this;
  }
  roundToZero() {
    this.x = Math.trunc(this.x);
    this.y = Math.trunc(this.y);
    this.z = Math.trunc(this.z);
    this.w = Math.trunc(this.w);
    return this;
  }
  negate() {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
    this.w = -this.w;
    return this;
  }
  dot(v) {
    return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(length2) {
    return this.normalize().multiplyScalar(length2);
  }
  lerp(v, alpha) {
    this.x += (v.x - this.x) * alpha;
    this.y += (v.y - this.y) * alpha;
    this.z += (v.z - this.z) * alpha;
    this.w += (v.w - this.w) * alpha;
    return this;
  }
  lerpVectors(v1, v2, alpha) {
    this.x = v1.x + (v2.x - v1.x) * alpha;
    this.y = v1.y + (v2.y - v1.y) * alpha;
    this.z = v1.z + (v2.z - v1.z) * alpha;
    this.w = v1.w + (v2.w - v1.w) * alpha;
    return this;
  }
  equals(v) {
    return v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w;
  }
  fromArray(array, offset = 0) {
    this.x = array[offset];
    this.y = array[offset + 1];
    this.z = array[offset + 2];
    this.w = array[offset + 3];
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this.x;
    array[offset + 1] = this.y;
    array[offset + 2] = this.z;
    array[offset + 3] = this.w;
    return array;
  }
  fromBufferAttribute(attribute, index) {
    this.x = attribute.getX(index);
    this.y = attribute.getY(index);
    this.z = attribute.getZ(index);
    this.w = attribute.getW(index);
    return this;
  }
  random() {
    this.x = Math.random();
    this.y = Math.random();
    this.z = Math.random();
    this.w = Math.random();
    return this;
  }
  *[Symbol.iterator]() {
    yield this.x;
    yield this.y;
    yield this.z;
    yield this.w;
  }
};
class RenderTarget extends EventDispatcher$1 {
  constructor(width = 1, height = 1, options = {}) {
    super();
    this.isRenderTarget = true;
    this.width = width;
    this.height = height;
    this.depth = 1;
    this.scissor = new Vector4$1(0, 0, width, height);
    this.scissorTest = false;
    this.viewport = new Vector4$1(0, 0, width, height);
    const image = { width, height, depth: 1 };
    options = Object.assign({
      generateMipmaps: false,
      internalFormat: null,
      minFilter: LinearFilter,
      depthBuffer: true,
      stencilBuffer: false,
      resolveDepthBuffer: true,
      resolveStencilBuffer: true,
      depthTexture: null,
      samples: 0,
      count: 1
    }, options);
    const texture = new Texture(image, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.colorSpace);
    texture.flipY = false;
    texture.generateMipmaps = options.generateMipmaps;
    texture.internalFormat = options.internalFormat;
    this.textures = [];
    const count = options.count;
    for (let i = 0; i < count; i++) {
      this.textures[i] = texture.clone();
      this.textures[i].isRenderTargetTexture = true;
      this.textures[i].renderTarget = this;
    }
    this.depthBuffer = options.depthBuffer;
    this.stencilBuffer = options.stencilBuffer;
    this.resolveDepthBuffer = options.resolveDepthBuffer;
    this.resolveStencilBuffer = options.resolveStencilBuffer;
    this._depthTexture = null;
    this.depthTexture = options.depthTexture;
    this.samples = options.samples;
  }
  get texture() {
    return this.textures[0];
  }
  set texture(value) {
    this.textures[0] = value;
  }
  set depthTexture(current) {
    if (this._depthTexture !== null) this._depthTexture.renderTarget = null;
    if (current !== null) current.renderTarget = this;
    this._depthTexture = current;
  }
  get depthTexture() {
    return this._depthTexture;
  }
  setSize(width, height, depth = 1) {
    if (this.width !== width || this.height !== height || this.depth !== depth) {
      this.width = width;
      this.height = height;
      this.depth = depth;
      for (let i = 0, il = this.textures.length; i < il; i++) {
        this.textures[i].image.width = width;
        this.textures[i].image.height = height;
        this.textures[i].image.depth = depth;
      }
      this.dispose();
    }
    this.viewport.set(0, 0, width, height);
    this.scissor.set(0, 0, width, height);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(source) {
    this.width = source.width;
    this.height = source.height;
    this.depth = source.depth;
    this.scissor.copy(source.scissor);
    this.scissorTest = source.scissorTest;
    this.viewport.copy(source.viewport);
    this.textures.length = 0;
    for (let i = 0, il = source.textures.length; i < il; i++) {
      this.textures[i] = source.textures[i].clone();
      this.textures[i].isRenderTargetTexture = true;
      this.textures[i].renderTarget = this;
    }
    const image = Object.assign({}, source.texture.image);
    this.texture.source = new Source(image);
    this.depthBuffer = source.depthBuffer;
    this.stencilBuffer = source.stencilBuffer;
    this.resolveDepthBuffer = source.resolveDepthBuffer;
    this.resolveStencilBuffer = source.resolveStencilBuffer;
    if (source.depthTexture !== null) this.depthTexture = source.depthTexture.clone();
    this.samples = source.samples;
    return this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class WebGLRenderTarget extends RenderTarget {
  constructor(width = 1, height = 1, options = {}) {
    super(width, height, options);
    this.isWebGLRenderTarget = true;
  }
}
class DataArrayTexture extends Texture {
  constructor(data = null, width = 1, height = 1, depth = 1) {
    super(null);
    this.isDataArrayTexture = true;
    this.image = { data, width, height, depth };
    this.magFilter = NearestFilter;
    this.minFilter = NearestFilter;
    this.wrapR = ClampToEdgeWrapping;
    this.generateMipmaps = false;
    this.flipY = false;
    this.unpackAlignment = 1;
    this.layerUpdates = /* @__PURE__ */ new Set();
  }
  addLayerUpdate(layerIndex) {
    this.layerUpdates.add(layerIndex);
  }
  clearLayerUpdates() {
    this.layerUpdates.clear();
  }
}
class WebGLArrayRenderTarget extends WebGLRenderTarget {
  constructor(width = 1, height = 1, depth = 1, options = {}) {
    super(width, height, options);
    this.isWebGLArrayRenderTarget = true;
    this.depth = depth;
    this.texture = new DataArrayTexture(null, width, height, depth);
    this.texture.isRenderTargetTexture = true;
  }
}
class Data3DTexture extends Texture {
  constructor(data = null, width = 1, height = 1, depth = 1) {
    super(null);
    this.isData3DTexture = true;
    this.image = { data, width, height, depth };
    this.magFilter = NearestFilter;
    this.minFilter = NearestFilter;
    this.wrapR = ClampToEdgeWrapping;
    this.generateMipmaps = false;
    this.flipY = false;
    this.unpackAlignment = 1;
  }
}
class WebGL3DRenderTarget extends WebGLRenderTarget {
  constructor(width = 1, height = 1, depth = 1, options = {}) {
    super(width, height, options);
    this.isWebGL3DRenderTarget = true;
    this.depth = depth;
    this.texture = new Data3DTexture(null, width, height, depth);
    this.texture.isRenderTargetTexture = true;
  }
}
let Quaternion$1 = class Quaternion {
  constructor(x = 0, y = 0, z = 0, w = 1) {
    this.isQuaternion = true;
    this._x = x;
    this._y = y;
    this._z = z;
    this._w = w;
  }
  static slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {
    let x0 = src0[srcOffset0 + 0], y0 = src0[srcOffset0 + 1], z0 = src0[srcOffset0 + 2], w0 = src0[srcOffset0 + 3];
    const x1 = src1[srcOffset1 + 0], y1 = src1[srcOffset1 + 1], z1 = src1[srcOffset1 + 2], w1 = src1[srcOffset1 + 3];
    if (t === 0) {
      dst[dstOffset + 0] = x0;
      dst[dstOffset + 1] = y0;
      dst[dstOffset + 2] = z0;
      dst[dstOffset + 3] = w0;
      return;
    }
    if (t === 1) {
      dst[dstOffset + 0] = x1;
      dst[dstOffset + 1] = y1;
      dst[dstOffset + 2] = z1;
      dst[dstOffset + 3] = w1;
      return;
    }
    if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
      let s = 1 - t;
      const cos2 = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1, dir = cos2 >= 0 ? 1 : -1, sqrSin = 1 - cos2 * cos2;
      if (sqrSin > Number.EPSILON) {
        const sin2 = Math.sqrt(sqrSin), len = Math.atan2(sin2, cos2 * dir);
        s = Math.sin(s * len) / sin2;
        t = Math.sin(t * len) / sin2;
      }
      const tDir = t * dir;
      x0 = x0 * s + x1 * tDir;
      y0 = y0 * s + y1 * tDir;
      z0 = z0 * s + z1 * tDir;
      w0 = w0 * s + w1 * tDir;
      if (s === 1 - t) {
        const f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
        x0 *= f;
        y0 *= f;
        z0 *= f;
        w0 *= f;
      }
    }
    dst[dstOffset] = x0;
    dst[dstOffset + 1] = y0;
    dst[dstOffset + 2] = z0;
    dst[dstOffset + 3] = w0;
  }
  static multiplyQuaternionsFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1) {
    const x0 = src0[srcOffset0];
    const y0 = src0[srcOffset0 + 1];
    const z0 = src0[srcOffset0 + 2];
    const w0 = src0[srcOffset0 + 3];
    const x1 = src1[srcOffset1];
    const y1 = src1[srcOffset1 + 1];
    const z1 = src1[srcOffset1 + 2];
    const w1 = src1[srcOffset1 + 3];
    dst[dstOffset] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
    dst[dstOffset + 1] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
    dst[dstOffset + 2] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
    dst[dstOffset + 3] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;
    return dst;
  }
  get x() {
    return this._x;
  }
  set x(value) {
    this._x = value;
    this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(value) {
    this._y = value;
    this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(value) {
    this._z = value;
    this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(value) {
    this._w = value;
    this._onChangeCallback();
  }
  set(x, y, z, w) {
    this._x = x;
    this._y = y;
    this._z = z;
    this._w = w;
    this._onChangeCallback();
    return this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(quaternion) {
    this._x = quaternion.x;
    this._y = quaternion.y;
    this._z = quaternion.z;
    this._w = quaternion.w;
    this._onChangeCallback();
    return this;
  }
  setFromEuler(euler, update = true) {
    const x = euler._x, y = euler._y, z = euler._z, order = euler._order;
    const cos2 = Math.cos;
    const sin2 = Math.sin;
    const c1 = cos2(x / 2);
    const c2 = cos2(y / 2);
    const c3 = cos2(z / 2);
    const s1 = sin2(x / 2);
    const s2 = sin2(y / 2);
    const s3 = sin2(z / 2);
    switch (order) {
      case "XYZ":
        this._x = s1 * c2 * c3 + c1 * s2 * s3;
        this._y = c1 * s2 * c3 - s1 * c2 * s3;
        this._z = c1 * c2 * s3 + s1 * s2 * c3;
        this._w = c1 * c2 * c3 - s1 * s2 * s3;
        break;
      case "YXZ":
        this._x = s1 * c2 * c3 + c1 * s2 * s3;
        this._y = c1 * s2 * c3 - s1 * c2 * s3;
        this._z = c1 * c2 * s3 - s1 * s2 * c3;
        this._w = c1 * c2 * c3 + s1 * s2 * s3;
        break;
      case "ZXY":
        this._x = s1 * c2 * c3 - c1 * s2 * s3;
        this._y = c1 * s2 * c3 + s1 * c2 * s3;
        this._z = c1 * c2 * s3 + s1 * s2 * c3;
        this._w = c1 * c2 * c3 - s1 * s2 * s3;
        break;
      case "ZYX":
        this._x = s1 * c2 * c3 - c1 * s2 * s3;
        this._y = c1 * s2 * c3 + s1 * c2 * s3;
        this._z = c1 * c2 * s3 - s1 * s2 * c3;
        this._w = c1 * c2 * c3 + s1 * s2 * s3;
        break;
      case "YZX":
        this._x = s1 * c2 * c3 + c1 * s2 * s3;
        this._y = c1 * s2 * c3 + s1 * c2 * s3;
        this._z = c1 * c2 * s3 - s1 * s2 * c3;
        this._w = c1 * c2 * c3 - s1 * s2 * s3;
        break;
      case "XZY":
        this._x = s1 * c2 * c3 - c1 * s2 * s3;
        this._y = c1 * s2 * c3 - s1 * c2 * s3;
        this._z = c1 * c2 * s3 + s1 * s2 * c3;
        this._w = c1 * c2 * c3 + s1 * s2 * s3;
        break;
      default:
        console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + order);
    }
    if (update === true) this._onChangeCallback();
    return this;
  }
  setFromAxisAngle(axis, angle) {
    const halfAngle = angle / 2, s = Math.sin(halfAngle);
    this._x = axis.x * s;
    this._y = axis.y * s;
    this._z = axis.z * s;
    this._w = Math.cos(halfAngle);
    this._onChangeCallback();
    return this;
  }
  setFromRotationMatrix(m) {
    const te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10], trace = m11 + m22 + m33;
    if (trace > 0) {
      const s = 0.5 / Math.sqrt(trace + 1);
      this._w = 0.25 / s;
      this._x = (m32 - m23) * s;
      this._y = (m13 - m31) * s;
      this._z = (m21 - m12) * s;
    } else if (m11 > m22 && m11 > m33) {
      const s = 2 * Math.sqrt(1 + m11 - m22 - m33);
      this._w = (m32 - m23) / s;
      this._x = 0.25 * s;
      this._y = (m12 + m21) / s;
      this._z = (m13 + m31) / s;
    } else if (m22 > m33) {
      const s = 2 * Math.sqrt(1 + m22 - m11 - m33);
      this._w = (m13 - m31) / s;
      this._x = (m12 + m21) / s;
      this._y = 0.25 * s;
      this._z = (m23 + m32) / s;
    } else {
      const s = 2 * Math.sqrt(1 + m33 - m11 - m22);
      this._w = (m21 - m12) / s;
      this._x = (m13 + m31) / s;
      this._y = (m23 + m32) / s;
      this._z = 0.25 * s;
    }
    this._onChangeCallback();
    return this;
  }
  setFromUnitVectors(vFrom, vTo) {
    let r = vFrom.dot(vTo) + 1;
    if (r < Number.EPSILON) {
      r = 0;
      if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
        this._x = -vFrom.y;
        this._y = vFrom.x;
        this._z = 0;
        this._w = r;
      } else {
        this._x = 0;
        this._y = -vFrom.z;
        this._z = vFrom.y;
        this._w = r;
      }
    } else {
      this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
      this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
      this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
      this._w = r;
    }
    return this.normalize();
  }
  angleTo(q) {
    return 2 * Math.acos(Math.abs(clamp$2(this.dot(q), -1, 1)));
  }
  rotateTowards(q, step2) {
    const angle = this.angleTo(q);
    if (angle === 0) return this;
    const t = Math.min(1, step2 / angle);
    this.slerp(q, t);
    return this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    this._x *= -1;
    this._y *= -1;
    this._z *= -1;
    this._onChangeCallback();
    return this;
  }
  dot(v) {
    return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
  }
  lengthSq() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  }
  length() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  }
  normalize() {
    let l = this.length();
    if (l === 0) {
      this._x = 0;
      this._y = 0;
      this._z = 0;
      this._w = 1;
    } else {
      l = 1 / l;
      this._x = this._x * l;
      this._y = this._y * l;
      this._z = this._z * l;
      this._w = this._w * l;
    }
    this._onChangeCallback();
    return this;
  }
  multiply(q) {
    return this.multiplyQuaternions(this, q);
  }
  premultiply(q) {
    return this.multiplyQuaternions(q, this);
  }
  multiplyQuaternions(a, b) {
    const qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
    const qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;
    this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
    this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
    this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
    this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
    this._onChangeCallback();
    return this;
  }
  slerp(qb, t) {
    if (t === 0) return this;
    if (t === 1) return this.copy(qb);
    const x = this._x, y = this._y, z = this._z, w = this._w;
    let cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;
    if (cosHalfTheta < 0) {
      this._w = -qb._w;
      this._x = -qb._x;
      this._y = -qb._y;
      this._z = -qb._z;
      cosHalfTheta = -cosHalfTheta;
    } else {
      this.copy(qb);
    }
    if (cosHalfTheta >= 1) {
      this._w = w;
      this._x = x;
      this._y = y;
      this._z = z;
      return this;
    }
    const sqrSinHalfTheta = 1 - cosHalfTheta * cosHalfTheta;
    if (sqrSinHalfTheta <= Number.EPSILON) {
      const s = 1 - t;
      this._w = s * w + t * this._w;
      this._x = s * x + t * this._x;
      this._y = s * y + t * this._y;
      this._z = s * z + t * this._z;
      this.normalize();
      return this;
    }
    const sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
    const halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
    const ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta, ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
    this._w = w * ratioA + this._w * ratioB;
    this._x = x * ratioA + this._x * ratioB;
    this._y = y * ratioA + this._y * ratioB;
    this._z = z * ratioA + this._z * ratioB;
    this._onChangeCallback();
    return this;
  }
  slerpQuaternions(qa, qb, t) {
    return this.copy(qa).slerp(qb, t);
  }
  random() {
    const theta1 = 2 * Math.PI * Math.random();
    const theta2 = 2 * Math.PI * Math.random();
    const x0 = Math.random();
    const r1 = Math.sqrt(1 - x0);
    const r2 = Math.sqrt(x0);
    return this.set(
      r1 * Math.sin(theta1),
      r1 * Math.cos(theta1),
      r2 * Math.sin(theta2),
      r2 * Math.cos(theta2)
    );
  }
  equals(quaternion) {
    return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;
  }
  fromArray(array, offset = 0) {
    this._x = array[offset];
    this._y = array[offset + 1];
    this._z = array[offset + 2];
    this._w = array[offset + 3];
    this._onChangeCallback();
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this._x;
    array[offset + 1] = this._y;
    array[offset + 2] = this._z;
    array[offset + 3] = this._w;
    return array;
  }
  fromBufferAttribute(attribute, index) {
    this._x = attribute.getX(index);
    this._y = attribute.getY(index);
    this._z = attribute.getZ(index);
    this._w = attribute.getW(index);
    this._onChangeCallback();
    return this;
  }
  toJSON() {
    return this.toArray();
  }
  _onChange(callback) {
    this._onChangeCallback = callback;
    return this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x;
    yield this._y;
    yield this._z;
    yield this._w;
  }
};
let Vector3$1 = class Vector3 {
  constructor(x = 0, y = 0, z = 0) {
    Vector3.prototype.isVector3 = true;
    this.x = x;
    this.y = y;
    this.z = z;
  }
  set(x, y, z) {
    if (z === void 0) z = this.z;
    this.x = x;
    this.y = y;
    this.z = z;
    return this;
  }
  setScalar(scalar) {
    this.x = scalar;
    this.y = scalar;
    this.z = scalar;
    return this;
  }
  setX(x) {
    this.x = x;
    return this;
  }
  setY(y) {
    this.y = y;
    return this;
  }
  setZ(z) {
    this.z = z;
    return this;
  }
  setComponent(index, value) {
    switch (index) {
      case 0:
        this.x = value;
        break;
      case 1:
        this.y = value;
        break;
      case 2:
        this.z = value;
        break;
      default:
        throw new Error("index is out of range: " + index);
    }
    return this;
  }
  getComponent(index) {
    switch (index) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + index);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(v) {
    this.x = v.x;
    this.y = v.y;
    this.z = v.z;
    return this;
  }
  add(v) {
    this.x += v.x;
    this.y += v.y;
    this.z += v.z;
    return this;
  }
  addScalar(s) {
    this.x += s;
    this.y += s;
    this.z += s;
    return this;
  }
  addVectors(a, b) {
    this.x = a.x + b.x;
    this.y = a.y + b.y;
    this.z = a.z + b.z;
    return this;
  }
  addScaledVector(v, s) {
    this.x += v.x * s;
    this.y += v.y * s;
    this.z += v.z * s;
    return this;
  }
  sub(v) {
    this.x -= v.x;
    this.y -= v.y;
    this.z -= v.z;
    return this;
  }
  subScalar(s) {
    this.x -= s;
    this.y -= s;
    this.z -= s;
    return this;
  }
  subVectors(a, b) {
    this.x = a.x - b.x;
    this.y = a.y - b.y;
    this.z = a.z - b.z;
    return this;
  }
  multiply(v) {
    this.x *= v.x;
    this.y *= v.y;
    this.z *= v.z;
    return this;
  }
  multiplyScalar(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    this.z *= scalar;
    return this;
  }
  multiplyVectors(a, b) {
    this.x = a.x * b.x;
    this.y = a.y * b.y;
    this.z = a.z * b.z;
    return this;
  }
  applyEuler(euler) {
    return this.applyQuaternion(_quaternion$4.setFromEuler(euler));
  }
  applyAxisAngle(axis, angle) {
    return this.applyQuaternion(_quaternion$4.setFromAxisAngle(axis, angle));
  }
  applyMatrix3(m) {
    const x = this.x, y = this.y, z = this.z;
    const e = m.elements;
    this.x = e[0] * x + e[3] * y + e[6] * z;
    this.y = e[1] * x + e[4] * y + e[7] * z;
    this.z = e[2] * x + e[5] * y + e[8] * z;
    return this;
  }
  applyNormalMatrix(m) {
    return this.applyMatrix3(m).normalize();
  }
  applyMatrix4(m) {
    const x = this.x, y = this.y, z = this.z;
    const e = m.elements;
    const w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);
    this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w;
    this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w;
    this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w;
    return this;
  }
  applyQuaternion(q) {
    const vx = this.x, vy = this.y, vz = this.z;
    const qx = q.x, qy = q.y, qz = q.z, qw = q.w;
    const tx = 2 * (qy * vz - qz * vy);
    const ty = 2 * (qz * vx - qx * vz);
    const tz = 2 * (qx * vy - qy * vx);
    this.x = vx + qw * tx + qy * tz - qz * ty;
    this.y = vy + qw * ty + qz * tx - qx * tz;
    this.z = vz + qw * tz + qx * ty - qy * tx;
    return this;
  }
  project(camera) {
    return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);
  }
  unproject(camera) {
    return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);
  }
  transformDirection(m) {
    const x = this.x, y = this.y, z = this.z;
    const e = m.elements;
    this.x = e[0] * x + e[4] * y + e[8] * z;
    this.y = e[1] * x + e[5] * y + e[9] * z;
    this.z = e[2] * x + e[6] * y + e[10] * z;
    return this.normalize();
  }
  divide(v) {
    this.x /= v.x;
    this.y /= v.y;
    this.z /= v.z;
    return this;
  }
  divideScalar(scalar) {
    return this.multiplyScalar(1 / scalar);
  }
  min(v) {
    this.x = Math.min(this.x, v.x);
    this.y = Math.min(this.y, v.y);
    this.z = Math.min(this.z, v.z);
    return this;
  }
  max(v) {
    this.x = Math.max(this.x, v.x);
    this.y = Math.max(this.y, v.y);
    this.z = Math.max(this.z, v.z);
    return this;
  }
  clamp(min2, max2) {
    this.x = clamp$2(this.x, min2.x, max2.x);
    this.y = clamp$2(this.y, min2.y, max2.y);
    this.z = clamp$2(this.z, min2.z, max2.z);
    return this;
  }
  clampScalar(minVal, maxVal) {
    this.x = clamp$2(this.x, minVal, maxVal);
    this.y = clamp$2(this.y, minVal, maxVal);
    this.z = clamp$2(this.z, minVal, maxVal);
    return this;
  }
  clampLength(min2, max2) {
    const length2 = this.length();
    return this.divideScalar(length2 || 1).multiplyScalar(clamp$2(length2, min2, max2));
  }
  floor() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    this.z = Math.floor(this.z);
    return this;
  }
  ceil() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    this.z = Math.ceil(this.z);
    return this;
  }
  round() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    this.z = Math.round(this.z);
    return this;
  }
  roundToZero() {
    this.x = Math.trunc(this.x);
    this.y = Math.trunc(this.y);
    this.z = Math.trunc(this.z);
    return this;
  }
  negate() {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
    return this;
  }
  dot(v) {
    return this.x * v.x + this.y * v.y + this.z * v.z;
  }
  // TODO lengthSquared?
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(length2) {
    return this.normalize().multiplyScalar(length2);
  }
  lerp(v, alpha) {
    this.x += (v.x - this.x) * alpha;
    this.y += (v.y - this.y) * alpha;
    this.z += (v.z - this.z) * alpha;
    return this;
  }
  lerpVectors(v1, v2, alpha) {
    this.x = v1.x + (v2.x - v1.x) * alpha;
    this.y = v1.y + (v2.y - v1.y) * alpha;
    this.z = v1.z + (v2.z - v1.z) * alpha;
    return this;
  }
  cross(v) {
    return this.crossVectors(this, v);
  }
  crossVectors(a, b) {
    const ax = a.x, ay = a.y, az = a.z;
    const bx = b.x, by = b.y, bz = b.z;
    this.x = ay * bz - az * by;
    this.y = az * bx - ax * bz;
    this.z = ax * by - ay * bx;
    return this;
  }
  projectOnVector(v) {
    const denominator = v.lengthSq();
    if (denominator === 0) return this.set(0, 0, 0);
    const scalar = v.dot(this) / denominator;
    return this.copy(v).multiplyScalar(scalar);
  }
  projectOnPlane(planeNormal) {
    _vector$c.copy(this).projectOnVector(planeNormal);
    return this.sub(_vector$c);
  }
  reflect(normal) {
    return this.sub(_vector$c.copy(normal).multiplyScalar(2 * this.dot(normal)));
  }
  angleTo(v) {
    const denominator = Math.sqrt(this.lengthSq() * v.lengthSq());
    if (denominator === 0) return Math.PI / 2;
    const theta = this.dot(v) / denominator;
    return Math.acos(clamp$2(theta, -1, 1));
  }
  distanceTo(v) {
    return Math.sqrt(this.distanceToSquared(v));
  }
  distanceToSquared(v) {
    const dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;
    return dx * dx + dy * dy + dz * dz;
  }
  manhattanDistanceTo(v) {
    return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);
  }
  setFromSpherical(s) {
    return this.setFromSphericalCoords(s.radius, s.phi, s.theta);
  }
  setFromSphericalCoords(radius, phi, theta) {
    const sinPhiRadius = Math.sin(phi) * radius;
    this.x = sinPhiRadius * Math.sin(theta);
    this.y = Math.cos(phi) * radius;
    this.z = sinPhiRadius * Math.cos(theta);
    return this;
  }
  setFromCylindrical(c) {
    return this.setFromCylindricalCoords(c.radius, c.theta, c.y);
  }
  setFromCylindricalCoords(radius, theta, y) {
    this.x = radius * Math.sin(theta);
    this.y = y;
    this.z = radius * Math.cos(theta);
    return this;
  }
  setFromMatrixPosition(m) {
    const e = m.elements;
    this.x = e[12];
    this.y = e[13];
    this.z = e[14];
    return this;
  }
  setFromMatrixScale(m) {
    const sx = this.setFromMatrixColumn(m, 0).length();
    const sy = this.setFromMatrixColumn(m, 1).length();
    const sz = this.setFromMatrixColumn(m, 2).length();
    this.x = sx;
    this.y = sy;
    this.z = sz;
    return this;
  }
  setFromMatrixColumn(m, index) {
    return this.fromArray(m.elements, index * 4);
  }
  setFromMatrix3Column(m, index) {
    return this.fromArray(m.elements, index * 3);
  }
  setFromEuler(e) {
    this.x = e._x;
    this.y = e._y;
    this.z = e._z;
    return this;
  }
  setFromColor(c) {
    this.x = c.r;
    this.y = c.g;
    this.z = c.b;
    return this;
  }
  equals(v) {
    return v.x === this.x && v.y === this.y && v.z === this.z;
  }
  fromArray(array, offset = 0) {
    this.x = array[offset];
    this.y = array[offset + 1];
    this.z = array[offset + 2];
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this.x;
    array[offset + 1] = this.y;
    array[offset + 2] = this.z;
    return array;
  }
  fromBufferAttribute(attribute, index) {
    this.x = attribute.getX(index);
    this.y = attribute.getY(index);
    this.z = attribute.getZ(index);
    return this;
  }
  random() {
    this.x = Math.random();
    this.y = Math.random();
    this.z = Math.random();
    return this;
  }
  randomDirection() {
    const theta = Math.random() * Math.PI * 2;
    const u = Math.random() * 2 - 1;
    const c = Math.sqrt(1 - u * u);
    this.x = c * Math.cos(theta);
    this.y = u;
    this.z = c * Math.sin(theta);
    return this;
  }
  *[Symbol.iterator]() {
    yield this.x;
    yield this.y;
    yield this.z;
  }
};
const _vector$c = /* @__PURE__ */ new Vector3$1();
const _quaternion$4 = /* @__PURE__ */ new Quaternion$1();
class Box3 {
  constructor(min2 = new Vector3$1(Infinity, Infinity, Infinity), max2 = new Vector3$1(-Infinity, -Infinity, -Infinity)) {
    this.isBox3 = true;
    this.min = min2;
    this.max = max2;
  }
  set(min2, max2) {
    this.min.copy(min2);
    this.max.copy(max2);
    return this;
  }
  setFromArray(array) {
    this.makeEmpty();
    for (let i = 0, il = array.length; i < il; i += 3) {
      this.expandByPoint(_vector$b.fromArray(array, i));
    }
    return this;
  }
  setFromBufferAttribute(attribute) {
    this.makeEmpty();
    for (let i = 0, il = attribute.count; i < il; i++) {
      this.expandByPoint(_vector$b.fromBufferAttribute(attribute, i));
    }
    return this;
  }
  setFromPoints(points) {
    this.makeEmpty();
    for (let i = 0, il = points.length; i < il; i++) {
      this.expandByPoint(points[i]);
    }
    return this;
  }
  setFromCenterAndSize(center, size) {
    const halfSize = _vector$b.copy(size).multiplyScalar(0.5);
    this.min.copy(center).sub(halfSize);
    this.max.copy(center).add(halfSize);
    return this;
  }
  setFromObject(object, precise = false) {
    this.makeEmpty();
    return this.expandByObject(object, precise);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(box) {
    this.min.copy(box.min);
    this.max.copy(box.max);
    return this;
  }
  makeEmpty() {
    this.min.x = this.min.y = this.min.z = Infinity;
    this.max.x = this.max.y = this.max.z = -Infinity;
    return this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  }
  getCenter(target) {
    return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(target) {
    return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);
  }
  expandByPoint(point) {
    this.min.min(point);
    this.max.max(point);
    return this;
  }
  expandByVector(vector) {
    this.min.sub(vector);
    this.max.add(vector);
    return this;
  }
  expandByScalar(scalar) {
    this.min.addScalar(-scalar);
    this.max.addScalar(scalar);
    return this;
  }
  expandByObject(object, precise = false) {
    object.updateWorldMatrix(false, false);
    const geometry = object.geometry;
    if (geometry !== void 0) {
      const positionAttribute = geometry.getAttribute("position");
      if (precise === true && positionAttribute !== void 0 && object.isInstancedMesh !== true) {
        for (let i = 0, l = positionAttribute.count; i < l; i++) {
          if (object.isMesh === true) {
            object.getVertexPosition(i, _vector$b);
          } else {
            _vector$b.fromBufferAttribute(positionAttribute, i);
          }
          _vector$b.applyMatrix4(object.matrixWorld);
          this.expandByPoint(_vector$b);
        }
      } else {
        if (object.boundingBox !== void 0) {
          if (object.boundingBox === null) {
            object.computeBoundingBox();
          }
          _box$4.copy(object.boundingBox);
        } else {
          if (geometry.boundingBox === null) {
            geometry.computeBoundingBox();
          }
          _box$4.copy(geometry.boundingBox);
        }
        _box$4.applyMatrix4(object.matrixWorld);
        this.union(_box$4);
      }
    }
    const children = object.children;
    for (let i = 0, l = children.length; i < l; i++) {
      this.expandByObject(children[i], precise);
    }
    return this;
  }
  containsPoint(point) {
    return point.x >= this.min.x && point.x <= this.max.x && point.y >= this.min.y && point.y <= this.max.y && point.z >= this.min.z && point.z <= this.max.z;
  }
  containsBox(box) {
    return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;
  }
  getParameter(point, target) {
    return target.set(
      (point.x - this.min.x) / (this.max.x - this.min.x),
      (point.y - this.min.y) / (this.max.y - this.min.y),
      (point.z - this.min.z) / (this.max.z - this.min.z)
    );
  }
  intersectsBox(box) {
    return box.max.x >= this.min.x && box.min.x <= this.max.x && box.max.y >= this.min.y && box.min.y <= this.max.y && box.max.z >= this.min.z && box.min.z <= this.max.z;
  }
  intersectsSphere(sphere) {
    this.clampPoint(sphere.center, _vector$b);
    return _vector$b.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;
  }
  intersectsPlane(plane) {
    let min2, max2;
    if (plane.normal.x > 0) {
      min2 = plane.normal.x * this.min.x;
      max2 = plane.normal.x * this.max.x;
    } else {
      min2 = plane.normal.x * this.max.x;
      max2 = plane.normal.x * this.min.x;
    }
    if (plane.normal.y > 0) {
      min2 += plane.normal.y * this.min.y;
      max2 += plane.normal.y * this.max.y;
    } else {
      min2 += plane.normal.y * this.max.y;
      max2 += plane.normal.y * this.min.y;
    }
    if (plane.normal.z > 0) {
      min2 += plane.normal.z * this.min.z;
      max2 += plane.normal.z * this.max.z;
    } else {
      min2 += plane.normal.z * this.max.z;
      max2 += plane.normal.z * this.min.z;
    }
    return min2 <= -plane.constant && max2 >= -plane.constant;
  }
  intersectsTriangle(triangle) {
    if (this.isEmpty()) {
      return false;
    }
    this.getCenter(_center);
    _extents.subVectors(this.max, _center);
    _v0$2.subVectors(triangle.a, _center);
    _v1$7.subVectors(triangle.b, _center);
    _v2$4.subVectors(triangle.c, _center);
    _f0.subVectors(_v1$7, _v0$2);
    _f1.subVectors(_v2$4, _v1$7);
    _f2.subVectors(_v0$2, _v2$4);
    let axes = [
      0,
      -_f0.z,
      _f0.y,
      0,
      -_f1.z,
      _f1.y,
      0,
      -_f2.z,
      _f2.y,
      _f0.z,
      0,
      -_f0.x,
      _f1.z,
      0,
      -_f1.x,
      _f2.z,
      0,
      -_f2.x,
      -_f0.y,
      _f0.x,
      0,
      -_f1.y,
      _f1.x,
      0,
      -_f2.y,
      _f2.x,
      0
    ];
    if (!satForAxes(axes, _v0$2, _v1$7, _v2$4, _extents)) {
      return false;
    }
    axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];
    if (!satForAxes(axes, _v0$2, _v1$7, _v2$4, _extents)) {
      return false;
    }
    _triangleNormal.crossVectors(_f0, _f1);
    axes = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z];
    return satForAxes(axes, _v0$2, _v1$7, _v2$4, _extents);
  }
  clampPoint(point, target) {
    return target.copy(point).clamp(this.min, this.max);
  }
  distanceToPoint(point) {
    return this.clampPoint(point, _vector$b).distanceTo(point);
  }
  getBoundingSphere(target) {
    if (this.isEmpty()) {
      target.makeEmpty();
    } else {
      this.getCenter(target.center);
      target.radius = this.getSize(_vector$b).length() * 0.5;
    }
    return target;
  }
  intersect(box) {
    this.min.max(box.min);
    this.max.min(box.max);
    if (this.isEmpty()) this.makeEmpty();
    return this;
  }
  union(box) {
    this.min.min(box.min);
    this.max.max(box.max);
    return this;
  }
  applyMatrix4(matrix) {
    if (this.isEmpty()) return this;
    _points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix);
    _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix);
    _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix);
    _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix);
    _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix);
    _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix);
    _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix);
    _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix);
    this.setFromPoints(_points);
    return this;
  }
  translate(offset) {
    this.min.add(offset);
    this.max.add(offset);
    return this;
  }
  equals(box) {
    return box.min.equals(this.min) && box.max.equals(this.max);
  }
}
const _points = [
  /* @__PURE__ */ new Vector3$1(),
  /* @__PURE__ */ new Vector3$1(),
  /* @__PURE__ */ new Vector3$1(),
  /* @__PURE__ */ new Vector3$1(),
  /* @__PURE__ */ new Vector3$1(),
  /* @__PURE__ */ new Vector3$1(),
  /* @__PURE__ */ new Vector3$1(),
  /* @__PURE__ */ new Vector3$1()
];
const _vector$b = /* @__PURE__ */ new Vector3$1();
const _box$4 = /* @__PURE__ */ new Box3();
const _v0$2 = /* @__PURE__ */ new Vector3$1();
const _v1$7 = /* @__PURE__ */ new Vector3$1();
const _v2$4 = /* @__PURE__ */ new Vector3$1();
const _f0 = /* @__PURE__ */ new Vector3$1();
const _f1 = /* @__PURE__ */ new Vector3$1();
const _f2 = /* @__PURE__ */ new Vector3$1();
const _center = /* @__PURE__ */ new Vector3$1();
const _extents = /* @__PURE__ */ new Vector3$1();
const _triangleNormal = /* @__PURE__ */ new Vector3$1();
const _testAxis = /* @__PURE__ */ new Vector3$1();
function satForAxes(axes, v0, v1, v2, extents) {
  for (let i = 0, j = axes.length - 3; i <= j; i += 3) {
    _testAxis.fromArray(axes, i);
    const r = extents.x * Math.abs(_testAxis.x) + extents.y * Math.abs(_testAxis.y) + extents.z * Math.abs(_testAxis.z);
    const p0 = v0.dot(_testAxis);
    const p1 = v1.dot(_testAxis);
    const p2 = v2.dot(_testAxis);
    if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r) {
      return false;
    }
  }
  return true;
}
const _box$3 = /* @__PURE__ */ new Box3();
const _v1$6 = /* @__PURE__ */ new Vector3$1();
const _v2$3 = /* @__PURE__ */ new Vector3$1();
class Sphere {
  constructor(center = new Vector3$1(), radius = -1) {
    this.isSphere = true;
    this.center = center;
    this.radius = radius;
  }
  set(center, radius) {
    this.center.copy(center);
    this.radius = radius;
    return this;
  }
  setFromPoints(points, optionalCenter) {
    const center = this.center;
    if (optionalCenter !== void 0) {
      center.copy(optionalCenter);
    } else {
      _box$3.setFromPoints(points).getCenter(center);
    }
    let maxRadiusSq = 0;
    for (let i = 0, il = points.length; i < il; i++) {
      maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));
    }
    this.radius = Math.sqrt(maxRadiusSq);
    return this;
  }
  copy(sphere) {
    this.center.copy(sphere.center);
    this.radius = sphere.radius;
    return this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    this.center.set(0, 0, 0);
    this.radius = -1;
    return this;
  }
  containsPoint(point) {
    return point.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(point) {
    return point.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(sphere) {
    const radiusSum = this.radius + sphere.radius;
    return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;
  }
  intersectsBox(box) {
    return box.intersectsSphere(this);
  }
  intersectsPlane(plane) {
    return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(point, target) {
    const deltaLengthSq = this.center.distanceToSquared(point);
    target.copy(point);
    if (deltaLengthSq > this.radius * this.radius) {
      target.sub(this.center).normalize();
      target.multiplyScalar(this.radius).add(this.center);
    }
    return target;
  }
  getBoundingBox(target) {
    if (this.isEmpty()) {
      target.makeEmpty();
      return target;
    }
    target.set(this.center, this.center);
    target.expandByScalar(this.radius);
    return target;
  }
  applyMatrix4(matrix) {
    this.center.applyMatrix4(matrix);
    this.radius = this.radius * matrix.getMaxScaleOnAxis();
    return this;
  }
  translate(offset) {
    this.center.add(offset);
    return this;
  }
  expandByPoint(point) {
    if (this.isEmpty()) {
      this.center.copy(point);
      this.radius = 0;
      return this;
    }
    _v1$6.subVectors(point, this.center);
    const lengthSq2 = _v1$6.lengthSq();
    if (lengthSq2 > this.radius * this.radius) {
      const length2 = Math.sqrt(lengthSq2);
      const delta = (length2 - this.radius) * 0.5;
      this.center.addScaledVector(_v1$6, delta / length2);
      this.radius += delta;
    }
    return this;
  }
  union(sphere) {
    if (sphere.isEmpty()) {
      return this;
    }
    if (this.isEmpty()) {
      this.copy(sphere);
      return this;
    }
    if (this.center.equals(sphere.center) === true) {
      this.radius = Math.max(this.radius, sphere.radius);
    } else {
      _v2$3.subVectors(sphere.center, this.center).setLength(sphere.radius);
      this.expandByPoint(_v1$6.copy(sphere.center).add(_v2$3));
      this.expandByPoint(_v1$6.copy(sphere.center).sub(_v2$3));
    }
    return this;
  }
  equals(sphere) {
    return sphere.center.equals(this.center) && sphere.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const _vector$a = /* @__PURE__ */ new Vector3$1();
const _segCenter = /* @__PURE__ */ new Vector3$1();
const _segDir = /* @__PURE__ */ new Vector3$1();
const _diff = /* @__PURE__ */ new Vector3$1();
const _edge1 = /* @__PURE__ */ new Vector3$1();
const _edge2 = /* @__PURE__ */ new Vector3$1();
const _normal$1 = /* @__PURE__ */ new Vector3$1();
class Ray {
  constructor(origin = new Vector3$1(), direction = new Vector3$1(0, 0, -1)) {
    this.origin = origin;
    this.direction = direction;
  }
  set(origin, direction) {
    this.origin.copy(origin);
    this.direction.copy(direction);
    return this;
  }
  copy(ray) {
    this.origin.copy(ray.origin);
    this.direction.copy(ray.direction);
    return this;
  }
  at(t, target) {
    return target.copy(this.origin).addScaledVector(this.direction, t);
  }
  lookAt(v) {
    this.direction.copy(v).sub(this.origin).normalize();
    return this;
  }
  recast(t) {
    this.origin.copy(this.at(t, _vector$a));
    return this;
  }
  closestPointToPoint(point, target) {
    target.subVectors(point, this.origin);
    const directionDistance = target.dot(this.direction);
    if (directionDistance < 0) {
      return target.copy(this.origin);
    }
    return target.copy(this.origin).addScaledVector(this.direction, directionDistance);
  }
  distanceToPoint(point) {
    return Math.sqrt(this.distanceSqToPoint(point));
  }
  distanceSqToPoint(point) {
    const directionDistance = _vector$a.subVectors(point, this.origin).dot(this.direction);
    if (directionDistance < 0) {
      return this.origin.distanceToSquared(point);
    }
    _vector$a.copy(this.origin).addScaledVector(this.direction, directionDistance);
    return _vector$a.distanceToSquared(point);
  }
  distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {
    _segCenter.copy(v0).add(v1).multiplyScalar(0.5);
    _segDir.copy(v1).sub(v0).normalize();
    _diff.copy(this.origin).sub(_segCenter);
    const segExtent = v0.distanceTo(v1) * 0.5;
    const a01 = -this.direction.dot(_segDir);
    const b0 = _diff.dot(this.direction);
    const b1 = -_diff.dot(_segDir);
    const c = _diff.lengthSq();
    const det = Math.abs(1 - a01 * a01);
    let s0, s1, sqrDist, extDet;
    if (det > 0) {
      s0 = a01 * b1 - b0;
      s1 = a01 * b0 - b1;
      extDet = segExtent * det;
      if (s0 >= 0) {
        if (s1 >= -extDet) {
          if (s1 <= extDet) {
            const invDet = 1 / det;
            s0 *= invDet;
            s1 *= invDet;
            sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;
          } else {
            s1 = segExtent;
            s0 = Math.max(0, -(a01 * s1 + b0));
            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
          }
        } else {
          s1 = -segExtent;
          s0 = Math.max(0, -(a01 * s1 + b0));
          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
        }
      } else {
        if (s1 <= -extDet) {
          s0 = Math.max(0, -(-a01 * segExtent + b0));
          s1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
        } else if (s1 <= extDet) {
          s0 = 0;
          s1 = Math.min(Math.max(-segExtent, -b1), segExtent);
          sqrDist = s1 * (s1 + 2 * b1) + c;
        } else {
          s0 = Math.max(0, -(a01 * segExtent + b0));
          s1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
        }
      }
    } else {
      s1 = a01 > 0 ? -segExtent : segExtent;
      s0 = Math.max(0, -(a01 * s1 + b0));
      sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
    }
    if (optionalPointOnRay) {
      optionalPointOnRay.copy(this.origin).addScaledVector(this.direction, s0);
    }
    if (optionalPointOnSegment) {
      optionalPointOnSegment.copy(_segCenter).addScaledVector(_segDir, s1);
    }
    return sqrDist;
  }
  intersectSphere(sphere, target) {
    _vector$a.subVectors(sphere.center, this.origin);
    const tca = _vector$a.dot(this.direction);
    const d2 = _vector$a.dot(_vector$a) - tca * tca;
    const radius2 = sphere.radius * sphere.radius;
    if (d2 > radius2) return null;
    const thc = Math.sqrt(radius2 - d2);
    const t0 = tca - thc;
    const t1 = tca + thc;
    if (t1 < 0) return null;
    if (t0 < 0) return this.at(t1, target);
    return this.at(t0, target);
  }
  intersectsSphere(sphere) {
    return this.distanceSqToPoint(sphere.center) <= sphere.radius * sphere.radius;
  }
  distanceToPlane(plane) {
    const denominator = plane.normal.dot(this.direction);
    if (denominator === 0) {
      if (plane.distanceToPoint(this.origin) === 0) {
        return 0;
      }
      return null;
    }
    const t = -(this.origin.dot(plane.normal) + plane.constant) / denominator;
    return t >= 0 ? t : null;
  }
  intersectPlane(plane, target) {
    const t = this.distanceToPlane(plane);
    if (t === null) {
      return null;
    }
    return this.at(t, target);
  }
  intersectsPlane(plane) {
    const distToPoint = plane.distanceToPoint(this.origin);
    if (distToPoint === 0) {
      return true;
    }
    const denominator = plane.normal.dot(this.direction);
    if (denominator * distToPoint < 0) {
      return true;
    }
    return false;
  }
  intersectBox(box, target) {
    let tmin, tmax, tymin, tymax, tzmin, tzmax;
    const invdirx = 1 / this.direction.x, invdiry = 1 / this.direction.y, invdirz = 1 / this.direction.z;
    const origin = this.origin;
    if (invdirx >= 0) {
      tmin = (box.min.x - origin.x) * invdirx;
      tmax = (box.max.x - origin.x) * invdirx;
    } else {
      tmin = (box.max.x - origin.x) * invdirx;
      tmax = (box.min.x - origin.x) * invdirx;
    }
    if (invdiry >= 0) {
      tymin = (box.min.y - origin.y) * invdiry;
      tymax = (box.max.y - origin.y) * invdiry;
    } else {
      tymin = (box.max.y - origin.y) * invdiry;
      tymax = (box.min.y - origin.y) * invdiry;
    }
    if (tmin > tymax || tymin > tmax) return null;
    if (tymin > tmin || isNaN(tmin)) tmin = tymin;
    if (tymax < tmax || isNaN(tmax)) tmax = tymax;
    if (invdirz >= 0) {
      tzmin = (box.min.z - origin.z) * invdirz;
      tzmax = (box.max.z - origin.z) * invdirz;
    } else {
      tzmin = (box.max.z - origin.z) * invdirz;
      tzmax = (box.min.z - origin.z) * invdirz;
    }
    if (tmin > tzmax || tzmin > tmax) return null;
    if (tzmin > tmin || tmin !== tmin) tmin = tzmin;
    if (tzmax < tmax || tmax !== tmax) tmax = tzmax;
    if (tmax < 0) return null;
    return this.at(tmin >= 0 ? tmin : tmax, target);
  }
  intersectsBox(box) {
    return this.intersectBox(box, _vector$a) !== null;
  }
  intersectTriangle(a, b, c, backfaceCulling, target) {
    _edge1.subVectors(b, a);
    _edge2.subVectors(c, a);
    _normal$1.crossVectors(_edge1, _edge2);
    let DdN = this.direction.dot(_normal$1);
    let sign2;
    if (DdN > 0) {
      if (backfaceCulling) return null;
      sign2 = 1;
    } else if (DdN < 0) {
      sign2 = -1;
      DdN = -DdN;
    } else {
      return null;
    }
    _diff.subVectors(this.origin, a);
    const DdQxE2 = sign2 * this.direction.dot(_edge2.crossVectors(_diff, _edge2));
    if (DdQxE2 < 0) {
      return null;
    }
    const DdE1xQ = sign2 * this.direction.dot(_edge1.cross(_diff));
    if (DdE1xQ < 0) {
      return null;
    }
    if (DdQxE2 + DdE1xQ > DdN) {
      return null;
    }
    const QdN = -sign2 * _diff.dot(_normal$1);
    if (QdN < 0) {
      return null;
    }
    return this.at(QdN / DdN, target);
  }
  applyMatrix4(matrix4) {
    this.origin.applyMatrix4(matrix4);
    this.direction.transformDirection(matrix4);
    return this;
  }
  equals(ray) {
    return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
let Matrix4$1 = class Matrix4 {
  constructor(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
    Matrix4.prototype.isMatrix4 = true;
    this.elements = [
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ];
    if (n11 !== void 0) {
      this.set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44);
    }
  }
  set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
    const te = this.elements;
    te[0] = n11;
    te[4] = n12;
    te[8] = n13;
    te[12] = n14;
    te[1] = n21;
    te[5] = n22;
    te[9] = n23;
    te[13] = n24;
    te[2] = n31;
    te[6] = n32;
    te[10] = n33;
    te[14] = n34;
    te[3] = n41;
    te[7] = n42;
    te[11] = n43;
    te[15] = n44;
    return this;
  }
  identity() {
    this.set(
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  clone() {
    return new Matrix4().fromArray(this.elements);
  }
  copy(m) {
    const te = this.elements;
    const me = m.elements;
    te[0] = me[0];
    te[1] = me[1];
    te[2] = me[2];
    te[3] = me[3];
    te[4] = me[4];
    te[5] = me[5];
    te[6] = me[6];
    te[7] = me[7];
    te[8] = me[8];
    te[9] = me[9];
    te[10] = me[10];
    te[11] = me[11];
    te[12] = me[12];
    te[13] = me[13];
    te[14] = me[14];
    te[15] = me[15];
    return this;
  }
  copyPosition(m) {
    const te = this.elements, me = m.elements;
    te[12] = me[12];
    te[13] = me[13];
    te[14] = me[14];
    return this;
  }
  setFromMatrix3(m) {
    const me = m.elements;
    this.set(
      me[0],
      me[3],
      me[6],
      0,
      me[1],
      me[4],
      me[7],
      0,
      me[2],
      me[5],
      me[8],
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  extractBasis(xAxis, yAxis, zAxis) {
    xAxis.setFromMatrixColumn(this, 0);
    yAxis.setFromMatrixColumn(this, 1);
    zAxis.setFromMatrixColumn(this, 2);
    return this;
  }
  makeBasis(xAxis, yAxis, zAxis) {
    this.set(
      xAxis.x,
      yAxis.x,
      zAxis.x,
      0,
      xAxis.y,
      yAxis.y,
      zAxis.y,
      0,
      xAxis.z,
      yAxis.z,
      zAxis.z,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  extractRotation(m) {
    const te = this.elements;
    const me = m.elements;
    const scaleX = 1 / _v1$5.setFromMatrixColumn(m, 0).length();
    const scaleY = 1 / _v1$5.setFromMatrixColumn(m, 1).length();
    const scaleZ = 1 / _v1$5.setFromMatrixColumn(m, 2).length();
    te[0] = me[0] * scaleX;
    te[1] = me[1] * scaleX;
    te[2] = me[2] * scaleX;
    te[3] = 0;
    te[4] = me[4] * scaleY;
    te[5] = me[5] * scaleY;
    te[6] = me[6] * scaleY;
    te[7] = 0;
    te[8] = me[8] * scaleZ;
    te[9] = me[9] * scaleZ;
    te[10] = me[10] * scaleZ;
    te[11] = 0;
    te[12] = 0;
    te[13] = 0;
    te[14] = 0;
    te[15] = 1;
    return this;
  }
  makeRotationFromEuler(euler) {
    const te = this.elements;
    const x = euler.x, y = euler.y, z = euler.z;
    const a = Math.cos(x), b = Math.sin(x);
    const c = Math.cos(y), d = Math.sin(y);
    const e = Math.cos(z), f = Math.sin(z);
    if (euler.order === "XYZ") {
      const ae = a * e, af = a * f, be = b * e, bf = b * f;
      te[0] = c * e;
      te[4] = -c * f;
      te[8] = d;
      te[1] = af + be * d;
      te[5] = ae - bf * d;
      te[9] = -b * c;
      te[2] = bf - ae * d;
      te[6] = be + af * d;
      te[10] = a * c;
    } else if (euler.order === "YXZ") {
      const ce = c * e, cf = c * f, de = d * e, df = d * f;
      te[0] = ce + df * b;
      te[4] = de * b - cf;
      te[8] = a * d;
      te[1] = a * f;
      te[5] = a * e;
      te[9] = -b;
      te[2] = cf * b - de;
      te[6] = df + ce * b;
      te[10] = a * c;
    } else if (euler.order === "ZXY") {
      const ce = c * e, cf = c * f, de = d * e, df = d * f;
      te[0] = ce - df * b;
      te[4] = -a * f;
      te[8] = de + cf * b;
      te[1] = cf + de * b;
      te[5] = a * e;
      te[9] = df - ce * b;
      te[2] = -a * d;
      te[6] = b;
      te[10] = a * c;
    } else if (euler.order === "ZYX") {
      const ae = a * e, af = a * f, be = b * e, bf = b * f;
      te[0] = c * e;
      te[4] = be * d - af;
      te[8] = ae * d + bf;
      te[1] = c * f;
      te[5] = bf * d + ae;
      te[9] = af * d - be;
      te[2] = -d;
      te[6] = b * c;
      te[10] = a * c;
    } else if (euler.order === "YZX") {
      const ac = a * c, ad = a * d, bc = b * c, bd = b * d;
      te[0] = c * e;
      te[4] = bd - ac * f;
      te[8] = bc * f + ad;
      te[1] = f;
      te[5] = a * e;
      te[9] = -b * e;
      te[2] = -d * e;
      te[6] = ad * f + bc;
      te[10] = ac - bd * f;
    } else if (euler.order === "XZY") {
      const ac = a * c, ad = a * d, bc = b * c, bd = b * d;
      te[0] = c * e;
      te[4] = -f;
      te[8] = d * e;
      te[1] = ac * f + bd;
      te[5] = a * e;
      te[9] = ad * f - bc;
      te[2] = bc * f - ad;
      te[6] = b * e;
      te[10] = bd * f + ac;
    }
    te[3] = 0;
    te[7] = 0;
    te[11] = 0;
    te[12] = 0;
    te[13] = 0;
    te[14] = 0;
    te[15] = 1;
    return this;
  }
  makeRotationFromQuaternion(q) {
    return this.compose(_zero$1, q, _one$1);
  }
  lookAt(eye, target, up) {
    const te = this.elements;
    _z$1.subVectors(eye, target);
    if (_z$1.lengthSq() === 0) {
      _z$1.z = 1;
    }
    _z$1.normalize();
    _x$1.crossVectors(up, _z$1);
    if (_x$1.lengthSq() === 0) {
      if (Math.abs(up.z) === 1) {
        _z$1.x += 1e-4;
      } else {
        _z$1.z += 1e-4;
      }
      _z$1.normalize();
      _x$1.crossVectors(up, _z$1);
    }
    _x$1.normalize();
    _y$1.crossVectors(_z$1, _x$1);
    te[0] = _x$1.x;
    te[4] = _y$1.x;
    te[8] = _z$1.x;
    te[1] = _x$1.y;
    te[5] = _y$1.y;
    te[9] = _z$1.y;
    te[2] = _x$1.z;
    te[6] = _y$1.z;
    te[10] = _z$1.z;
    return this;
  }
  multiply(m) {
    return this.multiplyMatrices(this, m);
  }
  premultiply(m) {
    return this.multiplyMatrices(m, this);
  }
  multiplyMatrices(a, b) {
    const ae = a.elements;
    const be = b.elements;
    const te = this.elements;
    const a11 = ae[0], a12 = ae[4], a13 = ae[8], a14 = ae[12];
    const a21 = ae[1], a22 = ae[5], a23 = ae[9], a24 = ae[13];
    const a31 = ae[2], a32 = ae[6], a33 = ae[10], a34 = ae[14];
    const a41 = ae[3], a42 = ae[7], a43 = ae[11], a44 = ae[15];
    const b11 = be[0], b12 = be[4], b13 = be[8], b14 = be[12];
    const b21 = be[1], b22 = be[5], b23 = be[9], b24 = be[13];
    const b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14];
    const b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15];
    te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
    te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
    te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
    te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
    te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
    te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
    te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
    te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
    te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
    te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
    te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
    te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
    te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
    te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
    te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
    te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
    return this;
  }
  multiplyScalar(s) {
    const te = this.elements;
    te[0] *= s;
    te[4] *= s;
    te[8] *= s;
    te[12] *= s;
    te[1] *= s;
    te[5] *= s;
    te[9] *= s;
    te[13] *= s;
    te[2] *= s;
    te[6] *= s;
    te[10] *= s;
    te[14] *= s;
    te[3] *= s;
    te[7] *= s;
    te[11] *= s;
    te[15] *= s;
    return this;
  }
  determinant() {
    const te = this.elements;
    const n11 = te[0], n12 = te[4], n13 = te[8], n14 = te[12];
    const n21 = te[1], n22 = te[5], n23 = te[9], n24 = te[13];
    const n31 = te[2], n32 = te[6], n33 = te[10], n34 = te[14];
    const n41 = te[3], n42 = te[7], n43 = te[11], n44 = te[15];
    return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);
  }
  transpose() {
    const te = this.elements;
    let tmp2;
    tmp2 = te[1];
    te[1] = te[4];
    te[4] = tmp2;
    tmp2 = te[2];
    te[2] = te[8];
    te[8] = tmp2;
    tmp2 = te[6];
    te[6] = te[9];
    te[9] = tmp2;
    tmp2 = te[3];
    te[3] = te[12];
    te[12] = tmp2;
    tmp2 = te[7];
    te[7] = te[13];
    te[13] = tmp2;
    tmp2 = te[11];
    te[11] = te[14];
    te[14] = tmp2;
    return this;
  }
  setPosition(x, y, z) {
    const te = this.elements;
    if (x.isVector3) {
      te[12] = x.x;
      te[13] = x.y;
      te[14] = x.z;
    } else {
      te[12] = x;
      te[13] = y;
      te[14] = z;
    }
    return this;
  }
  invert() {
    const te = this.elements, n11 = te[0], n21 = te[1], n31 = te[2], n41 = te[3], n12 = te[4], n22 = te[5], n32 = te[6], n42 = te[7], n13 = te[8], n23 = te[9], n33 = te[10], n43 = te[11], n14 = te[12], n24 = te[13], n34 = te[14], n44 = te[15], t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44, t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44, t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44, t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
    const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
    if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const detInv = 1 / det;
    te[0] = t11 * detInv;
    te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
    te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
    te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
    te[4] = t12 * detInv;
    te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
    te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
    te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
    te[8] = t13 * detInv;
    te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
    te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
    te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
    te[12] = t14 * detInv;
    te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
    te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
    te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
    return this;
  }
  scale(v) {
    const te = this.elements;
    const x = v.x, y = v.y, z = v.z;
    te[0] *= x;
    te[4] *= y;
    te[8] *= z;
    te[1] *= x;
    te[5] *= y;
    te[9] *= z;
    te[2] *= x;
    te[6] *= y;
    te[10] *= z;
    te[3] *= x;
    te[7] *= y;
    te[11] *= z;
    return this;
  }
  getMaxScaleOnAxis() {
    const te = this.elements;
    const scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
    const scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
    const scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
    return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
  }
  makeTranslation(x, y, z) {
    if (x.isVector3) {
      this.set(
        1,
        0,
        0,
        x.x,
        0,
        1,
        0,
        x.y,
        0,
        0,
        1,
        x.z,
        0,
        0,
        0,
        1
      );
    } else {
      this.set(
        1,
        0,
        0,
        x,
        0,
        1,
        0,
        y,
        0,
        0,
        1,
        z,
        0,
        0,
        0,
        1
      );
    }
    return this;
  }
  makeRotationX(theta) {
    const c = Math.cos(theta), s = Math.sin(theta);
    this.set(
      1,
      0,
      0,
      0,
      0,
      c,
      -s,
      0,
      0,
      s,
      c,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  makeRotationY(theta) {
    const c = Math.cos(theta), s = Math.sin(theta);
    this.set(
      c,
      0,
      s,
      0,
      0,
      1,
      0,
      0,
      -s,
      0,
      c,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  makeRotationZ(theta) {
    const c = Math.cos(theta), s = Math.sin(theta);
    this.set(
      c,
      -s,
      0,
      0,
      s,
      c,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  makeRotationAxis(axis, angle) {
    const c = Math.cos(angle);
    const s = Math.sin(angle);
    const t = 1 - c;
    const x = axis.x, y = axis.y, z = axis.z;
    const tx = t * x, ty = t * y;
    this.set(
      tx * x + c,
      tx * y - s * z,
      tx * z + s * y,
      0,
      tx * y + s * z,
      ty * y + c,
      ty * z - s * x,
      0,
      tx * z - s * y,
      ty * z + s * x,
      t * z * z + c,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  makeScale(x, y, z) {
    this.set(
      x,
      0,
      0,
      0,
      0,
      y,
      0,
      0,
      0,
      0,
      z,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  makeShear(xy, xz, yx, yz, zx, zy) {
    this.set(
      1,
      yx,
      zx,
      0,
      xy,
      1,
      zy,
      0,
      xz,
      yz,
      1,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  compose(position, quaternion, scale) {
    const te = this.elements;
    const x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;
    const x2 = x + x, y2 = y + y, z2 = z + z;
    const xx = x * x2, xy = x * y2, xz = x * z2;
    const yy = y * y2, yz = y * z2, zz = z * z2;
    const wx = w * x2, wy = w * y2, wz = w * z2;
    const sx = scale.x, sy = scale.y, sz = scale.z;
    te[0] = (1 - (yy + zz)) * sx;
    te[1] = (xy + wz) * sx;
    te[2] = (xz - wy) * sx;
    te[3] = 0;
    te[4] = (xy - wz) * sy;
    te[5] = (1 - (xx + zz)) * sy;
    te[6] = (yz + wx) * sy;
    te[7] = 0;
    te[8] = (xz + wy) * sz;
    te[9] = (yz - wx) * sz;
    te[10] = (1 - (xx + yy)) * sz;
    te[11] = 0;
    te[12] = position.x;
    te[13] = position.y;
    te[14] = position.z;
    te[15] = 1;
    return this;
  }
  decompose(position, quaternion, scale) {
    const te = this.elements;
    let sx = _v1$5.set(te[0], te[1], te[2]).length();
    const sy = _v1$5.set(te[4], te[5], te[6]).length();
    const sz = _v1$5.set(te[8], te[9], te[10]).length();
    const det = this.determinant();
    if (det < 0) sx = -sx;
    position.x = te[12];
    position.y = te[13];
    position.z = te[14];
    _m1$2$1.copy(this);
    const invSX = 1 / sx;
    const invSY = 1 / sy;
    const invSZ = 1 / sz;
    _m1$2$1.elements[0] *= invSX;
    _m1$2$1.elements[1] *= invSX;
    _m1$2$1.elements[2] *= invSX;
    _m1$2$1.elements[4] *= invSY;
    _m1$2$1.elements[5] *= invSY;
    _m1$2$1.elements[6] *= invSY;
    _m1$2$1.elements[8] *= invSZ;
    _m1$2$1.elements[9] *= invSZ;
    _m1$2$1.elements[10] *= invSZ;
    quaternion.setFromRotationMatrix(_m1$2$1);
    scale.x = sx;
    scale.y = sy;
    scale.z = sz;
    return this;
  }
  makePerspective(left, right, top, bottom, near, far, coordinateSystem = WebGLCoordinateSystem$1) {
    const te = this.elements;
    const x = 2 * near / (right - left);
    const y = 2 * near / (top - bottom);
    const a = (right + left) / (right - left);
    const b = (top + bottom) / (top - bottom);
    let c, d;
    if (coordinateSystem === WebGLCoordinateSystem$1) {
      c = -(far + near) / (far - near);
      d = -2 * far * near / (far - near);
    } else if (coordinateSystem === WebGPUCoordinateSystem$1) {
      c = -far / (far - near);
      d = -far * near / (far - near);
    } else {
      throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + coordinateSystem);
    }
    te[0] = x;
    te[4] = 0;
    te[8] = a;
    te[12] = 0;
    te[1] = 0;
    te[5] = y;
    te[9] = b;
    te[13] = 0;
    te[2] = 0;
    te[6] = 0;
    te[10] = c;
    te[14] = d;
    te[3] = 0;
    te[7] = 0;
    te[11] = -1;
    te[15] = 0;
    return this;
  }
  makeOrthographic(left, right, top, bottom, near, far, coordinateSystem = WebGLCoordinateSystem$1) {
    const te = this.elements;
    const w = 1 / (right - left);
    const h = 1 / (top - bottom);
    const p = 1 / (far - near);
    const x = (right + left) * w;
    const y = (top + bottom) * h;
    let z, zInv;
    if (coordinateSystem === WebGLCoordinateSystem$1) {
      z = (far + near) * p;
      zInv = -2 * p;
    } else if (coordinateSystem === WebGPUCoordinateSystem$1) {
      z = near * p;
      zInv = -1 * p;
    } else {
      throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + coordinateSystem);
    }
    te[0] = 2 * w;
    te[4] = 0;
    te[8] = 0;
    te[12] = -x;
    te[1] = 0;
    te[5] = 2 * h;
    te[9] = 0;
    te[13] = -y;
    te[2] = 0;
    te[6] = 0;
    te[10] = zInv;
    te[14] = -z;
    te[3] = 0;
    te[7] = 0;
    te[11] = 0;
    te[15] = 1;
    return this;
  }
  equals(matrix) {
    const te = this.elements;
    const me = matrix.elements;
    for (let i = 0; i < 16; i++) {
      if (te[i] !== me[i]) return false;
    }
    return true;
  }
  fromArray(array, offset = 0) {
    for (let i = 0; i < 16; i++) {
      this.elements[i] = array[i + offset];
    }
    return this;
  }
  toArray(array = [], offset = 0) {
    const te = this.elements;
    array[offset] = te[0];
    array[offset + 1] = te[1];
    array[offset + 2] = te[2];
    array[offset + 3] = te[3];
    array[offset + 4] = te[4];
    array[offset + 5] = te[5];
    array[offset + 6] = te[6];
    array[offset + 7] = te[7];
    array[offset + 8] = te[8];
    array[offset + 9] = te[9];
    array[offset + 10] = te[10];
    array[offset + 11] = te[11];
    array[offset + 12] = te[12];
    array[offset + 13] = te[13];
    array[offset + 14] = te[14];
    array[offset + 15] = te[15];
    return array;
  }
};
const _v1$5 = /* @__PURE__ */ new Vector3$1();
const _m1$2$1 = /* @__PURE__ */ new Matrix4$1();
const _zero$1 = /* @__PURE__ */ new Vector3$1(0, 0, 0);
const _one$1 = /* @__PURE__ */ new Vector3$1(1, 1, 1);
const _x$1 = /* @__PURE__ */ new Vector3$1();
const _y$1 = /* @__PURE__ */ new Vector3$1();
const _z$1 = /* @__PURE__ */ new Vector3$1();
const _matrix$2 = /* @__PURE__ */ new Matrix4$1();
const _quaternion$3 = /* @__PURE__ */ new Quaternion$1();
class Euler {
  constructor(x = 0, y = 0, z = 0, order = Euler.DEFAULT_ORDER) {
    this.isEuler = true;
    this._x = x;
    this._y = y;
    this._z = z;
    this._order = order;
  }
  get x() {
    return this._x;
  }
  set x(value) {
    this._x = value;
    this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(value) {
    this._y = value;
    this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(value) {
    this._z = value;
    this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(value) {
    this._order = value;
    this._onChangeCallback();
  }
  set(x, y, z, order = this._order) {
    this._x = x;
    this._y = y;
    this._z = z;
    this._order = order;
    this._onChangeCallback();
    return this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(euler) {
    this._x = euler._x;
    this._y = euler._y;
    this._z = euler._z;
    this._order = euler._order;
    this._onChangeCallback();
    return this;
  }
  setFromRotationMatrix(m, order = this._order, update = true) {
    const te = m.elements;
    const m11 = te[0], m12 = te[4], m13 = te[8];
    const m21 = te[1], m22 = te[5], m23 = te[9];
    const m31 = te[2], m32 = te[6], m33 = te[10];
    switch (order) {
      case "XYZ":
        this._y = Math.asin(clamp$2(m13, -1, 1));
        if (Math.abs(m13) < 0.9999999) {
          this._x = Math.atan2(-m23, m33);
          this._z = Math.atan2(-m12, m11);
        } else {
          this._x = Math.atan2(m32, m22);
          this._z = 0;
        }
        break;
      case "YXZ":
        this._x = Math.asin(-clamp$2(m23, -1, 1));
        if (Math.abs(m23) < 0.9999999) {
          this._y = Math.atan2(m13, m33);
          this._z = Math.atan2(m21, m22);
        } else {
          this._y = Math.atan2(-m31, m11);
          this._z = 0;
        }
        break;
      case "ZXY":
        this._x = Math.asin(clamp$2(m32, -1, 1));
        if (Math.abs(m32) < 0.9999999) {
          this._y = Math.atan2(-m31, m33);
          this._z = Math.atan2(-m12, m22);
        } else {
          this._y = 0;
          this._z = Math.atan2(m21, m11);
        }
        break;
      case "ZYX":
        this._y = Math.asin(-clamp$2(m31, -1, 1));
        if (Math.abs(m31) < 0.9999999) {
          this._x = Math.atan2(m32, m33);
          this._z = Math.atan2(m21, m11);
        } else {
          this._x = 0;
          this._z = Math.atan2(-m12, m22);
        }
        break;
      case "YZX":
        this._z = Math.asin(clamp$2(m21, -1, 1));
        if (Math.abs(m21) < 0.9999999) {
          this._x = Math.atan2(-m23, m22);
          this._y = Math.atan2(-m31, m11);
        } else {
          this._x = 0;
          this._y = Math.atan2(m13, m33);
        }
        break;
      case "XZY":
        this._z = Math.asin(-clamp$2(m12, -1, 1));
        if (Math.abs(m12) < 0.9999999) {
          this._x = Math.atan2(m32, m22);
          this._y = Math.atan2(m13, m11);
        } else {
          this._x = Math.atan2(-m23, m33);
          this._y = 0;
        }
        break;
      default:
        console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + order);
    }
    this._order = order;
    if (update === true) this._onChangeCallback();
    return this;
  }
  setFromQuaternion(q, order, update) {
    _matrix$2.makeRotationFromQuaternion(q);
    return this.setFromRotationMatrix(_matrix$2, order, update);
  }
  setFromVector3(v, order = this._order) {
    return this.set(v.x, v.y, v.z, order);
  }
  reorder(newOrder) {
    _quaternion$3.setFromEuler(this);
    return this.setFromQuaternion(_quaternion$3, newOrder);
  }
  equals(euler) {
    return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;
  }
  fromArray(array) {
    this._x = array[0];
    this._y = array[1];
    this._z = array[2];
    if (array[3] !== void 0) this._order = array[3];
    this._onChangeCallback();
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this._x;
    array[offset + 1] = this._y;
    array[offset + 2] = this._z;
    array[offset + 3] = this._order;
    return array;
  }
  _onChange(callback) {
    this._onChangeCallback = callback;
    return this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x;
    yield this._y;
    yield this._z;
    yield this._order;
  }
}
Euler.DEFAULT_ORDER = "XYZ";
class Layers {
  constructor() {
    this.mask = 1 | 0;
  }
  set(channel) {
    this.mask = (1 << channel | 0) >>> 0;
  }
  enable(channel) {
    this.mask |= 1 << channel | 0;
  }
  enableAll() {
    this.mask = 4294967295 | 0;
  }
  toggle(channel) {
    this.mask ^= 1 << channel | 0;
  }
  disable(channel) {
    this.mask &= ~(1 << channel | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(layers) {
    return (this.mask & layers.mask) !== 0;
  }
  isEnabled(channel) {
    return (this.mask & (1 << channel | 0)) !== 0;
  }
}
let _object3DId = 0;
const _v1$4 = /* @__PURE__ */ new Vector3$1();
const _q1 = /* @__PURE__ */ new Quaternion$1();
const _m1$1$1 = /* @__PURE__ */ new Matrix4$1();
const _target = /* @__PURE__ */ new Vector3$1();
const _position$3 = /* @__PURE__ */ new Vector3$1();
const _scale$2 = /* @__PURE__ */ new Vector3$1();
const _quaternion$2 = /* @__PURE__ */ new Quaternion$1();
const _xAxis = /* @__PURE__ */ new Vector3$1(1, 0, 0);
const _yAxis = /* @__PURE__ */ new Vector3$1(0, 1, 0);
const _zAxis = /* @__PURE__ */ new Vector3$1(0, 0, 1);
const _addedEvent = { type: "added" };
const _removedEvent = { type: "removed" };
const _childaddedEvent = { type: "childadded", child: null };
const _childremovedEvent = { type: "childremoved", child: null };
class Object3D extends EventDispatcher$1 {
  constructor() {
    super();
    this.isObject3D = true;
    Object.defineProperty(this, "id", { value: _object3DId++ });
    this.uuid = generateUUID$1();
    this.name = "";
    this.type = "Object3D";
    this.parent = null;
    this.children = [];
    this.up = Object3D.DEFAULT_UP.clone();
    const position = new Vector3$1();
    const rotation = new Euler();
    const quaternion = new Quaternion$1();
    const scale = new Vector3$1(1, 1, 1);
    function onRotationChange() {
      quaternion.setFromEuler(rotation, false);
    }
    function onQuaternionChange() {
      rotation.setFromQuaternion(quaternion, void 0, false);
    }
    rotation._onChange(onRotationChange);
    quaternion._onChange(onQuaternionChange);
    Object.defineProperties(this, {
      position: {
        configurable: true,
        enumerable: true,
        value: position
      },
      rotation: {
        configurable: true,
        enumerable: true,
        value: rotation
      },
      quaternion: {
        configurable: true,
        enumerable: true,
        value: quaternion
      },
      scale: {
        configurable: true,
        enumerable: true,
        value: scale
      },
      modelViewMatrix: {
        value: new Matrix4$1()
      },
      normalMatrix: {
        value: new Matrix3$1()
      }
    });
    this.matrix = new Matrix4$1();
    this.matrixWorld = new Matrix4$1();
    this.matrixAutoUpdate = Object3D.DEFAULT_MATRIX_AUTO_UPDATE;
    this.matrixWorldAutoUpdate = Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE;
    this.matrixWorldNeedsUpdate = false;
    this.layers = new Layers();
    this.visible = true;
    this.castShadow = false;
    this.receiveShadow = false;
    this.frustumCulled = true;
    this.renderOrder = 0;
    this.animations = [];
    this.userData = {};
  }
  onBeforeShadow() {
  }
  onAfterShadow() {
  }
  onBeforeRender() {
  }
  onAfterRender() {
  }
  applyMatrix4(matrix) {
    if (this.matrixAutoUpdate) this.updateMatrix();
    this.matrix.premultiply(matrix);
    this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(q) {
    this.quaternion.premultiply(q);
    return this;
  }
  setRotationFromAxisAngle(axis, angle) {
    this.quaternion.setFromAxisAngle(axis, angle);
  }
  setRotationFromEuler(euler) {
    this.quaternion.setFromEuler(euler, true);
  }
  setRotationFromMatrix(m) {
    this.quaternion.setFromRotationMatrix(m);
  }
  setRotationFromQuaternion(q) {
    this.quaternion.copy(q);
  }
  rotateOnAxis(axis, angle) {
    _q1.setFromAxisAngle(axis, angle);
    this.quaternion.multiply(_q1);
    return this;
  }
  rotateOnWorldAxis(axis, angle) {
    _q1.setFromAxisAngle(axis, angle);
    this.quaternion.premultiply(_q1);
    return this;
  }
  rotateX(angle) {
    return this.rotateOnAxis(_xAxis, angle);
  }
  rotateY(angle) {
    return this.rotateOnAxis(_yAxis, angle);
  }
  rotateZ(angle) {
    return this.rotateOnAxis(_zAxis, angle);
  }
  translateOnAxis(axis, distance2) {
    _v1$4.copy(axis).applyQuaternion(this.quaternion);
    this.position.add(_v1$4.multiplyScalar(distance2));
    return this;
  }
  translateX(distance2) {
    return this.translateOnAxis(_xAxis, distance2);
  }
  translateY(distance2) {
    return this.translateOnAxis(_yAxis, distance2);
  }
  translateZ(distance2) {
    return this.translateOnAxis(_zAxis, distance2);
  }
  localToWorld(vector) {
    this.updateWorldMatrix(true, false);
    return vector.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(vector) {
    this.updateWorldMatrix(true, false);
    return vector.applyMatrix4(_m1$1$1.copy(this.matrixWorld).invert());
  }
  lookAt(x, y, z) {
    if (x.isVector3) {
      _target.copy(x);
    } else {
      _target.set(x, y, z);
    }
    const parent = this.parent;
    this.updateWorldMatrix(true, false);
    _position$3.setFromMatrixPosition(this.matrixWorld);
    if (this.isCamera || this.isLight) {
      _m1$1$1.lookAt(_position$3, _target, this.up);
    } else {
      _m1$1$1.lookAt(_target, _position$3, this.up);
    }
    this.quaternion.setFromRotationMatrix(_m1$1$1);
    if (parent) {
      _m1$1$1.extractRotation(parent.matrixWorld);
      _q1.setFromRotationMatrix(_m1$1$1);
      this.quaternion.premultiply(_q1.invert());
    }
  }
  add(object) {
    if (arguments.length > 1) {
      for (let i = 0; i < arguments.length; i++) {
        this.add(arguments[i]);
      }
      return this;
    }
    if (object === this) {
      console.error("THREE.Object3D.add: object can't be added as a child of itself.", object);
      return this;
    }
    if (object && object.isObject3D) {
      object.removeFromParent();
      object.parent = this;
      this.children.push(object);
      object.dispatchEvent(_addedEvent);
      _childaddedEvent.child = object;
      this.dispatchEvent(_childaddedEvent);
      _childaddedEvent.child = null;
    } else {
      console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", object);
    }
    return this;
  }
  remove(object) {
    if (arguments.length > 1) {
      for (let i = 0; i < arguments.length; i++) {
        this.remove(arguments[i]);
      }
      return this;
    }
    const index = this.children.indexOf(object);
    if (index !== -1) {
      object.parent = null;
      this.children.splice(index, 1);
      object.dispatchEvent(_removedEvent);
      _childremovedEvent.child = object;
      this.dispatchEvent(_childremovedEvent);
      _childremovedEvent.child = null;
    }
    return this;
  }
  removeFromParent() {
    const parent = this.parent;
    if (parent !== null) {
      parent.remove(this);
    }
    return this;
  }
  clear() {
    return this.remove(...this.children);
  }
  attach(object) {
    this.updateWorldMatrix(true, false);
    _m1$1$1.copy(this.matrixWorld).invert();
    if (object.parent !== null) {
      object.parent.updateWorldMatrix(true, false);
      _m1$1$1.multiply(object.parent.matrixWorld);
    }
    object.applyMatrix4(_m1$1$1);
    object.removeFromParent();
    object.parent = this;
    this.children.push(object);
    object.updateWorldMatrix(false, true);
    object.dispatchEvent(_addedEvent);
    _childaddedEvent.child = object;
    this.dispatchEvent(_childaddedEvent);
    _childaddedEvent.child = null;
    return this;
  }
  getObjectById(id) {
    return this.getObjectByProperty("id", id);
  }
  getObjectByName(name) {
    return this.getObjectByProperty("name", name);
  }
  getObjectByProperty(name, value) {
    if (this[name] === value) return this;
    for (let i = 0, l = this.children.length; i < l; i++) {
      const child = this.children[i];
      const object = child.getObjectByProperty(name, value);
      if (object !== void 0) {
        return object;
      }
    }
    return void 0;
  }
  getObjectsByProperty(name, value, result = []) {
    if (this[name] === value) result.push(this);
    const children = this.children;
    for (let i = 0, l = children.length; i < l; i++) {
      children[i].getObjectsByProperty(name, value, result);
    }
    return result;
  }
  getWorldPosition(target) {
    this.updateWorldMatrix(true, false);
    return target.setFromMatrixPosition(this.matrixWorld);
  }
  getWorldQuaternion(target) {
    this.updateWorldMatrix(true, false);
    this.matrixWorld.decompose(_position$3, target, _scale$2);
    return target;
  }
  getWorldScale(target) {
    this.updateWorldMatrix(true, false);
    this.matrixWorld.decompose(_position$3, _quaternion$2, target);
    return target;
  }
  getWorldDirection(target) {
    this.updateWorldMatrix(true, false);
    const e = this.matrixWorld.elements;
    return target.set(e[8], e[9], e[10]).normalize();
  }
  raycast() {
  }
  traverse(callback) {
    callback(this);
    const children = this.children;
    for (let i = 0, l = children.length; i < l; i++) {
      children[i].traverse(callback);
    }
  }
  traverseVisible(callback) {
    if (this.visible === false) return;
    callback(this);
    const children = this.children;
    for (let i = 0, l = children.length; i < l; i++) {
      children[i].traverseVisible(callback);
    }
  }
  traverseAncestors(callback) {
    const parent = this.parent;
    if (parent !== null) {
      callback(parent);
      parent.traverseAncestors(callback);
    }
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale);
    this.matrixWorldNeedsUpdate = true;
  }
  updateMatrixWorld(force) {
    if (this.matrixAutoUpdate) this.updateMatrix();
    if (this.matrixWorldNeedsUpdate || force) {
      if (this.matrixWorldAutoUpdate === true) {
        if (this.parent === null) {
          this.matrixWorld.copy(this.matrix);
        } else {
          this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
        }
      }
      this.matrixWorldNeedsUpdate = false;
      force = true;
    }
    const children = this.children;
    for (let i = 0, l = children.length; i < l; i++) {
      const child = children[i];
      child.updateMatrixWorld(force);
    }
  }
  updateWorldMatrix(updateParents, updateChildren) {
    const parent = this.parent;
    if (updateParents === true && parent !== null) {
      parent.updateWorldMatrix(true, false);
    }
    if (this.matrixAutoUpdate) this.updateMatrix();
    if (this.matrixWorldAutoUpdate === true) {
      if (this.parent === null) {
        this.matrixWorld.copy(this.matrix);
      } else {
        this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
      }
    }
    if (updateChildren === true) {
      const children = this.children;
      for (let i = 0, l = children.length; i < l; i++) {
        const child = children[i];
        child.updateWorldMatrix(false, true);
      }
    }
  }
  toJSON(meta) {
    const isRootObject = meta === void 0 || typeof meta === "string";
    const output = {};
    if (isRootObject) {
      meta = {
        geometries: {},
        materials: {},
        textures: {},
        images: {},
        shapes: {},
        skeletons: {},
        animations: {},
        nodes: {}
      };
      output.metadata = {
        version: 4.6,
        type: "Object",
        generator: "Object3D.toJSON"
      };
    }
    const object = {};
    object.uuid = this.uuid;
    object.type = this.type;
    if (this.name !== "") object.name = this.name;
    if (this.castShadow === true) object.castShadow = true;
    if (this.receiveShadow === true) object.receiveShadow = true;
    if (this.visible === false) object.visible = false;
    if (this.frustumCulled === false) object.frustumCulled = false;
    if (this.renderOrder !== 0) object.renderOrder = this.renderOrder;
    if (Object.keys(this.userData).length > 0) object.userData = this.userData;
    object.layers = this.layers.mask;
    object.matrix = this.matrix.toArray();
    object.up = this.up.toArray();
    if (this.matrixAutoUpdate === false) object.matrixAutoUpdate = false;
    if (this.isInstancedMesh) {
      object.type = "InstancedMesh";
      object.count = this.count;
      object.instanceMatrix = this.instanceMatrix.toJSON();
      if (this.instanceColor !== null) object.instanceColor = this.instanceColor.toJSON();
    }
    if (this.isBatchedMesh) {
      object.type = "BatchedMesh";
      object.perObjectFrustumCulled = this.perObjectFrustumCulled;
      object.sortObjects = this.sortObjects;
      object.drawRanges = this._drawRanges;
      object.reservedRanges = this._reservedRanges;
      object.visibility = this._visibility;
      object.active = this._active;
      object.bounds = this._bounds.map((bound) => ({
        boxInitialized: bound.boxInitialized,
        boxMin: bound.box.min.toArray(),
        boxMax: bound.box.max.toArray(),
        sphereInitialized: bound.sphereInitialized,
        sphereRadius: bound.sphere.radius,
        sphereCenter: bound.sphere.center.toArray()
      }));
      object.maxInstanceCount = this._maxInstanceCount;
      object.maxVertexCount = this._maxVertexCount;
      object.maxIndexCount = this._maxIndexCount;
      object.geometryInitialized = this._geometryInitialized;
      object.geometryCount = this._geometryCount;
      object.matricesTexture = this._matricesTexture.toJSON(meta);
      if (this._colorsTexture !== null) object.colorsTexture = this._colorsTexture.toJSON(meta);
      if (this.boundingSphere !== null) {
        object.boundingSphere = {
          center: object.boundingSphere.center.toArray(),
          radius: object.boundingSphere.radius
        };
      }
      if (this.boundingBox !== null) {
        object.boundingBox = {
          min: object.boundingBox.min.toArray(),
          max: object.boundingBox.max.toArray()
        };
      }
    }
    function serialize(library, element2) {
      if (library[element2.uuid] === void 0) {
        library[element2.uuid] = element2.toJSON(meta);
      }
      return element2.uuid;
    }
    if (this.isScene) {
      if (this.background) {
        if (this.background.isColor) {
          object.background = this.background.toJSON();
        } else if (this.background.isTexture) {
          object.background = this.background.toJSON(meta).uuid;
        }
      }
      if (this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== true) {
        object.environment = this.environment.toJSON(meta).uuid;
      }
    } else if (this.isMesh || this.isLine || this.isPoints) {
      object.geometry = serialize(meta.geometries, this.geometry);
      const parameters = this.geometry.parameters;
      if (parameters !== void 0 && parameters.shapes !== void 0) {
        const shapes = parameters.shapes;
        if (Array.isArray(shapes)) {
          for (let i = 0, l = shapes.length; i < l; i++) {
            const shape = shapes[i];
            serialize(meta.shapes, shape);
          }
        } else {
          serialize(meta.shapes, shapes);
        }
      }
    }
    if (this.isSkinnedMesh) {
      object.bindMode = this.bindMode;
      object.bindMatrix = this.bindMatrix.toArray();
      if (this.skeleton !== void 0) {
        serialize(meta.skeletons, this.skeleton);
        object.skeleton = this.skeleton.uuid;
      }
    }
    if (this.material !== void 0) {
      if (Array.isArray(this.material)) {
        const uuids = [];
        for (let i = 0, l = this.material.length; i < l; i++) {
          uuids.push(serialize(meta.materials, this.material[i]));
        }
        object.material = uuids;
      } else {
        object.material = serialize(meta.materials, this.material);
      }
    }
    if (this.children.length > 0) {
      object.children = [];
      for (let i = 0; i < this.children.length; i++) {
        object.children.push(this.children[i].toJSON(meta).object);
      }
    }
    if (this.animations.length > 0) {
      object.animations = [];
      for (let i = 0; i < this.animations.length; i++) {
        const animation = this.animations[i];
        object.animations.push(serialize(meta.animations, animation));
      }
    }
    if (isRootObject) {
      const geometries = extractFromCache(meta.geometries);
      const materials = extractFromCache(meta.materials);
      const textures = extractFromCache(meta.textures);
      const images = extractFromCache(meta.images);
      const shapes = extractFromCache(meta.shapes);
      const skeletons = extractFromCache(meta.skeletons);
      const animations = extractFromCache(meta.animations);
      const nodes = extractFromCache(meta.nodes);
      if (geometries.length > 0) output.geometries = geometries;
      if (materials.length > 0) output.materials = materials;
      if (textures.length > 0) output.textures = textures;
      if (images.length > 0) output.images = images;
      if (shapes.length > 0) output.shapes = shapes;
      if (skeletons.length > 0) output.skeletons = skeletons;
      if (animations.length > 0) output.animations = animations;
      if (nodes.length > 0) output.nodes = nodes;
    }
    output.object = object;
    return output;
    function extractFromCache(cache2) {
      const values = [];
      for (const key in cache2) {
        const data = cache2[key];
        delete data.metadata;
        values.push(data);
      }
      return values;
    }
  }
  clone(recursive) {
    return new this.constructor().copy(this, recursive);
  }
  copy(source, recursive = true) {
    this.name = source.name;
    this.up.copy(source.up);
    this.position.copy(source.position);
    this.rotation.order = source.rotation.order;
    this.quaternion.copy(source.quaternion);
    this.scale.copy(source.scale);
    this.matrix.copy(source.matrix);
    this.matrixWorld.copy(source.matrixWorld);
    this.matrixAutoUpdate = source.matrixAutoUpdate;
    this.matrixWorldAutoUpdate = source.matrixWorldAutoUpdate;
    this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
    this.layers.mask = source.layers.mask;
    this.visible = source.visible;
    this.castShadow = source.castShadow;
    this.receiveShadow = source.receiveShadow;
    this.frustumCulled = source.frustumCulled;
    this.renderOrder = source.renderOrder;
    this.animations = source.animations.slice();
    this.userData = JSON.parse(JSON.stringify(source.userData));
    if (recursive === true) {
      for (let i = 0; i < source.children.length; i++) {
        const child = source.children[i];
        this.add(child.clone());
      }
    }
    return this;
  }
}
Object3D.DEFAULT_UP = /* @__PURE__ */ new Vector3$1(0, 1, 0);
Object3D.DEFAULT_MATRIX_AUTO_UPDATE = true;
Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = true;
const _v0$1 = /* @__PURE__ */ new Vector3$1();
const _v1$3 = /* @__PURE__ */ new Vector3$1();
const _v2$2 = /* @__PURE__ */ new Vector3$1();
const _v3$2 = /* @__PURE__ */ new Vector3$1();
const _vab = /* @__PURE__ */ new Vector3$1();
const _vac = /* @__PURE__ */ new Vector3$1();
const _vbc = /* @__PURE__ */ new Vector3$1();
const _vap = /* @__PURE__ */ new Vector3$1();
const _vbp = /* @__PURE__ */ new Vector3$1();
const _vcp = /* @__PURE__ */ new Vector3$1();
const _v40 = /* @__PURE__ */ new Vector4$1();
const _v41 = /* @__PURE__ */ new Vector4$1();
const _v42 = /* @__PURE__ */ new Vector4$1();
class Triangle {
  constructor(a = new Vector3$1(), b = new Vector3$1(), c = new Vector3$1()) {
    this.a = a;
    this.b = b;
    this.c = c;
  }
  static getNormal(a, b, c, target) {
    target.subVectors(c, b);
    _v0$1.subVectors(a, b);
    target.cross(_v0$1);
    const targetLengthSq = target.lengthSq();
    if (targetLengthSq > 0) {
      return target.multiplyScalar(1 / Math.sqrt(targetLengthSq));
    }
    return target.set(0, 0, 0);
  }
  // static/instance method to calculate barycentric coordinates
  // based on: http://www.blackpawn.com/texts/pointinpoly/default.html
  static getBarycoord(point, a, b, c, target) {
    _v0$1.subVectors(c, a);
    _v1$3.subVectors(b, a);
    _v2$2.subVectors(point, a);
    const dot00 = _v0$1.dot(_v0$1);
    const dot01 = _v0$1.dot(_v1$3);
    const dot02 = _v0$1.dot(_v2$2);
    const dot11 = _v1$3.dot(_v1$3);
    const dot12 = _v1$3.dot(_v2$2);
    const denom = dot00 * dot11 - dot01 * dot01;
    if (denom === 0) {
      target.set(0, 0, 0);
      return null;
    }
    const invDenom = 1 / denom;
    const u = (dot11 * dot02 - dot01 * dot12) * invDenom;
    const v = (dot00 * dot12 - dot01 * dot02) * invDenom;
    return target.set(1 - u - v, v, u);
  }
  static containsPoint(point, a, b, c) {
    if (this.getBarycoord(point, a, b, c, _v3$2) === null) {
      return false;
    }
    return _v3$2.x >= 0 && _v3$2.y >= 0 && _v3$2.x + _v3$2.y <= 1;
  }
  static getInterpolation(point, p1, p2, p3, v1, v2, v3, target) {
    if (this.getBarycoord(point, p1, p2, p3, _v3$2) === null) {
      target.x = 0;
      target.y = 0;
      if ("z" in target) target.z = 0;
      if ("w" in target) target.w = 0;
      return null;
    }
    target.setScalar(0);
    target.addScaledVector(v1, _v3$2.x);
    target.addScaledVector(v2, _v3$2.y);
    target.addScaledVector(v3, _v3$2.z);
    return target;
  }
  static getInterpolatedAttribute(attr, i1, i2, i3, barycoord, target) {
    _v40.setScalar(0);
    _v41.setScalar(0);
    _v42.setScalar(0);
    _v40.fromBufferAttribute(attr, i1);
    _v41.fromBufferAttribute(attr, i2);
    _v42.fromBufferAttribute(attr, i3);
    target.setScalar(0);
    target.addScaledVector(_v40, barycoord.x);
    target.addScaledVector(_v41, barycoord.y);
    target.addScaledVector(_v42, barycoord.z);
    return target;
  }
  static isFrontFacing(a, b, c, direction) {
    _v0$1.subVectors(c, b);
    _v1$3.subVectors(a, b);
    return _v0$1.cross(_v1$3).dot(direction) < 0 ? true : false;
  }
  set(a, b, c) {
    this.a.copy(a);
    this.b.copy(b);
    this.c.copy(c);
    return this;
  }
  setFromPointsAndIndices(points, i0, i1, i2) {
    this.a.copy(points[i0]);
    this.b.copy(points[i1]);
    this.c.copy(points[i2]);
    return this;
  }
  setFromAttributeAndIndices(attribute, i0, i1, i2) {
    this.a.fromBufferAttribute(attribute, i0);
    this.b.fromBufferAttribute(attribute, i1);
    this.c.fromBufferAttribute(attribute, i2);
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(triangle) {
    this.a.copy(triangle.a);
    this.b.copy(triangle.b);
    this.c.copy(triangle.c);
    return this;
  }
  getArea() {
    _v0$1.subVectors(this.c, this.b);
    _v1$3.subVectors(this.a, this.b);
    return _v0$1.cross(_v1$3).length() * 0.5;
  }
  getMidpoint(target) {
    return target.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
  }
  getNormal(target) {
    return Triangle.getNormal(this.a, this.b, this.c, target);
  }
  getPlane(target) {
    return target.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(point, target) {
    return Triangle.getBarycoord(point, this.a, this.b, this.c, target);
  }
  getInterpolation(point, v1, v2, v3, target) {
    return Triangle.getInterpolation(point, this.a, this.b, this.c, v1, v2, v3, target);
  }
  containsPoint(point) {
    return Triangle.containsPoint(point, this.a, this.b, this.c);
  }
  isFrontFacing(direction) {
    return Triangle.isFrontFacing(this.a, this.b, this.c, direction);
  }
  intersectsBox(box) {
    return box.intersectsTriangle(this);
  }
  closestPointToPoint(p, target) {
    const a = this.a, b = this.b, c = this.c;
    let v, w;
    _vab.subVectors(b, a);
    _vac.subVectors(c, a);
    _vap.subVectors(p, a);
    const d1 = _vab.dot(_vap);
    const d2 = _vac.dot(_vap);
    if (d1 <= 0 && d2 <= 0) {
      return target.copy(a);
    }
    _vbp.subVectors(p, b);
    const d3 = _vab.dot(_vbp);
    const d4 = _vac.dot(_vbp);
    if (d3 >= 0 && d4 <= d3) {
      return target.copy(b);
    }
    const vc = d1 * d4 - d3 * d2;
    if (vc <= 0 && d1 >= 0 && d3 <= 0) {
      v = d1 / (d1 - d3);
      return target.copy(a).addScaledVector(_vab, v);
    }
    _vcp.subVectors(p, c);
    const d5 = _vab.dot(_vcp);
    const d6 = _vac.dot(_vcp);
    if (d6 >= 0 && d5 <= d6) {
      return target.copy(c);
    }
    const vb = d5 * d2 - d1 * d6;
    if (vb <= 0 && d2 >= 0 && d6 <= 0) {
      w = d2 / (d2 - d6);
      return target.copy(a).addScaledVector(_vac, w);
    }
    const va = d3 * d6 - d5 * d4;
    if (va <= 0 && d4 - d3 >= 0 && d5 - d6 >= 0) {
      _vbc.subVectors(c, b);
      w = (d4 - d3) / (d4 - d3 + (d5 - d6));
      return target.copy(b).addScaledVector(_vbc, w);
    }
    const denom = 1 / (va + vb + vc);
    v = vb * denom;
    w = vc * denom;
    return target.copy(a).addScaledVector(_vab, v).addScaledVector(_vac, w);
  }
  equals(triangle) {
    return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);
  }
}
const _colorKeywords$1 = {
  "aliceblue": 15792383,
  "antiquewhite": 16444375,
  "aqua": 65535,
  "aquamarine": 8388564,
  "azure": 15794175,
  "beige": 16119260,
  "bisque": 16770244,
  "black": 0,
  "blanchedalmond": 16772045,
  "blue": 255,
  "blueviolet": 9055202,
  "brown": 10824234,
  "burlywood": 14596231,
  "cadetblue": 6266528,
  "chartreuse": 8388352,
  "chocolate": 13789470,
  "coral": 16744272,
  "cornflowerblue": 6591981,
  "cornsilk": 16775388,
  "crimson": 14423100,
  "cyan": 65535,
  "darkblue": 139,
  "darkcyan": 35723,
  "darkgoldenrod": 12092939,
  "darkgray": 11119017,
  "darkgreen": 25600,
  "darkgrey": 11119017,
  "darkkhaki": 12433259,
  "darkmagenta": 9109643,
  "darkolivegreen": 5597999,
  "darkorange": 16747520,
  "darkorchid": 10040012,
  "darkred": 9109504,
  "darksalmon": 15308410,
  "darkseagreen": 9419919,
  "darkslateblue": 4734347,
  "darkslategray": 3100495,
  "darkslategrey": 3100495,
  "darkturquoise": 52945,
  "darkviolet": 9699539,
  "deeppink": 16716947,
  "deepskyblue": 49151,
  "dimgray": 6908265,
  "dimgrey": 6908265,
  "dodgerblue": 2003199,
  "firebrick": 11674146,
  "floralwhite": 16775920,
  "forestgreen": 2263842,
  "fuchsia": 16711935,
  "gainsboro": 14474460,
  "ghostwhite": 16316671,
  "gold": 16766720,
  "goldenrod": 14329120,
  "gray": 8421504,
  "green": 32768,
  "greenyellow": 11403055,
  "grey": 8421504,
  "honeydew": 15794160,
  "hotpink": 16738740,
  "indianred": 13458524,
  "indigo": 4915330,
  "ivory": 16777200,
  "khaki": 15787660,
  "lavender": 15132410,
  "lavenderblush": 16773365,
  "lawngreen": 8190976,
  "lemonchiffon": 16775885,
  "lightblue": 11393254,
  "lightcoral": 15761536,
  "lightcyan": 14745599,
  "lightgoldenrodyellow": 16448210,
  "lightgray": 13882323,
  "lightgreen": 9498256,
  "lightgrey": 13882323,
  "lightpink": 16758465,
  "lightsalmon": 16752762,
  "lightseagreen": 2142890,
  "lightskyblue": 8900346,
  "lightslategray": 7833753,
  "lightslategrey": 7833753,
  "lightsteelblue": 11584734,
  "lightyellow": 16777184,
  "lime": 65280,
  "limegreen": 3329330,
  "linen": 16445670,
  "magenta": 16711935,
  "maroon": 8388608,
  "mediumaquamarine": 6737322,
  "mediumblue": 205,
  "mediumorchid": 12211667,
  "mediumpurple": 9662683,
  "mediumseagreen": 3978097,
  "mediumslateblue": 8087790,
  "mediumspringgreen": 64154,
  "mediumturquoise": 4772300,
  "mediumvioletred": 13047173,
  "midnightblue": 1644912,
  "mintcream": 16121850,
  "mistyrose": 16770273,
  "moccasin": 16770229,
  "navajowhite": 16768685,
  "navy": 128,
  "oldlace": 16643558,
  "olive": 8421376,
  "olivedrab": 7048739,
  "orange": 16753920,
  "orangered": 16729344,
  "orchid": 14315734,
  "palegoldenrod": 15657130,
  "palegreen": 10025880,
  "paleturquoise": 11529966,
  "palevioletred": 14381203,
  "papayawhip": 16773077,
  "peachpuff": 16767673,
  "peru": 13468991,
  "pink": 16761035,
  "plum": 14524637,
  "powderblue": 11591910,
  "purple": 8388736,
  "rebeccapurple": 6697881,
  "red": 16711680,
  "rosybrown": 12357519,
  "royalblue": 4286945,
  "saddlebrown": 9127187,
  "salmon": 16416882,
  "sandybrown": 16032864,
  "seagreen": 3050327,
  "seashell": 16774638,
  "sienna": 10506797,
  "silver": 12632256,
  "skyblue": 8900331,
  "slateblue": 6970061,
  "slategray": 7372944,
  "slategrey": 7372944,
  "snow": 16775930,
  "springgreen": 65407,
  "steelblue": 4620980,
  "tan": 13808780,
  "teal": 32896,
  "thistle": 14204888,
  "tomato": 16737095,
  "turquoise": 4251856,
  "violet": 15631086,
  "wheat": 16113331,
  "white": 16777215,
  "whitesmoke": 16119285,
  "yellow": 16776960,
  "yellowgreen": 10145074
};
const _hslA$1 = { h: 0, s: 0, l: 0 };
const _hslB$1 = { h: 0, s: 0, l: 0 };
function hue2rgb$1(p, q, t) {
  if (t < 0) t += 1;
  if (t > 1) t -= 1;
  if (t < 1 / 6) return p + (q - p) * 6 * t;
  if (t < 1 / 2) return q;
  if (t < 2 / 3) return p + (q - p) * 6 * (2 / 3 - t);
  return p;
}
let Color$1 = class Color {
  constructor(r, g, b) {
    this.isColor = true;
    this.r = 1;
    this.g = 1;
    this.b = 1;
    return this.set(r, g, b);
  }
  set(r, g, b) {
    if (g === void 0 && b === void 0) {
      const value = r;
      if (value && value.isColor) {
        this.copy(value);
      } else if (typeof value === "number") {
        this.setHex(value);
      } else if (typeof value === "string") {
        this.setStyle(value);
      }
    } else {
      this.setRGB(r, g, b);
    }
    return this;
  }
  setScalar(scalar) {
    this.r = scalar;
    this.g = scalar;
    this.b = scalar;
    return this;
  }
  setHex(hex, colorSpace = SRGBColorSpace$1) {
    hex = Math.floor(hex);
    this.r = (hex >> 16 & 255) / 255;
    this.g = (hex >> 8 & 255) / 255;
    this.b = (hex & 255) / 255;
    ColorManagement$1.toWorkingColorSpace(this, colorSpace);
    return this;
  }
  setRGB(r, g, b, colorSpace = ColorManagement$1.workingColorSpace) {
    this.r = r;
    this.g = g;
    this.b = b;
    ColorManagement$1.toWorkingColorSpace(this, colorSpace);
    return this;
  }
  setHSL(h, s, l, colorSpace = ColorManagement$1.workingColorSpace) {
    h = euclideanModulo$1(h, 1);
    s = clamp$2(s, 0, 1);
    l = clamp$2(l, 0, 1);
    if (s === 0) {
      this.r = this.g = this.b = l;
    } else {
      const p = l <= 0.5 ? l * (1 + s) : l + s - l * s;
      const q = 2 * l - p;
      this.r = hue2rgb$1(q, p, h + 1 / 3);
      this.g = hue2rgb$1(q, p, h);
      this.b = hue2rgb$1(q, p, h - 1 / 3);
    }
    ColorManagement$1.toWorkingColorSpace(this, colorSpace);
    return this;
  }
  setStyle(style, colorSpace = SRGBColorSpace$1) {
    function handleAlpha(string) {
      if (string === void 0) return;
      if (parseFloat(string) < 1) {
        console.warn("THREE.Color: Alpha component of " + style + " will be ignored.");
      }
    }
    let m;
    if (m = /^(\w+)\(([^\)]*)\)/.exec(style)) {
      let color2;
      const name = m[1];
      const components = m[2];
      switch (name) {
        case "rgb":
        case "rgba":
          if (color2 = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
            handleAlpha(color2[4]);
            return this.setRGB(
              Math.min(255, parseInt(color2[1], 10)) / 255,
              Math.min(255, parseInt(color2[2], 10)) / 255,
              Math.min(255, parseInt(color2[3], 10)) / 255,
              colorSpace
            );
          }
          if (color2 = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
            handleAlpha(color2[4]);
            return this.setRGB(
              Math.min(100, parseInt(color2[1], 10)) / 100,
              Math.min(100, parseInt(color2[2], 10)) / 100,
              Math.min(100, parseInt(color2[3], 10)) / 100,
              colorSpace
            );
          }
          break;
        case "hsl":
        case "hsla":
          if (color2 = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
            handleAlpha(color2[4]);
            return this.setHSL(
              parseFloat(color2[1]) / 360,
              parseFloat(color2[2]) / 100,
              parseFloat(color2[3]) / 100,
              colorSpace
            );
          }
          break;
        default:
          console.warn("THREE.Color: Unknown color model " + style);
      }
    } else if (m = /^\#([A-Fa-f\d]+)$/.exec(style)) {
      const hex = m[1];
      const size = hex.length;
      if (size === 3) {
        return this.setRGB(
          parseInt(hex.charAt(0), 16) / 15,
          parseInt(hex.charAt(1), 16) / 15,
          parseInt(hex.charAt(2), 16) / 15,
          colorSpace
        );
      } else if (size === 6) {
        return this.setHex(parseInt(hex, 16), colorSpace);
      } else {
        console.warn("THREE.Color: Invalid hex color " + style);
      }
    } else if (style && style.length > 0) {
      return this.setColorName(style, colorSpace);
    }
    return this;
  }
  setColorName(style, colorSpace = SRGBColorSpace$1) {
    const hex = _colorKeywords$1[style.toLowerCase()];
    if (hex !== void 0) {
      this.setHex(hex, colorSpace);
    } else {
      console.warn("THREE.Color: Unknown color " + style);
    }
    return this;
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(color2) {
    this.r = color2.r;
    this.g = color2.g;
    this.b = color2.b;
    return this;
  }
  copySRGBToLinear(color2) {
    this.r = SRGBToLinear$1(color2.r);
    this.g = SRGBToLinear$1(color2.g);
    this.b = SRGBToLinear$1(color2.b);
    return this;
  }
  copyLinearToSRGB(color2) {
    this.r = LinearToSRGB$1(color2.r);
    this.g = LinearToSRGB$1(color2.g);
    this.b = LinearToSRGB$1(color2.b);
    return this;
  }
  convertSRGBToLinear() {
    this.copySRGBToLinear(this);
    return this;
  }
  convertLinearToSRGB() {
    this.copyLinearToSRGB(this);
    return this;
  }
  getHex(colorSpace = SRGBColorSpace$1) {
    ColorManagement$1.fromWorkingColorSpace(_color$1.copy(this), colorSpace);
    return Math.round(clamp$2(_color$1.r * 255, 0, 255)) * 65536 + Math.round(clamp$2(_color$1.g * 255, 0, 255)) * 256 + Math.round(clamp$2(_color$1.b * 255, 0, 255));
  }
  getHexString(colorSpace = SRGBColorSpace$1) {
    return ("000000" + this.getHex(colorSpace).toString(16)).slice(-6);
  }
  getHSL(target, colorSpace = ColorManagement$1.workingColorSpace) {
    ColorManagement$1.fromWorkingColorSpace(_color$1.copy(this), colorSpace);
    const r = _color$1.r, g = _color$1.g, b = _color$1.b;
    const max2 = Math.max(r, g, b);
    const min2 = Math.min(r, g, b);
    let hue, saturation;
    const lightness = (min2 + max2) / 2;
    if (min2 === max2) {
      hue = 0;
      saturation = 0;
    } else {
      const delta = max2 - min2;
      saturation = lightness <= 0.5 ? delta / (max2 + min2) : delta / (2 - max2 - min2);
      switch (max2) {
        case r:
          hue = (g - b) / delta + (g < b ? 6 : 0);
          break;
        case g:
          hue = (b - r) / delta + 2;
          break;
        case b:
          hue = (r - g) / delta + 4;
          break;
      }
      hue /= 6;
    }
    target.h = hue;
    target.s = saturation;
    target.l = lightness;
    return target;
  }
  getRGB(target, colorSpace = ColorManagement$1.workingColorSpace) {
    ColorManagement$1.fromWorkingColorSpace(_color$1.copy(this), colorSpace);
    target.r = _color$1.r;
    target.g = _color$1.g;
    target.b = _color$1.b;
    return target;
  }
  getStyle(colorSpace = SRGBColorSpace$1) {
    ColorManagement$1.fromWorkingColorSpace(_color$1.copy(this), colorSpace);
    const r = _color$1.r, g = _color$1.g, b = _color$1.b;
    if (colorSpace !== SRGBColorSpace$1) {
      return `color(${colorSpace} ${r.toFixed(3)} ${g.toFixed(3)} ${b.toFixed(3)})`;
    }
    return `rgb(${Math.round(r * 255)},${Math.round(g * 255)},${Math.round(b * 255)})`;
  }
  offsetHSL(h, s, l) {
    this.getHSL(_hslA$1);
    return this.setHSL(_hslA$1.h + h, _hslA$1.s + s, _hslA$1.l + l);
  }
  add(color2) {
    this.r += color2.r;
    this.g += color2.g;
    this.b += color2.b;
    return this;
  }
  addColors(color1, color2) {
    this.r = color1.r + color2.r;
    this.g = color1.g + color2.g;
    this.b = color1.b + color2.b;
    return this;
  }
  addScalar(s) {
    this.r += s;
    this.g += s;
    this.b += s;
    return this;
  }
  sub(color2) {
    this.r = Math.max(0, this.r - color2.r);
    this.g = Math.max(0, this.g - color2.g);
    this.b = Math.max(0, this.b - color2.b);
    return this;
  }
  multiply(color2) {
    this.r *= color2.r;
    this.g *= color2.g;
    this.b *= color2.b;
    return this;
  }
  multiplyScalar(s) {
    this.r *= s;
    this.g *= s;
    this.b *= s;
    return this;
  }
  lerp(color2, alpha) {
    this.r += (color2.r - this.r) * alpha;
    this.g += (color2.g - this.g) * alpha;
    this.b += (color2.b - this.b) * alpha;
    return this;
  }
  lerpColors(color1, color2, alpha) {
    this.r = color1.r + (color2.r - color1.r) * alpha;
    this.g = color1.g + (color2.g - color1.g) * alpha;
    this.b = color1.b + (color2.b - color1.b) * alpha;
    return this;
  }
  lerpHSL(color2, alpha) {
    this.getHSL(_hslA$1);
    color2.getHSL(_hslB$1);
    const h = lerp$1(_hslA$1.h, _hslB$1.h, alpha);
    const s = lerp$1(_hslA$1.s, _hslB$1.s, alpha);
    const l = lerp$1(_hslA$1.l, _hslB$1.l, alpha);
    this.setHSL(h, s, l);
    return this;
  }
  setFromVector3(v) {
    this.r = v.x;
    this.g = v.y;
    this.b = v.z;
    return this;
  }
  applyMatrix3(m) {
    const r = this.r, g = this.g, b = this.b;
    const e = m.elements;
    this.r = e[0] * r + e[3] * g + e[6] * b;
    this.g = e[1] * r + e[4] * g + e[7] * b;
    this.b = e[2] * r + e[5] * g + e[8] * b;
    return this;
  }
  equals(c) {
    return c.r === this.r && c.g === this.g && c.b === this.b;
  }
  fromArray(array, offset = 0) {
    this.r = array[offset];
    this.g = array[offset + 1];
    this.b = array[offset + 2];
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this.r;
    array[offset + 1] = this.g;
    array[offset + 2] = this.b;
    return array;
  }
  fromBufferAttribute(attribute, index) {
    this.r = attribute.getX(index);
    this.g = attribute.getY(index);
    this.b = attribute.getZ(index);
    return this;
  }
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    yield this.r;
    yield this.g;
    yield this.b;
  }
};
const _color$1 = /* @__PURE__ */ new Color$1();
Color$1.NAMES = _colorKeywords$1;
let _materialId = 0;
class Material extends EventDispatcher$1 {
  constructor() {
    super();
    this.isMaterial = true;
    Object.defineProperty(this, "id", { value: _materialId++ });
    this.uuid = generateUUID$1();
    this.name = "";
    this.type = "Material";
    this.blending = NormalBlending;
    this.side = FrontSide;
    this.vertexColors = false;
    this.opacity = 1;
    this.transparent = false;
    this.alphaHash = false;
    this.blendSrc = SrcAlphaFactor;
    this.blendDst = OneMinusSrcAlphaFactor;
    this.blendEquation = AddEquation;
    this.blendSrcAlpha = null;
    this.blendDstAlpha = null;
    this.blendEquationAlpha = null;
    this.blendColor = new Color$1(0, 0, 0);
    this.blendAlpha = 0;
    this.depthFunc = LessEqualDepth;
    this.depthTest = true;
    this.depthWrite = true;
    this.stencilWriteMask = 255;
    this.stencilFunc = AlwaysStencilFunc;
    this.stencilRef = 0;
    this.stencilFuncMask = 255;
    this.stencilFail = KeepStencilOp;
    this.stencilZFail = KeepStencilOp;
    this.stencilZPass = KeepStencilOp;
    this.stencilWrite = false;
    this.clippingPlanes = null;
    this.clipIntersection = false;
    this.clipShadows = false;
    this.shadowSide = null;
    this.colorWrite = true;
    this.precision = null;
    this.polygonOffset = false;
    this.polygonOffsetFactor = 0;
    this.polygonOffsetUnits = 0;
    this.dithering = false;
    this.alphaToCoverage = false;
    this.premultipliedAlpha = false;
    this.forceSinglePass = false;
    this.visible = true;
    this.toneMapped = true;
    this.userData = {};
    this.version = 0;
    this._alphaTest = 0;
  }
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(value) {
    if (this._alphaTest > 0 !== value > 0) {
      this.version++;
    }
    this._alphaTest = value;
  }
  // onBeforeRender and onBeforeCompile only supported in WebGLRenderer
  onBeforeRender() {
  }
  onBeforeCompile() {
  }
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  setValues(values) {
    if (values === void 0) return;
    for (const key in values) {
      const newValue = values[key];
      if (newValue === void 0) {
        console.warn(`THREE.Material: parameter '${key}' has value of undefined.`);
        continue;
      }
      const currentValue = this[key];
      if (currentValue === void 0) {
        console.warn(`THREE.Material: '${key}' is not a property of THREE.${this.type}.`);
        continue;
      }
      if (currentValue && currentValue.isColor) {
        currentValue.set(newValue);
      } else if (currentValue && currentValue.isVector3 && (newValue && newValue.isVector3)) {
        currentValue.copy(newValue);
      } else {
        this[key] = newValue;
      }
    }
  }
  toJSON(meta) {
    const isRootObject = meta === void 0 || typeof meta === "string";
    if (isRootObject) {
      meta = {
        textures: {},
        images: {}
      };
    }
    const data = {
      metadata: {
        version: 4.6,
        type: "Material",
        generator: "Material.toJSON"
      }
    };
    data.uuid = this.uuid;
    data.type = this.type;
    if (this.name !== "") data.name = this.name;
    if (this.color && this.color.isColor) data.color = this.color.getHex();
    if (this.roughness !== void 0) data.roughness = this.roughness;
    if (this.metalness !== void 0) data.metalness = this.metalness;
    if (this.sheen !== void 0) data.sheen = this.sheen;
    if (this.sheenColor && this.sheenColor.isColor) data.sheenColor = this.sheenColor.getHex();
    if (this.sheenRoughness !== void 0) data.sheenRoughness = this.sheenRoughness;
    if (this.emissive && this.emissive.isColor) data.emissive = this.emissive.getHex();
    if (this.emissiveIntensity !== void 0 && this.emissiveIntensity !== 1) data.emissiveIntensity = this.emissiveIntensity;
    if (this.specular && this.specular.isColor) data.specular = this.specular.getHex();
    if (this.specularIntensity !== void 0) data.specularIntensity = this.specularIntensity;
    if (this.specularColor && this.specularColor.isColor) data.specularColor = this.specularColor.getHex();
    if (this.shininess !== void 0) data.shininess = this.shininess;
    if (this.clearcoat !== void 0) data.clearcoat = this.clearcoat;
    if (this.clearcoatRoughness !== void 0) data.clearcoatRoughness = this.clearcoatRoughness;
    if (this.clearcoatMap && this.clearcoatMap.isTexture) {
      data.clearcoatMap = this.clearcoatMap.toJSON(meta).uuid;
    }
    if (this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture) {
      data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(meta).uuid;
    }
    if (this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture) {
      data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(meta).uuid;
      data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();
    }
    if (this.dispersion !== void 0) data.dispersion = this.dispersion;
    if (this.iridescence !== void 0) data.iridescence = this.iridescence;
    if (this.iridescenceIOR !== void 0) data.iridescenceIOR = this.iridescenceIOR;
    if (this.iridescenceThicknessRange !== void 0) data.iridescenceThicknessRange = this.iridescenceThicknessRange;
    if (this.iridescenceMap && this.iridescenceMap.isTexture) {
      data.iridescenceMap = this.iridescenceMap.toJSON(meta).uuid;
    }
    if (this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture) {
      data.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(meta).uuid;
    }
    if (this.anisotropy !== void 0) data.anisotropy = this.anisotropy;
    if (this.anisotropyRotation !== void 0) data.anisotropyRotation = this.anisotropyRotation;
    if (this.anisotropyMap && this.anisotropyMap.isTexture) {
      data.anisotropyMap = this.anisotropyMap.toJSON(meta).uuid;
    }
    if (this.map && this.map.isTexture) data.map = this.map.toJSON(meta).uuid;
    if (this.matcap && this.matcap.isTexture) data.matcap = this.matcap.toJSON(meta).uuid;
    if (this.alphaMap && this.alphaMap.isTexture) data.alphaMap = this.alphaMap.toJSON(meta).uuid;
    if (this.lightMap && this.lightMap.isTexture) {
      data.lightMap = this.lightMap.toJSON(meta).uuid;
      data.lightMapIntensity = this.lightMapIntensity;
    }
    if (this.aoMap && this.aoMap.isTexture) {
      data.aoMap = this.aoMap.toJSON(meta).uuid;
      data.aoMapIntensity = this.aoMapIntensity;
    }
    if (this.bumpMap && this.bumpMap.isTexture) {
      data.bumpMap = this.bumpMap.toJSON(meta).uuid;
      data.bumpScale = this.bumpScale;
    }
    if (this.normalMap && this.normalMap.isTexture) {
      data.normalMap = this.normalMap.toJSON(meta).uuid;
      data.normalMapType = this.normalMapType;
      data.normalScale = this.normalScale.toArray();
    }
    if (this.displacementMap && this.displacementMap.isTexture) {
      data.displacementMap = this.displacementMap.toJSON(meta).uuid;
      data.displacementScale = this.displacementScale;
      data.displacementBias = this.displacementBias;
    }
    if (this.roughnessMap && this.roughnessMap.isTexture) data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;
    if (this.metalnessMap && this.metalnessMap.isTexture) data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;
    if (this.emissiveMap && this.emissiveMap.isTexture) data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;
    if (this.specularMap && this.specularMap.isTexture) data.specularMap = this.specularMap.toJSON(meta).uuid;
    if (this.specularIntensityMap && this.specularIntensityMap.isTexture) data.specularIntensityMap = this.specularIntensityMap.toJSON(meta).uuid;
    if (this.specularColorMap && this.specularColorMap.isTexture) data.specularColorMap = this.specularColorMap.toJSON(meta).uuid;
    if (this.envMap && this.envMap.isTexture) {
      data.envMap = this.envMap.toJSON(meta).uuid;
      if (this.combine !== void 0) data.combine = this.combine;
    }
    if (this.envMapRotation !== void 0) data.envMapRotation = this.envMapRotation.toArray();
    if (this.envMapIntensity !== void 0) data.envMapIntensity = this.envMapIntensity;
    if (this.reflectivity !== void 0) data.reflectivity = this.reflectivity;
    if (this.refractionRatio !== void 0) data.refractionRatio = this.refractionRatio;
    if (this.gradientMap && this.gradientMap.isTexture) {
      data.gradientMap = this.gradientMap.toJSON(meta).uuid;
    }
    if (this.transmission !== void 0) data.transmission = this.transmission;
    if (this.transmissionMap && this.transmissionMap.isTexture) data.transmissionMap = this.transmissionMap.toJSON(meta).uuid;
    if (this.thickness !== void 0) data.thickness = this.thickness;
    if (this.thicknessMap && this.thicknessMap.isTexture) data.thicknessMap = this.thicknessMap.toJSON(meta).uuid;
    if (this.attenuationDistance !== void 0 && this.attenuationDistance !== Infinity) data.attenuationDistance = this.attenuationDistance;
    if (this.attenuationColor !== void 0) data.attenuationColor = this.attenuationColor.getHex();
    if (this.size !== void 0) data.size = this.size;
    if (this.shadowSide !== null) data.shadowSide = this.shadowSide;
    if (this.sizeAttenuation !== void 0) data.sizeAttenuation = this.sizeAttenuation;
    if (this.blending !== NormalBlending) data.blending = this.blending;
    if (this.side !== FrontSide) data.side = this.side;
    if (this.vertexColors === true) data.vertexColors = true;
    if (this.opacity < 1) data.opacity = this.opacity;
    if (this.transparent === true) data.transparent = true;
    if (this.blendSrc !== SrcAlphaFactor) data.blendSrc = this.blendSrc;
    if (this.blendDst !== OneMinusSrcAlphaFactor) data.blendDst = this.blendDst;
    if (this.blendEquation !== AddEquation) data.blendEquation = this.blendEquation;
    if (this.blendSrcAlpha !== null) data.blendSrcAlpha = this.blendSrcAlpha;
    if (this.blendDstAlpha !== null) data.blendDstAlpha = this.blendDstAlpha;
    if (this.blendEquationAlpha !== null) data.blendEquationAlpha = this.blendEquationAlpha;
    if (this.blendColor && this.blendColor.isColor) data.blendColor = this.blendColor.getHex();
    if (this.blendAlpha !== 0) data.blendAlpha = this.blendAlpha;
    if (this.depthFunc !== LessEqualDepth) data.depthFunc = this.depthFunc;
    if (this.depthTest === false) data.depthTest = this.depthTest;
    if (this.depthWrite === false) data.depthWrite = this.depthWrite;
    if (this.colorWrite === false) data.colorWrite = this.colorWrite;
    if (this.stencilWriteMask !== 255) data.stencilWriteMask = this.stencilWriteMask;
    if (this.stencilFunc !== AlwaysStencilFunc) data.stencilFunc = this.stencilFunc;
    if (this.stencilRef !== 0) data.stencilRef = this.stencilRef;
    if (this.stencilFuncMask !== 255) data.stencilFuncMask = this.stencilFuncMask;
    if (this.stencilFail !== KeepStencilOp) data.stencilFail = this.stencilFail;
    if (this.stencilZFail !== KeepStencilOp) data.stencilZFail = this.stencilZFail;
    if (this.stencilZPass !== KeepStencilOp) data.stencilZPass = this.stencilZPass;
    if (this.stencilWrite === true) data.stencilWrite = this.stencilWrite;
    if (this.rotation !== void 0 && this.rotation !== 0) data.rotation = this.rotation;
    if (this.polygonOffset === true) data.polygonOffset = true;
    if (this.polygonOffsetFactor !== 0) data.polygonOffsetFactor = this.polygonOffsetFactor;
    if (this.polygonOffsetUnits !== 0) data.polygonOffsetUnits = this.polygonOffsetUnits;
    if (this.linewidth !== void 0 && this.linewidth !== 1) data.linewidth = this.linewidth;
    if (this.dashSize !== void 0) data.dashSize = this.dashSize;
    if (this.gapSize !== void 0) data.gapSize = this.gapSize;
    if (this.scale !== void 0) data.scale = this.scale;
    if (this.dithering === true) data.dithering = true;
    if (this.alphaTest > 0) data.alphaTest = this.alphaTest;
    if (this.alphaHash === true) data.alphaHash = true;
    if (this.alphaToCoverage === true) data.alphaToCoverage = true;
    if (this.premultipliedAlpha === true) data.premultipliedAlpha = true;
    if (this.forceSinglePass === true) data.forceSinglePass = true;
    if (this.wireframe === true) data.wireframe = true;
    if (this.wireframeLinewidth > 1) data.wireframeLinewidth = this.wireframeLinewidth;
    if (this.wireframeLinecap !== "round") data.wireframeLinecap = this.wireframeLinecap;
    if (this.wireframeLinejoin !== "round") data.wireframeLinejoin = this.wireframeLinejoin;
    if (this.flatShading === true) data.flatShading = true;
    if (this.visible === false) data.visible = false;
    if (this.toneMapped === false) data.toneMapped = false;
    if (this.fog === false) data.fog = false;
    if (Object.keys(this.userData).length > 0) data.userData = this.userData;
    function extractFromCache(cache2) {
      const values = [];
      for (const key in cache2) {
        const data2 = cache2[key];
        delete data2.metadata;
        values.push(data2);
      }
      return values;
    }
    if (isRootObject) {
      const textures = extractFromCache(meta.textures);
      const images = extractFromCache(meta.images);
      if (textures.length > 0) data.textures = textures;
      if (images.length > 0) data.images = images;
    }
    return data;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(source) {
    this.name = source.name;
    this.blending = source.blending;
    this.side = source.side;
    this.vertexColors = source.vertexColors;
    this.opacity = source.opacity;
    this.transparent = source.transparent;
    this.blendSrc = source.blendSrc;
    this.blendDst = source.blendDst;
    this.blendEquation = source.blendEquation;
    this.blendSrcAlpha = source.blendSrcAlpha;
    this.blendDstAlpha = source.blendDstAlpha;
    this.blendEquationAlpha = source.blendEquationAlpha;
    this.blendColor.copy(source.blendColor);
    this.blendAlpha = source.blendAlpha;
    this.depthFunc = source.depthFunc;
    this.depthTest = source.depthTest;
    this.depthWrite = source.depthWrite;
    this.stencilWriteMask = source.stencilWriteMask;
    this.stencilFunc = source.stencilFunc;
    this.stencilRef = source.stencilRef;
    this.stencilFuncMask = source.stencilFuncMask;
    this.stencilFail = source.stencilFail;
    this.stencilZFail = source.stencilZFail;
    this.stencilZPass = source.stencilZPass;
    this.stencilWrite = source.stencilWrite;
    const srcPlanes = source.clippingPlanes;
    let dstPlanes = null;
    if (srcPlanes !== null) {
      const n = srcPlanes.length;
      dstPlanes = new Array(n);
      for (let i = 0; i !== n; ++i) {
        dstPlanes[i] = srcPlanes[i].clone();
      }
    }
    this.clippingPlanes = dstPlanes;
    this.clipIntersection = source.clipIntersection;
    this.clipShadows = source.clipShadows;
    this.shadowSide = source.shadowSide;
    this.colorWrite = source.colorWrite;
    this.precision = source.precision;
    this.polygonOffset = source.polygonOffset;
    this.polygonOffsetFactor = source.polygonOffsetFactor;
    this.polygonOffsetUnits = source.polygonOffsetUnits;
    this.dithering = source.dithering;
    this.alphaTest = source.alphaTest;
    this.alphaHash = source.alphaHash;
    this.alphaToCoverage = source.alphaToCoverage;
    this.premultipliedAlpha = source.premultipliedAlpha;
    this.forceSinglePass = source.forceSinglePass;
    this.visible = source.visible;
    this.toneMapped = source.toneMapped;
    this.userData = JSON.parse(JSON.stringify(source.userData));
    return this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(value) {
    if (value === true) this.version++;
  }
  onBuild() {
    console.warn("Material: onBuild() has been removed.");
  }
}
class MeshBasicMaterial extends Material {
  constructor(parameters) {
    super();
    this.isMeshBasicMaterial = true;
    this.type = "MeshBasicMaterial";
    this.color = new Color$1(16777215);
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.specularMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.envMapRotation = new Euler();
    this.combine = MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.fog = true;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.map = source.map;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.specularMap = source.specularMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.envMapRotation.copy(source.envMapRotation);
    this.combine = source.combine;
    this.reflectivity = source.reflectivity;
    this.refractionRatio = source.refractionRatio;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.fog = source.fog;
    return this;
  }
}
const _tables = /* @__PURE__ */ _generateTables();
function _generateTables() {
  const buffer = new ArrayBuffer(4);
  const floatView = new Float32Array(buffer);
  const uint32View = new Uint32Array(buffer);
  const baseTable = new Uint32Array(512);
  const shiftTable = new Uint32Array(512);
  for (let i = 0; i < 256; ++i) {
    const e = i - 127;
    if (e < -27) {
      baseTable[i] = 0;
      baseTable[i | 256] = 32768;
      shiftTable[i] = 24;
      shiftTable[i | 256] = 24;
    } else if (e < -14) {
      baseTable[i] = 1024 >> -e - 14;
      baseTable[i | 256] = 1024 >> -e - 14 | 32768;
      shiftTable[i] = -e - 1;
      shiftTable[i | 256] = -e - 1;
    } else if (e <= 15) {
      baseTable[i] = e + 15 << 10;
      baseTable[i | 256] = e + 15 << 10 | 32768;
      shiftTable[i] = 13;
      shiftTable[i | 256] = 13;
    } else if (e < 128) {
      baseTable[i] = 31744;
      baseTable[i | 256] = 64512;
      shiftTable[i] = 24;
      shiftTable[i | 256] = 24;
    } else {
      baseTable[i] = 31744;
      baseTable[i | 256] = 64512;
      shiftTable[i] = 13;
      shiftTable[i | 256] = 13;
    }
  }
  const mantissaTable = new Uint32Array(2048);
  const exponentTable = new Uint32Array(64);
  const offsetTable = new Uint32Array(64);
  for (let i = 1; i < 1024; ++i) {
    let m = i << 13;
    let e = 0;
    while ((m & 8388608) === 0) {
      m <<= 1;
      e -= 8388608;
    }
    m &= -8388609;
    e += 947912704;
    mantissaTable[i] = m | e;
  }
  for (let i = 1024; i < 2048; ++i) {
    mantissaTable[i] = 939524096 + (i - 1024 << 13);
  }
  for (let i = 1; i < 31; ++i) {
    exponentTable[i] = i << 23;
  }
  exponentTable[31] = 1199570944;
  exponentTable[32] = 2147483648;
  for (let i = 33; i < 63; ++i) {
    exponentTable[i] = 2147483648 + (i - 32 << 23);
  }
  exponentTable[63] = 3347054592;
  for (let i = 1; i < 64; ++i) {
    if (i !== 32) {
      offsetTable[i] = 1024;
    }
  }
  return {
    floatView,
    uint32View,
    baseTable,
    shiftTable,
    mantissaTable,
    exponentTable,
    offsetTable
  };
}
function toHalfFloat(val) {
  if (Math.abs(val) > 65504) console.warn("THREE.DataUtils.toHalfFloat(): Value out of range.");
  val = clamp$2(val, -65504, 65504);
  _tables.floatView[0] = val;
  const f = _tables.uint32View[0];
  const e = f >> 23 & 511;
  return _tables.baseTable[e] + ((f & 8388607) >> _tables.shiftTable[e]);
}
function fromHalfFloat(val) {
  const m = val >> 10;
  _tables.uint32View[0] = _tables.mantissaTable[_tables.offsetTable[m] + (val & 1023)] + _tables.exponentTable[m];
  return _tables.floatView[0];
}
const DataUtils = {
  toHalfFloat,
  fromHalfFloat
};
const _vector$9 = /* @__PURE__ */ new Vector3$1();
const _vector2$1 = /* @__PURE__ */ new Vector2$1();
let BufferAttribute$1 = class BufferAttribute {
  constructor(array, itemSize, normalized = false) {
    if (Array.isArray(array)) {
      throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
    }
    this.isBufferAttribute = true;
    this.name = "";
    this.array = array;
    this.itemSize = itemSize;
    this.count = array !== void 0 ? array.length / itemSize : 0;
    this.normalized = normalized;
    this.usage = StaticDrawUsage$1;
    this.updateRanges = [];
    this.gpuType = FloatType$1;
    this.version = 0;
  }
  onUploadCallback() {
  }
  set needsUpdate(value) {
    if (value === true) this.version++;
  }
  setUsage(value) {
    this.usage = value;
    return this;
  }
  addUpdateRange(start, count) {
    this.updateRanges.push({ start, count });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(source) {
    this.name = source.name;
    this.array = new source.array.constructor(source.array);
    this.itemSize = source.itemSize;
    this.count = source.count;
    this.normalized = source.normalized;
    this.usage = source.usage;
    this.gpuType = source.gpuType;
    return this;
  }
  copyAt(index1, attribute, index2) {
    index1 *= this.itemSize;
    index2 *= attribute.itemSize;
    for (let i = 0, l = this.itemSize; i < l; i++) {
      this.array[index1 + i] = attribute.array[index2 + i];
    }
    return this;
  }
  copyArray(array) {
    this.array.set(array);
    return this;
  }
  applyMatrix3(m) {
    if (this.itemSize === 2) {
      for (let i = 0, l = this.count; i < l; i++) {
        _vector2$1.fromBufferAttribute(this, i);
        _vector2$1.applyMatrix3(m);
        this.setXY(i, _vector2$1.x, _vector2$1.y);
      }
    } else if (this.itemSize === 3) {
      for (let i = 0, l = this.count; i < l; i++) {
        _vector$9.fromBufferAttribute(this, i);
        _vector$9.applyMatrix3(m);
        this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
      }
    }
    return this;
  }
  applyMatrix4(m) {
    for (let i = 0, l = this.count; i < l; i++) {
      _vector$9.fromBufferAttribute(this, i);
      _vector$9.applyMatrix4(m);
      this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
    }
    return this;
  }
  applyNormalMatrix(m) {
    for (let i = 0, l = this.count; i < l; i++) {
      _vector$9.fromBufferAttribute(this, i);
      _vector$9.applyNormalMatrix(m);
      this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
    }
    return this;
  }
  transformDirection(m) {
    for (let i = 0, l = this.count; i < l; i++) {
      _vector$9.fromBufferAttribute(this, i);
      _vector$9.transformDirection(m);
      this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
    }
    return this;
  }
  set(value, offset = 0) {
    this.array.set(value, offset);
    return this;
  }
  getComponent(index, component) {
    let value = this.array[index * this.itemSize + component];
    if (this.normalized) value = denormalize$1(value, this.array);
    return value;
  }
  setComponent(index, component, value) {
    if (this.normalized) value = normalize$2(value, this.array);
    this.array[index * this.itemSize + component] = value;
    return this;
  }
  getX(index) {
    let x = this.array[index * this.itemSize];
    if (this.normalized) x = denormalize$1(x, this.array);
    return x;
  }
  setX(index, x) {
    if (this.normalized) x = normalize$2(x, this.array);
    this.array[index * this.itemSize] = x;
    return this;
  }
  getY(index) {
    let y = this.array[index * this.itemSize + 1];
    if (this.normalized) y = denormalize$1(y, this.array);
    return y;
  }
  setY(index, y) {
    if (this.normalized) y = normalize$2(y, this.array);
    this.array[index * this.itemSize + 1] = y;
    return this;
  }
  getZ(index) {
    let z = this.array[index * this.itemSize + 2];
    if (this.normalized) z = denormalize$1(z, this.array);
    return z;
  }
  setZ(index, z) {
    if (this.normalized) z = normalize$2(z, this.array);
    this.array[index * this.itemSize + 2] = z;
    return this;
  }
  getW(index) {
    let w = this.array[index * this.itemSize + 3];
    if (this.normalized) w = denormalize$1(w, this.array);
    return w;
  }
  setW(index, w) {
    if (this.normalized) w = normalize$2(w, this.array);
    this.array[index * this.itemSize + 3] = w;
    return this;
  }
  setXY(index, x, y) {
    index *= this.itemSize;
    if (this.normalized) {
      x = normalize$2(x, this.array);
      y = normalize$2(y, this.array);
    }
    this.array[index + 0] = x;
    this.array[index + 1] = y;
    return this;
  }
  setXYZ(index, x, y, z) {
    index *= this.itemSize;
    if (this.normalized) {
      x = normalize$2(x, this.array);
      y = normalize$2(y, this.array);
      z = normalize$2(z, this.array);
    }
    this.array[index + 0] = x;
    this.array[index + 1] = y;
    this.array[index + 2] = z;
    return this;
  }
  setXYZW(index, x, y, z, w) {
    index *= this.itemSize;
    if (this.normalized) {
      x = normalize$2(x, this.array);
      y = normalize$2(y, this.array);
      z = normalize$2(z, this.array);
      w = normalize$2(w, this.array);
    }
    this.array[index + 0] = x;
    this.array[index + 1] = y;
    this.array[index + 2] = z;
    this.array[index + 3] = w;
    return this;
  }
  onUpload(callback) {
    this.onUploadCallback = callback;
    return this;
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const data = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.from(this.array),
      normalized: this.normalized
    };
    if (this.name !== "") data.name = this.name;
    if (this.usage !== StaticDrawUsage$1) data.usage = this.usage;
    return data;
  }
};
class Int8BufferAttribute extends BufferAttribute$1 {
  constructor(array, itemSize, normalized) {
    super(new Int8Array(array), itemSize, normalized);
  }
}
class Uint8BufferAttribute extends BufferAttribute$1 {
  constructor(array, itemSize, normalized) {
    super(new Uint8Array(array), itemSize, normalized);
  }
}
class Uint8ClampedBufferAttribute extends BufferAttribute$1 {
  constructor(array, itemSize, normalized) {
    super(new Uint8ClampedArray(array), itemSize, normalized);
  }
}
class Int16BufferAttribute extends BufferAttribute$1 {
  constructor(array, itemSize, normalized) {
    super(new Int16Array(array), itemSize, normalized);
  }
}
class Uint16BufferAttribute extends BufferAttribute$1 {
  constructor(array, itemSize, normalized) {
    super(new Uint16Array(array), itemSize, normalized);
  }
}
class Int32BufferAttribute extends BufferAttribute$1 {
  constructor(array, itemSize, normalized) {
    super(new Int32Array(array), itemSize, normalized);
  }
}
class Uint32BufferAttribute extends BufferAttribute$1 {
  constructor(array, itemSize, normalized) {
    super(new Uint32Array(array), itemSize, normalized);
  }
}
class Float16BufferAttribute extends BufferAttribute$1 {
  constructor(array, itemSize, normalized) {
    super(new Uint16Array(array), itemSize, normalized);
    this.isFloat16BufferAttribute = true;
  }
  getX(index) {
    let x = fromHalfFloat(this.array[index * this.itemSize]);
    if (this.normalized) x = denormalize$1(x, this.array);
    return x;
  }
  setX(index, x) {
    if (this.normalized) x = normalize$2(x, this.array);
    this.array[index * this.itemSize] = toHalfFloat(x);
    return this;
  }
  getY(index) {
    let y = fromHalfFloat(this.array[index * this.itemSize + 1]);
    if (this.normalized) y = denormalize$1(y, this.array);
    return y;
  }
  setY(index, y) {
    if (this.normalized) y = normalize$2(y, this.array);
    this.array[index * this.itemSize + 1] = toHalfFloat(y);
    return this;
  }
  getZ(index) {
    let z = fromHalfFloat(this.array[index * this.itemSize + 2]);
    if (this.normalized) z = denormalize$1(z, this.array);
    return z;
  }
  setZ(index, z) {
    if (this.normalized) z = normalize$2(z, this.array);
    this.array[index * this.itemSize + 2] = toHalfFloat(z);
    return this;
  }
  getW(index) {
    let w = fromHalfFloat(this.array[index * this.itemSize + 3]);
    if (this.normalized) w = denormalize$1(w, this.array);
    return w;
  }
  setW(index, w) {
    if (this.normalized) w = normalize$2(w, this.array);
    this.array[index * this.itemSize + 3] = toHalfFloat(w);
    return this;
  }
  setXY(index, x, y) {
    index *= this.itemSize;
    if (this.normalized) {
      x = normalize$2(x, this.array);
      y = normalize$2(y, this.array);
    }
    this.array[index + 0] = toHalfFloat(x);
    this.array[index + 1] = toHalfFloat(y);
    return this;
  }
  setXYZ(index, x, y, z) {
    index *= this.itemSize;
    if (this.normalized) {
      x = normalize$2(x, this.array);
      y = normalize$2(y, this.array);
      z = normalize$2(z, this.array);
    }
    this.array[index + 0] = toHalfFloat(x);
    this.array[index + 1] = toHalfFloat(y);
    this.array[index + 2] = toHalfFloat(z);
    return this;
  }
  setXYZW(index, x, y, z, w) {
    index *= this.itemSize;
    if (this.normalized) {
      x = normalize$2(x, this.array);
      y = normalize$2(y, this.array);
      z = normalize$2(z, this.array);
      w = normalize$2(w, this.array);
    }
    this.array[index + 0] = toHalfFloat(x);
    this.array[index + 1] = toHalfFloat(y);
    this.array[index + 2] = toHalfFloat(z);
    this.array[index + 3] = toHalfFloat(w);
    return this;
  }
}
class Float32BufferAttribute extends BufferAttribute$1 {
  constructor(array, itemSize, normalized) {
    super(new Float32Array(array), itemSize, normalized);
  }
}
let _id$1 = 0;
const _m1$3 = /* @__PURE__ */ new Matrix4$1();
const _obj = /* @__PURE__ */ new Object3D();
const _offset = /* @__PURE__ */ new Vector3$1();
const _box$2 = /* @__PURE__ */ new Box3();
const _boxMorphTargets = /* @__PURE__ */ new Box3();
const _vector$8 = /* @__PURE__ */ new Vector3$1();
class BufferGeometry extends EventDispatcher$1 {
  constructor() {
    super();
    this.isBufferGeometry = true;
    Object.defineProperty(this, "id", { value: _id$1++ });
    this.uuid = generateUUID$1();
    this.name = "";
    this.type = "BufferGeometry";
    this.index = null;
    this.indirect = null;
    this.attributes = {};
    this.morphAttributes = {};
    this.morphTargetsRelative = false;
    this.groups = [];
    this.boundingBox = null;
    this.boundingSphere = null;
    this.drawRange = { start: 0, count: Infinity };
    this.userData = {};
  }
  getIndex() {
    return this.index;
  }
  setIndex(index) {
    if (Array.isArray(index)) {
      this.index = new (arrayNeedsUint32(index) ? Uint32BufferAttribute : Uint16BufferAttribute)(index, 1);
    } else {
      this.index = index;
    }
    return this;
  }
  setIndirect(indirect) {
    this.indirect = indirect;
    return this;
  }
  getIndirect() {
    return this.indirect;
  }
  getAttribute(name) {
    return this.attributes[name];
  }
  setAttribute(name, attribute) {
    this.attributes[name] = attribute;
    return this;
  }
  deleteAttribute(name) {
    delete this.attributes[name];
    return this;
  }
  hasAttribute(name) {
    return this.attributes[name] !== void 0;
  }
  addGroup(start, count, materialIndex = 0) {
    this.groups.push({
      start,
      count,
      materialIndex
    });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(start, count) {
    this.drawRange.start = start;
    this.drawRange.count = count;
  }
  applyMatrix4(matrix) {
    const position = this.attributes.position;
    if (position !== void 0) {
      position.applyMatrix4(matrix);
      position.needsUpdate = true;
    }
    const normal = this.attributes.normal;
    if (normal !== void 0) {
      const normalMatrix = new Matrix3$1().getNormalMatrix(matrix);
      normal.applyNormalMatrix(normalMatrix);
      normal.needsUpdate = true;
    }
    const tangent = this.attributes.tangent;
    if (tangent !== void 0) {
      tangent.transformDirection(matrix);
      tangent.needsUpdate = true;
    }
    if (this.boundingBox !== null) {
      this.computeBoundingBox();
    }
    if (this.boundingSphere !== null) {
      this.computeBoundingSphere();
    }
    return this;
  }
  applyQuaternion(q) {
    _m1$3.makeRotationFromQuaternion(q);
    this.applyMatrix4(_m1$3);
    return this;
  }
  rotateX(angle) {
    _m1$3.makeRotationX(angle);
    this.applyMatrix4(_m1$3);
    return this;
  }
  rotateY(angle) {
    _m1$3.makeRotationY(angle);
    this.applyMatrix4(_m1$3);
    return this;
  }
  rotateZ(angle) {
    _m1$3.makeRotationZ(angle);
    this.applyMatrix4(_m1$3);
    return this;
  }
  translate(x, y, z) {
    _m1$3.makeTranslation(x, y, z);
    this.applyMatrix4(_m1$3);
    return this;
  }
  scale(x, y, z) {
    _m1$3.makeScale(x, y, z);
    this.applyMatrix4(_m1$3);
    return this;
  }
  lookAt(vector) {
    _obj.lookAt(vector);
    _obj.updateMatrix();
    this.applyMatrix4(_obj.matrix);
    return this;
  }
  center() {
    this.computeBoundingBox();
    this.boundingBox.getCenter(_offset).negate();
    this.translate(_offset.x, _offset.y, _offset.z);
    return this;
  }
  setFromPoints(points) {
    const positionAttribute = this.getAttribute("position");
    if (positionAttribute === void 0) {
      const position = [];
      for (let i = 0, l = points.length; i < l; i++) {
        const point = points[i];
        position.push(point.x, point.y, point.z || 0);
      }
      this.setAttribute("position", new Float32BufferAttribute(position, 3));
    } else {
      const l = Math.min(points.length, positionAttribute.count);
      for (let i = 0; i < l; i++) {
        const point = points[i];
        positionAttribute.setXYZ(i, point.x, point.y, point.z || 0);
      }
      if (points.length > positionAttribute.count) {
        console.warn("THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry.");
      }
      positionAttribute.needsUpdate = true;
    }
    return this;
  }
  computeBoundingBox() {
    if (this.boundingBox === null) {
      this.boundingBox = new Box3();
    }
    const position = this.attributes.position;
    const morphAttributesPosition = this.morphAttributes.position;
    if (position && position.isGLBufferAttribute) {
      console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.", this);
      this.boundingBox.set(
        new Vector3$1(-Infinity, -Infinity, -Infinity),
        new Vector3$1(Infinity, Infinity, Infinity)
      );
      return;
    }
    if (position !== void 0) {
      this.boundingBox.setFromBufferAttribute(position);
      if (morphAttributesPosition) {
        for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
          const morphAttribute = morphAttributesPosition[i];
          _box$2.setFromBufferAttribute(morphAttribute);
          if (this.morphTargetsRelative) {
            _vector$8.addVectors(this.boundingBox.min, _box$2.min);
            this.boundingBox.expandByPoint(_vector$8);
            _vector$8.addVectors(this.boundingBox.max, _box$2.max);
            this.boundingBox.expandByPoint(_vector$8);
          } else {
            this.boundingBox.expandByPoint(_box$2.min);
            this.boundingBox.expandByPoint(_box$2.max);
          }
        }
      }
    } else {
      this.boundingBox.makeEmpty();
    }
    if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {
      console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
    }
  }
  computeBoundingSphere() {
    if (this.boundingSphere === null) {
      this.boundingSphere = new Sphere();
    }
    const position = this.attributes.position;
    const morphAttributesPosition = this.morphAttributes.position;
    if (position && position.isGLBufferAttribute) {
      console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.", this);
      this.boundingSphere.set(new Vector3$1(), Infinity);
      return;
    }
    if (position) {
      const center = this.boundingSphere.center;
      _box$2.setFromBufferAttribute(position);
      if (morphAttributesPosition) {
        for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
          const morphAttribute = morphAttributesPosition[i];
          _boxMorphTargets.setFromBufferAttribute(morphAttribute);
          if (this.morphTargetsRelative) {
            _vector$8.addVectors(_box$2.min, _boxMorphTargets.min);
            _box$2.expandByPoint(_vector$8);
            _vector$8.addVectors(_box$2.max, _boxMorphTargets.max);
            _box$2.expandByPoint(_vector$8);
          } else {
            _box$2.expandByPoint(_boxMorphTargets.min);
            _box$2.expandByPoint(_boxMorphTargets.max);
          }
        }
      }
      _box$2.getCenter(center);
      let maxRadiusSq = 0;
      for (let i = 0, il = position.count; i < il; i++) {
        _vector$8.fromBufferAttribute(position, i);
        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));
      }
      if (morphAttributesPosition) {
        for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
          const morphAttribute = morphAttributesPosition[i];
          const morphTargetsRelative = this.morphTargetsRelative;
          for (let j = 0, jl = morphAttribute.count; j < jl; j++) {
            _vector$8.fromBufferAttribute(morphAttribute, j);
            if (morphTargetsRelative) {
              _offset.fromBufferAttribute(position, j);
              _vector$8.add(_offset);
            }
            maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));
          }
        }
      }
      this.boundingSphere.radius = Math.sqrt(maxRadiusSq);
      if (isNaN(this.boundingSphere.radius)) {
        console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
      }
    }
  }
  computeTangents() {
    const index = this.index;
    const attributes = this.attributes;
    if (index === null || attributes.position === void 0 || attributes.normal === void 0 || attributes.uv === void 0) {
      console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
      return;
    }
    const positionAttribute = attributes.position;
    const normalAttribute = attributes.normal;
    const uvAttribute = attributes.uv;
    if (this.hasAttribute("tangent") === false) {
      this.setAttribute("tangent", new BufferAttribute$1(new Float32Array(4 * positionAttribute.count), 4));
    }
    const tangentAttribute = this.getAttribute("tangent");
    const tan1 = [], tan2 = [];
    for (let i = 0; i < positionAttribute.count; i++) {
      tan1[i] = new Vector3$1();
      tan2[i] = new Vector3$1();
    }
    const vA = new Vector3$1(), vB = new Vector3$1(), vC = new Vector3$1(), uvA = new Vector2$1(), uvB = new Vector2$1(), uvC = new Vector2$1(), sdir = new Vector3$1(), tdir = new Vector3$1();
    function handleTriangle(a, b, c) {
      vA.fromBufferAttribute(positionAttribute, a);
      vB.fromBufferAttribute(positionAttribute, b);
      vC.fromBufferAttribute(positionAttribute, c);
      uvA.fromBufferAttribute(uvAttribute, a);
      uvB.fromBufferAttribute(uvAttribute, b);
      uvC.fromBufferAttribute(uvAttribute, c);
      vB.sub(vA);
      vC.sub(vA);
      uvB.sub(uvA);
      uvC.sub(uvA);
      const r = 1 / (uvB.x * uvC.y - uvC.x * uvB.y);
      if (!isFinite(r)) return;
      sdir.copy(vB).multiplyScalar(uvC.y).addScaledVector(vC, -uvB.y).multiplyScalar(r);
      tdir.copy(vC).multiplyScalar(uvB.x).addScaledVector(vB, -uvC.x).multiplyScalar(r);
      tan1[a].add(sdir);
      tan1[b].add(sdir);
      tan1[c].add(sdir);
      tan2[a].add(tdir);
      tan2[b].add(tdir);
      tan2[c].add(tdir);
    }
    let groups = this.groups;
    if (groups.length === 0) {
      groups = [{
        start: 0,
        count: index.count
      }];
    }
    for (let i = 0, il = groups.length; i < il; ++i) {
      const group = groups[i];
      const start = group.start;
      const count = group.count;
      for (let j = start, jl = start + count; j < jl; j += 3) {
        handleTriangle(
          index.getX(j + 0),
          index.getX(j + 1),
          index.getX(j + 2)
        );
      }
    }
    const tmp2 = new Vector3$1(), tmp22 = new Vector3$1();
    const n = new Vector3$1(), n2 = new Vector3$1();
    function handleVertex(v) {
      n.fromBufferAttribute(normalAttribute, v);
      n2.copy(n);
      const t = tan1[v];
      tmp2.copy(t);
      tmp2.sub(n.multiplyScalar(n.dot(t))).normalize();
      tmp22.crossVectors(n2, t);
      const test = tmp22.dot(tan2[v]);
      const w = test < 0 ? -1 : 1;
      tangentAttribute.setXYZW(v, tmp2.x, tmp2.y, tmp2.z, w);
    }
    for (let i = 0, il = groups.length; i < il; ++i) {
      const group = groups[i];
      const start = group.start;
      const count = group.count;
      for (let j = start, jl = start + count; j < jl; j += 3) {
        handleVertex(index.getX(j + 0));
        handleVertex(index.getX(j + 1));
        handleVertex(index.getX(j + 2));
      }
    }
  }
  computeVertexNormals() {
    const index = this.index;
    const positionAttribute = this.getAttribute("position");
    if (positionAttribute !== void 0) {
      let normalAttribute = this.getAttribute("normal");
      if (normalAttribute === void 0) {
        normalAttribute = new BufferAttribute$1(new Float32Array(positionAttribute.count * 3), 3);
        this.setAttribute("normal", normalAttribute);
      } else {
        for (let i = 0, il = normalAttribute.count; i < il; i++) {
          normalAttribute.setXYZ(i, 0, 0, 0);
        }
      }
      const pA = new Vector3$1(), pB = new Vector3$1(), pC = new Vector3$1();
      const nA = new Vector3$1(), nB = new Vector3$1(), nC = new Vector3$1();
      const cb = new Vector3$1(), ab = new Vector3$1();
      if (index) {
        for (let i = 0, il = index.count; i < il; i += 3) {
          const vA = index.getX(i + 0);
          const vB = index.getX(i + 1);
          const vC = index.getX(i + 2);
          pA.fromBufferAttribute(positionAttribute, vA);
          pB.fromBufferAttribute(positionAttribute, vB);
          pC.fromBufferAttribute(positionAttribute, vC);
          cb.subVectors(pC, pB);
          ab.subVectors(pA, pB);
          cb.cross(ab);
          nA.fromBufferAttribute(normalAttribute, vA);
          nB.fromBufferAttribute(normalAttribute, vB);
          nC.fromBufferAttribute(normalAttribute, vC);
          nA.add(cb);
          nB.add(cb);
          nC.add(cb);
          normalAttribute.setXYZ(vA, nA.x, nA.y, nA.z);
          normalAttribute.setXYZ(vB, nB.x, nB.y, nB.z);
          normalAttribute.setXYZ(vC, nC.x, nC.y, nC.z);
        }
      } else {
        for (let i = 0, il = positionAttribute.count; i < il; i += 3) {
          pA.fromBufferAttribute(positionAttribute, i + 0);
          pB.fromBufferAttribute(positionAttribute, i + 1);
          pC.fromBufferAttribute(positionAttribute, i + 2);
          cb.subVectors(pC, pB);
          ab.subVectors(pA, pB);
          cb.cross(ab);
          normalAttribute.setXYZ(i + 0, cb.x, cb.y, cb.z);
          normalAttribute.setXYZ(i + 1, cb.x, cb.y, cb.z);
          normalAttribute.setXYZ(i + 2, cb.x, cb.y, cb.z);
        }
      }
      this.normalizeNormals();
      normalAttribute.needsUpdate = true;
    }
  }
  normalizeNormals() {
    const normals = this.attributes.normal;
    for (let i = 0, il = normals.count; i < il; i++) {
      _vector$8.fromBufferAttribute(normals, i);
      _vector$8.normalize();
      normals.setXYZ(i, _vector$8.x, _vector$8.y, _vector$8.z);
    }
  }
  toNonIndexed() {
    function convertBufferAttribute(attribute, indices2) {
      const array = attribute.array;
      const itemSize = attribute.itemSize;
      const normalized = attribute.normalized;
      const array2 = new array.constructor(indices2.length * itemSize);
      let index = 0, index2 = 0;
      for (let i = 0, l = indices2.length; i < l; i++) {
        if (attribute.isInterleavedBufferAttribute) {
          index = indices2[i] * attribute.data.stride + attribute.offset;
        } else {
          index = indices2[i] * itemSize;
        }
        for (let j = 0; j < itemSize; j++) {
          array2[index2++] = array[index++];
        }
      }
      return new BufferAttribute$1(array2, itemSize, normalized);
    }
    if (this.index === null) {
      console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.");
      return this;
    }
    const geometry2 = new BufferGeometry();
    const indices = this.index.array;
    const attributes = this.attributes;
    for (const name in attributes) {
      const attribute = attributes[name];
      const newAttribute = convertBufferAttribute(attribute, indices);
      geometry2.setAttribute(name, newAttribute);
    }
    const morphAttributes = this.morphAttributes;
    for (const name in morphAttributes) {
      const morphArray = [];
      const morphAttribute = morphAttributes[name];
      for (let i = 0, il = morphAttribute.length; i < il; i++) {
        const attribute = morphAttribute[i];
        const newAttribute = convertBufferAttribute(attribute, indices);
        morphArray.push(newAttribute);
      }
      geometry2.morphAttributes[name] = morphArray;
    }
    geometry2.morphTargetsRelative = this.morphTargetsRelative;
    const groups = this.groups;
    for (let i = 0, l = groups.length; i < l; i++) {
      const group = groups[i];
      geometry2.addGroup(group.start, group.count, group.materialIndex);
    }
    return geometry2;
  }
  toJSON() {
    const data = {
      metadata: {
        version: 4.6,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON"
      }
    };
    data.uuid = this.uuid;
    data.type = this.type;
    if (this.name !== "") data.name = this.name;
    if (Object.keys(this.userData).length > 0) data.userData = this.userData;
    if (this.parameters !== void 0) {
      const parameters = this.parameters;
      for (const key in parameters) {
        if (parameters[key] !== void 0) data[key] = parameters[key];
      }
      return data;
    }
    data.data = { attributes: {} };
    const index = this.index;
    if (index !== null) {
      data.data.index = {
        type: index.array.constructor.name,
        array: Array.prototype.slice.call(index.array)
      };
    }
    const attributes = this.attributes;
    for (const key in attributes) {
      const attribute = attributes[key];
      data.data.attributes[key] = attribute.toJSON(data.data);
    }
    const morphAttributes = {};
    let hasMorphAttributes = false;
    for (const key in this.morphAttributes) {
      const attributeArray = this.morphAttributes[key];
      const array = [];
      for (let i = 0, il = attributeArray.length; i < il; i++) {
        const attribute = attributeArray[i];
        array.push(attribute.toJSON(data.data));
      }
      if (array.length > 0) {
        morphAttributes[key] = array;
        hasMorphAttributes = true;
      }
    }
    if (hasMorphAttributes) {
      data.data.morphAttributes = morphAttributes;
      data.data.morphTargetsRelative = this.morphTargetsRelative;
    }
    const groups = this.groups;
    if (groups.length > 0) {
      data.data.groups = JSON.parse(JSON.stringify(groups));
    }
    const boundingSphere = this.boundingSphere;
    if (boundingSphere !== null) {
      data.data.boundingSphere = {
        center: boundingSphere.center.toArray(),
        radius: boundingSphere.radius
      };
    }
    return data;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(source) {
    this.index = null;
    this.attributes = {};
    this.morphAttributes = {};
    this.groups = [];
    this.boundingBox = null;
    this.boundingSphere = null;
    const data = {};
    this.name = source.name;
    const index = source.index;
    if (index !== null) {
      this.setIndex(index.clone(data));
    }
    const attributes = source.attributes;
    for (const name in attributes) {
      const attribute = attributes[name];
      this.setAttribute(name, attribute.clone(data));
    }
    const morphAttributes = source.morphAttributes;
    for (const name in morphAttributes) {
      const array = [];
      const morphAttribute = morphAttributes[name];
      for (let i = 0, l = morphAttribute.length; i < l; i++) {
        array.push(morphAttribute[i].clone(data));
      }
      this.morphAttributes[name] = array;
    }
    this.morphTargetsRelative = source.morphTargetsRelative;
    const groups = source.groups;
    for (let i = 0, l = groups.length; i < l; i++) {
      const group = groups[i];
      this.addGroup(group.start, group.count, group.materialIndex);
    }
    const boundingBox2 = source.boundingBox;
    if (boundingBox2 !== null) {
      this.boundingBox = boundingBox2.clone();
    }
    const boundingSphere = source.boundingSphere;
    if (boundingSphere !== null) {
      this.boundingSphere = boundingSphere.clone();
    }
    this.drawRange.start = source.drawRange.start;
    this.drawRange.count = source.drawRange.count;
    this.userData = source.userData;
    return this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
const _inverseMatrix$3 = /* @__PURE__ */ new Matrix4$1();
const _ray$3 = /* @__PURE__ */ new Ray();
const _sphere$6 = /* @__PURE__ */ new Sphere();
const _sphereHitAt = /* @__PURE__ */ new Vector3$1();
const _vA$1 = /* @__PURE__ */ new Vector3$1();
const _vB$1 = /* @__PURE__ */ new Vector3$1();
const _vC$1 = /* @__PURE__ */ new Vector3$1();
const _tempA = /* @__PURE__ */ new Vector3$1();
const _morphA = /* @__PURE__ */ new Vector3$1();
const _intersectionPoint = /* @__PURE__ */ new Vector3$1();
const _intersectionPointWorld = /* @__PURE__ */ new Vector3$1();
class Mesh extends Object3D {
  constructor(geometry = new BufferGeometry(), material = new MeshBasicMaterial()) {
    super();
    this.isMesh = true;
    this.type = "Mesh";
    this.geometry = geometry;
    this.material = material;
    this.updateMorphTargets();
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    if (source.morphTargetInfluences !== void 0) {
      this.morphTargetInfluences = source.morphTargetInfluences.slice();
    }
    if (source.morphTargetDictionary !== void 0) {
      this.morphTargetDictionary = Object.assign({}, source.morphTargetDictionary);
    }
    this.material = Array.isArray(source.material) ? source.material.slice() : source.material;
    this.geometry = source.geometry;
    return this;
  }
  updateMorphTargets() {
    const geometry = this.geometry;
    const morphAttributes = geometry.morphAttributes;
    const keys = Object.keys(morphAttributes);
    if (keys.length > 0) {
      const morphAttribute = morphAttributes[keys[0]];
      if (morphAttribute !== void 0) {
        this.morphTargetInfluences = [];
        this.morphTargetDictionary = {};
        for (let m = 0, ml = morphAttribute.length; m < ml; m++) {
          const name = morphAttribute[m].name || String(m);
          this.morphTargetInfluences.push(0);
          this.morphTargetDictionary[name] = m;
        }
      }
    }
  }
  getVertexPosition(index, target) {
    const geometry = this.geometry;
    const position = geometry.attributes.position;
    const morphPosition = geometry.morphAttributes.position;
    const morphTargetsRelative = geometry.morphTargetsRelative;
    target.fromBufferAttribute(position, index);
    const morphInfluences = this.morphTargetInfluences;
    if (morphPosition && morphInfluences) {
      _morphA.set(0, 0, 0);
      for (let i = 0, il = morphPosition.length; i < il; i++) {
        const influence = morphInfluences[i];
        const morphAttribute = morphPosition[i];
        if (influence === 0) continue;
        _tempA.fromBufferAttribute(morphAttribute, index);
        if (morphTargetsRelative) {
          _morphA.addScaledVector(_tempA, influence);
        } else {
          _morphA.addScaledVector(_tempA.sub(target), influence);
        }
      }
      target.add(_morphA);
    }
    return target;
  }
  raycast(raycaster, intersects2) {
    const geometry = this.geometry;
    const material = this.material;
    const matrixWorld = this.matrixWorld;
    if (material === void 0) return;
    if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
    _sphere$6.copy(geometry.boundingSphere);
    _sphere$6.applyMatrix4(matrixWorld);
    _ray$3.copy(raycaster.ray).recast(raycaster.near);
    if (_sphere$6.containsPoint(_ray$3.origin) === false) {
      if (_ray$3.intersectSphere(_sphere$6, _sphereHitAt) === null) return;
      if (_ray$3.origin.distanceToSquared(_sphereHitAt) > (raycaster.far - raycaster.near) ** 2) return;
    }
    _inverseMatrix$3.copy(matrixWorld).invert();
    _ray$3.copy(raycaster.ray).applyMatrix4(_inverseMatrix$3);
    if (geometry.boundingBox !== null) {
      if (_ray$3.intersectsBox(geometry.boundingBox) === false) return;
    }
    this._computeIntersections(raycaster, intersects2, _ray$3);
  }
  _computeIntersections(raycaster, intersects2, rayLocalSpace) {
    let intersection;
    const geometry = this.geometry;
    const material = this.material;
    const index = geometry.index;
    const position = geometry.attributes.position;
    const uv = geometry.attributes.uv;
    const uv1 = geometry.attributes.uv1;
    const normal = geometry.attributes.normal;
    const groups = geometry.groups;
    const drawRange = geometry.drawRange;
    if (index !== null) {
      if (Array.isArray(material)) {
        for (let i = 0, il = groups.length; i < il; i++) {
          const group = groups[i];
          const groupMaterial = material[group.materialIndex];
          const start = Math.max(group.start, drawRange.start);
          const end = Math.min(index.count, Math.min(group.start + group.count, drawRange.start + drawRange.count));
          for (let j = start, jl = end; j < jl; j += 3) {
            const a = index.getX(j);
            const b = index.getX(j + 1);
            const c = index.getX(j + 2);
            intersection = checkGeometryIntersection(this, groupMaterial, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c);
            if (intersection) {
              intersection.faceIndex = Math.floor(j / 3);
              intersection.face.materialIndex = group.materialIndex;
              intersects2.push(intersection);
            }
          }
        }
      } else {
        const start = Math.max(0, drawRange.start);
        const end = Math.min(index.count, drawRange.start + drawRange.count);
        for (let i = start, il = end; i < il; i += 3) {
          const a = index.getX(i);
          const b = index.getX(i + 1);
          const c = index.getX(i + 2);
          intersection = checkGeometryIntersection(this, material, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c);
          if (intersection) {
            intersection.faceIndex = Math.floor(i / 3);
            intersects2.push(intersection);
          }
        }
      }
    } else if (position !== void 0) {
      if (Array.isArray(material)) {
        for (let i = 0, il = groups.length; i < il; i++) {
          const group = groups[i];
          const groupMaterial = material[group.materialIndex];
          const start = Math.max(group.start, drawRange.start);
          const end = Math.min(position.count, Math.min(group.start + group.count, drawRange.start + drawRange.count));
          for (let j = start, jl = end; j < jl; j += 3) {
            const a = j;
            const b = j + 1;
            const c = j + 2;
            intersection = checkGeometryIntersection(this, groupMaterial, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c);
            if (intersection) {
              intersection.faceIndex = Math.floor(j / 3);
              intersection.face.materialIndex = group.materialIndex;
              intersects2.push(intersection);
            }
          }
        }
      } else {
        const start = Math.max(0, drawRange.start);
        const end = Math.min(position.count, drawRange.start + drawRange.count);
        for (let i = start, il = end; i < il; i += 3) {
          const a = i;
          const b = i + 1;
          const c = i + 2;
          intersection = checkGeometryIntersection(this, material, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c);
          if (intersection) {
            intersection.faceIndex = Math.floor(i / 3);
            intersects2.push(intersection);
          }
        }
      }
    }
  }
}
function checkIntersection$1(object, material, raycaster, ray, pA, pB, pC, point) {
  let intersect2;
  if (material.side === BackSide) {
    intersect2 = ray.intersectTriangle(pC, pB, pA, true, point);
  } else {
    intersect2 = ray.intersectTriangle(pA, pB, pC, material.side === FrontSide, point);
  }
  if (intersect2 === null) return null;
  _intersectionPointWorld.copy(point);
  _intersectionPointWorld.applyMatrix4(object.matrixWorld);
  const distance2 = raycaster.ray.origin.distanceTo(_intersectionPointWorld);
  if (distance2 < raycaster.near || distance2 > raycaster.far) return null;
  return {
    distance: distance2,
    point: _intersectionPointWorld.clone(),
    object
  };
}
function checkGeometryIntersection(object, material, raycaster, ray, uv, uv1, normal, a, b, c) {
  object.getVertexPosition(a, _vA$1);
  object.getVertexPosition(b, _vB$1);
  object.getVertexPosition(c, _vC$1);
  const intersection = checkIntersection$1(object, material, raycaster, ray, _vA$1, _vB$1, _vC$1, _intersectionPoint);
  if (intersection) {
    const barycoord = new Vector3$1();
    Triangle.getBarycoord(_intersectionPoint, _vA$1, _vB$1, _vC$1, barycoord);
    if (uv) {
      intersection.uv = Triangle.getInterpolatedAttribute(uv, a, b, c, barycoord, new Vector2$1());
    }
    if (uv1) {
      intersection.uv1 = Triangle.getInterpolatedAttribute(uv1, a, b, c, barycoord, new Vector2$1());
    }
    if (normal) {
      intersection.normal = Triangle.getInterpolatedAttribute(normal, a, b, c, barycoord, new Vector3$1());
      if (intersection.normal.dot(ray.direction) > 0) {
        intersection.normal.multiplyScalar(-1);
      }
    }
    const face = {
      a,
      b,
      c,
      normal: new Vector3$1(),
      materialIndex: 0
    };
    Triangle.getNormal(_vA$1, _vB$1, _vC$1, face.normal);
    intersection.face = face;
    intersection.barycoord = barycoord;
  }
  return intersection;
}
class BoxGeometry extends BufferGeometry {
  constructor(width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1) {
    super();
    this.type = "BoxGeometry";
    this.parameters = {
      width,
      height,
      depth,
      widthSegments,
      heightSegments,
      depthSegments
    };
    const scope = this;
    widthSegments = Math.floor(widthSegments);
    heightSegments = Math.floor(heightSegments);
    depthSegments = Math.floor(depthSegments);
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    let numberOfVertices = 0;
    let groupStart = 0;
    buildPlane("z", "y", "x", -1, -1, depth, height, width, depthSegments, heightSegments, 0);
    buildPlane("z", "y", "x", 1, -1, depth, height, -width, depthSegments, heightSegments, 1);
    buildPlane("x", "z", "y", 1, 1, width, depth, height, widthSegments, depthSegments, 2);
    buildPlane("x", "z", "y", 1, -1, width, depth, -height, widthSegments, depthSegments, 3);
    buildPlane("x", "y", "z", 1, -1, width, height, depth, widthSegments, heightSegments, 4);
    buildPlane("x", "y", "z", -1, -1, width, height, -depth, widthSegments, heightSegments, 5);
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    function buildPlane(u, v, w, udir, vdir, width2, height2, depth2, gridX, gridY, materialIndex) {
      const segmentWidth = width2 / gridX;
      const segmentHeight = height2 / gridY;
      const widthHalf = width2 / 2;
      const heightHalf = height2 / 2;
      const depthHalf = depth2 / 2;
      const gridX1 = gridX + 1;
      const gridY1 = gridY + 1;
      let vertexCounter = 0;
      let groupCount = 0;
      const vector = new Vector3$1();
      for (let iy = 0; iy < gridY1; iy++) {
        const y = iy * segmentHeight - heightHalf;
        for (let ix = 0; ix < gridX1; ix++) {
          const x = ix * segmentWidth - widthHalf;
          vector[u] = x * udir;
          vector[v] = y * vdir;
          vector[w] = depthHalf;
          vertices.push(vector.x, vector.y, vector.z);
          vector[u] = 0;
          vector[v] = 0;
          vector[w] = depth2 > 0 ? 1 : -1;
          normals.push(vector.x, vector.y, vector.z);
          uvs.push(ix / gridX);
          uvs.push(1 - iy / gridY);
          vertexCounter += 1;
        }
      }
      for (let iy = 0; iy < gridY; iy++) {
        for (let ix = 0; ix < gridX; ix++) {
          const a = numberOfVertices + ix + gridX1 * iy;
          const b = numberOfVertices + ix + gridX1 * (iy + 1);
          const c = numberOfVertices + (ix + 1) + gridX1 * (iy + 1);
          const d = numberOfVertices + (ix + 1) + gridX1 * iy;
          indices.push(a, b, d);
          indices.push(b, c, d);
          groupCount += 6;
        }
      }
      scope.addGroup(groupStart, groupCount, materialIndex);
      groupStart += groupCount;
      numberOfVertices += vertexCounter;
    }
  }
  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }
  static fromJSON(data) {
    return new BoxGeometry(data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments);
  }
}
function cloneUniforms(src) {
  const dst = {};
  for (const u in src) {
    dst[u] = {};
    for (const p in src[u]) {
      const property2 = src[u][p];
      if (property2 && (property2.isColor || property2.isMatrix3 || property2.isMatrix4 || property2.isVector2 || property2.isVector3 || property2.isVector4 || property2.isTexture || property2.isQuaternion)) {
        if (property2.isRenderTargetTexture) {
          console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms().");
          dst[u][p] = null;
        } else {
          dst[u][p] = property2.clone();
        }
      } else if (Array.isArray(property2)) {
        dst[u][p] = property2.slice();
      } else {
        dst[u][p] = property2;
      }
    }
  }
  return dst;
}
function mergeUniforms(uniforms) {
  const merged = {};
  for (let u = 0; u < uniforms.length; u++) {
    const tmp2 = cloneUniforms(uniforms[u]);
    for (const p in tmp2) {
      merged[p] = tmp2[p];
    }
  }
  return merged;
}
function cloneUniformsGroups(src) {
  const dst = [];
  for (let u = 0; u < src.length; u++) {
    dst.push(src[u].clone());
  }
  return dst;
}
function getUnlitUniformColorSpace(renderer) {
  const currentRenderTarget = renderer.getRenderTarget();
  if (currentRenderTarget === null) {
    return renderer.outputColorSpace;
  }
  if (currentRenderTarget.isXRRenderTarget === true) {
    return currentRenderTarget.texture.colorSpace;
  }
  return ColorManagement$1.workingColorSpace;
}
const UniformsUtils = { clone: cloneUniforms, merge: mergeUniforms };
var default_vertex = "void main() {\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";
var default_fragment = "void main() {\n	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";
class ShaderMaterial extends Material {
  constructor(parameters) {
    super();
    this.isShaderMaterial = true;
    this.type = "ShaderMaterial";
    this.defines = {};
    this.uniforms = {};
    this.uniformsGroups = [];
    this.vertexShader = default_vertex;
    this.fragmentShader = default_fragment;
    this.linewidth = 1;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.fog = false;
    this.lights = false;
    this.clipping = false;
    this.forceSinglePass = true;
    this.extensions = {
      clipCullDistance: false,
      // set to use vertex shader clipping
      multiDraw: false
      // set to use vertex shader multi_draw / enable gl_DrawID
    };
    this.defaultAttributeValues = {
      "color": [1, 1, 1],
      "uv": [0, 0],
      "uv1": [0, 0]
    };
    this.index0AttributeName = void 0;
    this.uniformsNeedUpdate = false;
    this.glslVersion = null;
    if (parameters !== void 0) {
      this.setValues(parameters);
    }
  }
  copy(source) {
    super.copy(source);
    this.fragmentShader = source.fragmentShader;
    this.vertexShader = source.vertexShader;
    this.uniforms = cloneUniforms(source.uniforms);
    this.uniformsGroups = cloneUniformsGroups(source.uniformsGroups);
    this.defines = Object.assign({}, source.defines);
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.fog = source.fog;
    this.lights = source.lights;
    this.clipping = source.clipping;
    this.extensions = Object.assign({}, source.extensions);
    this.glslVersion = source.glslVersion;
    return this;
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    data.glslVersion = this.glslVersion;
    data.uniforms = {};
    for (const name in this.uniforms) {
      const uniform2 = this.uniforms[name];
      const value = uniform2.value;
      if (value && value.isTexture) {
        data.uniforms[name] = {
          type: "t",
          value: value.toJSON(meta).uuid
        };
      } else if (value && value.isColor) {
        data.uniforms[name] = {
          type: "c",
          value: value.getHex()
        };
      } else if (value && value.isVector2) {
        data.uniforms[name] = {
          type: "v2",
          value: value.toArray()
        };
      } else if (value && value.isVector3) {
        data.uniforms[name] = {
          type: "v3",
          value: value.toArray()
        };
      } else if (value && value.isVector4) {
        data.uniforms[name] = {
          type: "v4",
          value: value.toArray()
        };
      } else if (value && value.isMatrix3) {
        data.uniforms[name] = {
          type: "m3",
          value: value.toArray()
        };
      } else if (value && value.isMatrix4) {
        data.uniforms[name] = {
          type: "m4",
          value: value.toArray()
        };
      } else {
        data.uniforms[name] = {
          value
        };
      }
    }
    if (Object.keys(this.defines).length > 0) data.defines = this.defines;
    data.vertexShader = this.vertexShader;
    data.fragmentShader = this.fragmentShader;
    data.lights = this.lights;
    data.clipping = this.clipping;
    const extensions = {};
    for (const key in this.extensions) {
      if (this.extensions[key] === true) extensions[key] = true;
    }
    if (Object.keys(extensions).length > 0) data.extensions = extensions;
    return data;
  }
}
class Camera extends Object3D {
  constructor() {
    super();
    this.isCamera = true;
    this.type = "Camera";
    this.matrixWorldInverse = new Matrix4$1();
    this.projectionMatrix = new Matrix4$1();
    this.projectionMatrixInverse = new Matrix4$1();
    this.coordinateSystem = WebGLCoordinateSystem$1;
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.matrixWorldInverse.copy(source.matrixWorldInverse);
    this.projectionMatrix.copy(source.projectionMatrix);
    this.projectionMatrixInverse.copy(source.projectionMatrixInverse);
    this.coordinateSystem = source.coordinateSystem;
    return this;
  }
  getWorldDirection(target) {
    return super.getWorldDirection(target).negate();
  }
  updateMatrixWorld(force) {
    super.updateMatrixWorld(force);
    this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(updateParents, updateChildren) {
    super.updateWorldMatrix(updateParents, updateChildren);
    this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const _v3$1 = /* @__PURE__ */ new Vector3$1();
const _minTarget = /* @__PURE__ */ new Vector2$1();
const _maxTarget = /* @__PURE__ */ new Vector2$1();
class PerspectiveCamera extends Camera {
  constructor(fov2 = 50, aspect2 = 1, near = 0.1, far = 2e3) {
    super();
    this.isPerspectiveCamera = true;
    this.type = "PerspectiveCamera";
    this.fov = fov2;
    this.zoom = 1;
    this.near = near;
    this.far = far;
    this.focus = 10;
    this.aspect = aspect2;
    this.view = null;
    this.filmGauge = 35;
    this.filmOffset = 0;
    this.updateProjectionMatrix();
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.fov = source.fov;
    this.zoom = source.zoom;
    this.near = source.near;
    this.far = source.far;
    this.focus = source.focus;
    this.aspect = source.aspect;
    this.view = source.view === null ? null : Object.assign({}, source.view);
    this.filmGauge = source.filmGauge;
    this.filmOffset = source.filmOffset;
    return this;
  }
  /**
   * Sets the FOV by focal length in respect to the current .filmGauge.
   *
   * The default film gauge is 35, so that the focal length can be specified for
   * a 35mm (full frame) camera.
   *
   * @param {number} focalLength - Values for focal length and film gauge must have the same unit.
   */
  setFocalLength(focalLength) {
    const vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;
    this.fov = RAD2DEG$1 * 2 * Math.atan(vExtentSlope);
    this.updateProjectionMatrix();
  }
  /**
   * Calculates the focal length from the current .fov and .filmGauge.
   *
   * @returns {number}
   */
  getFocalLength() {
    const vExtentSlope = Math.tan(DEG2RAD$1 * 0.5 * this.fov);
    return 0.5 * this.getFilmHeight() / vExtentSlope;
  }
  getEffectiveFOV() {
    return RAD2DEG$1 * 2 * Math.atan(
      Math.tan(DEG2RAD$1 * 0.5 * this.fov) / this.zoom
    );
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  /**
   * Computes the 2D bounds of the camera's viewable rectangle at a given distance along the viewing direction.
   * Sets minTarget and maxTarget to the coordinates of the lower-left and upper-right corners of the view rectangle.
   *
   * @param {number} distance
   * @param {Vector2} minTarget
   * @param {Vector2} maxTarget
   */
  getViewBounds(distance2, minTarget, maxTarget) {
    _v3$1.set(-1, -1, 0.5).applyMatrix4(this.projectionMatrixInverse);
    minTarget.set(_v3$1.x, _v3$1.y).multiplyScalar(-distance2 / _v3$1.z);
    _v3$1.set(1, 1, 0.5).applyMatrix4(this.projectionMatrixInverse);
    maxTarget.set(_v3$1.x, _v3$1.y).multiplyScalar(-distance2 / _v3$1.z);
  }
  /**
   * Computes the width and height of the camera's viewable rectangle at a given distance along the viewing direction.
   *
   * @param {number} distance
   * @param {Vector2} target - Vector2 target used to store result where x is width and y is height.
   * @returns {Vector2}
   */
  getViewSize(distance2, target) {
    this.getViewBounds(distance2, _minTarget, _maxTarget);
    return target.subVectors(_maxTarget, _minTarget);
  }
  /**
   * Sets an offset in a larger frustum. This is useful for multi-window or
   * multi-monitor/multi-machine setups.
   *
   * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
   * the monitors are in grid like this
   *
   *   +---+---+---+
   *   | A | B | C |
   *   +---+---+---+
   *   | D | E | F |
   *   +---+---+---+
   *
   * then for each monitor you would call it like this
   *
   *   const w = 1920;
   *   const h = 1080;
   *   const fullWidth = w * 3;
   *   const fullHeight = h * 2;
   *
   *   --A--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
   *   --B--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
   *   --C--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
   *   --D--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
   *   --E--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
   *   --F--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
   *
   *   Note there is no reason monitors have to be the same size or in a grid.
   *
   * @param {number} fullWidth
   * @param {number} fullHeight
   * @param {number} x
   * @param {number} y
   * @param {number} width
   * @param {number} height
   */
  setViewOffset(fullWidth, fullHeight, x, y, width, height) {
    this.aspect = fullWidth / fullHeight;
    if (this.view === null) {
      this.view = {
        enabled: true,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1
      };
    }
    this.view.enabled = true;
    this.view.fullWidth = fullWidth;
    this.view.fullHeight = fullHeight;
    this.view.offsetX = x;
    this.view.offsetY = y;
    this.view.width = width;
    this.view.height = height;
    this.updateProjectionMatrix();
  }
  clearViewOffset() {
    if (this.view !== null) {
      this.view.enabled = false;
    }
    this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const near = this.near;
    let top = near * Math.tan(DEG2RAD$1 * 0.5 * this.fov) / this.zoom;
    let height = 2 * top;
    let width = this.aspect * height;
    let left = -0.5 * width;
    const view = this.view;
    if (this.view !== null && this.view.enabled) {
      const fullWidth = view.fullWidth, fullHeight = view.fullHeight;
      left += view.offsetX * width / fullWidth;
      top -= view.offsetY * height / fullHeight;
      width *= view.width / fullWidth;
      height *= view.height / fullHeight;
    }
    const skew = this.filmOffset;
    if (skew !== 0) left += near * skew / this.getFilmWidth();
    this.projectionMatrix.makePerspective(left, left + width, top, top - height, near, this.far, this.coordinateSystem);
    this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    data.object.fov = this.fov;
    data.object.zoom = this.zoom;
    data.object.near = this.near;
    data.object.far = this.far;
    data.object.focus = this.focus;
    data.object.aspect = this.aspect;
    if (this.view !== null) data.object.view = Object.assign({}, this.view);
    data.object.filmGauge = this.filmGauge;
    data.object.filmOffset = this.filmOffset;
    return data;
  }
}
const fov = -90;
const aspect = 1;
class CubeCamera extends Object3D {
  constructor(near, far, renderTarget) {
    super();
    this.type = "CubeCamera";
    this.renderTarget = renderTarget;
    this.coordinateSystem = null;
    this.activeMipmapLevel = 0;
    const cameraPX = new PerspectiveCamera(fov, aspect, near, far);
    cameraPX.layers = this.layers;
    this.add(cameraPX);
    const cameraNX = new PerspectiveCamera(fov, aspect, near, far);
    cameraNX.layers = this.layers;
    this.add(cameraNX);
    const cameraPY = new PerspectiveCamera(fov, aspect, near, far);
    cameraPY.layers = this.layers;
    this.add(cameraPY);
    const cameraNY = new PerspectiveCamera(fov, aspect, near, far);
    cameraNY.layers = this.layers;
    this.add(cameraNY);
    const cameraPZ = new PerspectiveCamera(fov, aspect, near, far);
    cameraPZ.layers = this.layers;
    this.add(cameraPZ);
    const cameraNZ = new PerspectiveCamera(fov, aspect, near, far);
    cameraNZ.layers = this.layers;
    this.add(cameraNZ);
  }
  updateCoordinateSystem() {
    const coordinateSystem = this.coordinateSystem;
    const cameras = this.children.concat();
    const [cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ] = cameras;
    for (const camera of cameras) this.remove(camera);
    if (coordinateSystem === WebGLCoordinateSystem$1) {
      cameraPX.up.set(0, 1, 0);
      cameraPX.lookAt(1, 0, 0);
      cameraNX.up.set(0, 1, 0);
      cameraNX.lookAt(-1, 0, 0);
      cameraPY.up.set(0, 0, -1);
      cameraPY.lookAt(0, 1, 0);
      cameraNY.up.set(0, 0, 1);
      cameraNY.lookAt(0, -1, 0);
      cameraPZ.up.set(0, 1, 0);
      cameraPZ.lookAt(0, 0, 1);
      cameraNZ.up.set(0, 1, 0);
      cameraNZ.lookAt(0, 0, -1);
    } else if (coordinateSystem === WebGPUCoordinateSystem$1) {
      cameraPX.up.set(0, -1, 0);
      cameraPX.lookAt(-1, 0, 0);
      cameraNX.up.set(0, -1, 0);
      cameraNX.lookAt(1, 0, 0);
      cameraPY.up.set(0, 0, 1);
      cameraPY.lookAt(0, 1, 0);
      cameraNY.up.set(0, 0, -1);
      cameraNY.lookAt(0, -1, 0);
      cameraPZ.up.set(0, -1, 0);
      cameraPZ.lookAt(0, 0, 1);
      cameraNZ.up.set(0, -1, 0);
      cameraNZ.lookAt(0, 0, -1);
    } else {
      throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + coordinateSystem);
    }
    for (const camera of cameras) {
      this.add(camera);
      camera.updateMatrixWorld();
    }
  }
  update(renderer, scene) {
    if (this.parent === null) this.updateMatrixWorld();
    const { renderTarget, activeMipmapLevel } = this;
    if (this.coordinateSystem !== renderer.coordinateSystem) {
      this.coordinateSystem = renderer.coordinateSystem;
      this.updateCoordinateSystem();
    }
    const [cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ] = this.children;
    const currentRenderTarget = renderer.getRenderTarget();
    const currentActiveCubeFace = renderer.getActiveCubeFace();
    const currentActiveMipmapLevel = renderer.getActiveMipmapLevel();
    const currentXrEnabled = renderer.xr.enabled;
    renderer.xr.enabled = false;
    const generateMipmaps = renderTarget.texture.generateMipmaps;
    renderTarget.texture.generateMipmaps = false;
    renderer.setRenderTarget(renderTarget, 0, activeMipmapLevel);
    renderer.render(scene, cameraPX);
    renderer.setRenderTarget(renderTarget, 1, activeMipmapLevel);
    renderer.render(scene, cameraNX);
    renderer.setRenderTarget(renderTarget, 2, activeMipmapLevel);
    renderer.render(scene, cameraPY);
    renderer.setRenderTarget(renderTarget, 3, activeMipmapLevel);
    renderer.render(scene, cameraNY);
    renderer.setRenderTarget(renderTarget, 4, activeMipmapLevel);
    renderer.render(scene, cameraPZ);
    renderTarget.texture.generateMipmaps = generateMipmaps;
    renderer.setRenderTarget(renderTarget, 5, activeMipmapLevel);
    renderer.render(scene, cameraNZ);
    renderer.setRenderTarget(currentRenderTarget, currentActiveCubeFace, currentActiveMipmapLevel);
    renderer.xr.enabled = currentXrEnabled;
    renderTarget.texture.needsPMREMUpdate = true;
  }
}
class CubeTexture extends Texture {
  constructor(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace) {
    images = images !== void 0 ? images : [];
    mapping = mapping !== void 0 ? mapping : CubeReflectionMapping;
    super(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace);
    this.isCubeTexture = true;
    this.flipY = false;
  }
  get images() {
    return this.image;
  }
  set images(value) {
    this.image = value;
  }
}
class WebGLCubeRenderTarget extends WebGLRenderTarget {
  constructor(size = 1, options = {}) {
    super(size, size, options);
    this.isWebGLCubeRenderTarget = true;
    const image = { width: size, height: size, depth: 1 };
    const images = [image, image, image, image, image, image];
    this.texture = new CubeTexture(images, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.colorSpace);
    this.texture.isRenderTargetTexture = true;
    this.texture.generateMipmaps = options.generateMipmaps !== void 0 ? options.generateMipmaps : false;
    this.texture.minFilter = options.minFilter !== void 0 ? options.minFilter : LinearFilter;
  }
  fromEquirectangularTexture(renderer, texture) {
    this.texture.type = texture.type;
    this.texture.colorSpace = texture.colorSpace;
    this.texture.generateMipmaps = texture.generateMipmaps;
    this.texture.minFilter = texture.minFilter;
    this.texture.magFilter = texture.magFilter;
    const shader = {
      uniforms: {
        tEquirect: { value: null }
      },
      vertexShader: (
        /* glsl */
        `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`
      ),
      fragmentShader: (
        /* glsl */
        `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
      )
    };
    const geometry = new BoxGeometry(5, 5, 5);
    const material = new ShaderMaterial({
      name: "CubemapFromEquirect",
      uniforms: cloneUniforms(shader.uniforms),
      vertexShader: shader.vertexShader,
      fragmentShader: shader.fragmentShader,
      side: BackSide,
      blending: NoBlending
    });
    material.uniforms.tEquirect.value = texture;
    const mesh = new Mesh(geometry, material);
    const currentMinFilter = texture.minFilter;
    if (texture.minFilter === LinearMipmapLinearFilter) texture.minFilter = LinearFilter;
    const camera = new CubeCamera(1, 10, this);
    camera.update(renderer, mesh);
    texture.minFilter = currentMinFilter;
    mesh.geometry.dispose();
    mesh.material.dispose();
    return this;
  }
  clear(renderer, color2, depth, stencil) {
    const currentRenderTarget = renderer.getRenderTarget();
    for (let i = 0; i < 6; i++) {
      renderer.setRenderTarget(this, i);
      renderer.clear(color2, depth, stencil);
    }
    renderer.setRenderTarget(currentRenderTarget);
  }
}
class FogExp2 {
  constructor(color2, density = 25e-5) {
    this.isFogExp2 = true;
    this.name = "";
    this.color = new Color$1(color2);
    this.density = density;
  }
  clone() {
    return new FogExp2(this.color, this.density);
  }
  toJSON() {
    return {
      type: "FogExp2",
      name: this.name,
      color: this.color.getHex(),
      density: this.density
    };
  }
}
class Fog {
  constructor(color2, near = 1, far = 1e3) {
    this.isFog = true;
    this.name = "";
    this.color = new Color$1(color2);
    this.near = near;
    this.far = far;
  }
  clone() {
    return new Fog(this.color, this.near, this.far);
  }
  toJSON() {
    return {
      type: "Fog",
      name: this.name,
      color: this.color.getHex(),
      near: this.near,
      far: this.far
    };
  }
}
class Scene extends Object3D {
  constructor() {
    super();
    this.isScene = true;
    this.type = "Scene";
    this.background = null;
    this.environment = null;
    this.fog = null;
    this.backgroundBlurriness = 0;
    this.backgroundIntensity = 1;
    this.backgroundRotation = new Euler();
    this.environmentIntensity = 1;
    this.environmentRotation = new Euler();
    this.overrideMaterial = null;
    if (typeof __THREE_DEVTOOLS__ !== "undefined") {
      __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
    }
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    if (source.background !== null) this.background = source.background.clone();
    if (source.environment !== null) this.environment = source.environment.clone();
    if (source.fog !== null) this.fog = source.fog.clone();
    this.backgroundBlurriness = source.backgroundBlurriness;
    this.backgroundIntensity = source.backgroundIntensity;
    this.backgroundRotation.copy(source.backgroundRotation);
    this.environmentIntensity = source.environmentIntensity;
    this.environmentRotation.copy(source.environmentRotation);
    if (source.overrideMaterial !== null) this.overrideMaterial = source.overrideMaterial.clone();
    this.matrixAutoUpdate = source.matrixAutoUpdate;
    return this;
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    if (this.fog !== null) data.object.fog = this.fog.toJSON();
    if (this.backgroundBlurriness > 0) data.object.backgroundBlurriness = this.backgroundBlurriness;
    if (this.backgroundIntensity !== 1) data.object.backgroundIntensity = this.backgroundIntensity;
    data.object.backgroundRotation = this.backgroundRotation.toArray();
    if (this.environmentIntensity !== 1) data.object.environmentIntensity = this.environmentIntensity;
    data.object.environmentRotation = this.environmentRotation.toArray();
    return data;
  }
}
let InterleavedBuffer$1 = class InterleavedBuffer {
  constructor(array, stride) {
    this.isInterleavedBuffer = true;
    this.array = array;
    this.stride = stride;
    this.count = array !== void 0 ? array.length / stride : 0;
    this.usage = StaticDrawUsage$1;
    this.updateRanges = [];
    this.version = 0;
    this.uuid = generateUUID$1();
  }
  onUploadCallback() {
  }
  set needsUpdate(value) {
    if (value === true) this.version++;
  }
  setUsage(value) {
    this.usage = value;
    return this;
  }
  addUpdateRange(start, count) {
    this.updateRanges.push({ start, count });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(source) {
    this.array = new source.array.constructor(source.array);
    this.count = source.count;
    this.stride = source.stride;
    this.usage = source.usage;
    return this;
  }
  copyAt(index1, attribute, index2) {
    index1 *= this.stride;
    index2 *= attribute.stride;
    for (let i = 0, l = this.stride; i < l; i++) {
      this.array[index1 + i] = attribute.array[index2 + i];
    }
    return this;
  }
  set(value, offset = 0) {
    this.array.set(value, offset);
    return this;
  }
  clone(data) {
    if (data.arrayBuffers === void 0) {
      data.arrayBuffers = {};
    }
    if (this.array.buffer._uuid === void 0) {
      this.array.buffer._uuid = generateUUID$1();
    }
    if (data.arrayBuffers[this.array.buffer._uuid] === void 0) {
      data.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer;
    }
    const array = new this.array.constructor(data.arrayBuffers[this.array.buffer._uuid]);
    const ib = new this.constructor(array, this.stride);
    ib.setUsage(this.usage);
    return ib;
  }
  onUpload(callback) {
    this.onUploadCallback = callback;
    return this;
  }
  toJSON(data) {
    if (data.arrayBuffers === void 0) {
      data.arrayBuffers = {};
    }
    if (this.array.buffer._uuid === void 0) {
      this.array.buffer._uuid = generateUUID$1();
    }
    if (data.arrayBuffers[this.array.buffer._uuid] === void 0) {
      data.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer));
    }
    return {
      uuid: this.uuid,
      buffer: this.array.buffer._uuid,
      type: this.array.constructor.name,
      stride: this.stride
    };
  }
};
const _vector$7 = /* @__PURE__ */ new Vector3$1();
let InterleavedBufferAttribute$1 = class InterleavedBufferAttribute {
  constructor(interleavedBuffer, itemSize, offset, normalized = false) {
    this.isInterleavedBufferAttribute = true;
    this.name = "";
    this.data = interleavedBuffer;
    this.itemSize = itemSize;
    this.offset = offset;
    this.normalized = normalized;
  }
  get count() {
    return this.data.count;
  }
  get array() {
    return this.data.array;
  }
  set needsUpdate(value) {
    this.data.needsUpdate = value;
  }
  applyMatrix4(m) {
    for (let i = 0, l = this.data.count; i < l; i++) {
      _vector$7.fromBufferAttribute(this, i);
      _vector$7.applyMatrix4(m);
      this.setXYZ(i, _vector$7.x, _vector$7.y, _vector$7.z);
    }
    return this;
  }
  applyNormalMatrix(m) {
    for (let i = 0, l = this.count; i < l; i++) {
      _vector$7.fromBufferAttribute(this, i);
      _vector$7.applyNormalMatrix(m);
      this.setXYZ(i, _vector$7.x, _vector$7.y, _vector$7.z);
    }
    return this;
  }
  transformDirection(m) {
    for (let i = 0, l = this.count; i < l; i++) {
      _vector$7.fromBufferAttribute(this, i);
      _vector$7.transformDirection(m);
      this.setXYZ(i, _vector$7.x, _vector$7.y, _vector$7.z);
    }
    return this;
  }
  getComponent(index, component) {
    let value = this.array[index * this.data.stride + this.offset + component];
    if (this.normalized) value = denormalize$1(value, this.array);
    return value;
  }
  setComponent(index, component, value) {
    if (this.normalized) value = normalize$2(value, this.array);
    this.data.array[index * this.data.stride + this.offset + component] = value;
    return this;
  }
  setX(index, x) {
    if (this.normalized) x = normalize$2(x, this.array);
    this.data.array[index * this.data.stride + this.offset] = x;
    return this;
  }
  setY(index, y) {
    if (this.normalized) y = normalize$2(y, this.array);
    this.data.array[index * this.data.stride + this.offset + 1] = y;
    return this;
  }
  setZ(index, z) {
    if (this.normalized) z = normalize$2(z, this.array);
    this.data.array[index * this.data.stride + this.offset + 2] = z;
    return this;
  }
  setW(index, w) {
    if (this.normalized) w = normalize$2(w, this.array);
    this.data.array[index * this.data.stride + this.offset + 3] = w;
    return this;
  }
  getX(index) {
    let x = this.data.array[index * this.data.stride + this.offset];
    if (this.normalized) x = denormalize$1(x, this.array);
    return x;
  }
  getY(index) {
    let y = this.data.array[index * this.data.stride + this.offset + 1];
    if (this.normalized) y = denormalize$1(y, this.array);
    return y;
  }
  getZ(index) {
    let z = this.data.array[index * this.data.stride + this.offset + 2];
    if (this.normalized) z = denormalize$1(z, this.array);
    return z;
  }
  getW(index) {
    let w = this.data.array[index * this.data.stride + this.offset + 3];
    if (this.normalized) w = denormalize$1(w, this.array);
    return w;
  }
  setXY(index, x, y) {
    index = index * this.data.stride + this.offset;
    if (this.normalized) {
      x = normalize$2(x, this.array);
      y = normalize$2(y, this.array);
    }
    this.data.array[index + 0] = x;
    this.data.array[index + 1] = y;
    return this;
  }
  setXYZ(index, x, y, z) {
    index = index * this.data.stride + this.offset;
    if (this.normalized) {
      x = normalize$2(x, this.array);
      y = normalize$2(y, this.array);
      z = normalize$2(z, this.array);
    }
    this.data.array[index + 0] = x;
    this.data.array[index + 1] = y;
    this.data.array[index + 2] = z;
    return this;
  }
  setXYZW(index, x, y, z, w) {
    index = index * this.data.stride + this.offset;
    if (this.normalized) {
      x = normalize$2(x, this.array);
      y = normalize$2(y, this.array);
      z = normalize$2(z, this.array);
      w = normalize$2(w, this.array);
    }
    this.data.array[index + 0] = x;
    this.data.array[index + 1] = y;
    this.data.array[index + 2] = z;
    this.data.array[index + 3] = w;
    return this;
  }
  clone(data) {
    if (data === void 0) {
      console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
      const array = [];
      for (let i = 0; i < this.count; i++) {
        const index = i * this.data.stride + this.offset;
        for (let j = 0; j < this.itemSize; j++) {
          array.push(this.data.array[index + j]);
        }
      }
      return new BufferAttribute$1(new this.array.constructor(array), this.itemSize, this.normalized);
    } else {
      if (data.interleavedBuffers === void 0) {
        data.interleavedBuffers = {};
      }
      if (data.interleavedBuffers[this.data.uuid] === void 0) {
        data.interleavedBuffers[this.data.uuid] = this.data.clone(data);
      }
      return new InterleavedBufferAttribute(data.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
    }
  }
  toJSON(data) {
    if (data === void 0) {
      console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
      const array = [];
      for (let i = 0; i < this.count; i++) {
        const index = i * this.data.stride + this.offset;
        for (let j = 0; j < this.itemSize; j++) {
          array.push(this.data.array[index + j]);
        }
      }
      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array,
        normalized: this.normalized
      };
    } else {
      if (data.interleavedBuffers === void 0) {
        data.interleavedBuffers = {};
      }
      if (data.interleavedBuffers[this.data.uuid] === void 0) {
        data.interleavedBuffers[this.data.uuid] = this.data.toJSON(data);
      }
      return {
        isInterleavedBufferAttribute: true,
        itemSize: this.itemSize,
        data: this.data.uuid,
        offset: this.offset,
        normalized: this.normalized
      };
    }
  }
};
class SpriteMaterial extends Material {
  constructor(parameters) {
    super();
    this.isSpriteMaterial = true;
    this.type = "SpriteMaterial";
    this.color = new Color$1(16777215);
    this.map = null;
    this.alphaMap = null;
    this.rotation = 0;
    this.sizeAttenuation = true;
    this.transparent = true;
    this.fog = true;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.map = source.map;
    this.alphaMap = source.alphaMap;
    this.rotation = source.rotation;
    this.sizeAttenuation = source.sizeAttenuation;
    this.fog = source.fog;
    return this;
  }
}
let _geometry;
const _intersectPoint = /* @__PURE__ */ new Vector3$1();
const _worldScale = /* @__PURE__ */ new Vector3$1();
const _mvPosition = /* @__PURE__ */ new Vector3$1();
const _alignedPosition = /* @__PURE__ */ new Vector2$1();
const _rotatedPosition = /* @__PURE__ */ new Vector2$1();
const _viewWorldMatrix = /* @__PURE__ */ new Matrix4$1();
const _vA = /* @__PURE__ */ new Vector3$1();
const _vB = /* @__PURE__ */ new Vector3$1();
const _vC = /* @__PURE__ */ new Vector3$1();
const _uvA = /* @__PURE__ */ new Vector2$1();
const _uvB = /* @__PURE__ */ new Vector2$1();
const _uvC = /* @__PURE__ */ new Vector2$1();
class Sprite extends Object3D {
  constructor(material = new SpriteMaterial()) {
    super();
    this.isSprite = true;
    this.type = "Sprite";
    if (_geometry === void 0) {
      _geometry = new BufferGeometry();
      const float32Array = new Float32Array([
        -0.5,
        -0.5,
        0,
        0,
        0,
        0.5,
        -0.5,
        0,
        1,
        0,
        0.5,
        0.5,
        0,
        1,
        1,
        -0.5,
        0.5,
        0,
        0,
        1
      ]);
      const interleavedBuffer = new InterleavedBuffer$1(float32Array, 5);
      _geometry.setIndex([0, 1, 2, 0, 2, 3]);
      _geometry.setAttribute("position", new InterleavedBufferAttribute$1(interleavedBuffer, 3, 0, false));
      _geometry.setAttribute("uv", new InterleavedBufferAttribute$1(interleavedBuffer, 2, 3, false));
    }
    this.geometry = _geometry;
    this.material = material;
    this.center = new Vector2$1(0.5, 0.5);
  }
  raycast(raycaster, intersects2) {
    if (raycaster.camera === null) {
      console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.');
    }
    _worldScale.setFromMatrixScale(this.matrixWorld);
    _viewWorldMatrix.copy(raycaster.camera.matrixWorld);
    this.modelViewMatrix.multiplyMatrices(raycaster.camera.matrixWorldInverse, this.matrixWorld);
    _mvPosition.setFromMatrixPosition(this.modelViewMatrix);
    if (raycaster.camera.isPerspectiveCamera && this.material.sizeAttenuation === false) {
      _worldScale.multiplyScalar(-_mvPosition.z);
    }
    const rotation = this.material.rotation;
    let sin2, cos2;
    if (rotation !== 0) {
      cos2 = Math.cos(rotation);
      sin2 = Math.sin(rotation);
    }
    const center = this.center;
    transformVertex(_vA.set(-0.5, -0.5, 0), _mvPosition, center, _worldScale, sin2, cos2);
    transformVertex(_vB.set(0.5, -0.5, 0), _mvPosition, center, _worldScale, sin2, cos2);
    transformVertex(_vC.set(0.5, 0.5, 0), _mvPosition, center, _worldScale, sin2, cos2);
    _uvA.set(0, 0);
    _uvB.set(1, 0);
    _uvC.set(1, 1);
    let intersect2 = raycaster.ray.intersectTriangle(_vA, _vB, _vC, false, _intersectPoint);
    if (intersect2 === null) {
      transformVertex(_vB.set(-0.5, 0.5, 0), _mvPosition, center, _worldScale, sin2, cos2);
      _uvB.set(0, 1);
      intersect2 = raycaster.ray.intersectTriangle(_vA, _vC, _vB, false, _intersectPoint);
      if (intersect2 === null) {
        return;
      }
    }
    const distance2 = raycaster.ray.origin.distanceTo(_intersectPoint);
    if (distance2 < raycaster.near || distance2 > raycaster.far) return;
    intersects2.push({
      distance: distance2,
      point: _intersectPoint.clone(),
      uv: Triangle.getInterpolation(_intersectPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2$1()),
      face: null,
      object: this
    });
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    if (source.center !== void 0) this.center.copy(source.center);
    this.material = source.material;
    return this;
  }
}
function transformVertex(vertexPosition, mvPosition, center, scale, sin2, cos2) {
  _alignedPosition.subVectors(vertexPosition, center).addScalar(0.5).multiply(scale);
  if (sin2 !== void 0) {
    _rotatedPosition.x = cos2 * _alignedPosition.x - sin2 * _alignedPosition.y;
    _rotatedPosition.y = sin2 * _alignedPosition.x + cos2 * _alignedPosition.y;
  } else {
    _rotatedPosition.copy(_alignedPosition);
  }
  vertexPosition.copy(mvPosition);
  vertexPosition.x += _rotatedPosition.x;
  vertexPosition.y += _rotatedPosition.y;
  vertexPosition.applyMatrix4(_viewWorldMatrix);
}
const _v1$2 = /* @__PURE__ */ new Vector3$1();
const _v2$1 = /* @__PURE__ */ new Vector3$1();
class LOD extends Object3D {
  constructor() {
    super();
    this._currentLevel = 0;
    this.type = "LOD";
    Object.defineProperties(this, {
      levels: {
        enumerable: true,
        value: []
      },
      isLOD: {
        value: true
      }
    });
    this.autoUpdate = true;
  }
  copy(source) {
    super.copy(source, false);
    const levels = source.levels;
    for (let i = 0, l = levels.length; i < l; i++) {
      const level = levels[i];
      this.addLevel(level.object.clone(), level.distance, level.hysteresis);
    }
    this.autoUpdate = source.autoUpdate;
    return this;
  }
  addLevel(object, distance2 = 0, hysteresis = 0) {
    distance2 = Math.abs(distance2);
    const levels = this.levels;
    let l;
    for (l = 0; l < levels.length; l++) {
      if (distance2 < levels[l].distance) {
        break;
      }
    }
    levels.splice(l, 0, { distance: distance2, hysteresis, object });
    this.add(object);
    return this;
  }
  removeLevel(distance2) {
    const levels = this.levels;
    for (let i = 0; i < levels.length; i++) {
      if (levels[i].distance === distance2) {
        const removedElements = levels.splice(i, 1);
        this.remove(removedElements[0].object);
        return true;
      }
    }
    return false;
  }
  getCurrentLevel() {
    return this._currentLevel;
  }
  getObjectForDistance(distance2) {
    const levels = this.levels;
    if (levels.length > 0) {
      let i, l;
      for (i = 1, l = levels.length; i < l; i++) {
        let levelDistance = levels[i].distance;
        if (levels[i].object.visible) {
          levelDistance -= levelDistance * levels[i].hysteresis;
        }
        if (distance2 < levelDistance) {
          break;
        }
      }
      return levels[i - 1].object;
    }
    return null;
  }
  raycast(raycaster, intersects2) {
    const levels = this.levels;
    if (levels.length > 0) {
      _v1$2.setFromMatrixPosition(this.matrixWorld);
      const distance2 = raycaster.ray.origin.distanceTo(_v1$2);
      this.getObjectForDistance(distance2).raycast(raycaster, intersects2);
    }
  }
  update(camera) {
    const levels = this.levels;
    if (levels.length > 1) {
      _v1$2.setFromMatrixPosition(camera.matrixWorld);
      _v2$1.setFromMatrixPosition(this.matrixWorld);
      const distance2 = _v1$2.distanceTo(_v2$1) / camera.zoom;
      levels[0].object.visible = true;
      let i, l;
      for (i = 1, l = levels.length; i < l; i++) {
        let levelDistance = levels[i].distance;
        if (levels[i].object.visible) {
          levelDistance -= levelDistance * levels[i].hysteresis;
        }
        if (distance2 >= levelDistance) {
          levels[i - 1].object.visible = false;
          levels[i].object.visible = true;
        } else {
          break;
        }
      }
      this._currentLevel = i - 1;
      for (; i < l; i++) {
        levels[i].object.visible = false;
      }
    }
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    if (this.autoUpdate === false) data.object.autoUpdate = false;
    data.object.levels = [];
    const levels = this.levels;
    for (let i = 0, l = levels.length; i < l; i++) {
      const level = levels[i];
      data.object.levels.push({
        object: level.object.uuid,
        distance: level.distance,
        hysteresis: level.hysteresis
      });
    }
    return data;
  }
}
const _basePosition = /* @__PURE__ */ new Vector3$1();
const _skinIndex = /* @__PURE__ */ new Vector4$1();
const _skinWeight = /* @__PURE__ */ new Vector4$1();
const _vector3 = /* @__PURE__ */ new Vector3$1();
const _matrix4 = /* @__PURE__ */ new Matrix4$1();
const _vertex = /* @__PURE__ */ new Vector3$1();
const _sphere$5 = /* @__PURE__ */ new Sphere();
const _inverseMatrix$2 = /* @__PURE__ */ new Matrix4$1();
const _ray$2 = /* @__PURE__ */ new Ray();
class SkinnedMesh extends Mesh {
  constructor(geometry, material) {
    super(geometry, material);
    this.isSkinnedMesh = true;
    this.type = "SkinnedMesh";
    this.bindMode = AttachedBindMode;
    this.bindMatrix = new Matrix4$1();
    this.bindMatrixInverse = new Matrix4$1();
    this.boundingBox = null;
    this.boundingSphere = null;
  }
  computeBoundingBox() {
    const geometry = this.geometry;
    if (this.boundingBox === null) {
      this.boundingBox = new Box3();
    }
    this.boundingBox.makeEmpty();
    const positionAttribute = geometry.getAttribute("position");
    for (let i = 0; i < positionAttribute.count; i++) {
      this.getVertexPosition(i, _vertex);
      this.boundingBox.expandByPoint(_vertex);
    }
  }
  computeBoundingSphere() {
    const geometry = this.geometry;
    if (this.boundingSphere === null) {
      this.boundingSphere = new Sphere();
    }
    this.boundingSphere.makeEmpty();
    const positionAttribute = geometry.getAttribute("position");
    for (let i = 0; i < positionAttribute.count; i++) {
      this.getVertexPosition(i, _vertex);
      this.boundingSphere.expandByPoint(_vertex);
    }
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.bindMode = source.bindMode;
    this.bindMatrix.copy(source.bindMatrix);
    this.bindMatrixInverse.copy(source.bindMatrixInverse);
    this.skeleton = source.skeleton;
    if (source.boundingBox !== null) this.boundingBox = source.boundingBox.clone();
    if (source.boundingSphere !== null) this.boundingSphere = source.boundingSphere.clone();
    return this;
  }
  raycast(raycaster, intersects2) {
    const material = this.material;
    const matrixWorld = this.matrixWorld;
    if (material === void 0) return;
    if (this.boundingSphere === null) this.computeBoundingSphere();
    _sphere$5.copy(this.boundingSphere);
    _sphere$5.applyMatrix4(matrixWorld);
    if (raycaster.ray.intersectsSphere(_sphere$5) === false) return;
    _inverseMatrix$2.copy(matrixWorld).invert();
    _ray$2.copy(raycaster.ray).applyMatrix4(_inverseMatrix$2);
    if (this.boundingBox !== null) {
      if (_ray$2.intersectsBox(this.boundingBox) === false) return;
    }
    this._computeIntersections(raycaster, intersects2, _ray$2);
  }
  getVertexPosition(index, target) {
    super.getVertexPosition(index, target);
    this.applyBoneTransform(index, target);
    return target;
  }
  bind(skeleton, bindMatrix) {
    this.skeleton = skeleton;
    if (bindMatrix === void 0) {
      this.updateMatrixWorld(true);
      this.skeleton.calculateInverses();
      bindMatrix = this.matrixWorld;
    }
    this.bindMatrix.copy(bindMatrix);
    this.bindMatrixInverse.copy(bindMatrix).invert();
  }
  pose() {
    this.skeleton.pose();
  }
  normalizeSkinWeights() {
    const vector = new Vector4$1();
    const skinWeight = this.geometry.attributes.skinWeight;
    for (let i = 0, l = skinWeight.count; i < l; i++) {
      vector.fromBufferAttribute(skinWeight, i);
      const scale = 1 / vector.manhattanLength();
      if (scale !== Infinity) {
        vector.multiplyScalar(scale);
      } else {
        vector.set(1, 0, 0, 0);
      }
      skinWeight.setXYZW(i, vector.x, vector.y, vector.z, vector.w);
    }
  }
  updateMatrixWorld(force) {
    super.updateMatrixWorld(force);
    if (this.bindMode === AttachedBindMode) {
      this.bindMatrixInverse.copy(this.matrixWorld).invert();
    } else if (this.bindMode === DetachedBindMode) {
      this.bindMatrixInverse.copy(this.bindMatrix).invert();
    } else {
      console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
    }
  }
  applyBoneTransform(index, vector) {
    const skeleton = this.skeleton;
    const geometry = this.geometry;
    _skinIndex.fromBufferAttribute(geometry.attributes.skinIndex, index);
    _skinWeight.fromBufferAttribute(geometry.attributes.skinWeight, index);
    _basePosition.copy(vector).applyMatrix4(this.bindMatrix);
    vector.set(0, 0, 0);
    for (let i = 0; i < 4; i++) {
      const weight = _skinWeight.getComponent(i);
      if (weight !== 0) {
        const boneIndex = _skinIndex.getComponent(i);
        _matrix4.multiplyMatrices(skeleton.bones[boneIndex].matrixWorld, skeleton.boneInverses[boneIndex]);
        vector.addScaledVector(_vector3.copy(_basePosition).applyMatrix4(_matrix4), weight);
      }
    }
    return vector.applyMatrix4(this.bindMatrixInverse);
  }
}
class Bone extends Object3D {
  constructor() {
    super();
    this.isBone = true;
    this.type = "Bone";
  }
}
class DataTexture extends Texture {
  constructor(data = null, width = 1, height = 1, format, type, mapping, wrapS, wrapT, magFilter = NearestFilter, minFilter = NearestFilter, anisotropy, colorSpace) {
    super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace);
    this.isDataTexture = true;
    this.image = { data, width, height };
    this.generateMipmaps = false;
    this.flipY = false;
    this.unpackAlignment = 1;
  }
}
const _offsetMatrix = /* @__PURE__ */ new Matrix4$1();
const _identityMatrix = /* @__PURE__ */ new Matrix4$1();
class Skeleton {
  constructor(bones = [], boneInverses = []) {
    this.uuid = generateUUID$1();
    this.bones = bones.slice(0);
    this.boneInverses = boneInverses;
    this.boneMatrices = null;
    this.boneTexture = null;
    this.init();
  }
  init() {
    const bones = this.bones;
    const boneInverses = this.boneInverses;
    this.boneMatrices = new Float32Array(bones.length * 16);
    if (boneInverses.length === 0) {
      this.calculateInverses();
    } else {
      if (bones.length !== boneInverses.length) {
        console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.");
        this.boneInverses = [];
        for (let i = 0, il = this.bones.length; i < il; i++) {
          this.boneInverses.push(new Matrix4$1());
        }
      }
    }
  }
  calculateInverses() {
    this.boneInverses.length = 0;
    for (let i = 0, il = this.bones.length; i < il; i++) {
      const inverse = new Matrix4$1();
      if (this.bones[i]) {
        inverse.copy(this.bones[i].matrixWorld).invert();
      }
      this.boneInverses.push(inverse);
    }
  }
  pose() {
    for (let i = 0, il = this.bones.length; i < il; i++) {
      const bone = this.bones[i];
      if (bone) {
        bone.matrixWorld.copy(this.boneInverses[i]).invert();
      }
    }
    for (let i = 0, il = this.bones.length; i < il; i++) {
      const bone = this.bones[i];
      if (bone) {
        if (bone.parent && bone.parent.isBone) {
          bone.matrix.copy(bone.parent.matrixWorld).invert();
          bone.matrix.multiply(bone.matrixWorld);
        } else {
          bone.matrix.copy(bone.matrixWorld);
        }
        bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);
      }
    }
  }
  update() {
    const bones = this.bones;
    const boneInverses = this.boneInverses;
    const boneMatrices = this.boneMatrices;
    const boneTexture = this.boneTexture;
    for (let i = 0, il = bones.length; i < il; i++) {
      const matrix = bones[i] ? bones[i].matrixWorld : _identityMatrix;
      _offsetMatrix.multiplyMatrices(matrix, boneInverses[i]);
      _offsetMatrix.toArray(boneMatrices, i * 16);
    }
    if (boneTexture !== null) {
      boneTexture.needsUpdate = true;
    }
  }
  clone() {
    return new Skeleton(this.bones, this.boneInverses);
  }
  computeBoneTexture() {
    let size = Math.sqrt(this.bones.length * 4);
    size = Math.ceil(size / 4) * 4;
    size = Math.max(size, 4);
    const boneMatrices = new Float32Array(size * size * 4);
    boneMatrices.set(this.boneMatrices);
    const boneTexture = new DataTexture(boneMatrices, size, size, RGBAFormat, FloatType$1);
    boneTexture.needsUpdate = true;
    this.boneMatrices = boneMatrices;
    this.boneTexture = boneTexture;
    return this;
  }
  getBoneByName(name) {
    for (let i = 0, il = this.bones.length; i < il; i++) {
      const bone = this.bones[i];
      if (bone.name === name) {
        return bone;
      }
    }
    return void 0;
  }
  dispose() {
    if (this.boneTexture !== null) {
      this.boneTexture.dispose();
      this.boneTexture = null;
    }
  }
  fromJSON(json, bones) {
    this.uuid = json.uuid;
    for (let i = 0, l = json.bones.length; i < l; i++) {
      const uuid = json.bones[i];
      let bone = bones[uuid];
      if (bone === void 0) {
        console.warn("THREE.Skeleton: No bone found with UUID:", uuid);
        bone = new Bone();
      }
      this.bones.push(bone);
      this.boneInverses.push(new Matrix4$1().fromArray(json.boneInverses[i]));
    }
    this.init();
    return this;
  }
  toJSON() {
    const data = {
      metadata: {
        version: 4.6,
        type: "Skeleton",
        generator: "Skeleton.toJSON"
      },
      bones: [],
      boneInverses: []
    };
    data.uuid = this.uuid;
    const bones = this.bones;
    const boneInverses = this.boneInverses;
    for (let i = 0, l = bones.length; i < l; i++) {
      const bone = bones[i];
      data.bones.push(bone.uuid);
      const boneInverse = boneInverses[i];
      data.boneInverses.push(boneInverse.toArray());
    }
    return data;
  }
}
class InstancedBufferAttribute extends BufferAttribute$1 {
  constructor(array, itemSize, normalized, meshPerAttribute = 1) {
    super(array, itemSize, normalized);
    this.isInstancedBufferAttribute = true;
    this.meshPerAttribute = meshPerAttribute;
  }
  copy(source) {
    super.copy(source);
    this.meshPerAttribute = source.meshPerAttribute;
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.meshPerAttribute = this.meshPerAttribute;
    data.isInstancedBufferAttribute = true;
    return data;
  }
}
const _instanceLocalMatrix = /* @__PURE__ */ new Matrix4$1();
const _instanceWorldMatrix = /* @__PURE__ */ new Matrix4$1();
const _instanceIntersects = [];
const _box3 = /* @__PURE__ */ new Box3();
const _identity = /* @__PURE__ */ new Matrix4$1();
const _mesh$1 = /* @__PURE__ */ new Mesh();
const _sphere$4 = /* @__PURE__ */ new Sphere();
class InstancedMesh extends Mesh {
  constructor(geometry, material, count) {
    super(geometry, material);
    this.isInstancedMesh = true;
    this.instanceMatrix = new InstancedBufferAttribute(new Float32Array(count * 16), 16);
    this.instanceColor = null;
    this.morphTexture = null;
    this.count = count;
    this.boundingBox = null;
    this.boundingSphere = null;
    for (let i = 0; i < count; i++) {
      this.setMatrixAt(i, _identity);
    }
  }
  computeBoundingBox() {
    const geometry = this.geometry;
    const count = this.count;
    if (this.boundingBox === null) {
      this.boundingBox = new Box3();
    }
    if (geometry.boundingBox === null) {
      geometry.computeBoundingBox();
    }
    this.boundingBox.makeEmpty();
    for (let i = 0; i < count; i++) {
      this.getMatrixAt(i, _instanceLocalMatrix);
      _box3.copy(geometry.boundingBox).applyMatrix4(_instanceLocalMatrix);
      this.boundingBox.union(_box3);
    }
  }
  computeBoundingSphere() {
    const geometry = this.geometry;
    const count = this.count;
    if (this.boundingSphere === null) {
      this.boundingSphere = new Sphere();
    }
    if (geometry.boundingSphere === null) {
      geometry.computeBoundingSphere();
    }
    this.boundingSphere.makeEmpty();
    for (let i = 0; i < count; i++) {
      this.getMatrixAt(i, _instanceLocalMatrix);
      _sphere$4.copy(geometry.boundingSphere).applyMatrix4(_instanceLocalMatrix);
      this.boundingSphere.union(_sphere$4);
    }
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.instanceMatrix.copy(source.instanceMatrix);
    if (source.morphTexture !== null) this.morphTexture = source.morphTexture.clone();
    if (source.instanceColor !== null) this.instanceColor = source.instanceColor.clone();
    this.count = source.count;
    if (source.boundingBox !== null) this.boundingBox = source.boundingBox.clone();
    if (source.boundingSphere !== null) this.boundingSphere = source.boundingSphere.clone();
    return this;
  }
  getColorAt(index, color2) {
    color2.fromArray(this.instanceColor.array, index * 3);
  }
  getMatrixAt(index, matrix) {
    matrix.fromArray(this.instanceMatrix.array, index * 16);
  }
  getMorphAt(index, object) {
    const objectInfluences = object.morphTargetInfluences;
    const array = this.morphTexture.source.data.data;
    const len = objectInfluences.length + 1;
    const dataIndex = index * len + 1;
    for (let i = 0; i < objectInfluences.length; i++) {
      objectInfluences[i] = array[dataIndex + i];
    }
  }
  raycast(raycaster, intersects2) {
    const matrixWorld = this.matrixWorld;
    const raycastTimes = this.count;
    _mesh$1.geometry = this.geometry;
    _mesh$1.material = this.material;
    if (_mesh$1.material === void 0) return;
    if (this.boundingSphere === null) this.computeBoundingSphere();
    _sphere$4.copy(this.boundingSphere);
    _sphere$4.applyMatrix4(matrixWorld);
    if (raycaster.ray.intersectsSphere(_sphere$4) === false) return;
    for (let instanceId = 0; instanceId < raycastTimes; instanceId++) {
      this.getMatrixAt(instanceId, _instanceLocalMatrix);
      _instanceWorldMatrix.multiplyMatrices(matrixWorld, _instanceLocalMatrix);
      _mesh$1.matrixWorld = _instanceWorldMatrix;
      _mesh$1.raycast(raycaster, _instanceIntersects);
      for (let i = 0, l = _instanceIntersects.length; i < l; i++) {
        const intersect2 = _instanceIntersects[i];
        intersect2.instanceId = instanceId;
        intersect2.object = this;
        intersects2.push(intersect2);
      }
      _instanceIntersects.length = 0;
    }
  }
  setColorAt(index, color2) {
    if (this.instanceColor === null) {
      this.instanceColor = new InstancedBufferAttribute(new Float32Array(this.instanceMatrix.count * 3).fill(1), 3);
    }
    color2.toArray(this.instanceColor.array, index * 3);
  }
  setMatrixAt(index, matrix) {
    matrix.toArray(this.instanceMatrix.array, index * 16);
  }
  setMorphAt(index, object) {
    const objectInfluences = object.morphTargetInfluences;
    const len = objectInfluences.length + 1;
    if (this.morphTexture === null) {
      this.morphTexture = new DataTexture(new Float32Array(len * this.count), len, this.count, RedFormat, FloatType$1);
    }
    const array = this.morphTexture.source.data.data;
    let morphInfluencesSum = 0;
    for (let i = 0; i < objectInfluences.length; i++) {
      morphInfluencesSum += objectInfluences[i];
    }
    const morphBaseInfluence = this.geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
    const dataIndex = len * index;
    array[dataIndex] = morphBaseInfluence;
    array.set(objectInfluences, dataIndex + 1);
  }
  updateMorphTargets() {
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
    if (this.morphTexture !== null) {
      this.morphTexture.dispose();
      this.morphTexture = null;
    }
    return this;
  }
}
const _vector1 = /* @__PURE__ */ new Vector3$1();
const _vector2$2 = /* @__PURE__ */ new Vector3$1();
const _normalMatrix = /* @__PURE__ */ new Matrix3$1();
class Plane {
  constructor(normal = new Vector3$1(1, 0, 0), constant = 0) {
    this.isPlane = true;
    this.normal = normal;
    this.constant = constant;
  }
  set(normal, constant) {
    this.normal.copy(normal);
    this.constant = constant;
    return this;
  }
  setComponents(x, y, z, w) {
    this.normal.set(x, y, z);
    this.constant = w;
    return this;
  }
  setFromNormalAndCoplanarPoint(normal, point) {
    this.normal.copy(normal);
    this.constant = -point.dot(this.normal);
    return this;
  }
  setFromCoplanarPoints(a, b, c) {
    const normal = _vector1.subVectors(c, b).cross(_vector2$2.subVectors(a, b)).normalize();
    this.setFromNormalAndCoplanarPoint(normal, a);
    return this;
  }
  copy(plane) {
    this.normal.copy(plane.normal);
    this.constant = plane.constant;
    return this;
  }
  normalize() {
    const inverseNormalLength = 1 / this.normal.length();
    this.normal.multiplyScalar(inverseNormalLength);
    this.constant *= inverseNormalLength;
    return this;
  }
  negate() {
    this.constant *= -1;
    this.normal.negate();
    return this;
  }
  distanceToPoint(point) {
    return this.normal.dot(point) + this.constant;
  }
  distanceToSphere(sphere) {
    return this.distanceToPoint(sphere.center) - sphere.radius;
  }
  projectPoint(point, target) {
    return target.copy(point).addScaledVector(this.normal, -this.distanceToPoint(point));
  }
  intersectLine(line, target) {
    const direction = line.delta(_vector1);
    const denominator = this.normal.dot(direction);
    if (denominator === 0) {
      if (this.distanceToPoint(line.start) === 0) {
        return target.copy(line.start);
      }
      return null;
    }
    const t = -(line.start.dot(this.normal) + this.constant) / denominator;
    if (t < 0 || t > 1) {
      return null;
    }
    return target.copy(line.start).addScaledVector(direction, t);
  }
  intersectsLine(line) {
    const startSign = this.distanceToPoint(line.start);
    const endSign = this.distanceToPoint(line.end);
    return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;
  }
  intersectsBox(box) {
    return box.intersectsPlane(this);
  }
  intersectsSphere(sphere) {
    return sphere.intersectsPlane(this);
  }
  coplanarPoint(target) {
    return target.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(matrix, optionalNormalMatrix) {
    const normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix(matrix);
    const referencePoint = this.coplanarPoint(_vector1).applyMatrix4(matrix);
    const normal = this.normal.applyMatrix3(normalMatrix).normalize();
    this.constant = -referencePoint.dot(normal);
    return this;
  }
  translate(offset) {
    this.constant -= offset.dot(this.normal);
    return this;
  }
  equals(plane) {
    return plane.normal.equals(this.normal) && plane.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const _sphere$3 = /* @__PURE__ */ new Sphere();
const _vector$6 = /* @__PURE__ */ new Vector3$1();
class Frustum {
  constructor(p0 = new Plane(), p1 = new Plane(), p2 = new Plane(), p3 = new Plane(), p4 = new Plane(), p5 = new Plane()) {
    this.planes = [p0, p1, p2, p3, p4, p5];
  }
  set(p0, p1, p2, p3, p4, p5) {
    const planes = this.planes;
    planes[0].copy(p0);
    planes[1].copy(p1);
    planes[2].copy(p2);
    planes[3].copy(p3);
    planes[4].copy(p4);
    planes[5].copy(p5);
    return this;
  }
  copy(frustum) {
    const planes = this.planes;
    for (let i = 0; i < 6; i++) {
      planes[i].copy(frustum.planes[i]);
    }
    return this;
  }
  setFromProjectionMatrix(m, coordinateSystem = WebGLCoordinateSystem$1) {
    const planes = this.planes;
    const me = m.elements;
    const me0 = me[0], me1 = me[1], me2 = me[2], me3 = me[3];
    const me4 = me[4], me5 = me[5], me6 = me[6], me7 = me[7];
    const me8 = me[8], me9 = me[9], me10 = me[10], me11 = me[11];
    const me12 = me[12], me13 = me[13], me14 = me[14], me15 = me[15];
    planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();
    planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();
    planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();
    planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();
    planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();
    if (coordinateSystem === WebGLCoordinateSystem$1) {
      planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();
    } else if (coordinateSystem === WebGPUCoordinateSystem$1) {
      planes[5].setComponents(me2, me6, me10, me14).normalize();
    } else {
      throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + coordinateSystem);
    }
    return this;
  }
  intersectsObject(object) {
    if (object.boundingSphere !== void 0) {
      if (object.boundingSphere === null) object.computeBoundingSphere();
      _sphere$3.copy(object.boundingSphere).applyMatrix4(object.matrixWorld);
    } else {
      const geometry = object.geometry;
      if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
      _sphere$3.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);
    }
    return this.intersectsSphere(_sphere$3);
  }
  intersectsSprite(sprite) {
    _sphere$3.center.set(0, 0, 0);
    _sphere$3.radius = 0.7071067811865476;
    _sphere$3.applyMatrix4(sprite.matrixWorld);
    return this.intersectsSphere(_sphere$3);
  }
  intersectsSphere(sphere) {
    const planes = this.planes;
    const center = sphere.center;
    const negRadius = -sphere.radius;
    for (let i = 0; i < 6; i++) {
      const distance2 = planes[i].distanceToPoint(center);
      if (distance2 < negRadius) {
        return false;
      }
    }
    return true;
  }
  intersectsBox(box) {
    const planes = this.planes;
    for (let i = 0; i < 6; i++) {
      const plane = planes[i];
      _vector$6.x = plane.normal.x > 0 ? box.max.x : box.min.x;
      _vector$6.y = plane.normal.y > 0 ? box.max.y : box.min.y;
      _vector$6.z = plane.normal.z > 0 ? box.max.z : box.min.z;
      if (plane.distanceToPoint(_vector$6) < 0) {
        return false;
      }
    }
    return true;
  }
  containsPoint(point) {
    const planes = this.planes;
    for (let i = 0; i < 6; i++) {
      if (planes[i].distanceToPoint(point) < 0) {
        return false;
      }
    }
    return true;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
function ascIdSort(a, b) {
  return a - b;
}
function sortOpaque(a, b) {
  return a.z - b.z;
}
function sortTransparent(a, b) {
  return b.z - a.z;
}
class MultiDrawRenderList {
  constructor() {
    this.index = 0;
    this.pool = [];
    this.list = [];
  }
  push(start, count, z, index) {
    const pool = this.pool;
    const list = this.list;
    if (this.index >= pool.length) {
      pool.push({
        start: -1,
        count: -1,
        z: -1,
        index: -1
      });
    }
    const item = pool[this.index];
    list.push(item);
    this.index++;
    item.start = start;
    item.count = count;
    item.z = z;
    item.index = index;
  }
  reset() {
    this.list.length = 0;
    this.index = 0;
  }
}
const _matrix$1 = /* @__PURE__ */ new Matrix4$1();
const _whiteColor = /* @__PURE__ */ new Color$1(1, 1, 1);
const _frustum = /* @__PURE__ */ new Frustum();
const _box$1 = /* @__PURE__ */ new Box3();
const _sphere$2 = /* @__PURE__ */ new Sphere();
const _vector$5 = /* @__PURE__ */ new Vector3$1();
const _forward = /* @__PURE__ */ new Vector3$1();
const _temp = /* @__PURE__ */ new Vector3$1();
const _renderList = /* @__PURE__ */ new MultiDrawRenderList();
const _mesh = /* @__PURE__ */ new Mesh();
const _batchIntersects = [];
function copyAttributeData(src, target, targetOffset = 0) {
  const itemSize = target.itemSize;
  if (src.isInterleavedBufferAttribute || src.array.constructor !== target.array.constructor) {
    const vertexCount = src.count;
    for (let i = 0; i < vertexCount; i++) {
      for (let c = 0; c < itemSize; c++) {
        target.setComponent(i + targetOffset, c, src.getComponent(i, c));
      }
    }
  } else {
    target.array.set(src.array, targetOffset * itemSize);
  }
  target.needsUpdate = true;
}
function copyArrayContents(src, target) {
  if (src.constructor !== target.constructor) {
    const len = Math.min(src.length, target.length);
    for (let i = 0; i < len; i++) {
      target[i] = src[i];
    }
  } else {
    const len = Math.min(src.length, target.length);
    target.set(new src.constructor(src.buffer, 0, len));
  }
}
class BatchedMesh extends Mesh {
  get maxInstanceCount() {
    return this._maxInstanceCount;
  }
  get instanceCount() {
    return this._instanceInfo.length - this._availableInstanceIds.length;
  }
  get unusedVertexCount() {
    return this._maxVertexCount - this._nextVertexStart;
  }
  get unusedIndexCount() {
    return this._maxIndexCount - this._nextIndexStart;
  }
  constructor(maxInstanceCount, maxVertexCount, maxIndexCount = maxVertexCount * 2, material) {
    super(new BufferGeometry(), material);
    this.isBatchedMesh = true;
    this.perObjectFrustumCulled = true;
    this.sortObjects = true;
    this.boundingBox = null;
    this.boundingSphere = null;
    this.customSort = null;
    this._instanceInfo = [];
    this._geometryInfo = [];
    this._availableInstanceIds = [];
    this._availableGeometryIds = [];
    this._nextIndexStart = 0;
    this._nextVertexStart = 0;
    this._geometryCount = 0;
    this._visibilityChanged = true;
    this._geometryInitialized = false;
    this._maxInstanceCount = maxInstanceCount;
    this._maxVertexCount = maxVertexCount;
    this._maxIndexCount = maxIndexCount;
    this._multiDrawCounts = new Int32Array(maxInstanceCount);
    this._multiDrawStarts = new Int32Array(maxInstanceCount);
    this._multiDrawCount = 0;
    this._multiDrawInstances = null;
    this._matricesTexture = null;
    this._indirectTexture = null;
    this._colorsTexture = null;
    this._initMatricesTexture();
    this._initIndirectTexture();
  }
  _initMatricesTexture() {
    let size = Math.sqrt(this._maxInstanceCount * 4);
    size = Math.ceil(size / 4) * 4;
    size = Math.max(size, 4);
    const matricesArray = new Float32Array(size * size * 4);
    const matricesTexture = new DataTexture(matricesArray, size, size, RGBAFormat, FloatType$1);
    this._matricesTexture = matricesTexture;
  }
  _initIndirectTexture() {
    let size = Math.sqrt(this._maxInstanceCount);
    size = Math.ceil(size);
    const indirectArray = new Uint32Array(size * size);
    const indirectTexture = new DataTexture(indirectArray, size, size, RedIntegerFormat, UnsignedIntType);
    this._indirectTexture = indirectTexture;
  }
  _initColorsTexture() {
    let size = Math.sqrt(this._maxInstanceCount);
    size = Math.ceil(size);
    const colorsArray = new Float32Array(size * size * 4).fill(1);
    const colorsTexture = new DataTexture(colorsArray, size, size, RGBAFormat, FloatType$1);
    colorsTexture.colorSpace = ColorManagement$1.workingColorSpace;
    this._colorsTexture = colorsTexture;
  }
  _initializeGeometry(reference) {
    const geometry = this.geometry;
    const maxVertexCount = this._maxVertexCount;
    const maxIndexCount = this._maxIndexCount;
    if (this._geometryInitialized === false) {
      for (const attributeName in reference.attributes) {
        const srcAttribute = reference.getAttribute(attributeName);
        const { array, itemSize, normalized } = srcAttribute;
        const dstArray = new array.constructor(maxVertexCount * itemSize);
        const dstAttribute = new BufferAttribute$1(dstArray, itemSize, normalized);
        geometry.setAttribute(attributeName, dstAttribute);
      }
      if (reference.getIndex() !== null) {
        const indexArray = maxVertexCount > 65535 ? new Uint32Array(maxIndexCount) : new Uint16Array(maxIndexCount);
        geometry.setIndex(new BufferAttribute$1(indexArray, 1));
      }
      this._geometryInitialized = true;
    }
  }
  // Make sure the geometry is compatible with the existing combined geometry attributes
  _validateGeometry(geometry) {
    const batchGeometry = this.geometry;
    if (Boolean(geometry.getIndex()) !== Boolean(batchGeometry.getIndex())) {
      throw new Error('THREE.BatchedMesh: All geometries must consistently have "index".');
    }
    for (const attributeName in batchGeometry.attributes) {
      if (!geometry.hasAttribute(attributeName)) {
        throw new Error(`THREE.BatchedMesh: Added geometry missing "${attributeName}". All geometries must have consistent attributes.`);
      }
      const srcAttribute = geometry.getAttribute(attributeName);
      const dstAttribute = batchGeometry.getAttribute(attributeName);
      if (srcAttribute.itemSize !== dstAttribute.itemSize || srcAttribute.normalized !== dstAttribute.normalized) {
        throw new Error("THREE.BatchedMesh: All attributes must have a consistent itemSize and normalized value.");
      }
    }
  }
  validateInstanceId(instanceId) {
    const instanceInfo = this._instanceInfo;
    if (instanceId < 0 || instanceId >= instanceInfo.length || instanceInfo[instanceId].active === false) {
      throw new Error(`THREE.BatchedMesh: Invalid instanceId ${instanceId}. Instance is either out of range or has been deleted.`);
    }
  }
  validateGeometryId(geometryId) {
    const geometryInfoList = this._geometryInfo;
    if (geometryId < 0 || geometryId >= geometryInfoList.length || geometryInfoList[geometryId].active === false) {
      throw new Error(`THREE.BatchedMesh: Invalid geometryId ${geometryId}. Geometry is either out of range or has been deleted.`);
    }
  }
  setCustomSort(func) {
    this.customSort = func;
    return this;
  }
  computeBoundingBox() {
    if (this.boundingBox === null) {
      this.boundingBox = new Box3();
    }
    const boundingBox2 = this.boundingBox;
    const instanceInfo = this._instanceInfo;
    boundingBox2.makeEmpty();
    for (let i = 0, l = instanceInfo.length; i < l; i++) {
      if (instanceInfo[i].active === false) continue;
      const geometryId = instanceInfo[i].geometryIndex;
      this.getMatrixAt(i, _matrix$1);
      this.getBoundingBoxAt(geometryId, _box$1).applyMatrix4(_matrix$1);
      boundingBox2.union(_box$1);
    }
  }
  computeBoundingSphere() {
    if (this.boundingSphere === null) {
      this.boundingSphere = new Sphere();
    }
    const boundingSphere = this.boundingSphere;
    const instanceInfo = this._instanceInfo;
    boundingSphere.makeEmpty();
    for (let i = 0, l = instanceInfo.length; i < l; i++) {
      if (instanceInfo[i].active === false) continue;
      const geometryId = instanceInfo[i].geometryIndex;
      this.getMatrixAt(i, _matrix$1);
      this.getBoundingSphereAt(geometryId, _sphere$2).applyMatrix4(_matrix$1);
      boundingSphere.union(_sphere$2);
    }
  }
  addInstance(geometryId) {
    const atCapacity = this._instanceInfo.length >= this.maxInstanceCount;
    if (atCapacity && this._availableInstanceIds.length === 0) {
      throw new Error("THREE.BatchedMesh: Maximum item count reached.");
    }
    const instanceInfo = {
      visible: true,
      active: true,
      geometryIndex: geometryId
    };
    let drawId = null;
    if (this._availableInstanceIds.length > 0) {
      this._availableInstanceIds.sort(ascIdSort);
      drawId = this._availableInstanceIds.shift();
      this._instanceInfo[drawId] = instanceInfo;
    } else {
      drawId = this._instanceInfo.length;
      this._instanceInfo.push(instanceInfo);
    }
    const matricesTexture = this._matricesTexture;
    _matrix$1.identity().toArray(matricesTexture.image.data, drawId * 16);
    matricesTexture.needsUpdate = true;
    const colorsTexture = this._colorsTexture;
    if (colorsTexture) {
      _whiteColor.toArray(colorsTexture.image.data, drawId * 4);
      colorsTexture.needsUpdate = true;
    }
    this._visibilityChanged = true;
    return drawId;
  }
  addGeometry(geometry, reservedVertexCount = -1, reservedIndexCount = -1) {
    this._initializeGeometry(geometry);
    this._validateGeometry(geometry);
    const geometryInfo = {
      // geometry information
      vertexStart: -1,
      vertexCount: -1,
      reservedVertexCount: -1,
      indexStart: -1,
      indexCount: -1,
      reservedIndexCount: -1,
      // draw range information
      start: -1,
      count: -1,
      // state
      boundingBox: null,
      boundingSphere: null,
      active: true
    };
    const geometryInfoList = this._geometryInfo;
    geometryInfo.vertexStart = this._nextVertexStart;
    geometryInfo.reservedVertexCount = reservedVertexCount === -1 ? geometry.getAttribute("position").count : reservedVertexCount;
    const index = geometry.getIndex();
    const hasIndex = index !== null;
    if (hasIndex) {
      geometryInfo.indexStart = this._nextIndexStart;
      geometryInfo.reservedIndexCount = reservedIndexCount === -1 ? index.count : reservedIndexCount;
    }
    if (geometryInfo.indexStart !== -1 && geometryInfo.indexStart + geometryInfo.reservedIndexCount > this._maxIndexCount || geometryInfo.vertexStart + geometryInfo.reservedVertexCount > this._maxVertexCount) {
      throw new Error("THREE.BatchedMesh: Reserved space request exceeds the maximum buffer size.");
    }
    let geometryId;
    if (this._availableGeometryIds.length > 0) {
      this._availableGeometryIds.sort(ascIdSort);
      geometryId = this._availableGeometryIds.shift();
      geometryInfoList[geometryId] = geometryInfo;
    } else {
      geometryId = this._geometryCount;
      this._geometryCount++;
      geometryInfoList.push(geometryInfo);
    }
    this.setGeometryAt(geometryId, geometry);
    this._nextIndexStart = geometryInfo.indexStart + geometryInfo.reservedIndexCount;
    this._nextVertexStart = geometryInfo.vertexStart + geometryInfo.reservedVertexCount;
    return geometryId;
  }
  setGeometryAt(geometryId, geometry) {
    if (geometryId >= this._geometryCount) {
      throw new Error("THREE.BatchedMesh: Maximum geometry count reached.");
    }
    this._validateGeometry(geometry);
    const batchGeometry = this.geometry;
    const hasIndex = batchGeometry.getIndex() !== null;
    const dstIndex = batchGeometry.getIndex();
    const srcIndex = geometry.getIndex();
    const geometryInfo = this._geometryInfo[geometryId];
    if (hasIndex && srcIndex.count > geometryInfo.reservedIndexCount || geometry.attributes.position.count > geometryInfo.reservedVertexCount) {
      throw new Error("THREE.BatchedMesh: Reserved space not large enough for provided geometry.");
    }
    const vertexStart = geometryInfo.vertexStart;
    const reservedVertexCount = geometryInfo.reservedVertexCount;
    geometryInfo.vertexCount = geometry.getAttribute("position").count;
    for (const attributeName in batchGeometry.attributes) {
      const srcAttribute = geometry.getAttribute(attributeName);
      const dstAttribute = batchGeometry.getAttribute(attributeName);
      copyAttributeData(srcAttribute, dstAttribute, vertexStart);
      const itemSize = srcAttribute.itemSize;
      for (let i = srcAttribute.count, l = reservedVertexCount; i < l; i++) {
        const index = vertexStart + i;
        for (let c = 0; c < itemSize; c++) {
          dstAttribute.setComponent(index, c, 0);
        }
      }
      dstAttribute.needsUpdate = true;
      dstAttribute.addUpdateRange(vertexStart * itemSize, reservedVertexCount * itemSize);
    }
    if (hasIndex) {
      const indexStart = geometryInfo.indexStart;
      const reservedIndexCount = geometryInfo.reservedIndexCount;
      geometryInfo.indexCount = geometry.getIndex().count;
      for (let i = 0; i < srcIndex.count; i++) {
        dstIndex.setX(indexStart + i, vertexStart + srcIndex.getX(i));
      }
      for (let i = srcIndex.count, l = reservedIndexCount; i < l; i++) {
        dstIndex.setX(indexStart + i, vertexStart);
      }
      dstIndex.needsUpdate = true;
      dstIndex.addUpdateRange(indexStart, geometryInfo.reservedIndexCount);
    }
    geometryInfo.start = hasIndex ? geometryInfo.indexStart : geometryInfo.vertexStart;
    geometryInfo.count = hasIndex ? geometryInfo.indexCount : geometryInfo.vertexCount;
    geometryInfo.boundingBox = null;
    if (geometry.boundingBox !== null) {
      geometryInfo.boundingBox = geometry.boundingBox.clone();
    }
    geometryInfo.boundingSphere = null;
    if (geometry.boundingSphere !== null) {
      geometryInfo.boundingSphere = geometry.boundingSphere.clone();
    }
    this._visibilityChanged = true;
    return geometryId;
  }
  deleteGeometry(geometryId) {
    const geometryInfoList = this._geometryInfo;
    if (geometryId >= geometryInfoList.length || geometryInfoList[geometryId].active === false) {
      return this;
    }
    const instanceInfo = this._instanceInfo;
    for (let i = 0, l = instanceInfo.length; i < l; i++) {
      if (instanceInfo[i].geometryIndex === geometryId) {
        this.deleteInstance(i);
      }
    }
    geometryInfoList[geometryId].active = false;
    this._availableGeometryIds.push(geometryId);
    this._visibilityChanged = true;
    return this;
  }
  deleteInstance(instanceId) {
    this.validateInstanceId(instanceId);
    this._instanceInfo[instanceId].active = false;
    this._availableInstanceIds.push(instanceId);
    this._visibilityChanged = true;
    return this;
  }
  optimize() {
    let nextVertexStart = 0;
    let nextIndexStart = 0;
    const geometryInfoList = this._geometryInfo;
    const indices = geometryInfoList.map((e, i) => i).sort((a, b) => {
      return geometryInfoList[a].vertexStart - geometryInfoList[b].vertexStart;
    });
    const geometry = this.geometry;
    for (let i = 0, l = geometryInfoList.length; i < l; i++) {
      const index = indices[i];
      const geometryInfo = geometryInfoList[index];
      if (geometryInfo.active === false) {
        continue;
      }
      if (geometry.index !== null) {
        if (geometryInfo.indexStart !== nextIndexStart) {
          const { indexStart, vertexStart, reservedIndexCount } = geometryInfo;
          const index2 = geometry.index;
          const array = index2.array;
          const elementDelta = nextVertexStart - vertexStart;
          for (let j = indexStart; j < indexStart + reservedIndexCount; j++) {
            array[j] = array[j] + elementDelta;
          }
          index2.array.copyWithin(nextIndexStart, indexStart, indexStart + reservedIndexCount);
          index2.addUpdateRange(nextIndexStart, reservedIndexCount);
          geometryInfo.indexStart = nextIndexStart;
        }
        nextIndexStart += geometryInfo.reservedIndexCount;
      }
      if (geometryInfo.vertexStart !== nextVertexStart) {
        const { vertexStart, reservedVertexCount } = geometryInfo;
        const attributes = geometry.attributes;
        for (const key in attributes) {
          const attribute = attributes[key];
          const { array, itemSize } = attribute;
          array.copyWithin(nextVertexStart * itemSize, vertexStart * itemSize, (vertexStart + reservedVertexCount) * itemSize);
          attribute.addUpdateRange(nextVertexStart * itemSize, reservedVertexCount * itemSize);
        }
        geometryInfo.vertexStart = nextVertexStart;
      }
      nextVertexStart += geometryInfo.reservedVertexCount;
      geometryInfo.start = geometry.index ? geometryInfo.indexStart : geometryInfo.vertexStart;
      this._nextIndexStart = geometry.index ? geometryInfo.indexStart + geometryInfo.reservedIndexCount : 0;
      this._nextVertexStart = geometryInfo.vertexStart + geometryInfo.reservedVertexCount;
    }
    return this;
  }
  // get bounding box and compute it if it doesn't exist
  getBoundingBoxAt(geometryId, target) {
    if (geometryId >= this._geometryCount) {
      return null;
    }
    const geometry = this.geometry;
    const geometryInfo = this._geometryInfo[geometryId];
    if (geometryInfo.boundingBox === null) {
      const box = new Box3();
      const index = geometry.index;
      const position = geometry.attributes.position;
      for (let i = geometryInfo.start, l = geometryInfo.start + geometryInfo.count; i < l; i++) {
        let iv = i;
        if (index) {
          iv = index.getX(iv);
        }
        box.expandByPoint(_vector$5.fromBufferAttribute(position, iv));
      }
      geometryInfo.boundingBox = box;
    }
    target.copy(geometryInfo.boundingBox);
    return target;
  }
  // get bounding sphere and compute it if it doesn't exist
  getBoundingSphereAt(geometryId, target) {
    if (geometryId >= this._geometryCount) {
      return null;
    }
    const geometry = this.geometry;
    const geometryInfo = this._geometryInfo[geometryId];
    if (geometryInfo.boundingSphere === null) {
      const sphere = new Sphere();
      this.getBoundingBoxAt(geometryId, _box$1);
      _box$1.getCenter(sphere.center);
      const index = geometry.index;
      const position = geometry.attributes.position;
      let maxRadiusSq = 0;
      for (let i = geometryInfo.start, l = geometryInfo.start + geometryInfo.count; i < l; i++) {
        let iv = i;
        if (index) {
          iv = index.getX(iv);
        }
        _vector$5.fromBufferAttribute(position, iv);
        maxRadiusSq = Math.max(maxRadiusSq, sphere.center.distanceToSquared(_vector$5));
      }
      sphere.radius = Math.sqrt(maxRadiusSq);
      geometryInfo.boundingSphere = sphere;
    }
    target.copy(geometryInfo.boundingSphere);
    return target;
  }
  setMatrixAt(instanceId, matrix) {
    this.validateInstanceId(instanceId);
    const matricesTexture = this._matricesTexture;
    const matricesArray = this._matricesTexture.image.data;
    matrix.toArray(matricesArray, instanceId * 16);
    matricesTexture.needsUpdate = true;
    return this;
  }
  getMatrixAt(instanceId, matrix) {
    this.validateInstanceId(instanceId);
    return matrix.fromArray(this._matricesTexture.image.data, instanceId * 16);
  }
  setColorAt(instanceId, color2) {
    this.validateInstanceId(instanceId);
    if (this._colorsTexture === null) {
      this._initColorsTexture();
    }
    color2.toArray(this._colorsTexture.image.data, instanceId * 4);
    this._colorsTexture.needsUpdate = true;
    return this;
  }
  getColorAt(instanceId, color2) {
    this.validateInstanceId(instanceId);
    return color2.fromArray(this._colorsTexture.image.data, instanceId * 4);
  }
  setVisibleAt(instanceId, value) {
    this.validateInstanceId(instanceId);
    if (this._instanceInfo[instanceId].visible === value) {
      return this;
    }
    this._instanceInfo[instanceId].visible = value;
    this._visibilityChanged = true;
    return this;
  }
  getVisibleAt(instanceId) {
    this.validateInstanceId(instanceId);
    return this._instanceInfo[instanceId].visible;
  }
  setGeometryIdAt(instanceId, geometryId) {
    this.validateInstanceId(instanceId);
    this.validateGeometryId(geometryId);
    this._instanceInfo[instanceId].geometryIndex = geometryId;
    return this;
  }
  getGeometryIdAt(instanceId) {
    this.validateInstanceId(instanceId);
    return this._instanceInfo[instanceId].geometryIndex;
  }
  getGeometryRangeAt(geometryId, target = {}) {
    this.validateGeometryId(geometryId);
    const geometryInfo = this._geometryInfo[geometryId];
    target.vertexStart = geometryInfo.vertexStart;
    target.vertexCount = geometryInfo.vertexCount;
    target.reservedVertexCount = geometryInfo.reservedVertexCount;
    target.indexStart = geometryInfo.indexStart;
    target.indexCount = geometryInfo.indexCount;
    target.reservedIndexCount = geometryInfo.reservedIndexCount;
    target.start = geometryInfo.start;
    target.count = geometryInfo.count;
    return target;
  }
  setInstanceCount(maxInstanceCount) {
    const availableInstanceIds = this._availableInstanceIds;
    const instanceInfo = this._instanceInfo;
    availableInstanceIds.sort(ascIdSort);
    while (availableInstanceIds[availableInstanceIds.length - 1] === instanceInfo.length) {
      instanceInfo.pop();
      availableInstanceIds.pop();
    }
    if (maxInstanceCount < instanceInfo.length) {
      throw new Error(`BatchedMesh: Instance ids outside the range ${maxInstanceCount} are being used. Cannot shrink instance count.`);
    }
    const multiDrawCounts = new Int32Array(maxInstanceCount);
    const multiDrawStarts = new Int32Array(maxInstanceCount);
    copyArrayContents(this._multiDrawCounts, multiDrawCounts);
    copyArrayContents(this._multiDrawStarts, multiDrawStarts);
    this._multiDrawCounts = multiDrawCounts;
    this._multiDrawStarts = multiDrawStarts;
    this._maxInstanceCount = maxInstanceCount;
    const indirectTexture = this._indirectTexture;
    const matricesTexture = this._matricesTexture;
    const colorsTexture = this._colorsTexture;
    indirectTexture.dispose();
    this._initIndirectTexture();
    copyArrayContents(indirectTexture.image.data, this._indirectTexture.image.data);
    matricesTexture.dispose();
    this._initMatricesTexture();
    copyArrayContents(matricesTexture.image.data, this._matricesTexture.image.data);
    if (colorsTexture) {
      colorsTexture.dispose();
      this._initColorsTexture();
      copyArrayContents(colorsTexture.image.data, this._colorsTexture.image.data);
    }
  }
  setGeometrySize(maxVertexCount, maxIndexCount) {
    const validRanges = [...this._geometryInfo].filter((info) => info.active);
    const requiredVertexLength = Math.max(...validRanges.map((range) => range.vertexStart + range.reservedVertexCount));
    if (requiredVertexLength > maxVertexCount) {
      throw new Error(`BatchedMesh: Geometry vertex values are being used outside the range ${maxIndexCount}. Cannot shrink further.`);
    }
    if (this.geometry.index) {
      const requiredIndexLength = Math.max(...validRanges.map((range) => range.indexStart + range.reservedIndexCount));
      if (requiredIndexLength > maxIndexCount) {
        throw new Error(`BatchedMesh: Geometry index values are being used outside the range ${maxIndexCount}. Cannot shrink further.`);
      }
    }
    const oldGeometry = this.geometry;
    oldGeometry.dispose();
    this._maxVertexCount = maxVertexCount;
    this._maxIndexCount = maxIndexCount;
    if (this._geometryInitialized) {
      this._geometryInitialized = false;
      this.geometry = new BufferGeometry();
      this._initializeGeometry(oldGeometry);
    }
    const geometry = this.geometry;
    if (oldGeometry.index) {
      copyArrayContents(oldGeometry.index.array, geometry.index.array);
    }
    for (const key in oldGeometry.attributes) {
      copyArrayContents(oldGeometry.attributes[key].array, geometry.attributes[key].array);
    }
  }
  raycast(raycaster, intersects2) {
    const instanceInfo = this._instanceInfo;
    const geometryInfoList = this._geometryInfo;
    const matrixWorld = this.matrixWorld;
    const batchGeometry = this.geometry;
    _mesh.material = this.material;
    _mesh.geometry.index = batchGeometry.index;
    _mesh.geometry.attributes = batchGeometry.attributes;
    if (_mesh.geometry.boundingBox === null) {
      _mesh.geometry.boundingBox = new Box3();
    }
    if (_mesh.geometry.boundingSphere === null) {
      _mesh.geometry.boundingSphere = new Sphere();
    }
    for (let i = 0, l = instanceInfo.length; i < l; i++) {
      if (!instanceInfo[i].visible || !instanceInfo[i].active) {
        continue;
      }
      const geometryId = instanceInfo[i].geometryIndex;
      const geometryInfo = geometryInfoList[geometryId];
      _mesh.geometry.setDrawRange(geometryInfo.start, geometryInfo.count);
      this.getMatrixAt(i, _mesh.matrixWorld).premultiply(matrixWorld);
      this.getBoundingBoxAt(geometryId, _mesh.geometry.boundingBox);
      this.getBoundingSphereAt(geometryId, _mesh.geometry.boundingSphere);
      _mesh.raycast(raycaster, _batchIntersects);
      for (let j = 0, l2 = _batchIntersects.length; j < l2; j++) {
        const intersect2 = _batchIntersects[j];
        intersect2.object = this;
        intersect2.batchId = i;
        intersects2.push(intersect2);
      }
      _batchIntersects.length = 0;
    }
    _mesh.material = null;
    _mesh.geometry.index = null;
    _mesh.geometry.attributes = {};
    _mesh.geometry.setDrawRange(0, Infinity);
  }
  copy(source) {
    super.copy(source);
    this.geometry = source.geometry.clone();
    this.perObjectFrustumCulled = source.perObjectFrustumCulled;
    this.sortObjects = source.sortObjects;
    this.boundingBox = source.boundingBox !== null ? source.boundingBox.clone() : null;
    this.boundingSphere = source.boundingSphere !== null ? source.boundingSphere.clone() : null;
    this._geometryInfo = source._geometryInfo.map((info) => ({
      ...info,
      boundingBox: info.boundingBox !== null ? info.boundingBox.clone() : null,
      boundingSphere: info.boundingSphere !== null ? info.boundingSphere.clone() : null
    }));
    this._instanceInfo = source._instanceInfo.map((info) => ({ ...info }));
    this._maxInstanceCount = source._maxInstanceCount;
    this._maxVertexCount = source._maxVertexCount;
    this._maxIndexCount = source._maxIndexCount;
    this._geometryInitialized = source._geometryInitialized;
    this._geometryCount = source._geometryCount;
    this._multiDrawCounts = source._multiDrawCounts.slice();
    this._multiDrawStarts = source._multiDrawStarts.slice();
    this._matricesTexture = source._matricesTexture.clone();
    this._matricesTexture.image.data = this._matricesTexture.image.data.slice();
    if (this._colorsTexture !== null) {
      this._colorsTexture = source._colorsTexture.clone();
      this._colorsTexture.image.data = this._colorsTexture.image.data.slice();
    }
    return this;
  }
  dispose() {
    this.geometry.dispose();
    this._matricesTexture.dispose();
    this._matricesTexture = null;
    this._indirectTexture.dispose();
    this._indirectTexture = null;
    if (this._colorsTexture !== null) {
      this._colorsTexture.dispose();
      this._colorsTexture = null;
    }
    return this;
  }
  onBeforeRender(renderer, scene, camera, geometry, material) {
    if (!this._visibilityChanged && !this.perObjectFrustumCulled && !this.sortObjects) {
      return;
    }
    const index = geometry.getIndex();
    const bytesPerElement = index === null ? 1 : index.array.BYTES_PER_ELEMENT;
    const instanceInfo = this._instanceInfo;
    const multiDrawStarts = this._multiDrawStarts;
    const multiDrawCounts = this._multiDrawCounts;
    const geometryInfoList = this._geometryInfo;
    const perObjectFrustumCulled = this.perObjectFrustumCulled;
    const indirectTexture = this._indirectTexture;
    const indirectArray = indirectTexture.image.data;
    if (perObjectFrustumCulled) {
      _matrix$1.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse).multiply(this.matrixWorld);
      _frustum.setFromProjectionMatrix(
        _matrix$1,
        renderer.coordinateSystem
      );
    }
    let multiDrawCount = 0;
    if (this.sortObjects) {
      _matrix$1.copy(this.matrixWorld).invert();
      _vector$5.setFromMatrixPosition(camera.matrixWorld).applyMatrix4(_matrix$1);
      _forward.set(0, 0, -1).transformDirection(camera.matrixWorld).transformDirection(_matrix$1);
      for (let i = 0, l = instanceInfo.length; i < l; i++) {
        if (instanceInfo[i].visible && instanceInfo[i].active) {
          const geometryId = instanceInfo[i].geometryIndex;
          this.getMatrixAt(i, _matrix$1);
          this.getBoundingSphereAt(geometryId, _sphere$2).applyMatrix4(_matrix$1);
          let culled = false;
          if (perObjectFrustumCulled) {
            culled = !_frustum.intersectsSphere(_sphere$2);
          }
          if (!culled) {
            const geometryInfo = geometryInfoList[geometryId];
            const z = _temp.subVectors(_sphere$2.center, _vector$5).dot(_forward);
            _renderList.push(geometryInfo.start, geometryInfo.count, z, i);
          }
        }
      }
      const list = _renderList.list;
      const customSort = this.customSort;
      if (customSort === null) {
        list.sort(material.transparent ? sortTransparent : sortOpaque);
      } else {
        customSort.call(this, list, camera);
      }
      for (let i = 0, l = list.length; i < l; i++) {
        const item = list[i];
        multiDrawStarts[multiDrawCount] = item.start * bytesPerElement;
        multiDrawCounts[multiDrawCount] = item.count;
        indirectArray[multiDrawCount] = item.index;
        multiDrawCount++;
      }
      _renderList.reset();
    } else {
      for (let i = 0, l = instanceInfo.length; i < l; i++) {
        if (instanceInfo[i].visible && instanceInfo[i].active) {
          const geometryId = instanceInfo[i].geometryIndex;
          let culled = false;
          if (perObjectFrustumCulled) {
            this.getMatrixAt(i, _matrix$1);
            this.getBoundingSphereAt(geometryId, _sphere$2).applyMatrix4(_matrix$1);
            culled = !_frustum.intersectsSphere(_sphere$2);
          }
          if (!culled) {
            const geometryInfo = geometryInfoList[geometryId];
            multiDrawStarts[multiDrawCount] = geometryInfo.start * bytesPerElement;
            multiDrawCounts[multiDrawCount] = geometryInfo.count;
            indirectArray[multiDrawCount] = i;
            multiDrawCount++;
          }
        }
      }
    }
    indirectTexture.needsUpdate = true;
    this._multiDrawCount = multiDrawCount;
    this._visibilityChanged = false;
  }
  onBeforeShadow(renderer, object, camera, shadowCamera, geometry, depthMaterial) {
    this.onBeforeRender(renderer, null, shadowCamera, geometry, depthMaterial);
  }
}
class LineBasicMaterial extends Material {
  constructor(parameters) {
    super();
    this.isLineBasicMaterial = true;
    this.type = "LineBasicMaterial";
    this.color = new Color$1(16777215);
    this.map = null;
    this.linewidth = 1;
    this.linecap = "round";
    this.linejoin = "round";
    this.fog = true;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.map = source.map;
    this.linewidth = source.linewidth;
    this.linecap = source.linecap;
    this.linejoin = source.linejoin;
    this.fog = source.fog;
    return this;
  }
}
const _vStart = /* @__PURE__ */ new Vector3$1();
const _vEnd = /* @__PURE__ */ new Vector3$1();
const _inverseMatrix$1 = /* @__PURE__ */ new Matrix4$1();
const _ray$1 = /* @__PURE__ */ new Ray();
const _sphere$1 = /* @__PURE__ */ new Sphere();
const _intersectPointOnRay = /* @__PURE__ */ new Vector3$1();
const _intersectPointOnSegment = /* @__PURE__ */ new Vector3$1();
class Line extends Object3D {
  constructor(geometry = new BufferGeometry(), material = new LineBasicMaterial()) {
    super();
    this.isLine = true;
    this.type = "Line";
    this.geometry = geometry;
    this.material = material;
    this.updateMorphTargets();
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.material = Array.isArray(source.material) ? source.material.slice() : source.material;
    this.geometry = source.geometry;
    return this;
  }
  computeLineDistances() {
    const geometry = this.geometry;
    if (geometry.index === null) {
      const positionAttribute = geometry.attributes.position;
      const lineDistances = [0];
      for (let i = 1, l = positionAttribute.count; i < l; i++) {
        _vStart.fromBufferAttribute(positionAttribute, i - 1);
        _vEnd.fromBufferAttribute(positionAttribute, i);
        lineDistances[i] = lineDistances[i - 1];
        lineDistances[i] += _vStart.distanceTo(_vEnd);
      }
      geometry.setAttribute("lineDistance", new Float32BufferAttribute(lineDistances, 1));
    } else {
      console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
    }
    return this;
  }
  raycast(raycaster, intersects2) {
    const geometry = this.geometry;
    const matrixWorld = this.matrixWorld;
    const threshold = raycaster.params.Line.threshold;
    const drawRange = geometry.drawRange;
    if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
    _sphere$1.copy(geometry.boundingSphere);
    _sphere$1.applyMatrix4(matrixWorld);
    _sphere$1.radius += threshold;
    if (raycaster.ray.intersectsSphere(_sphere$1) === false) return;
    _inverseMatrix$1.copy(matrixWorld).invert();
    _ray$1.copy(raycaster.ray).applyMatrix4(_inverseMatrix$1);
    const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
    const localThresholdSq = localThreshold * localThreshold;
    const step2 = this.isLineSegments ? 2 : 1;
    const index = geometry.index;
    const attributes = geometry.attributes;
    const positionAttribute = attributes.position;
    if (index !== null) {
      const start = Math.max(0, drawRange.start);
      const end = Math.min(index.count, drawRange.start + drawRange.count);
      for (let i = start, l = end - 1; i < l; i += step2) {
        const a = index.getX(i);
        const b = index.getX(i + 1);
        const intersect2 = checkIntersection(this, raycaster, _ray$1, localThresholdSq, a, b);
        if (intersect2) {
          intersects2.push(intersect2);
        }
      }
      if (this.isLineLoop) {
        const a = index.getX(end - 1);
        const b = index.getX(start);
        const intersect2 = checkIntersection(this, raycaster, _ray$1, localThresholdSq, a, b);
        if (intersect2) {
          intersects2.push(intersect2);
        }
      }
    } else {
      const start = Math.max(0, drawRange.start);
      const end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);
      for (let i = start, l = end - 1; i < l; i += step2) {
        const intersect2 = checkIntersection(this, raycaster, _ray$1, localThresholdSq, i, i + 1);
        if (intersect2) {
          intersects2.push(intersect2);
        }
      }
      if (this.isLineLoop) {
        const intersect2 = checkIntersection(this, raycaster, _ray$1, localThresholdSq, end - 1, start);
        if (intersect2) {
          intersects2.push(intersect2);
        }
      }
    }
  }
  updateMorphTargets() {
    const geometry = this.geometry;
    const morphAttributes = geometry.morphAttributes;
    const keys = Object.keys(morphAttributes);
    if (keys.length > 0) {
      const morphAttribute = morphAttributes[keys[0]];
      if (morphAttribute !== void 0) {
        this.morphTargetInfluences = [];
        this.morphTargetDictionary = {};
        for (let m = 0, ml = morphAttribute.length; m < ml; m++) {
          const name = morphAttribute[m].name || String(m);
          this.morphTargetInfluences.push(0);
          this.morphTargetDictionary[name] = m;
        }
      }
    }
  }
}
function checkIntersection(object, raycaster, ray, thresholdSq, a, b) {
  const positionAttribute = object.geometry.attributes.position;
  _vStart.fromBufferAttribute(positionAttribute, a);
  _vEnd.fromBufferAttribute(positionAttribute, b);
  const distSq = ray.distanceSqToSegment(_vStart, _vEnd, _intersectPointOnRay, _intersectPointOnSegment);
  if (distSq > thresholdSq) return;
  _intersectPointOnRay.applyMatrix4(object.matrixWorld);
  const distance2 = raycaster.ray.origin.distanceTo(_intersectPointOnRay);
  if (distance2 < raycaster.near || distance2 > raycaster.far) return;
  return {
    distance: distance2,
    // What do we want? intersection point on the ray or on the segment??
    // point: raycaster.ray.at( distance ),
    point: _intersectPointOnSegment.clone().applyMatrix4(object.matrixWorld),
    index: a,
    face: null,
    faceIndex: null,
    barycoord: null,
    object
  };
}
const _start = /* @__PURE__ */ new Vector3$1();
const _end = /* @__PURE__ */ new Vector3$1();
class LineSegments extends Line {
  constructor(geometry, material) {
    super(geometry, material);
    this.isLineSegments = true;
    this.type = "LineSegments";
  }
  computeLineDistances() {
    const geometry = this.geometry;
    if (geometry.index === null) {
      const positionAttribute = geometry.attributes.position;
      const lineDistances = [];
      for (let i = 0, l = positionAttribute.count; i < l; i += 2) {
        _start.fromBufferAttribute(positionAttribute, i);
        _end.fromBufferAttribute(positionAttribute, i + 1);
        lineDistances[i] = i === 0 ? 0 : lineDistances[i - 1];
        lineDistances[i + 1] = lineDistances[i] + _start.distanceTo(_end);
      }
      geometry.setAttribute("lineDistance", new Float32BufferAttribute(lineDistances, 1));
    } else {
      console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
    }
    return this;
  }
}
class LineLoop extends Line {
  constructor(geometry, material) {
    super(geometry, material);
    this.isLineLoop = true;
    this.type = "LineLoop";
  }
}
class PointsMaterial extends Material {
  constructor(parameters) {
    super();
    this.isPointsMaterial = true;
    this.type = "PointsMaterial";
    this.color = new Color$1(16777215);
    this.map = null;
    this.alphaMap = null;
    this.size = 1;
    this.sizeAttenuation = true;
    this.fog = true;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.map = source.map;
    this.alphaMap = source.alphaMap;
    this.size = source.size;
    this.sizeAttenuation = source.sizeAttenuation;
    this.fog = source.fog;
    return this;
  }
}
const _inverseMatrix = /* @__PURE__ */ new Matrix4$1();
const _ray$4 = /* @__PURE__ */ new Ray();
const _sphere = /* @__PURE__ */ new Sphere();
const _position$2 = /* @__PURE__ */ new Vector3$1();
class Points extends Object3D {
  constructor(geometry = new BufferGeometry(), material = new PointsMaterial()) {
    super();
    this.isPoints = true;
    this.type = "Points";
    this.geometry = geometry;
    this.material = material;
    this.updateMorphTargets();
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.material = Array.isArray(source.material) ? source.material.slice() : source.material;
    this.geometry = source.geometry;
    return this;
  }
  raycast(raycaster, intersects2) {
    const geometry = this.geometry;
    const matrixWorld = this.matrixWorld;
    const threshold = raycaster.params.Points.threshold;
    const drawRange = geometry.drawRange;
    if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
    _sphere.copy(geometry.boundingSphere);
    _sphere.applyMatrix4(matrixWorld);
    _sphere.radius += threshold;
    if (raycaster.ray.intersectsSphere(_sphere) === false) return;
    _inverseMatrix.copy(matrixWorld).invert();
    _ray$4.copy(raycaster.ray).applyMatrix4(_inverseMatrix);
    const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
    const localThresholdSq = localThreshold * localThreshold;
    const index = geometry.index;
    const attributes = geometry.attributes;
    const positionAttribute = attributes.position;
    if (index !== null) {
      const start = Math.max(0, drawRange.start);
      const end = Math.min(index.count, drawRange.start + drawRange.count);
      for (let i = start, il = end; i < il; i++) {
        const a = index.getX(i);
        _position$2.fromBufferAttribute(positionAttribute, a);
        testPoint(_position$2, a, localThresholdSq, matrixWorld, raycaster, intersects2, this);
      }
    } else {
      const start = Math.max(0, drawRange.start);
      const end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);
      for (let i = start, l = end; i < l; i++) {
        _position$2.fromBufferAttribute(positionAttribute, i);
        testPoint(_position$2, i, localThresholdSq, matrixWorld, raycaster, intersects2, this);
      }
    }
  }
  updateMorphTargets() {
    const geometry = this.geometry;
    const morphAttributes = geometry.morphAttributes;
    const keys = Object.keys(morphAttributes);
    if (keys.length > 0) {
      const morphAttribute = morphAttributes[keys[0]];
      if (morphAttribute !== void 0) {
        this.morphTargetInfluences = [];
        this.morphTargetDictionary = {};
        for (let m = 0, ml = morphAttribute.length; m < ml; m++) {
          const name = morphAttribute[m].name || String(m);
          this.morphTargetInfluences.push(0);
          this.morphTargetDictionary[name] = m;
        }
      }
    }
  }
}
function testPoint(point, index, localThresholdSq, matrixWorld, raycaster, intersects2, object) {
  const rayPointDistanceSq = _ray$4.distanceSqToPoint(point);
  if (rayPointDistanceSq < localThresholdSq) {
    const intersectPoint = new Vector3$1();
    _ray$4.closestPointToPoint(point, intersectPoint);
    intersectPoint.applyMatrix4(matrixWorld);
    const distance2 = raycaster.ray.origin.distanceTo(intersectPoint);
    if (distance2 < raycaster.near || distance2 > raycaster.far) return;
    intersects2.push({
      distance: distance2,
      distanceToRay: Math.sqrt(rayPointDistanceSq),
      point: intersectPoint,
      index,
      face: null,
      faceIndex: null,
      barycoord: null,
      object
    });
  }
}
let Group$1 = class Group extends Object3D {
  constructor() {
    super();
    this.isGroup = true;
    this.type = "Group";
  }
};
class VideoTexture extends Texture {
  constructor(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
    super(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
    this.isVideoTexture = true;
    this.minFilter = minFilter !== void 0 ? minFilter : LinearFilter;
    this.magFilter = magFilter !== void 0 ? magFilter : LinearFilter;
    this.generateMipmaps = false;
    const scope = this;
    function updateVideo() {
      scope.needsUpdate = true;
      video.requestVideoFrameCallback(updateVideo);
    }
    if ("requestVideoFrameCallback" in video) {
      video.requestVideoFrameCallback(updateVideo);
    }
  }
  clone() {
    return new this.constructor(this.image).copy(this);
  }
  update() {
    const video = this.image;
    const hasVideoFrameCallback = "requestVideoFrameCallback" in video;
    if (hasVideoFrameCallback === false && video.readyState >= video.HAVE_CURRENT_DATA) {
      this.needsUpdate = true;
    }
  }
}
class FramebufferTexture extends Texture {
  constructor(width, height) {
    super({ width, height });
    this.isFramebufferTexture = true;
    this.magFilter = NearestFilter;
    this.minFilter = NearestFilter;
    this.generateMipmaps = false;
    this.needsUpdate = true;
  }
}
class CompressedTexture extends Texture {
  constructor(mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, colorSpace) {
    super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace);
    this.isCompressedTexture = true;
    this.image = { width, height };
    this.mipmaps = mipmaps;
    this.flipY = false;
    this.generateMipmaps = false;
  }
}
class CompressedArrayTexture extends CompressedTexture {
  constructor(mipmaps, width, height, depth, format, type) {
    super(mipmaps, width, height, format, type);
    this.isCompressedArrayTexture = true;
    this.image.depth = depth;
    this.wrapR = ClampToEdgeWrapping;
    this.layerUpdates = /* @__PURE__ */ new Set();
  }
  addLayerUpdate(layerIndex) {
    this.layerUpdates.add(layerIndex);
  }
  clearLayerUpdates() {
    this.layerUpdates.clear();
  }
}
class CompressedCubeTexture extends CompressedTexture {
  constructor(images, format, type) {
    super(void 0, images[0].width, images[0].height, format, type, CubeReflectionMapping);
    this.isCompressedCubeTexture = true;
    this.isCubeTexture = true;
    this.image = images;
  }
}
class CanvasTexture extends Texture {
  constructor(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
    super(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
    this.isCanvasTexture = true;
    this.needsUpdate = true;
  }
}
class DepthTexture extends Texture {
  constructor(width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format = DepthFormat) {
    if (format !== DepthFormat && format !== DepthStencilFormat) {
      throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
    }
    if (type === void 0 && format === DepthFormat) type = UnsignedIntType;
    if (type === void 0 && format === DepthStencilFormat) type = UnsignedInt248Type;
    super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
    this.isDepthTexture = true;
    this.image = { width, height };
    this.magFilter = magFilter !== void 0 ? magFilter : NearestFilter;
    this.minFilter = minFilter !== void 0 ? minFilter : NearestFilter;
    this.flipY = false;
    this.generateMipmaps = false;
    this.compareFunction = null;
  }
  copy(source) {
    super.copy(source);
    this.compareFunction = source.compareFunction;
    return this;
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    if (this.compareFunction !== null) data.compareFunction = this.compareFunction;
    return data;
  }
}
class Curve {
  constructor() {
    this.type = "Curve";
    this.arcLengthDivisions = 200;
  }
  // Virtual base class method to overwrite and implement in subclasses
  //	- t [0 .. 1]
  getPoint() {
    console.warn("THREE.Curve: .getPoint() not implemented.");
    return null;
  }
  // Get point at relative position in curve according to arc length
  // - u [0 .. 1]
  getPointAt(u, optionalTarget) {
    const t = this.getUtoTmapping(u);
    return this.getPoint(t, optionalTarget);
  }
  // Get sequence of points using getPoint( t )
  getPoints(divisions = 5) {
    const points = [];
    for (let d = 0; d <= divisions; d++) {
      points.push(this.getPoint(d / divisions));
    }
    return points;
  }
  // Get sequence of points using getPointAt( u )
  getSpacedPoints(divisions = 5) {
    const points = [];
    for (let d = 0; d <= divisions; d++) {
      points.push(this.getPointAt(d / divisions));
    }
    return points;
  }
  // Get total curve arc length
  getLength() {
    const lengths = this.getLengths();
    return lengths[lengths.length - 1];
  }
  // Get list of cumulative segment lengths
  getLengths(divisions = this.arcLengthDivisions) {
    if (this.cacheArcLengths && this.cacheArcLengths.length === divisions + 1 && !this.needsUpdate) {
      return this.cacheArcLengths;
    }
    this.needsUpdate = false;
    const cache2 = [];
    let current, last = this.getPoint(0);
    let sum = 0;
    cache2.push(0);
    for (let p = 1; p <= divisions; p++) {
      current = this.getPoint(p / divisions);
      sum += current.distanceTo(last);
      cache2.push(sum);
      last = current;
    }
    this.cacheArcLengths = cache2;
    return cache2;
  }
  updateArcLengths() {
    this.needsUpdate = true;
    this.getLengths();
  }
  // Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant
  getUtoTmapping(u, distance2) {
    const arcLengths = this.getLengths();
    let i = 0;
    const il = arcLengths.length;
    let targetArcLength;
    if (distance2) {
      targetArcLength = distance2;
    } else {
      targetArcLength = u * arcLengths[il - 1];
    }
    let low = 0, high = il - 1, comparison;
    while (low <= high) {
      i = Math.floor(low + (high - low) / 2);
      comparison = arcLengths[i] - targetArcLength;
      if (comparison < 0) {
        low = i + 1;
      } else if (comparison > 0) {
        high = i - 1;
      } else {
        high = i;
        break;
      }
    }
    i = high;
    if (arcLengths[i] === targetArcLength) {
      return i / (il - 1);
    }
    const lengthBefore = arcLengths[i];
    const lengthAfter = arcLengths[i + 1];
    const segmentLength = lengthAfter - lengthBefore;
    const segmentFraction = (targetArcLength - lengthBefore) / segmentLength;
    const t = (i + segmentFraction) / (il - 1);
    return t;
  }
  // Returns a unit vector tangent at t
  // In case any sub curve does not implement its tangent derivation,
  // 2 points a small delta apart will be used to find its gradient
  // which seems to give a reasonable approximation
  getTangent(t, optionalTarget) {
    const delta = 1e-4;
    let t1 = t - delta;
    let t2 = t + delta;
    if (t1 < 0) t1 = 0;
    if (t2 > 1) t2 = 1;
    const pt1 = this.getPoint(t1);
    const pt2 = this.getPoint(t2);
    const tangent = optionalTarget || (pt1.isVector2 ? new Vector2$1() : new Vector3$1());
    tangent.copy(pt2).sub(pt1).normalize();
    return tangent;
  }
  getTangentAt(u, optionalTarget) {
    const t = this.getUtoTmapping(u);
    return this.getTangent(t, optionalTarget);
  }
  computeFrenetFrames(segments, closed) {
    const normal = new Vector3$1();
    const tangents = [];
    const normals = [];
    const binormals = [];
    const vec = new Vector3$1();
    const mat = new Matrix4$1();
    for (let i = 0; i <= segments; i++) {
      const u = i / segments;
      tangents[i] = this.getTangentAt(u, new Vector3$1());
    }
    normals[0] = new Vector3$1();
    binormals[0] = new Vector3$1();
    let min2 = Number.MAX_VALUE;
    const tx = Math.abs(tangents[0].x);
    const ty = Math.abs(tangents[0].y);
    const tz = Math.abs(tangents[0].z);
    if (tx <= min2) {
      min2 = tx;
      normal.set(1, 0, 0);
    }
    if (ty <= min2) {
      min2 = ty;
      normal.set(0, 1, 0);
    }
    if (tz <= min2) {
      normal.set(0, 0, 1);
    }
    vec.crossVectors(tangents[0], normal).normalize();
    normals[0].crossVectors(tangents[0], vec);
    binormals[0].crossVectors(tangents[0], normals[0]);
    for (let i = 1; i <= segments; i++) {
      normals[i] = normals[i - 1].clone();
      binormals[i] = binormals[i - 1].clone();
      vec.crossVectors(tangents[i - 1], tangents[i]);
      if (vec.length() > Number.EPSILON) {
        vec.normalize();
        const theta = Math.acos(clamp$2(tangents[i - 1].dot(tangents[i]), -1, 1));
        normals[i].applyMatrix4(mat.makeRotationAxis(vec, theta));
      }
      binormals[i].crossVectors(tangents[i], normals[i]);
    }
    if (closed === true) {
      let theta = Math.acos(clamp$2(normals[0].dot(normals[segments]), -1, 1));
      theta /= segments;
      if (tangents[0].dot(vec.crossVectors(normals[0], normals[segments])) > 0) {
        theta = -theta;
      }
      for (let i = 1; i <= segments; i++) {
        normals[i].applyMatrix4(mat.makeRotationAxis(tangents[i], theta * i));
        binormals[i].crossVectors(tangents[i], normals[i]);
      }
    }
    return {
      tangents,
      normals,
      binormals
    };
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(source) {
    this.arcLengthDivisions = source.arcLengthDivisions;
    return this;
  }
  toJSON() {
    const data = {
      metadata: {
        version: 4.6,
        type: "Curve",
        generator: "Curve.toJSON"
      }
    };
    data.arcLengthDivisions = this.arcLengthDivisions;
    data.type = this.type;
    return data;
  }
  fromJSON(json) {
    this.arcLengthDivisions = json.arcLengthDivisions;
    return this;
  }
}
class EllipseCurve extends Curve {
  constructor(aX = 0, aY = 0, xRadius = 1, yRadius = 1, aStartAngle = 0, aEndAngle = Math.PI * 2, aClockwise = false, aRotation = 0) {
    super();
    this.isEllipseCurve = true;
    this.type = "EllipseCurve";
    this.aX = aX;
    this.aY = aY;
    this.xRadius = xRadius;
    this.yRadius = yRadius;
    this.aStartAngle = aStartAngle;
    this.aEndAngle = aEndAngle;
    this.aClockwise = aClockwise;
    this.aRotation = aRotation;
  }
  getPoint(t, optionalTarget = new Vector2$1()) {
    const point = optionalTarget;
    const twoPi = Math.PI * 2;
    let deltaAngle = this.aEndAngle - this.aStartAngle;
    const samePoints = Math.abs(deltaAngle) < Number.EPSILON;
    while (deltaAngle < 0) deltaAngle += twoPi;
    while (deltaAngle > twoPi) deltaAngle -= twoPi;
    if (deltaAngle < Number.EPSILON) {
      if (samePoints) {
        deltaAngle = 0;
      } else {
        deltaAngle = twoPi;
      }
    }
    if (this.aClockwise === true && !samePoints) {
      if (deltaAngle === twoPi) {
        deltaAngle = -twoPi;
      } else {
        deltaAngle = deltaAngle - twoPi;
      }
    }
    const angle = this.aStartAngle + t * deltaAngle;
    let x = this.aX + this.xRadius * Math.cos(angle);
    let y = this.aY + this.yRadius * Math.sin(angle);
    if (this.aRotation !== 0) {
      const cos2 = Math.cos(this.aRotation);
      const sin2 = Math.sin(this.aRotation);
      const tx = x - this.aX;
      const ty = y - this.aY;
      x = tx * cos2 - ty * sin2 + this.aX;
      y = tx * sin2 + ty * cos2 + this.aY;
    }
    return point.set(x, y);
  }
  copy(source) {
    super.copy(source);
    this.aX = source.aX;
    this.aY = source.aY;
    this.xRadius = source.xRadius;
    this.yRadius = source.yRadius;
    this.aStartAngle = source.aStartAngle;
    this.aEndAngle = source.aEndAngle;
    this.aClockwise = source.aClockwise;
    this.aRotation = source.aRotation;
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.aX = this.aX;
    data.aY = this.aY;
    data.xRadius = this.xRadius;
    data.yRadius = this.yRadius;
    data.aStartAngle = this.aStartAngle;
    data.aEndAngle = this.aEndAngle;
    data.aClockwise = this.aClockwise;
    data.aRotation = this.aRotation;
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.aX = json.aX;
    this.aY = json.aY;
    this.xRadius = json.xRadius;
    this.yRadius = json.yRadius;
    this.aStartAngle = json.aStartAngle;
    this.aEndAngle = json.aEndAngle;
    this.aClockwise = json.aClockwise;
    this.aRotation = json.aRotation;
    return this;
  }
}
class ArcCurve extends EllipseCurve {
  constructor(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
    super(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
    this.isArcCurve = true;
    this.type = "ArcCurve";
  }
}
function CubicPoly() {
  let c0 = 0, c1 = 0, c2 = 0, c3 = 0;
  function init(x0, x1, t0, t1) {
    c0 = x0;
    c1 = t0;
    c2 = -3 * x0 + 3 * x1 - 2 * t0 - t1;
    c3 = 2 * x0 - 2 * x1 + t0 + t1;
  }
  return {
    initCatmullRom: function(x0, x1, x2, x3, tension) {
      init(x1, x2, tension * (x2 - x0), tension * (x3 - x1));
    },
    initNonuniformCatmullRom: function(x0, x1, x2, x3, dt0, dt1, dt2) {
      let t1 = (x1 - x0) / dt0 - (x2 - x0) / (dt0 + dt1) + (x2 - x1) / dt1;
      let t2 = (x2 - x1) / dt1 - (x3 - x1) / (dt1 + dt2) + (x3 - x2) / dt2;
      t1 *= dt1;
      t2 *= dt1;
      init(x1, x2, t1, t2);
    },
    calc: function(t) {
      const t2 = t * t;
      const t3 = t2 * t;
      return c0 + c1 * t + c2 * t2 + c3 * t3;
    }
  };
}
const tmp = /* @__PURE__ */ new Vector3$1();
const px = /* @__PURE__ */ new CubicPoly();
const py = /* @__PURE__ */ new CubicPoly();
const pz = /* @__PURE__ */ new CubicPoly();
class CatmullRomCurve3 extends Curve {
  constructor(points = [], closed = false, curveType = "centripetal", tension = 0.5) {
    super();
    this.isCatmullRomCurve3 = true;
    this.type = "CatmullRomCurve3";
    this.points = points;
    this.closed = closed;
    this.curveType = curveType;
    this.tension = tension;
  }
  getPoint(t, optionalTarget = new Vector3$1()) {
    const point = optionalTarget;
    const points = this.points;
    const l = points.length;
    const p = (l - (this.closed ? 0 : 1)) * t;
    let intPoint = Math.floor(p);
    let weight = p - intPoint;
    if (this.closed) {
      intPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / l) + 1) * l;
    } else if (weight === 0 && intPoint === l - 1) {
      intPoint = l - 2;
      weight = 1;
    }
    let p0, p3;
    if (this.closed || intPoint > 0) {
      p0 = points[(intPoint - 1) % l];
    } else {
      tmp.subVectors(points[0], points[1]).add(points[0]);
      p0 = tmp;
    }
    const p1 = points[intPoint % l];
    const p2 = points[(intPoint + 1) % l];
    if (this.closed || intPoint + 2 < l) {
      p3 = points[(intPoint + 2) % l];
    } else {
      tmp.subVectors(points[l - 1], points[l - 2]).add(points[l - 1]);
      p3 = tmp;
    }
    if (this.curveType === "centripetal" || this.curveType === "chordal") {
      const pow5 = this.curveType === "chordal" ? 0.5 : 0.25;
      let dt0 = Math.pow(p0.distanceToSquared(p1), pow5);
      let dt1 = Math.pow(p1.distanceToSquared(p2), pow5);
      let dt2 = Math.pow(p2.distanceToSquared(p3), pow5);
      if (dt1 < 1e-4) dt1 = 1;
      if (dt0 < 1e-4) dt0 = dt1;
      if (dt2 < 1e-4) dt2 = dt1;
      px.initNonuniformCatmullRom(p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2);
      py.initNonuniformCatmullRom(p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2);
      pz.initNonuniformCatmullRom(p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2);
    } else if (this.curveType === "catmullrom") {
      px.initCatmullRom(p0.x, p1.x, p2.x, p3.x, this.tension);
      py.initCatmullRom(p0.y, p1.y, p2.y, p3.y, this.tension);
      pz.initCatmullRom(p0.z, p1.z, p2.z, p3.z, this.tension);
    }
    point.set(
      px.calc(weight),
      py.calc(weight),
      pz.calc(weight)
    );
    return point;
  }
  copy(source) {
    super.copy(source);
    this.points = [];
    for (let i = 0, l = source.points.length; i < l; i++) {
      const point = source.points[i];
      this.points.push(point.clone());
    }
    this.closed = source.closed;
    this.curveType = source.curveType;
    this.tension = source.tension;
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.points = [];
    for (let i = 0, l = this.points.length; i < l; i++) {
      const point = this.points[i];
      data.points.push(point.toArray());
    }
    data.closed = this.closed;
    data.curveType = this.curveType;
    data.tension = this.tension;
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.points = [];
    for (let i = 0, l = json.points.length; i < l; i++) {
      const point = json.points[i];
      this.points.push(new Vector3$1().fromArray(point));
    }
    this.closed = json.closed;
    this.curveType = json.curveType;
    this.tension = json.tension;
    return this;
  }
}
function CatmullRom(t, p0, p1, p2, p3) {
  const v0 = (p2 - p0) * 0.5;
  const v1 = (p3 - p1) * 0.5;
  const t2 = t * t;
  const t3 = t * t2;
  return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
}
function QuadraticBezierP0(t, p) {
  const k = 1 - t;
  return k * k * p;
}
function QuadraticBezierP1(t, p) {
  return 2 * (1 - t) * t * p;
}
function QuadraticBezierP2(t, p) {
  return t * t * p;
}
function QuadraticBezier(t, p0, p1, p2) {
  return QuadraticBezierP0(t, p0) + QuadraticBezierP1(t, p1) + QuadraticBezierP2(t, p2);
}
function CubicBezierP0(t, p) {
  const k = 1 - t;
  return k * k * k * p;
}
function CubicBezierP1(t, p) {
  const k = 1 - t;
  return 3 * k * k * t * p;
}
function CubicBezierP2(t, p) {
  return 3 * (1 - t) * t * t * p;
}
function CubicBezierP3(t, p) {
  return t * t * t * p;
}
function CubicBezier(t, p0, p1, p2, p3) {
  return CubicBezierP0(t, p0) + CubicBezierP1(t, p1) + CubicBezierP2(t, p2) + CubicBezierP3(t, p3);
}
class CubicBezierCurve extends Curve {
  constructor(v0 = new Vector2$1(), v1 = new Vector2$1(), v2 = new Vector2$1(), v3 = new Vector2$1()) {
    super();
    this.isCubicBezierCurve = true;
    this.type = "CubicBezierCurve";
    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;
    this.v3 = v3;
  }
  getPoint(t, optionalTarget = new Vector2$1()) {
    const point = optionalTarget;
    const v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;
    point.set(
      CubicBezier(t, v0.x, v1.x, v2.x, v3.x),
      CubicBezier(t, v0.y, v1.y, v2.y, v3.y)
    );
    return point;
  }
  copy(source) {
    super.copy(source);
    this.v0.copy(source.v0);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    this.v3.copy(source.v3);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.v0 = this.v0.toArray();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    data.v3 = this.v3.toArray();
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.v0.fromArray(json.v0);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    this.v3.fromArray(json.v3);
    return this;
  }
}
class CubicBezierCurve3 extends Curve {
  constructor(v0 = new Vector3$1(), v1 = new Vector3$1(), v2 = new Vector3$1(), v3 = new Vector3$1()) {
    super();
    this.isCubicBezierCurve3 = true;
    this.type = "CubicBezierCurve3";
    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;
    this.v3 = v3;
  }
  getPoint(t, optionalTarget = new Vector3$1()) {
    const point = optionalTarget;
    const v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;
    point.set(
      CubicBezier(t, v0.x, v1.x, v2.x, v3.x),
      CubicBezier(t, v0.y, v1.y, v2.y, v3.y),
      CubicBezier(t, v0.z, v1.z, v2.z, v3.z)
    );
    return point;
  }
  copy(source) {
    super.copy(source);
    this.v0.copy(source.v0);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    this.v3.copy(source.v3);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.v0 = this.v0.toArray();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    data.v3 = this.v3.toArray();
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.v0.fromArray(json.v0);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    this.v3.fromArray(json.v3);
    return this;
  }
}
class LineCurve extends Curve {
  constructor(v1 = new Vector2$1(), v2 = new Vector2$1()) {
    super();
    this.isLineCurve = true;
    this.type = "LineCurve";
    this.v1 = v1;
    this.v2 = v2;
  }
  getPoint(t, optionalTarget = new Vector2$1()) {
    const point = optionalTarget;
    if (t === 1) {
      point.copy(this.v2);
    } else {
      point.copy(this.v2).sub(this.v1);
      point.multiplyScalar(t).add(this.v1);
    }
    return point;
  }
  // Line curve is linear, so we can overwrite default getPointAt
  getPointAt(u, optionalTarget) {
    return this.getPoint(u, optionalTarget);
  }
  getTangent(t, optionalTarget = new Vector2$1()) {
    return optionalTarget.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(u, optionalTarget) {
    return this.getTangent(u, optionalTarget);
  }
  copy(source) {
    super.copy(source);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    return this;
  }
}
class LineCurve3 extends Curve {
  constructor(v1 = new Vector3$1(), v2 = new Vector3$1()) {
    super();
    this.isLineCurve3 = true;
    this.type = "LineCurve3";
    this.v1 = v1;
    this.v2 = v2;
  }
  getPoint(t, optionalTarget = new Vector3$1()) {
    const point = optionalTarget;
    if (t === 1) {
      point.copy(this.v2);
    } else {
      point.copy(this.v2).sub(this.v1);
      point.multiplyScalar(t).add(this.v1);
    }
    return point;
  }
  // Line curve is linear, so we can overwrite default getPointAt
  getPointAt(u, optionalTarget) {
    return this.getPoint(u, optionalTarget);
  }
  getTangent(t, optionalTarget = new Vector3$1()) {
    return optionalTarget.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(u, optionalTarget) {
    return this.getTangent(u, optionalTarget);
  }
  copy(source) {
    super.copy(source);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    return this;
  }
}
class QuadraticBezierCurve extends Curve {
  constructor(v0 = new Vector2$1(), v1 = new Vector2$1(), v2 = new Vector2$1()) {
    super();
    this.isQuadraticBezierCurve = true;
    this.type = "QuadraticBezierCurve";
    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;
  }
  getPoint(t, optionalTarget = new Vector2$1()) {
    const point = optionalTarget;
    const v0 = this.v0, v1 = this.v1, v2 = this.v2;
    point.set(
      QuadraticBezier(t, v0.x, v1.x, v2.x),
      QuadraticBezier(t, v0.y, v1.y, v2.y)
    );
    return point;
  }
  copy(source) {
    super.copy(source);
    this.v0.copy(source.v0);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.v0 = this.v0.toArray();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.v0.fromArray(json.v0);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    return this;
  }
}
class QuadraticBezierCurve3 extends Curve {
  constructor(v0 = new Vector3$1(), v1 = new Vector3$1(), v2 = new Vector3$1()) {
    super();
    this.isQuadraticBezierCurve3 = true;
    this.type = "QuadraticBezierCurve3";
    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;
  }
  getPoint(t, optionalTarget = new Vector3$1()) {
    const point = optionalTarget;
    const v0 = this.v0, v1 = this.v1, v2 = this.v2;
    point.set(
      QuadraticBezier(t, v0.x, v1.x, v2.x),
      QuadraticBezier(t, v0.y, v1.y, v2.y),
      QuadraticBezier(t, v0.z, v1.z, v2.z)
    );
    return point;
  }
  copy(source) {
    super.copy(source);
    this.v0.copy(source.v0);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.v0 = this.v0.toArray();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.v0.fromArray(json.v0);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    return this;
  }
}
class SplineCurve extends Curve {
  constructor(points = []) {
    super();
    this.isSplineCurve = true;
    this.type = "SplineCurve";
    this.points = points;
  }
  getPoint(t, optionalTarget = new Vector2$1()) {
    const point = optionalTarget;
    const points = this.points;
    const p = (points.length - 1) * t;
    const intPoint = Math.floor(p);
    const weight = p - intPoint;
    const p0 = points[intPoint === 0 ? intPoint : intPoint - 1];
    const p1 = points[intPoint];
    const p2 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];
    const p3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];
    point.set(
      CatmullRom(weight, p0.x, p1.x, p2.x, p3.x),
      CatmullRom(weight, p0.y, p1.y, p2.y, p3.y)
    );
    return point;
  }
  copy(source) {
    super.copy(source);
    this.points = [];
    for (let i = 0, l = source.points.length; i < l; i++) {
      const point = source.points[i];
      this.points.push(point.clone());
    }
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.points = [];
    for (let i = 0, l = this.points.length; i < l; i++) {
      const point = this.points[i];
      data.points.push(point.toArray());
    }
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.points = [];
    for (let i = 0, l = json.points.length; i < l; i++) {
      const point = json.points[i];
      this.points.push(new Vector2$1().fromArray(point));
    }
    return this;
  }
}
var Curves = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ArcCurve,
  CatmullRomCurve3,
  CubicBezierCurve,
  CubicBezierCurve3,
  EllipseCurve,
  LineCurve,
  LineCurve3,
  QuadraticBezierCurve,
  QuadraticBezierCurve3,
  SplineCurve
});
class CurvePath extends Curve {
  constructor() {
    super();
    this.type = "CurvePath";
    this.curves = [];
    this.autoClose = false;
  }
  add(curve) {
    this.curves.push(curve);
  }
  closePath() {
    const startPoint = this.curves[0].getPoint(0);
    const endPoint = this.curves[this.curves.length - 1].getPoint(1);
    if (!startPoint.equals(endPoint)) {
      const lineType = startPoint.isVector2 === true ? "LineCurve" : "LineCurve3";
      this.curves.push(new Curves[lineType](endPoint, startPoint));
    }
    return this;
  }
  // To get accurate point with reference to
  // entire path distance at time t,
  // following has to be done:
  // 1. Length of each sub path have to be known
  // 2. Locate and identify type of curve
  // 3. Get t for the curve
  // 4. Return curve.getPointAt(t')
  getPoint(t, optionalTarget) {
    const d = t * this.getLength();
    const curveLengths = this.getCurveLengths();
    let i = 0;
    while (i < curveLengths.length) {
      if (curveLengths[i] >= d) {
        const diff = curveLengths[i] - d;
        const curve = this.curves[i];
        const segmentLength = curve.getLength();
        const u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;
        return curve.getPointAt(u, optionalTarget);
      }
      i++;
    }
    return null;
  }
  // We cannot use the default THREE.Curve getPoint() with getLength() because in
  // THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
  // getPoint() depends on getLength
  getLength() {
    const lens = this.getCurveLengths();
    return lens[lens.length - 1];
  }
  // cacheLengths must be recalculated.
  updateArcLengths() {
    this.needsUpdate = true;
    this.cacheLengths = null;
    this.getCurveLengths();
  }
  // Compute lengths and cache them
  // We cannot overwrite getLengths() because UtoT mapping uses it.
  getCurveLengths() {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length) {
      return this.cacheLengths;
    }
    const lengths = [];
    let sums = 0;
    for (let i = 0, l = this.curves.length; i < l; i++) {
      sums += this.curves[i].getLength();
      lengths.push(sums);
    }
    this.cacheLengths = lengths;
    return lengths;
  }
  getSpacedPoints(divisions = 40) {
    const points = [];
    for (let i = 0; i <= divisions; i++) {
      points.push(this.getPoint(i / divisions));
    }
    if (this.autoClose) {
      points.push(points[0]);
    }
    return points;
  }
  getPoints(divisions = 12) {
    const points = [];
    let last;
    for (let i = 0, curves = this.curves; i < curves.length; i++) {
      const curve = curves[i];
      const resolution2 = curve.isEllipseCurve ? divisions * 2 : curve.isLineCurve || curve.isLineCurve3 ? 1 : curve.isSplineCurve ? divisions * curve.points.length : divisions;
      const pts = curve.getPoints(resolution2);
      for (let j = 0; j < pts.length; j++) {
        const point = pts[j];
        if (last && last.equals(point)) continue;
        points.push(point);
        last = point;
      }
    }
    if (this.autoClose && points.length > 1 && !points[points.length - 1].equals(points[0])) {
      points.push(points[0]);
    }
    return points;
  }
  copy(source) {
    super.copy(source);
    this.curves = [];
    for (let i = 0, l = source.curves.length; i < l; i++) {
      const curve = source.curves[i];
      this.curves.push(curve.clone());
    }
    this.autoClose = source.autoClose;
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.autoClose = this.autoClose;
    data.curves = [];
    for (let i = 0, l = this.curves.length; i < l; i++) {
      const curve = this.curves[i];
      data.curves.push(curve.toJSON());
    }
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.autoClose = json.autoClose;
    this.curves = [];
    for (let i = 0, l = json.curves.length; i < l; i++) {
      const curve = json.curves[i];
      this.curves.push(new Curves[curve.type]().fromJSON(curve));
    }
    return this;
  }
}
class Path extends CurvePath {
  constructor(points) {
    super();
    this.type = "Path";
    this.currentPoint = new Vector2$1();
    if (points) {
      this.setFromPoints(points);
    }
  }
  setFromPoints(points) {
    this.moveTo(points[0].x, points[0].y);
    for (let i = 1, l = points.length; i < l; i++) {
      this.lineTo(points[i].x, points[i].y);
    }
    return this;
  }
  moveTo(x, y) {
    this.currentPoint.set(x, y);
    return this;
  }
  lineTo(x, y) {
    const curve = new LineCurve(this.currentPoint.clone(), new Vector2$1(x, y));
    this.curves.push(curve);
    this.currentPoint.set(x, y);
    return this;
  }
  quadraticCurveTo(aCPx, aCPy, aX, aY) {
    const curve = new QuadraticBezierCurve(
      this.currentPoint.clone(),
      new Vector2$1(aCPx, aCPy),
      new Vector2$1(aX, aY)
    );
    this.curves.push(curve);
    this.currentPoint.set(aX, aY);
    return this;
  }
  bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
    const curve = new CubicBezierCurve(
      this.currentPoint.clone(),
      new Vector2$1(aCP1x, aCP1y),
      new Vector2$1(aCP2x, aCP2y),
      new Vector2$1(aX, aY)
    );
    this.curves.push(curve);
    this.currentPoint.set(aX, aY);
    return this;
  }
  splineThru(pts) {
    const npts = [this.currentPoint.clone()].concat(pts);
    const curve = new SplineCurve(npts);
    this.curves.push(curve);
    this.currentPoint.copy(pts[pts.length - 1]);
    return this;
  }
  arc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
    const x0 = this.currentPoint.x;
    const y0 = this.currentPoint.y;
    this.absarc(
      aX + x0,
      aY + y0,
      aRadius,
      aStartAngle,
      aEndAngle,
      aClockwise
    );
    return this;
  }
  absarc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
    this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
    return this;
  }
  ellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
    const x0 = this.currentPoint.x;
    const y0 = this.currentPoint.y;
    this.absellipse(aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
    return this;
  }
  absellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
    const curve = new EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
    if (this.curves.length > 0) {
      const firstPoint = curve.getPoint(0);
      if (!firstPoint.equals(this.currentPoint)) {
        this.lineTo(firstPoint.x, firstPoint.y);
      }
    }
    this.curves.push(curve);
    const lastPoint = curve.getPoint(1);
    this.currentPoint.copy(lastPoint);
    return this;
  }
  copy(source) {
    super.copy(source);
    this.currentPoint.copy(source.currentPoint);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.currentPoint = this.currentPoint.toArray();
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.currentPoint.fromArray(json.currentPoint);
    return this;
  }
}
class LatheGeometry extends BufferGeometry {
  constructor(points = [new Vector2$1(0, -0.5), new Vector2$1(0.5, 0), new Vector2$1(0, 0.5)], segments = 12, phiStart = 0, phiLength = Math.PI * 2) {
    super();
    this.type = "LatheGeometry";
    this.parameters = {
      points,
      segments,
      phiStart,
      phiLength
    };
    segments = Math.floor(segments);
    phiLength = clamp$2(phiLength, 0, Math.PI * 2);
    const indices = [];
    const vertices = [];
    const uvs = [];
    const initNormals = [];
    const normals = [];
    const inverseSegments = 1 / segments;
    const vertex2 = new Vector3$1();
    const uv = new Vector2$1();
    const normal = new Vector3$1();
    const curNormal = new Vector3$1();
    const prevNormal = new Vector3$1();
    let dx = 0;
    let dy = 0;
    for (let j = 0; j <= points.length - 1; j++) {
      switch (j) {
        case 0:
          dx = points[j + 1].x - points[j].x;
          dy = points[j + 1].y - points[j].y;
          normal.x = dy * 1;
          normal.y = -dx;
          normal.z = dy * 0;
          prevNormal.copy(normal);
          normal.normalize();
          initNormals.push(normal.x, normal.y, normal.z);
          break;
        case points.length - 1:
          initNormals.push(prevNormal.x, prevNormal.y, prevNormal.z);
          break;
        default:
          dx = points[j + 1].x - points[j].x;
          dy = points[j + 1].y - points[j].y;
          normal.x = dy * 1;
          normal.y = -dx;
          normal.z = dy * 0;
          curNormal.copy(normal);
          normal.x += prevNormal.x;
          normal.y += prevNormal.y;
          normal.z += prevNormal.z;
          normal.normalize();
          initNormals.push(normal.x, normal.y, normal.z);
          prevNormal.copy(curNormal);
      }
    }
    for (let i = 0; i <= segments; i++) {
      const phi = phiStart + i * inverseSegments * phiLength;
      const sin2 = Math.sin(phi);
      const cos2 = Math.cos(phi);
      for (let j = 0; j <= points.length - 1; j++) {
        vertex2.x = points[j].x * sin2;
        vertex2.y = points[j].y;
        vertex2.z = points[j].x * cos2;
        vertices.push(vertex2.x, vertex2.y, vertex2.z);
        uv.x = i / segments;
        uv.y = j / (points.length - 1);
        uvs.push(uv.x, uv.y);
        const x = initNormals[3 * j + 0] * sin2;
        const y = initNormals[3 * j + 1];
        const z = initNormals[3 * j + 0] * cos2;
        normals.push(x, y, z);
      }
    }
    for (let i = 0; i < segments; i++) {
      for (let j = 0; j < points.length - 1; j++) {
        const base = j + i * points.length;
        const a = base;
        const b = base + points.length;
        const c = base + points.length + 1;
        const d = base + 1;
        indices.push(a, b, d);
        indices.push(c, d, b);
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
  }
  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }
  static fromJSON(data) {
    return new LatheGeometry(data.points, data.segments, data.phiStart, data.phiLength);
  }
}
class CapsuleGeometry extends LatheGeometry {
  constructor(radius = 1, length2 = 1, capSegments = 4, radialSegments = 8) {
    const path = new Path();
    path.absarc(0, -length2 / 2, radius, Math.PI * 1.5, 0);
    path.absarc(0, length2 / 2, radius, 0, Math.PI * 0.5);
    super(path.getPoints(capSegments), radialSegments);
    this.type = "CapsuleGeometry";
    this.parameters = {
      radius,
      length: length2,
      capSegments,
      radialSegments
    };
  }
  static fromJSON(data) {
    return new CapsuleGeometry(data.radius, data.length, data.capSegments, data.radialSegments);
  }
}
class CircleGeometry extends BufferGeometry {
  constructor(radius = 1, segments = 32, thetaStart = 0, thetaLength = Math.PI * 2) {
    super();
    this.type = "CircleGeometry";
    this.parameters = {
      radius,
      segments,
      thetaStart,
      thetaLength
    };
    segments = Math.max(3, segments);
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    const vertex2 = new Vector3$1();
    const uv = new Vector2$1();
    vertices.push(0, 0, 0);
    normals.push(0, 0, 1);
    uvs.push(0.5, 0.5);
    for (let s = 0, i = 3; s <= segments; s++, i += 3) {
      const segment = thetaStart + s / segments * thetaLength;
      vertex2.x = radius * Math.cos(segment);
      vertex2.y = radius * Math.sin(segment);
      vertices.push(vertex2.x, vertex2.y, vertex2.z);
      normals.push(0, 0, 1);
      uv.x = (vertices[i] / radius + 1) / 2;
      uv.y = (vertices[i + 1] / radius + 1) / 2;
      uvs.push(uv.x, uv.y);
    }
    for (let i = 1; i <= segments; i++) {
      indices.push(i, i + 1, 0);
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
  }
  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }
  static fromJSON(data) {
    return new CircleGeometry(data.radius, data.segments, data.thetaStart, data.thetaLength);
  }
}
class CylinderGeometry extends BufferGeometry {
  constructor(radiusTop = 1, radiusBottom = 1, height = 1, radialSegments = 32, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2) {
    super();
    this.type = "CylinderGeometry";
    this.parameters = {
      radiusTop,
      radiusBottom,
      height,
      radialSegments,
      heightSegments,
      openEnded,
      thetaStart,
      thetaLength
    };
    const scope = this;
    radialSegments = Math.floor(radialSegments);
    heightSegments = Math.floor(heightSegments);
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    let index = 0;
    const indexArray = [];
    const halfHeight = height / 2;
    let groupStart = 0;
    generateTorso();
    if (openEnded === false) {
      if (radiusTop > 0) generateCap(true);
      if (radiusBottom > 0) generateCap(false);
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    function generateTorso() {
      const normal = new Vector3$1();
      const vertex2 = new Vector3$1();
      let groupCount = 0;
      const slope = (radiusBottom - radiusTop) / height;
      for (let y = 0; y <= heightSegments; y++) {
        const indexRow = [];
        const v = y / heightSegments;
        const radius = v * (radiusBottom - radiusTop) + radiusTop;
        for (let x = 0; x <= radialSegments; x++) {
          const u = x / radialSegments;
          const theta = u * thetaLength + thetaStart;
          const sinTheta = Math.sin(theta);
          const cosTheta = Math.cos(theta);
          vertex2.x = radius * sinTheta;
          vertex2.y = -v * height + halfHeight;
          vertex2.z = radius * cosTheta;
          vertices.push(vertex2.x, vertex2.y, vertex2.z);
          normal.set(sinTheta, slope, cosTheta).normalize();
          normals.push(normal.x, normal.y, normal.z);
          uvs.push(u, 1 - v);
          indexRow.push(index++);
        }
        indexArray.push(indexRow);
      }
      for (let x = 0; x < radialSegments; x++) {
        for (let y = 0; y < heightSegments; y++) {
          const a = indexArray[y][x];
          const b = indexArray[y + 1][x];
          const c = indexArray[y + 1][x + 1];
          const d = indexArray[y][x + 1];
          if (radiusTop > 0 || y !== 0) {
            indices.push(a, b, d);
            groupCount += 3;
          }
          if (radiusBottom > 0 || y !== heightSegments - 1) {
            indices.push(b, c, d);
            groupCount += 3;
          }
        }
      }
      scope.addGroup(groupStart, groupCount, 0);
      groupStart += groupCount;
    }
    function generateCap(top) {
      const centerIndexStart = index;
      const uv = new Vector2$1();
      const vertex2 = new Vector3$1();
      let groupCount = 0;
      const radius = top === true ? radiusTop : radiusBottom;
      const sign2 = top === true ? 1 : -1;
      for (let x = 1; x <= radialSegments; x++) {
        vertices.push(0, halfHeight * sign2, 0);
        normals.push(0, sign2, 0);
        uvs.push(0.5, 0.5);
        index++;
      }
      const centerIndexEnd = index;
      for (let x = 0; x <= radialSegments; x++) {
        const u = x / radialSegments;
        const theta = u * thetaLength + thetaStart;
        const cosTheta = Math.cos(theta);
        const sinTheta = Math.sin(theta);
        vertex2.x = radius * sinTheta;
        vertex2.y = halfHeight * sign2;
        vertex2.z = radius * cosTheta;
        vertices.push(vertex2.x, vertex2.y, vertex2.z);
        normals.push(0, sign2, 0);
        uv.x = cosTheta * 0.5 + 0.5;
        uv.y = sinTheta * 0.5 * sign2 + 0.5;
        uvs.push(uv.x, uv.y);
        index++;
      }
      for (let x = 0; x < radialSegments; x++) {
        const c = centerIndexStart + x;
        const i = centerIndexEnd + x;
        if (top === true) {
          indices.push(i, i + 1, c);
        } else {
          indices.push(i + 1, i, c);
        }
        groupCount += 3;
      }
      scope.addGroup(groupStart, groupCount, top === true ? 1 : 2);
      groupStart += groupCount;
    }
  }
  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }
  static fromJSON(data) {
    return new CylinderGeometry(data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
  }
}
class ConeGeometry extends CylinderGeometry {
  constructor(radius = 1, height = 1, radialSegments = 32, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2) {
    super(0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);
    this.type = "ConeGeometry";
    this.parameters = {
      radius,
      height,
      radialSegments,
      heightSegments,
      openEnded,
      thetaStart,
      thetaLength
    };
  }
  static fromJSON(data) {
    return new ConeGeometry(data.radius, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
  }
}
class PolyhedronGeometry extends BufferGeometry {
  constructor(vertices = [], indices = [], radius = 1, detail = 0) {
    super();
    this.type = "PolyhedronGeometry";
    this.parameters = {
      vertices,
      indices,
      radius,
      detail
    };
    const vertexBuffer = [];
    const uvBuffer = [];
    subdivide(detail);
    applyRadius(radius);
    generateUVs();
    this.setAttribute("position", new Float32BufferAttribute(vertexBuffer, 3));
    this.setAttribute("normal", new Float32BufferAttribute(vertexBuffer.slice(), 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvBuffer, 2));
    if (detail === 0) {
      this.computeVertexNormals();
    } else {
      this.normalizeNormals();
    }
    function subdivide(detail2) {
      const a = new Vector3$1();
      const b = new Vector3$1();
      const c = new Vector3$1();
      for (let i = 0; i < indices.length; i += 3) {
        getVertexByIndex(indices[i + 0], a);
        getVertexByIndex(indices[i + 1], b);
        getVertexByIndex(indices[i + 2], c);
        subdivideFace(a, b, c, detail2);
      }
    }
    function subdivideFace(a, b, c, detail2) {
      const cols = detail2 + 1;
      const v = [];
      for (let i = 0; i <= cols; i++) {
        v[i] = [];
        const aj = a.clone().lerp(c, i / cols);
        const bj = b.clone().lerp(c, i / cols);
        const rows = cols - i;
        for (let j = 0; j <= rows; j++) {
          if (j === 0 && i === cols) {
            v[i][j] = aj;
          } else {
            v[i][j] = aj.clone().lerp(bj, j / rows);
          }
        }
      }
      for (let i = 0; i < cols; i++) {
        for (let j = 0; j < 2 * (cols - i) - 1; j++) {
          const k = Math.floor(j / 2);
          if (j % 2 === 0) {
            pushVertex(v[i][k + 1]);
            pushVertex(v[i + 1][k]);
            pushVertex(v[i][k]);
          } else {
            pushVertex(v[i][k + 1]);
            pushVertex(v[i + 1][k + 1]);
            pushVertex(v[i + 1][k]);
          }
        }
      }
    }
    function applyRadius(radius2) {
      const vertex2 = new Vector3$1();
      for (let i = 0; i < vertexBuffer.length; i += 3) {
        vertex2.x = vertexBuffer[i + 0];
        vertex2.y = vertexBuffer[i + 1];
        vertex2.z = vertexBuffer[i + 2];
        vertex2.normalize().multiplyScalar(radius2);
        vertexBuffer[i + 0] = vertex2.x;
        vertexBuffer[i + 1] = vertex2.y;
        vertexBuffer[i + 2] = vertex2.z;
      }
    }
    function generateUVs() {
      const vertex2 = new Vector3$1();
      for (let i = 0; i < vertexBuffer.length; i += 3) {
        vertex2.x = vertexBuffer[i + 0];
        vertex2.y = vertexBuffer[i + 1];
        vertex2.z = vertexBuffer[i + 2];
        const u = azimuth(vertex2) / 2 / Math.PI + 0.5;
        const v = inclination(vertex2) / Math.PI + 0.5;
        uvBuffer.push(u, 1 - v);
      }
      correctUVs();
      correctSeam();
    }
    function correctSeam() {
      for (let i = 0; i < uvBuffer.length; i += 6) {
        const x0 = uvBuffer[i + 0];
        const x1 = uvBuffer[i + 2];
        const x2 = uvBuffer[i + 4];
        const max2 = Math.max(x0, x1, x2);
        const min2 = Math.min(x0, x1, x2);
        if (max2 > 0.9 && min2 < 0.1) {
          if (x0 < 0.2) uvBuffer[i + 0] += 1;
          if (x1 < 0.2) uvBuffer[i + 2] += 1;
          if (x2 < 0.2) uvBuffer[i + 4] += 1;
        }
      }
    }
    function pushVertex(vertex2) {
      vertexBuffer.push(vertex2.x, vertex2.y, vertex2.z);
    }
    function getVertexByIndex(index, vertex2) {
      const stride = index * 3;
      vertex2.x = vertices[stride + 0];
      vertex2.y = vertices[stride + 1];
      vertex2.z = vertices[stride + 2];
    }
    function correctUVs() {
      const a = new Vector3$1();
      const b = new Vector3$1();
      const c = new Vector3$1();
      const centroid = new Vector3$1();
      const uvA = new Vector2$1();
      const uvB = new Vector2$1();
      const uvC = new Vector2$1();
      for (let i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6) {
        a.set(vertexBuffer[i + 0], vertexBuffer[i + 1], vertexBuffer[i + 2]);
        b.set(vertexBuffer[i + 3], vertexBuffer[i + 4], vertexBuffer[i + 5]);
        c.set(vertexBuffer[i + 6], vertexBuffer[i + 7], vertexBuffer[i + 8]);
        uvA.set(uvBuffer[j + 0], uvBuffer[j + 1]);
        uvB.set(uvBuffer[j + 2], uvBuffer[j + 3]);
        uvC.set(uvBuffer[j + 4], uvBuffer[j + 5]);
        centroid.copy(a).add(b).add(c).divideScalar(3);
        const azi = azimuth(centroid);
        correctUV(uvA, j + 0, a, azi);
        correctUV(uvB, j + 2, b, azi);
        correctUV(uvC, j + 4, c, azi);
      }
    }
    function correctUV(uv, stride, vector, azimuth2) {
      if (azimuth2 < 0 && uv.x === 1) {
        uvBuffer[stride] = uv.x - 1;
      }
      if (vector.x === 0 && vector.z === 0) {
        uvBuffer[stride] = azimuth2 / 2 / Math.PI + 0.5;
      }
    }
    function azimuth(vector) {
      return Math.atan2(vector.z, -vector.x);
    }
    function inclination(vector) {
      return Math.atan2(-vector.y, Math.sqrt(vector.x * vector.x + vector.z * vector.z));
    }
  }
  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }
  static fromJSON(data) {
    return new PolyhedronGeometry(data.vertices, data.indices, data.radius, data.details);
  }
}
class DodecahedronGeometry extends PolyhedronGeometry {
  constructor(radius = 1, detail = 0) {
    const t = (1 + Math.sqrt(5)) / 2;
    const r = 1 / t;
    const vertices = [
      // (±1, ±1, ±1)
      -1,
      -1,
      -1,
      -1,
      -1,
      1,
      -1,
      1,
      -1,
      -1,
      1,
      1,
      1,
      -1,
      -1,
      1,
      -1,
      1,
      1,
      1,
      -1,
      1,
      1,
      1,
      // (0, ±1/φ, ±φ)
      0,
      -r,
      -t,
      0,
      -r,
      t,
      0,
      r,
      -t,
      0,
      r,
      t,
      // (±1/φ, ±φ, 0)
      -r,
      -t,
      0,
      -r,
      t,
      0,
      r,
      -t,
      0,
      r,
      t,
      0,
      // (±φ, 0, ±1/φ)
      -t,
      0,
      -r,
      t,
      0,
      -r,
      -t,
      0,
      r,
      t,
      0,
      r
    ];
    const indices = [
      3,
      11,
      7,
      3,
      7,
      15,
      3,
      15,
      13,
      7,
      19,
      17,
      7,
      17,
      6,
      7,
      6,
      15,
      17,
      4,
      8,
      17,
      8,
      10,
      17,
      10,
      6,
      8,
      0,
      16,
      8,
      16,
      2,
      8,
      2,
      10,
      0,
      12,
      1,
      0,
      1,
      18,
      0,
      18,
      16,
      6,
      10,
      2,
      6,
      2,
      13,
      6,
      13,
      15,
      2,
      16,
      18,
      2,
      18,
      3,
      2,
      3,
      13,
      18,
      1,
      9,
      18,
      9,
      11,
      18,
      11,
      3,
      4,
      14,
      12,
      4,
      12,
      0,
      4,
      0,
      8,
      11,
      9,
      5,
      11,
      5,
      19,
      11,
      19,
      7,
      19,
      5,
      14,
      19,
      14,
      4,
      19,
      4,
      17,
      1,
      12,
      14,
      1,
      14,
      5,
      1,
      5,
      9
    ];
    super(vertices, indices, radius, detail);
    this.type = "DodecahedronGeometry";
    this.parameters = {
      radius,
      detail
    };
  }
  static fromJSON(data) {
    return new DodecahedronGeometry(data.radius, data.detail);
  }
}
const _v0$3 = /* @__PURE__ */ new Vector3$1();
const _v1$1 = /* @__PURE__ */ new Vector3$1();
const _normal = /* @__PURE__ */ new Vector3$1();
const _triangle = /* @__PURE__ */ new Triangle();
class EdgesGeometry extends BufferGeometry {
  constructor(geometry = null, thresholdAngle = 1) {
    super();
    this.type = "EdgesGeometry";
    this.parameters = {
      geometry,
      thresholdAngle
    };
    if (geometry !== null) {
      const precisionPoints = 4;
      const precision = Math.pow(10, precisionPoints);
      const thresholdDot = Math.cos(DEG2RAD$1 * thresholdAngle);
      const indexAttr = geometry.getIndex();
      const positionAttr = geometry.getAttribute("position");
      const indexCount = indexAttr ? indexAttr.count : positionAttr.count;
      const indexArr = [0, 0, 0];
      const vertKeys = ["a", "b", "c"];
      const hashes = new Array(3);
      const edgeData = {};
      const vertices = [];
      for (let i = 0; i < indexCount; i += 3) {
        if (indexAttr) {
          indexArr[0] = indexAttr.getX(i);
          indexArr[1] = indexAttr.getX(i + 1);
          indexArr[2] = indexAttr.getX(i + 2);
        } else {
          indexArr[0] = i;
          indexArr[1] = i + 1;
          indexArr[2] = i + 2;
        }
        const { a, b, c } = _triangle;
        a.fromBufferAttribute(positionAttr, indexArr[0]);
        b.fromBufferAttribute(positionAttr, indexArr[1]);
        c.fromBufferAttribute(positionAttr, indexArr[2]);
        _triangle.getNormal(_normal);
        hashes[0] = `${Math.round(a.x * precision)},${Math.round(a.y * precision)},${Math.round(a.z * precision)}`;
        hashes[1] = `${Math.round(b.x * precision)},${Math.round(b.y * precision)},${Math.round(b.z * precision)}`;
        hashes[2] = `${Math.round(c.x * precision)},${Math.round(c.y * precision)},${Math.round(c.z * precision)}`;
        if (hashes[0] === hashes[1] || hashes[1] === hashes[2] || hashes[2] === hashes[0]) {
          continue;
        }
        for (let j = 0; j < 3; j++) {
          const jNext = (j + 1) % 3;
          const vecHash0 = hashes[j];
          const vecHash1 = hashes[jNext];
          const v0 = _triangle[vertKeys[j]];
          const v1 = _triangle[vertKeys[jNext]];
          const hash2 = `${vecHash0}_${vecHash1}`;
          const reverseHash = `${vecHash1}_${vecHash0}`;
          if (reverseHash in edgeData && edgeData[reverseHash]) {
            if (_normal.dot(edgeData[reverseHash].normal) <= thresholdDot) {
              vertices.push(v0.x, v0.y, v0.z);
              vertices.push(v1.x, v1.y, v1.z);
            }
            edgeData[reverseHash] = null;
          } else if (!(hash2 in edgeData)) {
            edgeData[hash2] = {
              index0: indexArr[j],
              index1: indexArr[jNext],
              normal: _normal.clone()
            };
          }
        }
      }
      for (const key in edgeData) {
        if (edgeData[key]) {
          const { index0, index1 } = edgeData[key];
          _v0$3.fromBufferAttribute(positionAttr, index0);
          _v1$1.fromBufferAttribute(positionAttr, index1);
          vertices.push(_v0$3.x, _v0$3.y, _v0$3.z);
          vertices.push(_v1$1.x, _v1$1.y, _v1$1.z);
        }
      }
      this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    }
  }
  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }
}
let Shape$1 = class Shape extends Path {
  constructor(points) {
    super(points);
    this.uuid = generateUUID$1();
    this.type = "Shape";
    this.holes = [];
  }
  getPointsHoles(divisions) {
    const holesPts = [];
    for (let i = 0, l = this.holes.length; i < l; i++) {
      holesPts[i] = this.holes[i].getPoints(divisions);
    }
    return holesPts;
  }
  // get points of shape and holes (keypoints based on segments parameter)
  extractPoints(divisions) {
    return {
      shape: this.getPoints(divisions),
      holes: this.getPointsHoles(divisions)
    };
  }
  copy(source) {
    super.copy(source);
    this.holes = [];
    for (let i = 0, l = source.holes.length; i < l; i++) {
      const hole = source.holes[i];
      this.holes.push(hole.clone());
    }
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.uuid = this.uuid;
    data.holes = [];
    for (let i = 0, l = this.holes.length; i < l; i++) {
      const hole = this.holes[i];
      data.holes.push(hole.toJSON());
    }
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.uuid = json.uuid;
    this.holes = [];
    for (let i = 0, l = json.holes.length; i < l; i++) {
      const hole = json.holes[i];
      this.holes.push(new Path().fromJSON(hole));
    }
    return this;
  }
};
const Earcut = {
  triangulate: function(data, holeIndices, dim = 2) {
    const hasHoles = holeIndices && holeIndices.length;
    const outerLen = hasHoles ? holeIndices[0] * dim : data.length;
    let outerNode = linkedList(data, 0, outerLen, dim, true);
    const triangles = [];
    if (!outerNode || outerNode.next === outerNode.prev) return triangles;
    let minX, minY, maxX, maxY, x, y, invSize;
    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
    if (data.length > 80 * dim) {
      minX = maxX = data[0];
      minY = maxY = data[1];
      for (let i = dim; i < outerLen; i += dim) {
        x = data[i];
        y = data[i + 1];
        if (x < minX) minX = x;
        if (y < minY) minY = y;
        if (x > maxX) maxX = x;
        if (y > maxY) maxY = y;
      }
      invSize = Math.max(maxX - minX, maxY - minY);
      invSize = invSize !== 0 ? 32767 / invSize : 0;
    }
    earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);
    return triangles;
  }
};
function linkedList(data, start, end, dim, clockwise) {
  let i, last;
  if (clockwise === signedArea(data, start, end, dim) > 0) {
    for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);
  } else {
    for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);
  }
  if (last && equals$1(last, last.next)) {
    removeNode(last);
    last = last.next;
  }
  return last;
}
function filterPoints(start, end) {
  if (!start) return start;
  if (!end) end = start;
  let p = start, again;
  do {
    again = false;
    if (!p.steiner && (equals$1(p, p.next) || area(p.prev, p, p.next) === 0)) {
      removeNode(p);
      p = end = p.prev;
      if (p === p.next) break;
      again = true;
    } else {
      p = p.next;
    }
  } while (again || p !== end);
  return end;
}
function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
  if (!ear) return;
  if (!pass && invSize) indexCurve(ear, minX, minY, invSize);
  let stop = ear, prev, next;
  while (ear.prev !== ear.next) {
    prev = ear.prev;
    next = ear.next;
    if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
      triangles.push(prev.i / dim | 0);
      triangles.push(ear.i / dim | 0);
      triangles.push(next.i / dim | 0);
      removeNode(ear);
      ear = next.next;
      stop = next.next;
      continue;
    }
    ear = next;
    if (ear === stop) {
      if (!pass) {
        earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
      } else if (pass === 1) {
        ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
        earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
      } else if (pass === 2) {
        splitEarcut(ear, triangles, dim, minX, minY, invSize);
      }
      break;
    }
  }
}
function isEar(ear) {
  const a = ear.prev, b = ear, c = ear.next;
  if (area(a, b, c) >= 0) return false;
  const ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;
  const x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
  let p = c.next;
  while (p !== a) {
    if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
    p = p.next;
  }
  return true;
}
function isEarHashed(ear, minX, minY, invSize) {
  const a = ear.prev, b = ear, c = ear.next;
  if (area(a, b, c) >= 0) return false;
  const ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;
  const x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
  const minZ = zOrder(x0, y0, minX, minY, invSize), maxZ = zOrder(x1, y1, minX, minY, invSize);
  let p = ear.prevZ, n = ear.nextZ;
  while (p && p.z >= minZ && n && n.z <= maxZ) {
    if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
    p = p.prevZ;
    if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
    n = n.nextZ;
  }
  while (p && p.z >= minZ) {
    if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
    p = p.prevZ;
  }
  while (n && n.z <= maxZ) {
    if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
    n = n.nextZ;
  }
  return true;
}
function cureLocalIntersections(start, triangles, dim) {
  let p = start;
  do {
    const a = p.prev, b = p.next.next;
    if (!equals$1(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
      triangles.push(a.i / dim | 0);
      triangles.push(p.i / dim | 0);
      triangles.push(b.i / dim | 0);
      removeNode(p);
      removeNode(p.next);
      p = start = b;
    }
    p = p.next;
  } while (p !== start);
  return filterPoints(p);
}
function splitEarcut(start, triangles, dim, minX, minY, invSize) {
  let a = start;
  do {
    let b = a.next.next;
    while (b !== a.prev) {
      if (a.i !== b.i && isValidDiagonal(a, b)) {
        let c = splitPolygon(a, b);
        a = filterPoints(a, a.next);
        c = filterPoints(c, c.next);
        earcutLinked(a, triangles, dim, minX, minY, invSize, 0);
        earcutLinked(c, triangles, dim, minX, minY, invSize, 0);
        return;
      }
      b = b.next;
    }
    a = a.next;
  } while (a !== start);
}
function eliminateHoles(data, holeIndices, outerNode, dim) {
  const queue = [];
  let i, len, start, end, list;
  for (i = 0, len = holeIndices.length; i < len; i++) {
    start = holeIndices[i] * dim;
    end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
    list = linkedList(data, start, end, dim, false);
    if (list === list.next) list.steiner = true;
    queue.push(getLeftmost(list));
  }
  queue.sort(compareX);
  for (i = 0; i < queue.length; i++) {
    outerNode = eliminateHole(queue[i], outerNode);
  }
  return outerNode;
}
function compareX(a, b) {
  return a.x - b.x;
}
function eliminateHole(hole, outerNode) {
  const bridge = findHoleBridge(hole, outerNode);
  if (!bridge) {
    return outerNode;
  }
  const bridgeReverse = splitPolygon(bridge, hole);
  filterPoints(bridgeReverse, bridgeReverse.next);
  return filterPoints(bridge, bridge.next);
}
function findHoleBridge(hole, outerNode) {
  let p = outerNode, qx = -Infinity, m;
  const hx = hole.x, hy = hole.y;
  do {
    if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
      const x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
      if (x <= hx && x > qx) {
        qx = x;
        m = p.x < p.next.x ? p : p.next;
        if (x === hx) return m;
      }
    }
    p = p.next;
  } while (p !== outerNode);
  if (!m) return null;
  const stop = m, mx = m.x, my = m.y;
  let tanMin = Infinity, tan2;
  p = m;
  do {
    if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
      tan2 = Math.abs(hy - p.y) / (hx - p.x);
      if (locallyInside(p, hole) && (tan2 < tanMin || tan2 === tanMin && (p.x > m.x || p.x === m.x && sectorContainsSector(m, p)))) {
        m = p;
        tanMin = tan2;
      }
    }
    p = p.next;
  } while (p !== stop);
  return m;
}
function sectorContainsSector(m, p) {
  return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
}
function indexCurve(start, minX, minY, invSize) {
  let p = start;
  do {
    if (p.z === 0) p.z = zOrder(p.x, p.y, minX, minY, invSize);
    p.prevZ = p.prev;
    p.nextZ = p.next;
    p = p.next;
  } while (p !== start);
  p.prevZ.nextZ = null;
  p.prevZ = null;
  sortLinked(p);
}
function sortLinked(list) {
  let i, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;
  do {
    p = list;
    list = null;
    tail = null;
    numMerges = 0;
    while (p) {
      numMerges++;
      q = p;
      pSize = 0;
      for (i = 0; i < inSize; i++) {
        pSize++;
        q = q.nextZ;
        if (!q) break;
      }
      qSize = inSize;
      while (pSize > 0 || qSize > 0 && q) {
        if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
          e = p;
          p = p.nextZ;
          pSize--;
        } else {
          e = q;
          q = q.nextZ;
          qSize--;
        }
        if (tail) tail.nextZ = e;
        else list = e;
        e.prevZ = tail;
        tail = e;
      }
      p = q;
    }
    tail.nextZ = null;
    inSize *= 2;
  } while (numMerges > 1);
  return list;
}
function zOrder(x, y, minX, minY, invSize) {
  x = (x - minX) * invSize | 0;
  y = (y - minY) * invSize | 0;
  x = (x | x << 8) & 16711935;
  x = (x | x << 4) & 252645135;
  x = (x | x << 2) & 858993459;
  x = (x | x << 1) & 1431655765;
  y = (y | y << 8) & 16711935;
  y = (y | y << 4) & 252645135;
  y = (y | y << 2) & 858993459;
  y = (y | y << 1) & 1431655765;
  return x | y << 1;
}
function getLeftmost(start) {
  let p = start, leftmost = start;
  do {
    if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y) leftmost = p;
    p = p.next;
  } while (p !== start);
  return leftmost;
}
function pointInTriangle(ax, ay, bx, by, cx, cy, px2, py2) {
  return (cx - px2) * (ay - py2) >= (ax - px2) * (cy - py2) && (ax - px2) * (by - py2) >= (bx - px2) * (ay - py2) && (bx - px2) * (cy - py2) >= (cx - px2) * (by - py2);
}
function isValidDiagonal(a, b) {
  return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // doesn't intersect other edges
  (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible
  (area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors
  equals$1(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0);
}
function area(p, q, r) {
  return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
}
function equals$1(p1, p2) {
  return p1.x === p2.x && p1.y === p2.y;
}
function intersects(p1, q1, p2, q2) {
  const o1 = sign$1(area(p1, q1, p2));
  const o2 = sign$1(area(p1, q1, q2));
  const o3 = sign$1(area(p2, q2, p1));
  const o4 = sign$1(area(p2, q2, q1));
  if (o1 !== o2 && o3 !== o4) return true;
  if (o1 === 0 && onSegment(p1, p2, q1)) return true;
  if (o2 === 0 && onSegment(p1, q2, q1)) return true;
  if (o3 === 0 && onSegment(p2, p1, q2)) return true;
  if (o4 === 0 && onSegment(p2, q1, q2)) return true;
  return false;
}
function onSegment(p, q, r) {
  return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
}
function sign$1(num) {
  return num > 0 ? 1 : num < 0 ? -1 : 0;
}
function intersectsPolygon(a, b) {
  let p = a;
  do {
    if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b)) return true;
    p = p.next;
  } while (p !== a);
  return false;
}
function locallyInside(a, b) {
  return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
}
function middleInside(a, b) {
  let p = a, inside = false;
  const px2 = (a.x + b.x) / 2, py2 = (a.y + b.y) / 2;
  do {
    if (p.y > py2 !== p.next.y > py2 && p.next.y !== p.y && px2 < (p.next.x - p.x) * (py2 - p.y) / (p.next.y - p.y) + p.x)
      inside = !inside;
    p = p.next;
  } while (p !== a);
  return inside;
}
function splitPolygon(a, b) {
  const a2 = new Node$1(a.i, a.x, a.y), b2 = new Node$1(b.i, b.x, b.y), an = a.next, bp = b.prev;
  a.next = b;
  b.prev = a;
  a2.next = an;
  an.prev = a2;
  b2.next = a2;
  a2.prev = b2;
  bp.next = b2;
  b2.prev = bp;
  return b2;
}
function insertNode(i, x, y, last) {
  const p = new Node$1(i, x, y);
  if (!last) {
    p.prev = p;
    p.next = p;
  } else {
    p.next = last.next;
    p.prev = last;
    last.next.prev = p;
    last.next = p;
  }
  return p;
}
function removeNode(p) {
  p.next.prev = p.prev;
  p.prev.next = p.next;
  if (p.prevZ) p.prevZ.nextZ = p.nextZ;
  if (p.nextZ) p.nextZ.prevZ = p.prevZ;
}
function Node$1(i, x, y) {
  this.i = i;
  this.x = x;
  this.y = y;
  this.prev = null;
  this.next = null;
  this.z = 0;
  this.prevZ = null;
  this.nextZ = null;
  this.steiner = false;
}
function signedArea(data, start, end, dim) {
  let sum = 0;
  for (let i = start, j = end - dim; i < end; i += dim) {
    sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
    j = i;
  }
  return sum;
}
class ShapeUtils {
  // calculate area of the contour polygon
  static area(contour) {
    const n = contour.length;
    let a = 0;
    for (let p = n - 1, q = 0; q < n; p = q++) {
      a += contour[p].x * contour[q].y - contour[q].x * contour[p].y;
    }
    return a * 0.5;
  }
  static isClockWise(pts) {
    return ShapeUtils.area(pts) < 0;
  }
  static triangulateShape(contour, holes) {
    const vertices = [];
    const holeIndices = [];
    const faces = [];
    removeDupEndPts(contour);
    addContour(vertices, contour);
    let holeIndex = contour.length;
    holes.forEach(removeDupEndPts);
    for (let i = 0; i < holes.length; i++) {
      holeIndices.push(holeIndex);
      holeIndex += holes[i].length;
      addContour(vertices, holes[i]);
    }
    const triangles = Earcut.triangulate(vertices, holeIndices);
    for (let i = 0; i < triangles.length; i += 3) {
      faces.push(triangles.slice(i, i + 3));
    }
    return faces;
  }
}
function removeDupEndPts(points) {
  const l = points.length;
  if (l > 2 && points[l - 1].equals(points[0])) {
    points.pop();
  }
}
function addContour(vertices, contour) {
  for (let i = 0; i < contour.length; i++) {
    vertices.push(contour[i].x);
    vertices.push(contour[i].y);
  }
}
class ExtrudeGeometry extends BufferGeometry {
  constructor(shapes = new Shape$1([new Vector2$1(0.5, 0.5), new Vector2$1(-0.5, 0.5), new Vector2$1(-0.5, -0.5), new Vector2$1(0.5, -0.5)]), options = {}) {
    super();
    this.type = "ExtrudeGeometry";
    this.parameters = {
      shapes,
      options
    };
    shapes = Array.isArray(shapes) ? shapes : [shapes];
    const scope = this;
    const verticesArray = [];
    const uvArray = [];
    for (let i = 0, l = shapes.length; i < l; i++) {
      const shape = shapes[i];
      addShape(shape);
    }
    this.setAttribute("position", new Float32BufferAttribute(verticesArray, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvArray, 2));
    this.computeVertexNormals();
    function addShape(shape) {
      const placeholder = [];
      const curveSegments = options.curveSegments !== void 0 ? options.curveSegments : 12;
      const steps = options.steps !== void 0 ? options.steps : 1;
      const depth = options.depth !== void 0 ? options.depth : 1;
      let bevelEnabled = options.bevelEnabled !== void 0 ? options.bevelEnabled : true;
      let bevelThickness = options.bevelThickness !== void 0 ? options.bevelThickness : 0.2;
      let bevelSize = options.bevelSize !== void 0 ? options.bevelSize : bevelThickness - 0.1;
      let bevelOffset = options.bevelOffset !== void 0 ? options.bevelOffset : 0;
      let bevelSegments = options.bevelSegments !== void 0 ? options.bevelSegments : 3;
      const extrudePath = options.extrudePath;
      const uvgen = options.UVGenerator !== void 0 ? options.UVGenerator : WorldUVGenerator;
      let extrudePts, extrudeByPath = false;
      let splineTube, binormal, normal, position2;
      if (extrudePath) {
        extrudePts = extrudePath.getSpacedPoints(steps);
        extrudeByPath = true;
        bevelEnabled = false;
        splineTube = extrudePath.computeFrenetFrames(steps, false);
        binormal = new Vector3$1();
        normal = new Vector3$1();
        position2 = new Vector3$1();
      }
      if (!bevelEnabled) {
        bevelSegments = 0;
        bevelThickness = 0;
        bevelSize = 0;
        bevelOffset = 0;
      }
      const shapePoints = shape.extractPoints(curveSegments);
      let vertices = shapePoints.shape;
      const holes = shapePoints.holes;
      const reverse = !ShapeUtils.isClockWise(vertices);
      if (reverse) {
        vertices = vertices.reverse();
        for (let h = 0, hl = holes.length; h < hl; h++) {
          const ahole = holes[h];
          if (ShapeUtils.isClockWise(ahole)) {
            holes[h] = ahole.reverse();
          }
        }
      }
      const faces = ShapeUtils.triangulateShape(vertices, holes);
      const contour = vertices;
      for (let h = 0, hl = holes.length; h < hl; h++) {
        const ahole = holes[h];
        vertices = vertices.concat(ahole);
      }
      function scalePt2(pt, vec, size) {
        if (!vec) console.error("THREE.ExtrudeGeometry: vec does not exist");
        return pt.clone().addScaledVector(vec, size);
      }
      const vlen = vertices.length, flen = faces.length;
      function getBevelVec(inPt, inPrev, inNext) {
        let v_trans_x, v_trans_y, shrink_by;
        const v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;
        const v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;
        const v_prev_lensq = v_prev_x * v_prev_x + v_prev_y * v_prev_y;
        const collinear0 = v_prev_x * v_next_y - v_prev_y * v_next_x;
        if (Math.abs(collinear0) > Number.EPSILON) {
          const v_prev_len = Math.sqrt(v_prev_lensq);
          const v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y);
          const ptPrevShift_x = inPrev.x - v_prev_y / v_prev_len;
          const ptPrevShift_y = inPrev.y + v_prev_x / v_prev_len;
          const ptNextShift_x = inNext.x - v_next_y / v_next_len;
          const ptNextShift_y = inNext.y + v_next_x / v_next_len;
          const sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y - (ptNextShift_y - ptPrevShift_y) * v_next_x) / (v_prev_x * v_next_y - v_prev_y * v_next_x);
          v_trans_x = ptPrevShift_x + v_prev_x * sf - inPt.x;
          v_trans_y = ptPrevShift_y + v_prev_y * sf - inPt.y;
          const v_trans_lensq = v_trans_x * v_trans_x + v_trans_y * v_trans_y;
          if (v_trans_lensq <= 2) {
            return new Vector2$1(v_trans_x, v_trans_y);
          } else {
            shrink_by = Math.sqrt(v_trans_lensq / 2);
          }
        } else {
          let direction_eq = false;
          if (v_prev_x > Number.EPSILON) {
            if (v_next_x > Number.EPSILON) {
              direction_eq = true;
            }
          } else {
            if (v_prev_x < -Number.EPSILON) {
              if (v_next_x < -Number.EPSILON) {
                direction_eq = true;
              }
            } else {
              if (Math.sign(v_prev_y) === Math.sign(v_next_y)) {
                direction_eq = true;
              }
            }
          }
          if (direction_eq) {
            v_trans_x = -v_prev_y;
            v_trans_y = v_prev_x;
            shrink_by = Math.sqrt(v_prev_lensq);
          } else {
            v_trans_x = v_prev_x;
            v_trans_y = v_prev_y;
            shrink_by = Math.sqrt(v_prev_lensq / 2);
          }
        }
        return new Vector2$1(v_trans_x / shrink_by, v_trans_y / shrink_by);
      }
      const contourMovements = [];
      for (let i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {
        if (j === il) j = 0;
        if (k === il) k = 0;
        contourMovements[i] = getBevelVec(contour[i], contour[j], contour[k]);
      }
      const holesMovements = [];
      let oneHoleMovements, verticesMovements = contourMovements.concat();
      for (let h = 0, hl = holes.length; h < hl; h++) {
        const ahole = holes[h];
        oneHoleMovements = [];
        for (let i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {
          if (j === il) j = 0;
          if (k === il) k = 0;
          oneHoleMovements[i] = getBevelVec(ahole[i], ahole[j], ahole[k]);
        }
        holesMovements.push(oneHoleMovements);
        verticesMovements = verticesMovements.concat(oneHoleMovements);
      }
      for (let b = 0; b < bevelSegments; b++) {
        const t = b / bevelSegments;
        const z = bevelThickness * Math.cos(t * Math.PI / 2);
        const bs2 = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset;
        for (let i = 0, il = contour.length; i < il; i++) {
          const vert = scalePt2(contour[i], contourMovements[i], bs2);
          v(vert.x, vert.y, -z);
        }
        for (let h = 0, hl = holes.length; h < hl; h++) {
          const ahole = holes[h];
          oneHoleMovements = holesMovements[h];
          for (let i = 0, il = ahole.length; i < il; i++) {
            const vert = scalePt2(ahole[i], oneHoleMovements[i], bs2);
            v(vert.x, vert.y, -z);
          }
        }
      }
      const bs = bevelSize + bevelOffset;
      for (let i = 0; i < vlen; i++) {
        const vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];
        if (!extrudeByPath) {
          v(vert.x, vert.y, 0);
        } else {
          normal.copy(splineTube.normals[0]).multiplyScalar(vert.x);
          binormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y);
          position2.copy(extrudePts[0]).add(normal).add(binormal);
          v(position2.x, position2.y, position2.z);
        }
      }
      for (let s = 1; s <= steps; s++) {
        for (let i = 0; i < vlen; i++) {
          const vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];
          if (!extrudeByPath) {
            v(vert.x, vert.y, depth / steps * s);
          } else {
            normal.copy(splineTube.normals[s]).multiplyScalar(vert.x);
            binormal.copy(splineTube.binormals[s]).multiplyScalar(vert.y);
            position2.copy(extrudePts[s]).add(normal).add(binormal);
            v(position2.x, position2.y, position2.z);
          }
        }
      }
      for (let b = bevelSegments - 1; b >= 0; b--) {
        const t = b / bevelSegments;
        const z = bevelThickness * Math.cos(t * Math.PI / 2);
        const bs2 = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset;
        for (let i = 0, il = contour.length; i < il; i++) {
          const vert = scalePt2(contour[i], contourMovements[i], bs2);
          v(vert.x, vert.y, depth + z);
        }
        for (let h = 0, hl = holes.length; h < hl; h++) {
          const ahole = holes[h];
          oneHoleMovements = holesMovements[h];
          for (let i = 0, il = ahole.length; i < il; i++) {
            const vert = scalePt2(ahole[i], oneHoleMovements[i], bs2);
            if (!extrudeByPath) {
              v(vert.x, vert.y, depth + z);
            } else {
              v(vert.x, vert.y + extrudePts[steps - 1].y, extrudePts[steps - 1].x + z);
            }
          }
        }
      }
      buildLidFaces();
      buildSideFaces();
      function buildLidFaces() {
        const start = verticesArray.length / 3;
        if (bevelEnabled) {
          let layer = 0;
          let offset = vlen * layer;
          for (let i = 0; i < flen; i++) {
            const face = faces[i];
            f3(face[2] + offset, face[1] + offset, face[0] + offset);
          }
          layer = steps + bevelSegments * 2;
          offset = vlen * layer;
          for (let i = 0; i < flen; i++) {
            const face = faces[i];
            f3(face[0] + offset, face[1] + offset, face[2] + offset);
          }
        } else {
          for (let i = 0; i < flen; i++) {
            const face = faces[i];
            f3(face[2], face[1], face[0]);
          }
          for (let i = 0; i < flen; i++) {
            const face = faces[i];
            f3(face[0] + vlen * steps, face[1] + vlen * steps, face[2] + vlen * steps);
          }
        }
        scope.addGroup(start, verticesArray.length / 3 - start, 0);
      }
      function buildSideFaces() {
        const start = verticesArray.length / 3;
        let layeroffset = 0;
        sidewalls(contour, layeroffset);
        layeroffset += contour.length;
        for (let h = 0, hl = holes.length; h < hl; h++) {
          const ahole = holes[h];
          sidewalls(ahole, layeroffset);
          layeroffset += ahole.length;
        }
        scope.addGroup(start, verticesArray.length / 3 - start, 1);
      }
      function sidewalls(contour2, layeroffset) {
        let i = contour2.length;
        while (--i >= 0) {
          const j = i;
          let k = i - 1;
          if (k < 0) k = contour2.length - 1;
          for (let s = 0, sl = steps + bevelSegments * 2; s < sl; s++) {
            const slen1 = vlen * s;
            const slen2 = vlen * (s + 1);
            const a = layeroffset + j + slen1, b = layeroffset + k + slen1, c = layeroffset + k + slen2, d = layeroffset + j + slen2;
            f4(a, b, c, d);
          }
        }
      }
      function v(x, y, z) {
        placeholder.push(x);
        placeholder.push(y);
        placeholder.push(z);
      }
      function f3(a, b, c) {
        addVertex(a);
        addVertex(b);
        addVertex(c);
        const nextIndex = verticesArray.length / 3;
        const uvs = uvgen.generateTopUV(scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1);
        addUV(uvs[0]);
        addUV(uvs[1]);
        addUV(uvs[2]);
      }
      function f4(a, b, c, d) {
        addVertex(a);
        addVertex(b);
        addVertex(d);
        addVertex(b);
        addVertex(c);
        addVertex(d);
        const nextIndex = verticesArray.length / 3;
        const uvs = uvgen.generateSideWallUV(scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1);
        addUV(uvs[0]);
        addUV(uvs[1]);
        addUV(uvs[3]);
        addUV(uvs[1]);
        addUV(uvs[2]);
        addUV(uvs[3]);
      }
      function addVertex(index) {
        verticesArray.push(placeholder[index * 3 + 0]);
        verticesArray.push(placeholder[index * 3 + 1]);
        verticesArray.push(placeholder[index * 3 + 2]);
      }
      function addUV(vector2) {
        uvArray.push(vector2.x);
        uvArray.push(vector2.y);
      }
    }
  }
  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    const shapes = this.parameters.shapes;
    const options = this.parameters.options;
    return toJSON$1(shapes, options, data);
  }
  static fromJSON(data, shapes) {
    const geometryShapes = [];
    for (let j = 0, jl = data.shapes.length; j < jl; j++) {
      const shape = shapes[data.shapes[j]];
      geometryShapes.push(shape);
    }
    const extrudePath = data.options.extrudePath;
    if (extrudePath !== void 0) {
      data.options.extrudePath = new Curves[extrudePath.type]().fromJSON(extrudePath);
    }
    return new ExtrudeGeometry(geometryShapes, data.options);
  }
}
const WorldUVGenerator = {
  generateTopUV: function(geometry, vertices, indexA, indexB, indexC) {
    const a_x = vertices[indexA * 3];
    const a_y = vertices[indexA * 3 + 1];
    const b_x = vertices[indexB * 3];
    const b_y = vertices[indexB * 3 + 1];
    const c_x = vertices[indexC * 3];
    const c_y = vertices[indexC * 3 + 1];
    return [
      new Vector2$1(a_x, a_y),
      new Vector2$1(b_x, b_y),
      new Vector2$1(c_x, c_y)
    ];
  },
  generateSideWallUV: function(geometry, vertices, indexA, indexB, indexC, indexD) {
    const a_x = vertices[indexA * 3];
    const a_y = vertices[indexA * 3 + 1];
    const a_z = vertices[indexA * 3 + 2];
    const b_x = vertices[indexB * 3];
    const b_y = vertices[indexB * 3 + 1];
    const b_z = vertices[indexB * 3 + 2];
    const c_x = vertices[indexC * 3];
    const c_y = vertices[indexC * 3 + 1];
    const c_z = vertices[indexC * 3 + 2];
    const d_x = vertices[indexD * 3];
    const d_y = vertices[indexD * 3 + 1];
    const d_z = vertices[indexD * 3 + 2];
    if (Math.abs(a_y - b_y) < Math.abs(a_x - b_x)) {
      return [
        new Vector2$1(a_x, 1 - a_z),
        new Vector2$1(b_x, 1 - b_z),
        new Vector2$1(c_x, 1 - c_z),
        new Vector2$1(d_x, 1 - d_z)
      ];
    } else {
      return [
        new Vector2$1(a_y, 1 - a_z),
        new Vector2$1(b_y, 1 - b_z),
        new Vector2$1(c_y, 1 - c_z),
        new Vector2$1(d_y, 1 - d_z)
      ];
    }
  }
};
function toJSON$1(shapes, options, data) {
  data.shapes = [];
  if (Array.isArray(shapes)) {
    for (let i = 0, l = shapes.length; i < l; i++) {
      const shape = shapes[i];
      data.shapes.push(shape.uuid);
    }
  } else {
    data.shapes.push(shapes.uuid);
  }
  data.options = Object.assign({}, options);
  if (options.extrudePath !== void 0) data.options.extrudePath = options.extrudePath.toJSON();
  return data;
}
class IcosahedronGeometry extends PolyhedronGeometry {
  constructor(radius = 1, detail = 0) {
    const t = (1 + Math.sqrt(5)) / 2;
    const vertices = [
      -1,
      t,
      0,
      1,
      t,
      0,
      -1,
      -t,
      0,
      1,
      -t,
      0,
      0,
      -1,
      t,
      0,
      1,
      t,
      0,
      -1,
      -t,
      0,
      1,
      -t,
      t,
      0,
      -1,
      t,
      0,
      1,
      -t,
      0,
      -1,
      -t,
      0,
      1
    ];
    const indices = [
      0,
      11,
      5,
      0,
      5,
      1,
      0,
      1,
      7,
      0,
      7,
      10,
      0,
      10,
      11,
      1,
      5,
      9,
      5,
      11,
      4,
      11,
      10,
      2,
      10,
      7,
      6,
      7,
      1,
      8,
      3,
      9,
      4,
      3,
      4,
      2,
      3,
      2,
      6,
      3,
      6,
      8,
      3,
      8,
      9,
      4,
      9,
      5,
      2,
      4,
      11,
      6,
      2,
      10,
      8,
      6,
      7,
      9,
      8,
      1
    ];
    super(vertices, indices, radius, detail);
    this.type = "IcosahedronGeometry";
    this.parameters = {
      radius,
      detail
    };
  }
  static fromJSON(data) {
    return new IcosahedronGeometry(data.radius, data.detail);
  }
}
class OctahedronGeometry extends PolyhedronGeometry {
  constructor(radius = 1, detail = 0) {
    const vertices = [
      1,
      0,
      0,
      -1,
      0,
      0,
      0,
      1,
      0,
      0,
      -1,
      0,
      0,
      0,
      1,
      0,
      0,
      -1
    ];
    const indices = [
      0,
      2,
      4,
      0,
      4,
      3,
      0,
      3,
      5,
      0,
      5,
      2,
      1,
      2,
      5,
      1,
      5,
      3,
      1,
      3,
      4,
      1,
      4,
      2
    ];
    super(vertices, indices, radius, detail);
    this.type = "OctahedronGeometry";
    this.parameters = {
      radius,
      detail
    };
  }
  static fromJSON(data) {
    return new OctahedronGeometry(data.radius, data.detail);
  }
}
class PlaneGeometry extends BufferGeometry {
  constructor(width = 1, height = 1, widthSegments = 1, heightSegments = 1) {
    super();
    this.type = "PlaneGeometry";
    this.parameters = {
      width,
      height,
      widthSegments,
      heightSegments
    };
    const width_half = width / 2;
    const height_half = height / 2;
    const gridX = Math.floor(widthSegments);
    const gridY = Math.floor(heightSegments);
    const gridX1 = gridX + 1;
    const gridY1 = gridY + 1;
    const segment_width = width / gridX;
    const segment_height = height / gridY;
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    for (let iy = 0; iy < gridY1; iy++) {
      const y = iy * segment_height - height_half;
      for (let ix = 0; ix < gridX1; ix++) {
        const x = ix * segment_width - width_half;
        vertices.push(x, -y, 0);
        normals.push(0, 0, 1);
        uvs.push(ix / gridX);
        uvs.push(1 - iy / gridY);
      }
    }
    for (let iy = 0; iy < gridY; iy++) {
      for (let ix = 0; ix < gridX; ix++) {
        const a = ix + gridX1 * iy;
        const b = ix + gridX1 * (iy + 1);
        const c = ix + 1 + gridX1 * (iy + 1);
        const d = ix + 1 + gridX1 * iy;
        indices.push(a, b, d);
        indices.push(b, c, d);
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
  }
  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }
  static fromJSON(data) {
    return new PlaneGeometry(data.width, data.height, data.widthSegments, data.heightSegments);
  }
}
class RingGeometry extends BufferGeometry {
  constructor(innerRadius = 0.5, outerRadius = 1, thetaSegments = 32, phiSegments = 1, thetaStart = 0, thetaLength = Math.PI * 2) {
    super();
    this.type = "RingGeometry";
    this.parameters = {
      innerRadius,
      outerRadius,
      thetaSegments,
      phiSegments,
      thetaStart,
      thetaLength
    };
    thetaSegments = Math.max(3, thetaSegments);
    phiSegments = Math.max(1, phiSegments);
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    let radius = innerRadius;
    const radiusStep = (outerRadius - innerRadius) / phiSegments;
    const vertex2 = new Vector3$1();
    const uv = new Vector2$1();
    for (let j = 0; j <= phiSegments; j++) {
      for (let i = 0; i <= thetaSegments; i++) {
        const segment = thetaStart + i / thetaSegments * thetaLength;
        vertex2.x = radius * Math.cos(segment);
        vertex2.y = radius * Math.sin(segment);
        vertices.push(vertex2.x, vertex2.y, vertex2.z);
        normals.push(0, 0, 1);
        uv.x = (vertex2.x / outerRadius + 1) / 2;
        uv.y = (vertex2.y / outerRadius + 1) / 2;
        uvs.push(uv.x, uv.y);
      }
      radius += radiusStep;
    }
    for (let j = 0; j < phiSegments; j++) {
      const thetaSegmentLevel = j * (thetaSegments + 1);
      for (let i = 0; i < thetaSegments; i++) {
        const segment = i + thetaSegmentLevel;
        const a = segment;
        const b = segment + thetaSegments + 1;
        const c = segment + thetaSegments + 2;
        const d = segment + 1;
        indices.push(a, b, d);
        indices.push(b, c, d);
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
  }
  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }
  static fromJSON(data) {
    return new RingGeometry(data.innerRadius, data.outerRadius, data.thetaSegments, data.phiSegments, data.thetaStart, data.thetaLength);
  }
}
class ShapeGeometry extends BufferGeometry {
  constructor(shapes = new Shape$1([new Vector2$1(0, 0.5), new Vector2$1(-0.5, -0.5), new Vector2$1(0.5, -0.5)]), curveSegments = 12) {
    super();
    this.type = "ShapeGeometry";
    this.parameters = {
      shapes,
      curveSegments
    };
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    let groupStart = 0;
    let groupCount = 0;
    if (Array.isArray(shapes) === false) {
      addShape(shapes);
    } else {
      for (let i = 0; i < shapes.length; i++) {
        addShape(shapes[i]);
        this.addGroup(groupStart, groupCount, i);
        groupStart += groupCount;
        groupCount = 0;
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    function addShape(shape) {
      const indexOffset = vertices.length / 3;
      const points = shape.extractPoints(curveSegments);
      let shapeVertices = points.shape;
      const shapeHoles = points.holes;
      if (ShapeUtils.isClockWise(shapeVertices) === false) {
        shapeVertices = shapeVertices.reverse();
      }
      for (let i = 0, l = shapeHoles.length; i < l; i++) {
        const shapeHole = shapeHoles[i];
        if (ShapeUtils.isClockWise(shapeHole) === true) {
          shapeHoles[i] = shapeHole.reverse();
        }
      }
      const faces = ShapeUtils.triangulateShape(shapeVertices, shapeHoles);
      for (let i = 0, l = shapeHoles.length; i < l; i++) {
        const shapeHole = shapeHoles[i];
        shapeVertices = shapeVertices.concat(shapeHole);
      }
      for (let i = 0, l = shapeVertices.length; i < l; i++) {
        const vertex2 = shapeVertices[i];
        vertices.push(vertex2.x, vertex2.y, 0);
        normals.push(0, 0, 1);
        uvs.push(vertex2.x, vertex2.y);
      }
      for (let i = 0, l = faces.length; i < l; i++) {
        const face = faces[i];
        const a = face[0] + indexOffset;
        const b = face[1] + indexOffset;
        const c = face[2] + indexOffset;
        indices.push(a, b, c);
        groupCount += 3;
      }
    }
  }
  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    const shapes = this.parameters.shapes;
    return toJSON(shapes, data);
  }
  static fromJSON(data, shapes) {
    const geometryShapes = [];
    for (let j = 0, jl = data.shapes.length; j < jl; j++) {
      const shape = shapes[data.shapes[j]];
      geometryShapes.push(shape);
    }
    return new ShapeGeometry(geometryShapes, data.curveSegments);
  }
}
function toJSON(shapes, data) {
  data.shapes = [];
  if (Array.isArray(shapes)) {
    for (let i = 0, l = shapes.length; i < l; i++) {
      const shape = shapes[i];
      data.shapes.push(shape.uuid);
    }
  } else {
    data.shapes.push(shapes.uuid);
  }
  return data;
}
class SphereGeometry extends BufferGeometry {
  constructor(radius = 1, widthSegments = 32, heightSegments = 16, phiStart = 0, phiLength = Math.PI * 2, thetaStart = 0, thetaLength = Math.PI) {
    super();
    this.type = "SphereGeometry";
    this.parameters = {
      radius,
      widthSegments,
      heightSegments,
      phiStart,
      phiLength,
      thetaStart,
      thetaLength
    };
    widthSegments = Math.max(3, Math.floor(widthSegments));
    heightSegments = Math.max(2, Math.floor(heightSegments));
    const thetaEnd = Math.min(thetaStart + thetaLength, Math.PI);
    let index = 0;
    const grid = [];
    const vertex2 = new Vector3$1();
    const normal = new Vector3$1();
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    for (let iy = 0; iy <= heightSegments; iy++) {
      const verticesRow = [];
      const v = iy / heightSegments;
      let uOffset = 0;
      if (iy === 0 && thetaStart === 0) {
        uOffset = 0.5 / widthSegments;
      } else if (iy === heightSegments && thetaEnd === Math.PI) {
        uOffset = -0.5 / widthSegments;
      }
      for (let ix = 0; ix <= widthSegments; ix++) {
        const u = ix / widthSegments;
        vertex2.x = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
        vertex2.y = radius * Math.cos(thetaStart + v * thetaLength);
        vertex2.z = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
        vertices.push(vertex2.x, vertex2.y, vertex2.z);
        normal.copy(vertex2).normalize();
        normals.push(normal.x, normal.y, normal.z);
        uvs.push(u + uOffset, 1 - v);
        verticesRow.push(index++);
      }
      grid.push(verticesRow);
    }
    for (let iy = 0; iy < heightSegments; iy++) {
      for (let ix = 0; ix < widthSegments; ix++) {
        const a = grid[iy][ix + 1];
        const b = grid[iy][ix];
        const c = grid[iy + 1][ix];
        const d = grid[iy + 1][ix + 1];
        if (iy !== 0 || thetaStart > 0) indices.push(a, b, d);
        if (iy !== heightSegments - 1 || thetaEnd < Math.PI) indices.push(b, c, d);
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
  }
  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }
  static fromJSON(data) {
    return new SphereGeometry(data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength);
  }
}
class TetrahedronGeometry extends PolyhedronGeometry {
  constructor(radius = 1, detail = 0) {
    const vertices = [
      1,
      1,
      1,
      -1,
      -1,
      1,
      -1,
      1,
      -1,
      1,
      -1,
      -1
    ];
    const indices = [
      2,
      1,
      0,
      0,
      3,
      2,
      1,
      3,
      0,
      2,
      3,
      1
    ];
    super(vertices, indices, radius, detail);
    this.type = "TetrahedronGeometry";
    this.parameters = {
      radius,
      detail
    };
  }
  static fromJSON(data) {
    return new TetrahedronGeometry(data.radius, data.detail);
  }
}
class TorusGeometry extends BufferGeometry {
  constructor(radius = 1, tube = 0.4, radialSegments = 12, tubularSegments = 48, arc = Math.PI * 2) {
    super();
    this.type = "TorusGeometry";
    this.parameters = {
      radius,
      tube,
      radialSegments,
      tubularSegments,
      arc
    };
    radialSegments = Math.floor(radialSegments);
    tubularSegments = Math.floor(tubularSegments);
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    const center = new Vector3$1();
    const vertex2 = new Vector3$1();
    const normal = new Vector3$1();
    for (let j = 0; j <= radialSegments; j++) {
      for (let i = 0; i <= tubularSegments; i++) {
        const u = i / tubularSegments * arc;
        const v = j / radialSegments * Math.PI * 2;
        vertex2.x = (radius + tube * Math.cos(v)) * Math.cos(u);
        vertex2.y = (radius + tube * Math.cos(v)) * Math.sin(u);
        vertex2.z = tube * Math.sin(v);
        vertices.push(vertex2.x, vertex2.y, vertex2.z);
        center.x = radius * Math.cos(u);
        center.y = radius * Math.sin(u);
        normal.subVectors(vertex2, center).normalize();
        normals.push(normal.x, normal.y, normal.z);
        uvs.push(i / tubularSegments);
        uvs.push(j / radialSegments);
      }
    }
    for (let j = 1; j <= radialSegments; j++) {
      for (let i = 1; i <= tubularSegments; i++) {
        const a = (tubularSegments + 1) * j + i - 1;
        const b = (tubularSegments + 1) * (j - 1) + i - 1;
        const c = (tubularSegments + 1) * (j - 1) + i;
        const d = (tubularSegments + 1) * j + i;
        indices.push(a, b, d);
        indices.push(b, c, d);
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
  }
  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }
  static fromJSON(data) {
    return new TorusGeometry(data.radius, data.tube, data.radialSegments, data.tubularSegments, data.arc);
  }
}
class TorusKnotGeometry extends BufferGeometry {
  constructor(radius = 1, tube = 0.4, tubularSegments = 64, radialSegments = 8, p = 2, q = 3) {
    super();
    this.type = "TorusKnotGeometry";
    this.parameters = {
      radius,
      tube,
      tubularSegments,
      radialSegments,
      p,
      q
    };
    tubularSegments = Math.floor(tubularSegments);
    radialSegments = Math.floor(radialSegments);
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    const vertex2 = new Vector3$1();
    const normal = new Vector3$1();
    const P1 = new Vector3$1();
    const P2 = new Vector3$1();
    const B = new Vector3$1();
    const T = new Vector3$1();
    const N = new Vector3$1();
    for (let i = 0; i <= tubularSegments; ++i) {
      const u = i / tubularSegments * p * Math.PI * 2;
      calculatePositionOnCurve(u, p, q, radius, P1);
      calculatePositionOnCurve(u + 0.01, p, q, radius, P2);
      T.subVectors(P2, P1);
      N.addVectors(P2, P1);
      B.crossVectors(T, N);
      N.crossVectors(B, T);
      B.normalize();
      N.normalize();
      for (let j = 0; j <= radialSegments; ++j) {
        const v = j / radialSegments * Math.PI * 2;
        const cx = -tube * Math.cos(v);
        const cy = tube * Math.sin(v);
        vertex2.x = P1.x + (cx * N.x + cy * B.x);
        vertex2.y = P1.y + (cx * N.y + cy * B.y);
        vertex2.z = P1.z + (cx * N.z + cy * B.z);
        vertices.push(vertex2.x, vertex2.y, vertex2.z);
        normal.subVectors(vertex2, P1).normalize();
        normals.push(normal.x, normal.y, normal.z);
        uvs.push(i / tubularSegments);
        uvs.push(j / radialSegments);
      }
    }
    for (let j = 1; j <= tubularSegments; j++) {
      for (let i = 1; i <= radialSegments; i++) {
        const a = (radialSegments + 1) * (j - 1) + (i - 1);
        const b = (radialSegments + 1) * j + (i - 1);
        const c = (radialSegments + 1) * j + i;
        const d = (radialSegments + 1) * (j - 1) + i;
        indices.push(a, b, d);
        indices.push(b, c, d);
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    function calculatePositionOnCurve(u, p2, q2, radius2, position) {
      const cu = Math.cos(u);
      const su = Math.sin(u);
      const quOverP = q2 / p2 * u;
      const cs = Math.cos(quOverP);
      position.x = radius2 * (2 + cs) * 0.5 * cu;
      position.y = radius2 * (2 + cs) * su * 0.5;
      position.z = radius2 * Math.sin(quOverP) * 0.5;
    }
  }
  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }
  static fromJSON(data) {
    return new TorusKnotGeometry(data.radius, data.tube, data.tubularSegments, data.radialSegments, data.p, data.q);
  }
}
class TubeGeometry extends BufferGeometry {
  constructor(path = new QuadraticBezierCurve3(new Vector3$1(-1, -1, 0), new Vector3$1(-1, 1, 0), new Vector3$1(1, 1, 0)), tubularSegments = 64, radius = 1, radialSegments = 8, closed = false) {
    super();
    this.type = "TubeGeometry";
    this.parameters = {
      path,
      tubularSegments,
      radius,
      radialSegments,
      closed
    };
    const frames = path.computeFrenetFrames(tubularSegments, closed);
    this.tangents = frames.tangents;
    this.normals = frames.normals;
    this.binormals = frames.binormals;
    const vertex2 = new Vector3$1();
    const normal = new Vector3$1();
    const uv = new Vector2$1();
    let P = new Vector3$1();
    const vertices = [];
    const normals = [];
    const uvs = [];
    const indices = [];
    generateBufferData();
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    function generateBufferData() {
      for (let i = 0; i < tubularSegments; i++) {
        generateSegment(i);
      }
      generateSegment(closed === false ? tubularSegments : 0);
      generateUVs();
      generateIndices();
    }
    function generateSegment(i) {
      P = path.getPointAt(i / tubularSegments, P);
      const N = frames.normals[i];
      const B = frames.binormals[i];
      for (let j = 0; j <= radialSegments; j++) {
        const v = j / radialSegments * Math.PI * 2;
        const sin2 = Math.sin(v);
        const cos2 = -Math.cos(v);
        normal.x = cos2 * N.x + sin2 * B.x;
        normal.y = cos2 * N.y + sin2 * B.y;
        normal.z = cos2 * N.z + sin2 * B.z;
        normal.normalize();
        normals.push(normal.x, normal.y, normal.z);
        vertex2.x = P.x + radius * normal.x;
        vertex2.y = P.y + radius * normal.y;
        vertex2.z = P.z + radius * normal.z;
        vertices.push(vertex2.x, vertex2.y, vertex2.z);
      }
    }
    function generateIndices() {
      for (let j = 1; j <= tubularSegments; j++) {
        for (let i = 1; i <= radialSegments; i++) {
          const a = (radialSegments + 1) * (j - 1) + (i - 1);
          const b = (radialSegments + 1) * j + (i - 1);
          const c = (radialSegments + 1) * j + i;
          const d = (radialSegments + 1) * (j - 1) + i;
          indices.push(a, b, d);
          indices.push(b, c, d);
        }
      }
    }
    function generateUVs() {
      for (let i = 0; i <= tubularSegments; i++) {
        for (let j = 0; j <= radialSegments; j++) {
          uv.x = i / tubularSegments;
          uv.y = j / radialSegments;
          uvs.push(uv.x, uv.y);
        }
      }
    }
  }
  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.path = this.parameters.path.toJSON();
    return data;
  }
  static fromJSON(data) {
    return new TubeGeometry(
      new Curves[data.path.type]().fromJSON(data.path),
      data.tubularSegments,
      data.radius,
      data.radialSegments,
      data.closed
    );
  }
}
class WireframeGeometry extends BufferGeometry {
  constructor(geometry = null) {
    super();
    this.type = "WireframeGeometry";
    this.parameters = {
      geometry
    };
    if (geometry !== null) {
      const vertices = [];
      const edges = /* @__PURE__ */ new Set();
      const start = new Vector3$1();
      const end = new Vector3$1();
      if (geometry.index !== null) {
        const position = geometry.attributes.position;
        const indices = geometry.index;
        let groups = geometry.groups;
        if (groups.length === 0) {
          groups = [{ start: 0, count: indices.count, materialIndex: 0 }];
        }
        for (let o = 0, ol = groups.length; o < ol; ++o) {
          const group = groups[o];
          const groupStart = group.start;
          const groupCount = group.count;
          for (let i = groupStart, l = groupStart + groupCount; i < l; i += 3) {
            for (let j = 0; j < 3; j++) {
              const index1 = indices.getX(i + j);
              const index2 = indices.getX(i + (j + 1) % 3);
              start.fromBufferAttribute(position, index1);
              end.fromBufferAttribute(position, index2);
              if (isUniqueEdge(start, end, edges) === true) {
                vertices.push(start.x, start.y, start.z);
                vertices.push(end.x, end.y, end.z);
              }
            }
          }
        }
      } else {
        const position = geometry.attributes.position;
        for (let i = 0, l = position.count / 3; i < l; i++) {
          for (let j = 0; j < 3; j++) {
            const index1 = 3 * i + j;
            const index2 = 3 * i + (j + 1) % 3;
            start.fromBufferAttribute(position, index1);
            end.fromBufferAttribute(position, index2);
            if (isUniqueEdge(start, end, edges) === true) {
              vertices.push(start.x, start.y, start.z);
              vertices.push(end.x, end.y, end.z);
            }
          }
        }
      }
      this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    }
  }
  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }
}
function isUniqueEdge(start, end, edges) {
  const hash1 = `${start.x},${start.y},${start.z}-${end.x},${end.y},${end.z}`;
  const hash2 = `${end.x},${end.y},${end.z}-${start.x},${start.y},${start.z}`;
  if (edges.has(hash1) === true || edges.has(hash2) === true) {
    return false;
  } else {
    edges.add(hash1);
    edges.add(hash2);
    return true;
  }
}
var Geometries = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  BoxGeometry,
  CapsuleGeometry,
  CircleGeometry,
  ConeGeometry,
  CylinderGeometry,
  DodecahedronGeometry,
  EdgesGeometry,
  ExtrudeGeometry,
  IcosahedronGeometry,
  LatheGeometry,
  OctahedronGeometry,
  PlaneGeometry,
  PolyhedronGeometry,
  RingGeometry,
  ShapeGeometry,
  SphereGeometry,
  TetrahedronGeometry,
  TorusGeometry,
  TorusKnotGeometry,
  TubeGeometry,
  WireframeGeometry
});
class ShadowMaterial extends Material {
  constructor(parameters) {
    super();
    this.isShadowMaterial = true;
    this.type = "ShadowMaterial";
    this.color = new Color$1(0);
    this.transparent = true;
    this.fog = true;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.fog = source.fog;
    return this;
  }
}
class RawShaderMaterial extends ShaderMaterial {
  constructor(parameters) {
    super(parameters);
    this.isRawShaderMaterial = true;
    this.type = "RawShaderMaterial";
  }
}
class MeshStandardMaterial extends Material {
  constructor(parameters) {
    super();
    this.isMeshStandardMaterial = true;
    this.type = "MeshStandardMaterial";
    this.defines = { "STANDARD": "" };
    this.color = new Color$1(16777215);
    this.roughness = 1;
    this.metalness = 0;
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.emissive = new Color$1(0);
    this.emissiveIntensity = 1;
    this.emissiveMap = null;
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2$1(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.roughnessMap = null;
    this.metalnessMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.envMapRotation = new Euler();
    this.envMapIntensity = 1;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.flatShading = false;
    this.fog = true;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.defines = { "STANDARD": "" };
    this.color.copy(source.color);
    this.roughness = source.roughness;
    this.metalness = source.metalness;
    this.map = source.map;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.emissive.copy(source.emissive);
    this.emissiveMap = source.emissiveMap;
    this.emissiveIntensity = source.emissiveIntensity;
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.roughnessMap = source.roughnessMap;
    this.metalnessMap = source.metalnessMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.envMapRotation.copy(source.envMapRotation);
    this.envMapIntensity = source.envMapIntensity;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.flatShading = source.flatShading;
    this.fog = source.fog;
    return this;
  }
}
class MeshPhysicalMaterial extends MeshStandardMaterial {
  constructor(parameters) {
    super();
    this.isMeshPhysicalMaterial = true;
    this.defines = {
      "STANDARD": "",
      "PHYSICAL": ""
    };
    this.type = "MeshPhysicalMaterial";
    this.anisotropyRotation = 0;
    this.anisotropyMap = null;
    this.clearcoatMap = null;
    this.clearcoatRoughness = 0;
    this.clearcoatRoughnessMap = null;
    this.clearcoatNormalScale = new Vector2$1(1, 1);
    this.clearcoatNormalMap = null;
    this.ior = 1.5;
    Object.defineProperty(this, "reflectivity", {
      get: function() {
        return clamp$2(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1);
      },
      set: function(reflectivity) {
        this.ior = (1 + 0.4 * reflectivity) / (1 - 0.4 * reflectivity);
      }
    });
    this.iridescenceMap = null;
    this.iridescenceIOR = 1.3;
    this.iridescenceThicknessRange = [100, 400];
    this.iridescenceThicknessMap = null;
    this.sheenColor = new Color$1(0);
    this.sheenColorMap = null;
    this.sheenRoughness = 1;
    this.sheenRoughnessMap = null;
    this.transmissionMap = null;
    this.thickness = 0;
    this.thicknessMap = null;
    this.attenuationDistance = Infinity;
    this.attenuationColor = new Color$1(1, 1, 1);
    this.specularIntensity = 1;
    this.specularIntensityMap = null;
    this.specularColor = new Color$1(1, 1, 1);
    this.specularColorMap = null;
    this._anisotropy = 0;
    this._clearcoat = 0;
    this._dispersion = 0;
    this._iridescence = 0;
    this._sheen = 0;
    this._transmission = 0;
    this.setValues(parameters);
  }
  get anisotropy() {
    return this._anisotropy;
  }
  set anisotropy(value) {
    if (this._anisotropy > 0 !== value > 0) {
      this.version++;
    }
    this._anisotropy = value;
  }
  get clearcoat() {
    return this._clearcoat;
  }
  set clearcoat(value) {
    if (this._clearcoat > 0 !== value > 0) {
      this.version++;
    }
    this._clearcoat = value;
  }
  get iridescence() {
    return this._iridescence;
  }
  set iridescence(value) {
    if (this._iridescence > 0 !== value > 0) {
      this.version++;
    }
    this._iridescence = value;
  }
  get dispersion() {
    return this._dispersion;
  }
  set dispersion(value) {
    if (this._dispersion > 0 !== value > 0) {
      this.version++;
    }
    this._dispersion = value;
  }
  get sheen() {
    return this._sheen;
  }
  set sheen(value) {
    if (this._sheen > 0 !== value > 0) {
      this.version++;
    }
    this._sheen = value;
  }
  get transmission() {
    return this._transmission;
  }
  set transmission(value) {
    if (this._transmission > 0 !== value > 0) {
      this.version++;
    }
    this._transmission = value;
  }
  copy(source) {
    super.copy(source);
    this.defines = {
      "STANDARD": "",
      "PHYSICAL": ""
    };
    this.anisotropy = source.anisotropy;
    this.anisotropyRotation = source.anisotropyRotation;
    this.anisotropyMap = source.anisotropyMap;
    this.clearcoat = source.clearcoat;
    this.clearcoatMap = source.clearcoatMap;
    this.clearcoatRoughness = source.clearcoatRoughness;
    this.clearcoatRoughnessMap = source.clearcoatRoughnessMap;
    this.clearcoatNormalMap = source.clearcoatNormalMap;
    this.clearcoatNormalScale.copy(source.clearcoatNormalScale);
    this.dispersion = source.dispersion;
    this.ior = source.ior;
    this.iridescence = source.iridescence;
    this.iridescenceMap = source.iridescenceMap;
    this.iridescenceIOR = source.iridescenceIOR;
    this.iridescenceThicknessRange = [...source.iridescenceThicknessRange];
    this.iridescenceThicknessMap = source.iridescenceThicknessMap;
    this.sheen = source.sheen;
    this.sheenColor.copy(source.sheenColor);
    this.sheenColorMap = source.sheenColorMap;
    this.sheenRoughness = source.sheenRoughness;
    this.sheenRoughnessMap = source.sheenRoughnessMap;
    this.transmission = source.transmission;
    this.transmissionMap = source.transmissionMap;
    this.thickness = source.thickness;
    this.thicknessMap = source.thicknessMap;
    this.attenuationDistance = source.attenuationDistance;
    this.attenuationColor.copy(source.attenuationColor);
    this.specularIntensity = source.specularIntensity;
    this.specularIntensityMap = source.specularIntensityMap;
    this.specularColor.copy(source.specularColor);
    this.specularColorMap = source.specularColorMap;
    return this;
  }
}
class MeshPhongMaterial extends Material {
  constructor(parameters) {
    super();
    this.isMeshPhongMaterial = true;
    this.type = "MeshPhongMaterial";
    this.color = new Color$1(16777215);
    this.specular = new Color$1(1118481);
    this.shininess = 30;
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.emissive = new Color$1(0);
    this.emissiveIntensity = 1;
    this.emissiveMap = null;
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2$1(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.specularMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.envMapRotation = new Euler();
    this.combine = MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.flatShading = false;
    this.fog = true;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.specular.copy(source.specular);
    this.shininess = source.shininess;
    this.map = source.map;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.emissive.copy(source.emissive);
    this.emissiveMap = source.emissiveMap;
    this.emissiveIntensity = source.emissiveIntensity;
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.specularMap = source.specularMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.envMapRotation.copy(source.envMapRotation);
    this.combine = source.combine;
    this.reflectivity = source.reflectivity;
    this.refractionRatio = source.refractionRatio;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.flatShading = source.flatShading;
    this.fog = source.fog;
    return this;
  }
}
class MeshToonMaterial extends Material {
  constructor(parameters) {
    super();
    this.isMeshToonMaterial = true;
    this.defines = { "TOON": "" };
    this.type = "MeshToonMaterial";
    this.color = new Color$1(16777215);
    this.map = null;
    this.gradientMap = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.emissive = new Color$1(0);
    this.emissiveIntensity = 1;
    this.emissiveMap = null;
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2$1(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.alphaMap = null;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.fog = true;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.map = source.map;
    this.gradientMap = source.gradientMap;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.emissive.copy(source.emissive);
    this.emissiveMap = source.emissiveMap;
    this.emissiveIntensity = source.emissiveIntensity;
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.alphaMap = source.alphaMap;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.fog = source.fog;
    return this;
  }
}
class MeshNormalMaterial extends Material {
  constructor(parameters) {
    super();
    this.isMeshNormalMaterial = true;
    this.type = "MeshNormalMaterial";
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2$1(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.flatShading = false;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.flatShading = source.flatShading;
    return this;
  }
}
class MeshLambertMaterial extends Material {
  constructor(parameters) {
    super();
    this.isMeshLambertMaterial = true;
    this.type = "MeshLambertMaterial";
    this.color = new Color$1(16777215);
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.emissive = new Color$1(0);
    this.emissiveIntensity = 1;
    this.emissiveMap = null;
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2$1(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.specularMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.envMapRotation = new Euler();
    this.combine = MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.flatShading = false;
    this.fog = true;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.map = source.map;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.emissive.copy(source.emissive);
    this.emissiveMap = source.emissiveMap;
    this.emissiveIntensity = source.emissiveIntensity;
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.specularMap = source.specularMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.envMapRotation.copy(source.envMapRotation);
    this.combine = source.combine;
    this.reflectivity = source.reflectivity;
    this.refractionRatio = source.refractionRatio;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.flatShading = source.flatShading;
    this.fog = source.fog;
    return this;
  }
}
class MeshDepthMaterial extends Material {
  constructor(parameters) {
    super();
    this.isMeshDepthMaterial = true;
    this.type = "MeshDepthMaterial";
    this.depthPacking = BasicDepthPacking;
    this.map = null;
    this.alphaMap = null;
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.depthPacking = source.depthPacking;
    this.map = source.map;
    this.alphaMap = source.alphaMap;
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    return this;
  }
}
class MeshDistanceMaterial extends Material {
  constructor(parameters) {
    super();
    this.isMeshDistanceMaterial = true;
    this.type = "MeshDistanceMaterial";
    this.map = null;
    this.alphaMap = null;
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.map = source.map;
    this.alphaMap = source.alphaMap;
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    return this;
  }
}
class MeshMatcapMaterial extends Material {
  constructor(parameters) {
    super();
    this.isMeshMatcapMaterial = true;
    this.defines = { "MATCAP": "" };
    this.type = "MeshMatcapMaterial";
    this.color = new Color$1(16777215);
    this.matcap = null;
    this.map = null;
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2$1(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.alphaMap = null;
    this.flatShading = false;
    this.fog = true;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.defines = { "MATCAP": "" };
    this.color.copy(source.color);
    this.matcap = source.matcap;
    this.map = source.map;
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.alphaMap = source.alphaMap;
    this.flatShading = source.flatShading;
    this.fog = source.fog;
    return this;
  }
}
class LineDashedMaterial extends LineBasicMaterial {
  constructor(parameters) {
    super();
    this.isLineDashedMaterial = true;
    this.type = "LineDashedMaterial";
    this.scale = 1;
    this.dashSize = 3;
    this.gapSize = 1;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.scale = source.scale;
    this.dashSize = source.dashSize;
    this.gapSize = source.gapSize;
    return this;
  }
}
function convertArray(array, type, forceClone) {
  if (!array || // let 'undefined' and 'null' pass
  !forceClone && array.constructor === type) return array;
  if (typeof type.BYTES_PER_ELEMENT === "number") {
    return new type(array);
  }
  return Array.prototype.slice.call(array);
}
function isTypedArray(object) {
  return ArrayBuffer.isView(object) && !(object instanceof DataView);
}
function getKeyframeOrder(times) {
  function compareTime(i, j) {
    return times[i] - times[j];
  }
  const n = times.length;
  const result = new Array(n);
  for (let i = 0; i !== n; ++i) result[i] = i;
  result.sort(compareTime);
  return result;
}
function sortedArray(values, stride, order) {
  const nValues = values.length;
  const result = new values.constructor(nValues);
  for (let i = 0, dstOffset = 0; dstOffset !== nValues; ++i) {
    const srcOffset = order[i] * stride;
    for (let j = 0; j !== stride; ++j) {
      result[dstOffset++] = values[srcOffset + j];
    }
  }
  return result;
}
function flattenJSON(jsonKeys, times, values, valuePropertyName) {
  let i = 1, key = jsonKeys[0];
  while (key !== void 0 && key[valuePropertyName] === void 0) {
    key = jsonKeys[i++];
  }
  if (key === void 0) return;
  let value = key[valuePropertyName];
  if (value === void 0) return;
  if (Array.isArray(value)) {
    do {
      value = key[valuePropertyName];
      if (value !== void 0) {
        times.push(key.time);
        values.push.apply(values, value);
      }
      key = jsonKeys[i++];
    } while (key !== void 0);
  } else if (value.toArray !== void 0) {
    do {
      value = key[valuePropertyName];
      if (value !== void 0) {
        times.push(key.time);
        value.toArray(values, values.length);
      }
      key = jsonKeys[i++];
    } while (key !== void 0);
  } else {
    do {
      value = key[valuePropertyName];
      if (value !== void 0) {
        times.push(key.time);
        values.push(value);
      }
      key = jsonKeys[i++];
    } while (key !== void 0);
  }
}
function subclip(sourceClip, name, startFrame, endFrame, fps = 30) {
  const clip = sourceClip.clone();
  clip.name = name;
  const tracks = [];
  for (let i = 0; i < clip.tracks.length; ++i) {
    const track = clip.tracks[i];
    const valueSize = track.getValueSize();
    const times = [];
    const values = [];
    for (let j = 0; j < track.times.length; ++j) {
      const frame = track.times[j] * fps;
      if (frame < startFrame || frame >= endFrame) continue;
      times.push(track.times[j]);
      for (let k = 0; k < valueSize; ++k) {
        values.push(track.values[j * valueSize + k]);
      }
    }
    if (times.length === 0) continue;
    track.times = convertArray(times, track.times.constructor);
    track.values = convertArray(values, track.values.constructor);
    tracks.push(track);
  }
  clip.tracks = tracks;
  let minStartTime = Infinity;
  for (let i = 0; i < clip.tracks.length; ++i) {
    if (minStartTime > clip.tracks[i].times[0]) {
      minStartTime = clip.tracks[i].times[0];
    }
  }
  for (let i = 0; i < clip.tracks.length; ++i) {
    clip.tracks[i].shift(-1 * minStartTime);
  }
  clip.resetDuration();
  return clip;
}
function makeClipAdditive(targetClip, referenceFrame = 0, referenceClip = targetClip, fps = 30) {
  if (fps <= 0) fps = 30;
  const numTracks = referenceClip.tracks.length;
  const referenceTime = referenceFrame / fps;
  for (let i = 0; i < numTracks; ++i) {
    const referenceTrack = referenceClip.tracks[i];
    const referenceTrackType = referenceTrack.ValueTypeName;
    if (referenceTrackType === "bool" || referenceTrackType === "string") continue;
    const targetTrack = targetClip.tracks.find(function(track) {
      return track.name === referenceTrack.name && track.ValueTypeName === referenceTrackType;
    });
    if (targetTrack === void 0) continue;
    let referenceOffset = 0;
    const referenceValueSize = referenceTrack.getValueSize();
    if (referenceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {
      referenceOffset = referenceValueSize / 3;
    }
    let targetOffset = 0;
    const targetValueSize = targetTrack.getValueSize();
    if (targetTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {
      targetOffset = targetValueSize / 3;
    }
    const lastIndex = referenceTrack.times.length - 1;
    let referenceValue;
    if (referenceTime <= referenceTrack.times[0]) {
      const startIndex = referenceOffset;
      const endIndex = referenceValueSize - referenceOffset;
      referenceValue = referenceTrack.values.slice(startIndex, endIndex);
    } else if (referenceTime >= referenceTrack.times[lastIndex]) {
      const startIndex = lastIndex * referenceValueSize + referenceOffset;
      const endIndex = startIndex + referenceValueSize - referenceOffset;
      referenceValue = referenceTrack.values.slice(startIndex, endIndex);
    } else {
      const interpolant = referenceTrack.createInterpolant();
      const startIndex = referenceOffset;
      const endIndex = referenceValueSize - referenceOffset;
      interpolant.evaluate(referenceTime);
      referenceValue = interpolant.resultBuffer.slice(startIndex, endIndex);
    }
    if (referenceTrackType === "quaternion") {
      const referenceQuat = new Quaternion$1().fromArray(referenceValue).normalize().conjugate();
      referenceQuat.toArray(referenceValue);
    }
    const numTimes = targetTrack.times.length;
    for (let j = 0; j < numTimes; ++j) {
      const valueStart = j * targetValueSize + targetOffset;
      if (referenceTrackType === "quaternion") {
        Quaternion$1.multiplyQuaternionsFlat(
          targetTrack.values,
          valueStart,
          referenceValue,
          0,
          targetTrack.values,
          valueStart
        );
      } else {
        const valueEnd = targetValueSize - targetOffset * 2;
        for (let k = 0; k < valueEnd; ++k) {
          targetTrack.values[valueStart + k] -= referenceValue[k];
        }
      }
    }
  }
  targetClip.blendMode = AdditiveAnimationBlendMode;
  return targetClip;
}
const AnimationUtils = {
  convertArray,
  isTypedArray,
  getKeyframeOrder,
  sortedArray,
  flattenJSON,
  subclip,
  makeClipAdditive
};
class Interpolant {
  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    this.parameterPositions = parameterPositions;
    this._cachedIndex = 0;
    this.resultBuffer = resultBuffer !== void 0 ? resultBuffer : new sampleValues.constructor(sampleSize);
    this.sampleValues = sampleValues;
    this.valueSize = sampleSize;
    this.settings = null;
    this.DefaultSettings_ = {};
  }
  evaluate(t) {
    const pp = this.parameterPositions;
    let i1 = this._cachedIndex, t1 = pp[i1], t0 = pp[i1 - 1];
    validate_interval: {
      seek: {
        let right;
        linear_scan: {
          forward_scan: if (!(t < t1)) {
            for (let giveUpAt = i1 + 2; ; ) {
              if (t1 === void 0) {
                if (t < t0) break forward_scan;
                i1 = pp.length;
                this._cachedIndex = i1;
                return this.copySampleValue_(i1 - 1);
              }
              if (i1 === giveUpAt) break;
              t0 = t1;
              t1 = pp[++i1];
              if (t < t1) {
                break seek;
              }
            }
            right = pp.length;
            break linear_scan;
          }
          if (!(t >= t0)) {
            const t1global = pp[1];
            if (t < t1global) {
              i1 = 2;
              t0 = t1global;
            }
            for (let giveUpAt = i1 - 2; ; ) {
              if (t0 === void 0) {
                this._cachedIndex = 0;
                return this.copySampleValue_(0);
              }
              if (i1 === giveUpAt) break;
              t1 = t0;
              t0 = pp[--i1 - 1];
              if (t >= t0) {
                break seek;
              }
            }
            right = i1;
            i1 = 0;
            break linear_scan;
          }
          break validate_interval;
        }
        while (i1 < right) {
          const mid = i1 + right >>> 1;
          if (t < pp[mid]) {
            right = mid;
          } else {
            i1 = mid + 1;
          }
        }
        t1 = pp[i1];
        t0 = pp[i1 - 1];
        if (t0 === void 0) {
          this._cachedIndex = 0;
          return this.copySampleValue_(0);
        }
        if (t1 === void 0) {
          i1 = pp.length;
          this._cachedIndex = i1;
          return this.copySampleValue_(i1 - 1);
        }
      }
      this._cachedIndex = i1;
      this.intervalChanged_(i1, t0, t1);
    }
    return this.interpolate_(i1, t0, t, t1);
  }
  getSettings_() {
    return this.settings || this.DefaultSettings_;
  }
  copySampleValue_(index) {
    const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset = index * stride;
    for (let i = 0; i !== stride; ++i) {
      result[i] = values[offset + i];
    }
    return result;
  }
  // Template methods for derived classes:
  interpolate_() {
    throw new Error("call to abstract method");
  }
  intervalChanged_() {
  }
}
class CubicInterpolant extends Interpolant {
  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    super(parameterPositions, sampleValues, sampleSize, resultBuffer);
    this._weightPrev = -0;
    this._offsetPrev = -0;
    this._weightNext = -0;
    this._offsetNext = -0;
    this.DefaultSettings_ = {
      endingStart: ZeroCurvatureEnding,
      endingEnd: ZeroCurvatureEnding
    };
  }
  intervalChanged_(i1, t0, t1) {
    const pp = this.parameterPositions;
    let iPrev = i1 - 2, iNext = i1 + 1, tPrev = pp[iPrev], tNext = pp[iNext];
    if (tPrev === void 0) {
      switch (this.getSettings_().endingStart) {
        case ZeroSlopeEnding:
          iPrev = i1;
          tPrev = 2 * t0 - t1;
          break;
        case WrapAroundEnding:
          iPrev = pp.length - 2;
          tPrev = t0 + pp[iPrev] - pp[iPrev + 1];
          break;
        default:
          iPrev = i1;
          tPrev = t1;
      }
    }
    if (tNext === void 0) {
      switch (this.getSettings_().endingEnd) {
        case ZeroSlopeEnding:
          iNext = i1;
          tNext = 2 * t1 - t0;
          break;
        case WrapAroundEnding:
          iNext = 1;
          tNext = t1 + pp[1] - pp[0];
          break;
        default:
          iNext = i1 - 1;
          tNext = t0;
      }
    }
    const halfDt = (t1 - t0) * 0.5, stride = this.valueSize;
    this._weightPrev = halfDt / (t0 - tPrev);
    this._weightNext = halfDt / (tNext - t1);
    this._offsetPrev = iPrev * stride;
    this._offsetNext = iNext * stride;
  }
  interpolate_(i1, t0, t, t1) {
    const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, o1 = i1 * stride, o0 = o1 - stride, oP = this._offsetPrev, oN = this._offsetNext, wP = this._weightPrev, wN = this._weightNext, p = (t - t0) / (t1 - t0), pp = p * p, ppp = pp * p;
    const sP = -wP * ppp + 2 * wP * pp - wP * p;
    const s0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-0.5 + wP) * p + 1;
    const s1 = (-1 - wN) * ppp + (1.5 + wN) * pp + 0.5 * p;
    const sN = wN * ppp - wN * pp;
    for (let i = 0; i !== stride; ++i) {
      result[i] = sP * values[oP + i] + s0 * values[o0 + i] + s1 * values[o1 + i] + sN * values[oN + i];
    }
    return result;
  }
}
class LinearInterpolant extends Interpolant {
  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    super(parameterPositions, sampleValues, sampleSize, resultBuffer);
  }
  interpolate_(i1, t0, t, t1) {
    const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset1 = i1 * stride, offset0 = offset1 - stride, weight1 = (t - t0) / (t1 - t0), weight0 = 1 - weight1;
    for (let i = 0; i !== stride; ++i) {
      result[i] = values[offset0 + i] * weight0 + values[offset1 + i] * weight1;
    }
    return result;
  }
}
class DiscreteInterpolant extends Interpolant {
  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    super(parameterPositions, sampleValues, sampleSize, resultBuffer);
  }
  interpolate_(i1) {
    return this.copySampleValue_(i1 - 1);
  }
}
class KeyframeTrack {
  constructor(name, times, values, interpolation) {
    if (name === void 0) throw new Error("THREE.KeyframeTrack: track name is undefined");
    if (times === void 0 || times.length === 0) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + name);
    this.name = name;
    this.times = convertArray(times, this.TimeBufferType);
    this.values = convertArray(values, this.ValueBufferType);
    this.setInterpolation(interpolation || this.DefaultInterpolation);
  }
  // Serialization (in static context, because of constructor invocation
  // and automatic invocation of .toJSON):
  static toJSON(track) {
    const trackType = track.constructor;
    let json;
    if (trackType.toJSON !== this.toJSON) {
      json = trackType.toJSON(track);
    } else {
      json = {
        "name": track.name,
        "times": convertArray(track.times, Array),
        "values": convertArray(track.values, Array)
      };
      const interpolation = track.getInterpolation();
      if (interpolation !== track.DefaultInterpolation) {
        json.interpolation = interpolation;
      }
    }
    json.type = track.ValueTypeName;
    return json;
  }
  InterpolantFactoryMethodDiscrete(result) {
    return new DiscreteInterpolant(this.times, this.values, this.getValueSize(), result);
  }
  InterpolantFactoryMethodLinear(result) {
    return new LinearInterpolant(this.times, this.values, this.getValueSize(), result);
  }
  InterpolantFactoryMethodSmooth(result) {
    return new CubicInterpolant(this.times, this.values, this.getValueSize(), result);
  }
  setInterpolation(interpolation) {
    let factoryMethod;
    switch (interpolation) {
      case InterpolateDiscrete:
        factoryMethod = this.InterpolantFactoryMethodDiscrete;
        break;
      case InterpolateLinear:
        factoryMethod = this.InterpolantFactoryMethodLinear;
        break;
      case InterpolateSmooth:
        factoryMethod = this.InterpolantFactoryMethodSmooth;
        break;
    }
    if (factoryMethod === void 0) {
      const message = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
      if (this.createInterpolant === void 0) {
        if (interpolation !== this.DefaultInterpolation) {
          this.setInterpolation(this.DefaultInterpolation);
        } else {
          throw new Error(message);
        }
      }
      console.warn("THREE.KeyframeTrack:", message);
      return this;
    }
    this.createInterpolant = factoryMethod;
    return this;
  }
  getInterpolation() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return InterpolateDiscrete;
      case this.InterpolantFactoryMethodLinear:
        return InterpolateLinear;
      case this.InterpolantFactoryMethodSmooth:
        return InterpolateSmooth;
    }
  }
  getValueSize() {
    return this.values.length / this.times.length;
  }
  // move all keyframes either forwards or backwards in time
  shift(timeOffset) {
    if (timeOffset !== 0) {
      const times = this.times;
      for (let i = 0, n = times.length; i !== n; ++i) {
        times[i] += timeOffset;
      }
    }
    return this;
  }
  // scale all keyframe times by a factor (useful for frame <-> seconds conversions)
  scale(timeScale) {
    if (timeScale !== 1) {
      const times = this.times;
      for (let i = 0, n = times.length; i !== n; ++i) {
        times[i] *= timeScale;
      }
    }
    return this;
  }
  // removes keyframes before and after animation without changing any values within the range [startTime, endTime].
  // IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
  trim(startTime, endTime) {
    const times = this.times, nKeys = times.length;
    let from = 0, to = nKeys - 1;
    while (from !== nKeys && times[from] < startTime) {
      ++from;
    }
    while (to !== -1 && times[to] > endTime) {
      --to;
    }
    ++to;
    if (from !== 0 || to !== nKeys) {
      if (from >= to) {
        to = Math.max(to, 1);
        from = to - 1;
      }
      const stride = this.getValueSize();
      this.times = times.slice(from, to);
      this.values = this.values.slice(from * stride, to * stride);
    }
    return this;
  }
  // ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
  validate() {
    let valid = true;
    const valueSize = this.getValueSize();
    if (valueSize - Math.floor(valueSize) !== 0) {
      console.error("THREE.KeyframeTrack: Invalid value size in track.", this);
      valid = false;
    }
    const times = this.times, values = this.values, nKeys = times.length;
    if (nKeys === 0) {
      console.error("THREE.KeyframeTrack: Track is empty.", this);
      valid = false;
    }
    let prevTime = null;
    for (let i = 0; i !== nKeys; i++) {
      const currTime = times[i];
      if (typeof currTime === "number" && isNaN(currTime)) {
        console.error("THREE.KeyframeTrack: Time is not a valid number.", this, i, currTime);
        valid = false;
        break;
      }
      if (prevTime !== null && prevTime > currTime) {
        console.error("THREE.KeyframeTrack: Out of order keys.", this, i, currTime, prevTime);
        valid = false;
        break;
      }
      prevTime = currTime;
    }
    if (values !== void 0) {
      if (isTypedArray(values)) {
        for (let i = 0, n = values.length; i !== n; ++i) {
          const value = values[i];
          if (isNaN(value)) {
            console.error("THREE.KeyframeTrack: Value is not a valid number.", this, i, value);
            valid = false;
            break;
          }
        }
      }
    }
    return valid;
  }
  // removes equivalent sequential keys as common in morph target sequences
  // (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
  optimize() {
    const times = this.times.slice(), values = this.values.slice(), stride = this.getValueSize(), smoothInterpolation = this.getInterpolation() === InterpolateSmooth, lastIndex = times.length - 1;
    let writeIndex = 1;
    for (let i = 1; i < lastIndex; ++i) {
      let keep = false;
      const time = times[i];
      const timeNext = times[i + 1];
      if (time !== timeNext && (i !== 1 || time !== times[0])) {
        if (!smoothInterpolation) {
          const offset = i * stride, offsetP = offset - stride, offsetN = offset + stride;
          for (let j = 0; j !== stride; ++j) {
            const value = values[offset + j];
            if (value !== values[offsetP + j] || value !== values[offsetN + j]) {
              keep = true;
              break;
            }
          }
        } else {
          keep = true;
        }
      }
      if (keep) {
        if (i !== writeIndex) {
          times[writeIndex] = times[i];
          const readOffset = i * stride, writeOffset = writeIndex * stride;
          for (let j = 0; j !== stride; ++j) {
            values[writeOffset + j] = values[readOffset + j];
          }
        }
        ++writeIndex;
      }
    }
    if (lastIndex > 0) {
      times[writeIndex] = times[lastIndex];
      for (let readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++j) {
        values[writeOffset + j] = values[readOffset + j];
      }
      ++writeIndex;
    }
    if (writeIndex !== times.length) {
      this.times = times.slice(0, writeIndex);
      this.values = values.slice(0, writeIndex * stride);
    } else {
      this.times = times;
      this.values = values;
    }
    return this;
  }
  clone() {
    const times = this.times.slice();
    const values = this.values.slice();
    const TypedKeyframeTrack = this.constructor;
    const track = new TypedKeyframeTrack(this.name, times, values);
    track.createInterpolant = this.createInterpolant;
    return track;
  }
}
KeyframeTrack.prototype.TimeBufferType = Float32Array;
KeyframeTrack.prototype.ValueBufferType = Float32Array;
KeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
class BooleanKeyframeTrack extends KeyframeTrack {
  // No interpolation parameter because only InterpolateDiscrete is valid.
  constructor(name, times, values) {
    super(name, times, values);
  }
}
BooleanKeyframeTrack.prototype.ValueTypeName = "bool";
BooleanKeyframeTrack.prototype.ValueBufferType = Array;
BooleanKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0;
BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
class ColorKeyframeTrack extends KeyframeTrack {
}
ColorKeyframeTrack.prototype.ValueTypeName = "color";
class NumberKeyframeTrack extends KeyframeTrack {
}
NumberKeyframeTrack.prototype.ValueTypeName = "number";
class QuaternionLinearInterpolant extends Interpolant {
  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    super(parameterPositions, sampleValues, sampleSize, resultBuffer);
  }
  interpolate_(i1, t0, t, t1) {
    const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, alpha = (t - t0) / (t1 - t0);
    let offset = i1 * stride;
    for (let end = offset + stride; offset !== end; offset += 4) {
      Quaternion$1.slerpFlat(result, 0, values, offset - stride, values, offset, alpha);
    }
    return result;
  }
}
class QuaternionKeyframeTrack extends KeyframeTrack {
  InterpolantFactoryMethodLinear(result) {
    return new QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), result);
  }
}
QuaternionKeyframeTrack.prototype.ValueTypeName = "quaternion";
QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
class StringKeyframeTrack extends KeyframeTrack {
  // No interpolation parameter because only InterpolateDiscrete is valid.
  constructor(name, times, values) {
    super(name, times, values);
  }
}
StringKeyframeTrack.prototype.ValueTypeName = "string";
StringKeyframeTrack.prototype.ValueBufferType = Array;
StringKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0;
StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
class VectorKeyframeTrack extends KeyframeTrack {
}
VectorKeyframeTrack.prototype.ValueTypeName = "vector";
class AnimationClip {
  constructor(name = "", duration = -1, tracks = [], blendMode = NormalAnimationBlendMode) {
    this.name = name;
    this.tracks = tracks;
    this.duration = duration;
    this.blendMode = blendMode;
    this.uuid = generateUUID$1();
    if (this.duration < 0) {
      this.resetDuration();
    }
  }
  static parse(json) {
    const tracks = [], jsonTracks = json.tracks, frameTime = 1 / (json.fps || 1);
    for (let i = 0, n = jsonTracks.length; i !== n; ++i) {
      tracks.push(parseKeyframeTrack(jsonTracks[i]).scale(frameTime));
    }
    const clip = new this(json.name, json.duration, tracks, json.blendMode);
    clip.uuid = json.uuid;
    return clip;
  }
  static toJSON(clip) {
    const tracks = [], clipTracks = clip.tracks;
    const json = {
      "name": clip.name,
      "duration": clip.duration,
      "tracks": tracks,
      "uuid": clip.uuid,
      "blendMode": clip.blendMode
    };
    for (let i = 0, n = clipTracks.length; i !== n; ++i) {
      tracks.push(KeyframeTrack.toJSON(clipTracks[i]));
    }
    return json;
  }
  static CreateFromMorphTargetSequence(name, morphTargetSequence, fps, noLoop) {
    const numMorphTargets = morphTargetSequence.length;
    const tracks = [];
    for (let i = 0; i < numMorphTargets; i++) {
      let times = [];
      let values = [];
      times.push(
        (i + numMorphTargets - 1) % numMorphTargets,
        i,
        (i + 1) % numMorphTargets
      );
      values.push(0, 1, 0);
      const order = getKeyframeOrder(times);
      times = sortedArray(times, 1, order);
      values = sortedArray(values, 1, order);
      if (!noLoop && times[0] === 0) {
        times.push(numMorphTargets);
        values.push(values[0]);
      }
      tracks.push(
        new NumberKeyframeTrack(
          ".morphTargetInfluences[" + morphTargetSequence[i].name + "]",
          times,
          values
        ).scale(1 / fps)
      );
    }
    return new this(name, -1, tracks);
  }
  static findByName(objectOrClipArray, name) {
    let clipArray = objectOrClipArray;
    if (!Array.isArray(objectOrClipArray)) {
      const o = objectOrClipArray;
      clipArray = o.geometry && o.geometry.animations || o.animations;
    }
    for (let i = 0; i < clipArray.length; i++) {
      if (clipArray[i].name === name) {
        return clipArray[i];
      }
    }
    return null;
  }
  static CreateClipsFromMorphTargetSequences(morphTargets, fps, noLoop) {
    const animationToMorphTargets = {};
    const pattern = /^([\w-]*?)([\d]+)$/;
    for (let i = 0, il = morphTargets.length; i < il; i++) {
      const morphTarget = morphTargets[i];
      const parts = morphTarget.name.match(pattern);
      if (parts && parts.length > 1) {
        const name = parts[1];
        let animationMorphTargets = animationToMorphTargets[name];
        if (!animationMorphTargets) {
          animationToMorphTargets[name] = animationMorphTargets = [];
        }
        animationMorphTargets.push(morphTarget);
      }
    }
    const clips = [];
    for (const name in animationToMorphTargets) {
      clips.push(this.CreateFromMorphTargetSequence(name, animationToMorphTargets[name], fps, noLoop));
    }
    return clips;
  }
  // parse the animation.hierarchy format
  static parseAnimation(animation, bones) {
    if (!animation) {
      console.error("THREE.AnimationClip: No animation in JSONLoader data.");
      return null;
    }
    const addNonemptyTrack = function(trackType, trackName, animationKeys, propertyName, destTracks) {
      if (animationKeys.length !== 0) {
        const times = [];
        const values = [];
        flattenJSON(animationKeys, times, values, propertyName);
        if (times.length !== 0) {
          destTracks.push(new trackType(trackName, times, values));
        }
      }
    };
    const tracks = [];
    const clipName = animation.name || "default";
    const fps = animation.fps || 30;
    const blendMode = animation.blendMode;
    let duration = animation.length || -1;
    const hierarchyTracks = animation.hierarchy || [];
    for (let h = 0; h < hierarchyTracks.length; h++) {
      const animationKeys = hierarchyTracks[h].keys;
      if (!animationKeys || animationKeys.length === 0) continue;
      if (animationKeys[0].morphTargets) {
        const morphTargetNames = {};
        let k;
        for (k = 0; k < animationKeys.length; k++) {
          if (animationKeys[k].morphTargets) {
            for (let m = 0; m < animationKeys[k].morphTargets.length; m++) {
              morphTargetNames[animationKeys[k].morphTargets[m]] = -1;
            }
          }
        }
        for (const morphTargetName in morphTargetNames) {
          const times = [];
          const values = [];
          for (let m = 0; m !== animationKeys[k].morphTargets.length; ++m) {
            const animationKey = animationKeys[k];
            times.push(animationKey.time);
            values.push(animationKey.morphTarget === morphTargetName ? 1 : 0);
          }
          tracks.push(new NumberKeyframeTrack(".morphTargetInfluence[" + morphTargetName + "]", times, values));
        }
        duration = morphTargetNames.length * fps;
      } else {
        const boneName = ".bones[" + bones[h].name + "]";
        addNonemptyTrack(
          VectorKeyframeTrack,
          boneName + ".position",
          animationKeys,
          "pos",
          tracks
        );
        addNonemptyTrack(
          QuaternionKeyframeTrack,
          boneName + ".quaternion",
          animationKeys,
          "rot",
          tracks
        );
        addNonemptyTrack(
          VectorKeyframeTrack,
          boneName + ".scale",
          animationKeys,
          "scl",
          tracks
        );
      }
    }
    if (tracks.length === 0) {
      return null;
    }
    const clip = new this(clipName, duration, tracks, blendMode);
    return clip;
  }
  resetDuration() {
    const tracks = this.tracks;
    let duration = 0;
    for (let i = 0, n = tracks.length; i !== n; ++i) {
      const track = this.tracks[i];
      duration = Math.max(duration, track.times[track.times.length - 1]);
    }
    this.duration = duration;
    return this;
  }
  trim() {
    for (let i = 0; i < this.tracks.length; i++) {
      this.tracks[i].trim(0, this.duration);
    }
    return this;
  }
  validate() {
    let valid = true;
    for (let i = 0; i < this.tracks.length; i++) {
      valid = valid && this.tracks[i].validate();
    }
    return valid;
  }
  optimize() {
    for (let i = 0; i < this.tracks.length; i++) {
      this.tracks[i].optimize();
    }
    return this;
  }
  clone() {
    const tracks = [];
    for (let i = 0; i < this.tracks.length; i++) {
      tracks.push(this.tracks[i].clone());
    }
    return new this.constructor(this.name, this.duration, tracks, this.blendMode);
  }
  toJSON() {
    return this.constructor.toJSON(this);
  }
}
function getTrackTypeForValueTypeName(typeName) {
  switch (typeName.toLowerCase()) {
    case "scalar":
    case "double":
    case "float":
    case "number":
    case "integer":
      return NumberKeyframeTrack;
    case "vector":
    case "vector2":
    case "vector3":
    case "vector4":
      return VectorKeyframeTrack;
    case "color":
      return ColorKeyframeTrack;
    case "quaternion":
      return QuaternionKeyframeTrack;
    case "bool":
    case "boolean":
      return BooleanKeyframeTrack;
    case "string":
      return StringKeyframeTrack;
  }
  throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + typeName);
}
function parseKeyframeTrack(json) {
  if (json.type === void 0) {
    throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
  }
  const trackType = getTrackTypeForValueTypeName(json.type);
  if (json.times === void 0) {
    const times = [], values = [];
    flattenJSON(json.keys, times, values, "value");
    json.times = times;
    json.values = values;
  }
  if (trackType.parse !== void 0) {
    return trackType.parse(json);
  } else {
    return new trackType(json.name, json.times, json.values, json.interpolation);
  }
}
const Cache = {
  enabled: false,
  files: {},
  add: function(key, file) {
    if (this.enabled === false) return;
    this.files[key] = file;
  },
  get: function(key) {
    if (this.enabled === false) return;
    return this.files[key];
  },
  remove: function(key) {
    delete this.files[key];
  },
  clear: function() {
    this.files = {};
  }
};
class LoadingManager {
  constructor(onLoad, onProgress, onError) {
    const scope = this;
    let isLoading = false;
    let itemsLoaded = 0;
    let itemsTotal = 0;
    let urlModifier = void 0;
    const handlers = [];
    this.onStart = void 0;
    this.onLoad = onLoad;
    this.onProgress = onProgress;
    this.onError = onError;
    this.itemStart = function(url) {
      itemsTotal++;
      if (isLoading === false) {
        if (scope.onStart !== void 0) {
          scope.onStart(url, itemsLoaded, itemsTotal);
        }
      }
      isLoading = true;
    };
    this.itemEnd = function(url) {
      itemsLoaded++;
      if (scope.onProgress !== void 0) {
        scope.onProgress(url, itemsLoaded, itemsTotal);
      }
      if (itemsLoaded === itemsTotal) {
        isLoading = false;
        if (scope.onLoad !== void 0) {
          scope.onLoad();
        }
      }
    };
    this.itemError = function(url) {
      if (scope.onError !== void 0) {
        scope.onError(url);
      }
    };
    this.resolveURL = function(url) {
      if (urlModifier) {
        return urlModifier(url);
      }
      return url;
    };
    this.setURLModifier = function(transform) {
      urlModifier = transform;
      return this;
    };
    this.addHandler = function(regex, loader) {
      handlers.push(regex, loader);
      return this;
    };
    this.removeHandler = function(regex) {
      const index = handlers.indexOf(regex);
      if (index !== -1) {
        handlers.splice(index, 2);
      }
      return this;
    };
    this.getHandler = function(file) {
      for (let i = 0, l = handlers.length; i < l; i += 2) {
        const regex = handlers[i];
        const loader = handlers[i + 1];
        if (regex.global) regex.lastIndex = 0;
        if (regex.test(file)) {
          return loader;
        }
      }
      return null;
    };
  }
}
const DefaultLoadingManager = /* @__PURE__ */ new LoadingManager();
class Loader {
  constructor(manager) {
    this.manager = manager !== void 0 ? manager : DefaultLoadingManager;
    this.crossOrigin = "anonymous";
    this.withCredentials = false;
    this.path = "";
    this.resourcePath = "";
    this.requestHeader = {};
  }
  load() {
  }
  loadAsync(url, onProgress) {
    const scope = this;
    return new Promise(function(resolve, reject) {
      scope.load(url, resolve, onProgress, reject);
    });
  }
  parse() {
  }
  setCrossOrigin(crossOrigin) {
    this.crossOrigin = crossOrigin;
    return this;
  }
  setWithCredentials(value) {
    this.withCredentials = value;
    return this;
  }
  setPath(path) {
    this.path = path;
    return this;
  }
  setResourcePath(resourcePath) {
    this.resourcePath = resourcePath;
    return this;
  }
  setRequestHeader(requestHeader) {
    this.requestHeader = requestHeader;
    return this;
  }
}
Loader.DEFAULT_MATERIAL_NAME = "__DEFAULT";
const loading = {};
class HttpError extends Error {
  constructor(message, response) {
    super(message);
    this.response = response;
  }
}
class FileLoader extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    if (url === void 0) url = "";
    if (this.path !== void 0) url = this.path + url;
    url = this.manager.resolveURL(url);
    const cached = Cache.get(url);
    if (cached !== void 0) {
      this.manager.itemStart(url);
      setTimeout(() => {
        if (onLoad) onLoad(cached);
        this.manager.itemEnd(url);
      }, 0);
      return cached;
    }
    if (loading[url] !== void 0) {
      loading[url].push({
        onLoad,
        onProgress,
        onError
      });
      return;
    }
    loading[url] = [];
    loading[url].push({
      onLoad,
      onProgress,
      onError
    });
    const req = new Request(url, {
      headers: new Headers(this.requestHeader),
      credentials: this.withCredentials ? "include" : "same-origin"
      // An abort controller could be added within a future PR
    });
    const mimeType = this.mimeType;
    const responseType = this.responseType;
    fetch(req).then((response) => {
      if (response.status === 200 || response.status === 0) {
        if (response.status === 0) {
          console.warn("THREE.FileLoader: HTTP Status 0 received.");
        }
        if (typeof ReadableStream === "undefined" || response.body === void 0 || response.body.getReader === void 0) {
          return response;
        }
        const callbacks = loading[url];
        const reader = response.body.getReader();
        const contentLength = response.headers.get("X-File-Size") || response.headers.get("Content-Length");
        const total = contentLength ? parseInt(contentLength) : 0;
        const lengthComputable = total !== 0;
        let loaded = 0;
        const stream = new ReadableStream({
          start(controller) {
            readData();
            function readData() {
              reader.read().then(({ done, value }) => {
                if (done) {
                  controller.close();
                } else {
                  loaded += value.byteLength;
                  const event = new ProgressEvent("progress", { lengthComputable, loaded, total });
                  for (let i = 0, il = callbacks.length; i < il; i++) {
                    const callback = callbacks[i];
                    if (callback.onProgress) callback.onProgress(event);
                  }
                  controller.enqueue(value);
                  readData();
                }
              }, (e) => {
                controller.error(e);
              });
            }
          }
        });
        return new Response(stream);
      } else {
        throw new HttpError(`fetch for "${response.url}" responded with ${response.status}: ${response.statusText}`, response);
      }
    }).then((response) => {
      switch (responseType) {
        case "arraybuffer":
          return response.arrayBuffer();
        case "blob":
          return response.blob();
        case "document":
          return response.text().then((text) => {
            const parser = new DOMParser();
            return parser.parseFromString(text, mimeType);
          });
        case "json":
          return response.json();
        default:
          if (mimeType === void 0) {
            return response.text();
          } else {
            const re = /charset="?([^;"\s]*)"?/i;
            const exec = re.exec(mimeType);
            const label2 = exec && exec[1] ? exec[1].toLowerCase() : void 0;
            const decoder = new TextDecoder(label2);
            return response.arrayBuffer().then((ab) => decoder.decode(ab));
          }
      }
    }).then((data) => {
      Cache.add(url, data);
      const callbacks = loading[url];
      delete loading[url];
      for (let i = 0, il = callbacks.length; i < il; i++) {
        const callback = callbacks[i];
        if (callback.onLoad) callback.onLoad(data);
      }
    }).catch((err) => {
      const callbacks = loading[url];
      if (callbacks === void 0) {
        this.manager.itemError(url);
        throw err;
      }
      delete loading[url];
      for (let i = 0, il = callbacks.length; i < il; i++) {
        const callback = callbacks[i];
        if (callback.onError) callback.onError(err);
      }
      this.manager.itemError(url);
    }).finally(() => {
      this.manager.itemEnd(url);
    });
    this.manager.itemStart(url);
  }
  setResponseType(value) {
    this.responseType = value;
    return this;
  }
  setMimeType(value) {
    this.mimeType = value;
    return this;
  }
}
class AnimationLoader extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    const scope = this;
    const loader = new FileLoader(this.manager);
    loader.setPath(this.path);
    loader.setRequestHeader(this.requestHeader);
    loader.setWithCredentials(this.withCredentials);
    loader.load(url, function(text) {
      try {
        onLoad(scope.parse(JSON.parse(text)));
      } catch (e) {
        if (onError) {
          onError(e);
        } else {
          console.error(e);
        }
        scope.manager.itemError(url);
      }
    }, onProgress, onError);
  }
  parse(json) {
    const animations = [];
    for (let i = 0; i < json.length; i++) {
      const clip = AnimationClip.parse(json[i]);
      animations.push(clip);
    }
    return animations;
  }
}
class CompressedTextureLoader extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    const scope = this;
    const images = [];
    const texture = new CompressedTexture();
    const loader = new FileLoader(this.manager);
    loader.setPath(this.path);
    loader.setResponseType("arraybuffer");
    loader.setRequestHeader(this.requestHeader);
    loader.setWithCredentials(scope.withCredentials);
    let loaded = 0;
    function loadTexture(i) {
      loader.load(url[i], function(buffer) {
        const texDatas = scope.parse(buffer, true);
        images[i] = {
          width: texDatas.width,
          height: texDatas.height,
          format: texDatas.format,
          mipmaps: texDatas.mipmaps
        };
        loaded += 1;
        if (loaded === 6) {
          if (texDatas.mipmapCount === 1) texture.minFilter = LinearFilter;
          texture.image = images;
          texture.format = texDatas.format;
          texture.needsUpdate = true;
          if (onLoad) onLoad(texture);
        }
      }, onProgress, onError);
    }
    if (Array.isArray(url)) {
      for (let i = 0, il = url.length; i < il; ++i) {
        loadTexture(i);
      }
    } else {
      loader.load(url, function(buffer) {
        const texDatas = scope.parse(buffer, true);
        if (texDatas.isCubemap) {
          const faces = texDatas.mipmaps.length / texDatas.mipmapCount;
          for (let f = 0; f < faces; f++) {
            images[f] = { mipmaps: [] };
            for (let i = 0; i < texDatas.mipmapCount; i++) {
              images[f].mipmaps.push(texDatas.mipmaps[f * texDatas.mipmapCount + i]);
              images[f].format = texDatas.format;
              images[f].width = texDatas.width;
              images[f].height = texDatas.height;
            }
          }
          texture.image = images;
        } else {
          texture.image.width = texDatas.width;
          texture.image.height = texDatas.height;
          texture.mipmaps = texDatas.mipmaps;
        }
        if (texDatas.mipmapCount === 1) {
          texture.minFilter = LinearFilter;
        }
        texture.format = texDatas.format;
        texture.needsUpdate = true;
        if (onLoad) onLoad(texture);
      }, onProgress, onError);
    }
    return texture;
  }
}
class ImageLoader extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    if (this.path !== void 0) url = this.path + url;
    url = this.manager.resolveURL(url);
    const scope = this;
    const cached = Cache.get(url);
    if (cached !== void 0) {
      scope.manager.itemStart(url);
      setTimeout(function() {
        if (onLoad) onLoad(cached);
        scope.manager.itemEnd(url);
      }, 0);
      return cached;
    }
    const image = createElementNS("img");
    function onImageLoad() {
      removeEventListeners();
      Cache.add(url, this);
      if (onLoad) onLoad(this);
      scope.manager.itemEnd(url);
    }
    function onImageError(event) {
      removeEventListeners();
      if (onError) onError(event);
      scope.manager.itemError(url);
      scope.manager.itemEnd(url);
    }
    function removeEventListeners() {
      image.removeEventListener("load", onImageLoad, false);
      image.removeEventListener("error", onImageError, false);
    }
    image.addEventListener("load", onImageLoad, false);
    image.addEventListener("error", onImageError, false);
    if (url.slice(0, 5) !== "data:") {
      if (this.crossOrigin !== void 0) image.crossOrigin = this.crossOrigin;
    }
    scope.manager.itemStart(url);
    image.src = url;
    return image;
  }
}
class CubeTextureLoader extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(urls, onLoad, onProgress, onError) {
    const texture = new CubeTexture();
    texture.colorSpace = SRGBColorSpace$1;
    const loader = new ImageLoader(this.manager);
    loader.setCrossOrigin(this.crossOrigin);
    loader.setPath(this.path);
    let loaded = 0;
    function loadTexture(i) {
      loader.load(urls[i], function(image) {
        texture.images[i] = image;
        loaded++;
        if (loaded === 6) {
          texture.needsUpdate = true;
          if (onLoad) onLoad(texture);
        }
      }, void 0, onError);
    }
    for (let i = 0; i < urls.length; ++i) {
      loadTexture(i);
    }
    return texture;
  }
}
class DataTextureLoader extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    const scope = this;
    const texture = new DataTexture();
    const loader = new FileLoader(this.manager);
    loader.setResponseType("arraybuffer");
    loader.setRequestHeader(this.requestHeader);
    loader.setPath(this.path);
    loader.setWithCredentials(scope.withCredentials);
    loader.load(url, function(buffer) {
      let texData;
      try {
        texData = scope.parse(buffer);
      } catch (error2) {
        if (onError !== void 0) {
          onError(error2);
        } else {
          console.error(error2);
          return;
        }
      }
      if (texData.image !== void 0) {
        texture.image = texData.image;
      } else if (texData.data !== void 0) {
        texture.image.width = texData.width;
        texture.image.height = texData.height;
        texture.image.data = texData.data;
      }
      texture.wrapS = texData.wrapS !== void 0 ? texData.wrapS : ClampToEdgeWrapping;
      texture.wrapT = texData.wrapT !== void 0 ? texData.wrapT : ClampToEdgeWrapping;
      texture.magFilter = texData.magFilter !== void 0 ? texData.magFilter : LinearFilter;
      texture.minFilter = texData.minFilter !== void 0 ? texData.minFilter : LinearFilter;
      texture.anisotropy = texData.anisotropy !== void 0 ? texData.anisotropy : 1;
      if (texData.colorSpace !== void 0) {
        texture.colorSpace = texData.colorSpace;
      }
      if (texData.flipY !== void 0) {
        texture.flipY = texData.flipY;
      }
      if (texData.format !== void 0) {
        texture.format = texData.format;
      }
      if (texData.type !== void 0) {
        texture.type = texData.type;
      }
      if (texData.mipmaps !== void 0) {
        texture.mipmaps = texData.mipmaps;
        texture.minFilter = LinearMipmapLinearFilter;
      }
      if (texData.mipmapCount === 1) {
        texture.minFilter = LinearFilter;
      }
      if (texData.generateMipmaps !== void 0) {
        texture.generateMipmaps = texData.generateMipmaps;
      }
      texture.needsUpdate = true;
      if (onLoad) onLoad(texture, texData);
    }, onProgress, onError);
    return texture;
  }
}
class TextureLoader extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    const texture = new Texture();
    const loader = new ImageLoader(this.manager);
    loader.setCrossOrigin(this.crossOrigin);
    loader.setPath(this.path);
    loader.load(url, function(image) {
      texture.image = image;
      texture.needsUpdate = true;
      if (onLoad !== void 0) {
        onLoad(texture);
      }
    }, onProgress, onError);
    return texture;
  }
}
class Light extends Object3D {
  constructor(color2, intensity = 1) {
    super();
    this.isLight = true;
    this.type = "Light";
    this.color = new Color$1(color2);
    this.intensity = intensity;
  }
  dispose() {
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.color.copy(source.color);
    this.intensity = source.intensity;
    return this;
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    data.object.color = this.color.getHex();
    data.object.intensity = this.intensity;
    if (this.groundColor !== void 0) data.object.groundColor = this.groundColor.getHex();
    if (this.distance !== void 0) data.object.distance = this.distance;
    if (this.angle !== void 0) data.object.angle = this.angle;
    if (this.decay !== void 0) data.object.decay = this.decay;
    if (this.penumbra !== void 0) data.object.penumbra = this.penumbra;
    if (this.shadow !== void 0) data.object.shadow = this.shadow.toJSON();
    if (this.target !== void 0) data.object.target = this.target.uuid;
    return data;
  }
}
class HemisphereLight extends Light {
  constructor(skyColor, groundColor, intensity) {
    super(skyColor, intensity);
    this.isHemisphereLight = true;
    this.type = "HemisphereLight";
    this.position.copy(Object3D.DEFAULT_UP);
    this.updateMatrix();
    this.groundColor = new Color$1(groundColor);
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.groundColor.copy(source.groundColor);
    return this;
  }
}
const _projScreenMatrix$1 = /* @__PURE__ */ new Matrix4$1();
const _lightPositionWorld$1 = /* @__PURE__ */ new Vector3$1();
const _lookTarget$1 = /* @__PURE__ */ new Vector3$1();
class LightShadow {
  constructor(camera) {
    this.camera = camera;
    this.intensity = 1;
    this.bias = 0;
    this.normalBias = 0;
    this.radius = 1;
    this.blurSamples = 8;
    this.mapSize = new Vector2$1(512, 512);
    this.map = null;
    this.mapPass = null;
    this.matrix = new Matrix4$1();
    this.autoUpdate = true;
    this.needsUpdate = false;
    this._frustum = new Frustum();
    this._frameExtents = new Vector2$1(1, 1);
    this._viewportCount = 1;
    this._viewports = [
      new Vector4$1(0, 0, 1, 1)
    ];
  }
  getViewportCount() {
    return this._viewportCount;
  }
  getFrustum() {
    return this._frustum;
  }
  updateMatrices(light) {
    const shadowCamera = this.camera;
    const shadowMatrix = this.matrix;
    _lightPositionWorld$1.setFromMatrixPosition(light.matrixWorld);
    shadowCamera.position.copy(_lightPositionWorld$1);
    _lookTarget$1.setFromMatrixPosition(light.target.matrixWorld);
    shadowCamera.lookAt(_lookTarget$1);
    shadowCamera.updateMatrixWorld();
    _projScreenMatrix$1.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);
    this._frustum.setFromProjectionMatrix(_projScreenMatrix$1);
    shadowMatrix.set(
      0.5,
      0,
      0,
      0.5,
      0,
      0.5,
      0,
      0.5,
      0,
      0,
      0.5,
      0.5,
      0,
      0,
      0,
      1
    );
    shadowMatrix.multiply(_projScreenMatrix$1);
  }
  getViewport(viewportIndex) {
    return this._viewports[viewportIndex];
  }
  getFrameExtents() {
    return this._frameExtents;
  }
  dispose() {
    if (this.map) {
      this.map.dispose();
    }
    if (this.mapPass) {
      this.mapPass.dispose();
    }
  }
  copy(source) {
    this.camera = source.camera.clone();
    this.intensity = source.intensity;
    this.bias = source.bias;
    this.radius = source.radius;
    this.mapSize.copy(source.mapSize);
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const object = {};
    if (this.intensity !== 1) object.intensity = this.intensity;
    if (this.bias !== 0) object.bias = this.bias;
    if (this.normalBias !== 0) object.normalBias = this.normalBias;
    if (this.radius !== 1) object.radius = this.radius;
    if (this.mapSize.x !== 512 || this.mapSize.y !== 512) object.mapSize = this.mapSize.toArray();
    object.camera = this.camera.toJSON(false).object;
    delete object.camera.matrix;
    return object;
  }
}
class SpotLightShadow extends LightShadow {
  constructor() {
    super(new PerspectiveCamera(50, 1, 0.5, 500));
    this.isSpotLightShadow = true;
    this.focus = 1;
  }
  updateMatrices(light) {
    const camera = this.camera;
    const fov2 = RAD2DEG$1 * 2 * light.angle * this.focus;
    const aspect2 = this.mapSize.width / this.mapSize.height;
    const far = light.distance || camera.far;
    if (fov2 !== camera.fov || aspect2 !== camera.aspect || far !== camera.far) {
      camera.fov = fov2;
      camera.aspect = aspect2;
      camera.far = far;
      camera.updateProjectionMatrix();
    }
    super.updateMatrices(light);
  }
  copy(source) {
    super.copy(source);
    this.focus = source.focus;
    return this;
  }
}
class SpotLight extends Light {
  constructor(color2, intensity, distance2 = 0, angle = Math.PI / 3, penumbra = 0, decay = 2) {
    super(color2, intensity);
    this.isSpotLight = true;
    this.type = "SpotLight";
    this.position.copy(Object3D.DEFAULT_UP);
    this.updateMatrix();
    this.target = new Object3D();
    this.distance = distance2;
    this.angle = angle;
    this.penumbra = penumbra;
    this.decay = decay;
    this.map = null;
    this.shadow = new SpotLightShadow();
  }
  get power() {
    return this.intensity * Math.PI;
  }
  set power(power) {
    this.intensity = power / Math.PI;
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.distance = source.distance;
    this.angle = source.angle;
    this.penumbra = source.penumbra;
    this.decay = source.decay;
    this.target = source.target.clone();
    this.shadow = source.shadow.clone();
    return this;
  }
}
const _projScreenMatrix = /* @__PURE__ */ new Matrix4$1();
const _lightPositionWorld = /* @__PURE__ */ new Vector3$1();
const _lookTarget = /* @__PURE__ */ new Vector3$1();
class PointLightShadow extends LightShadow {
  constructor() {
    super(new PerspectiveCamera(90, 1, 0.5, 500));
    this.isPointLightShadow = true;
    this._frameExtents = new Vector2$1(4, 2);
    this._viewportCount = 6;
    this._viewports = [
      // These viewports map a cube-map onto a 2D texture with the
      // following orientation:
      //
      //  xzXZ
      //   y Y
      //
      // X - Positive x direction
      // x - Negative x direction
      // Y - Positive y direction
      // y - Negative y direction
      // Z - Positive z direction
      // z - Negative z direction
      // positive X
      new Vector4$1(2, 1, 1, 1),
      // negative X
      new Vector4$1(0, 1, 1, 1),
      // positive Z
      new Vector4$1(3, 1, 1, 1),
      // negative Z
      new Vector4$1(1, 1, 1, 1),
      // positive Y
      new Vector4$1(3, 0, 1, 1),
      // negative Y
      new Vector4$1(1, 0, 1, 1)
    ];
    this._cubeDirections = [
      new Vector3$1(1, 0, 0),
      new Vector3$1(-1, 0, 0),
      new Vector3$1(0, 0, 1),
      new Vector3$1(0, 0, -1),
      new Vector3$1(0, 1, 0),
      new Vector3$1(0, -1, 0)
    ];
    this._cubeUps = [
      new Vector3$1(0, 1, 0),
      new Vector3$1(0, 1, 0),
      new Vector3$1(0, 1, 0),
      new Vector3$1(0, 1, 0),
      new Vector3$1(0, 0, 1),
      new Vector3$1(0, 0, -1)
    ];
  }
  updateMatrices(light, viewportIndex = 0) {
    const camera = this.camera;
    const shadowMatrix = this.matrix;
    const far = light.distance || camera.far;
    if (far !== camera.far) {
      camera.far = far;
      camera.updateProjectionMatrix();
    }
    _lightPositionWorld.setFromMatrixPosition(light.matrixWorld);
    camera.position.copy(_lightPositionWorld);
    _lookTarget.copy(camera.position);
    _lookTarget.add(this._cubeDirections[viewportIndex]);
    camera.up.copy(this._cubeUps[viewportIndex]);
    camera.lookAt(_lookTarget);
    camera.updateMatrixWorld();
    shadowMatrix.makeTranslation(-_lightPositionWorld.x, -_lightPositionWorld.y, -_lightPositionWorld.z);
    _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
    this._frustum.setFromProjectionMatrix(_projScreenMatrix);
  }
}
class PointLight extends Light {
  constructor(color2, intensity, distance2 = 0, decay = 2) {
    super(color2, intensity);
    this.isPointLight = true;
    this.type = "PointLight";
    this.distance = distance2;
    this.decay = decay;
    this.shadow = new PointLightShadow();
  }
  get power() {
    return this.intensity * 4 * Math.PI;
  }
  set power(power) {
    this.intensity = power / (4 * Math.PI);
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.distance = source.distance;
    this.decay = source.decay;
    this.shadow = source.shadow.clone();
    return this;
  }
}
class OrthographicCamera extends Camera {
  constructor(left = -1, right = 1, top = 1, bottom = -1, near = 0.1, far = 2e3) {
    super();
    this.isOrthographicCamera = true;
    this.type = "OrthographicCamera";
    this.zoom = 1;
    this.view = null;
    this.left = left;
    this.right = right;
    this.top = top;
    this.bottom = bottom;
    this.near = near;
    this.far = far;
    this.updateProjectionMatrix();
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.left = source.left;
    this.right = source.right;
    this.top = source.top;
    this.bottom = source.bottom;
    this.near = source.near;
    this.far = source.far;
    this.zoom = source.zoom;
    this.view = source.view === null ? null : Object.assign({}, source.view);
    return this;
  }
  setViewOffset(fullWidth, fullHeight, x, y, width, height) {
    if (this.view === null) {
      this.view = {
        enabled: true,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1
      };
    }
    this.view.enabled = true;
    this.view.fullWidth = fullWidth;
    this.view.fullHeight = fullHeight;
    this.view.offsetX = x;
    this.view.offsetY = y;
    this.view.width = width;
    this.view.height = height;
    this.updateProjectionMatrix();
  }
  clearViewOffset() {
    if (this.view !== null) {
      this.view.enabled = false;
    }
    this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const dx = (this.right - this.left) / (2 * this.zoom);
    const dy = (this.top - this.bottom) / (2 * this.zoom);
    const cx = (this.right + this.left) / 2;
    const cy = (this.top + this.bottom) / 2;
    let left = cx - dx;
    let right = cx + dx;
    let top = cy + dy;
    let bottom = cy - dy;
    if (this.view !== null && this.view.enabled) {
      const scaleW = (this.right - this.left) / this.view.fullWidth / this.zoom;
      const scaleH = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      left += scaleW * this.view.offsetX;
      right = left + scaleW * this.view.width;
      top -= scaleH * this.view.offsetY;
      bottom = top - scaleH * this.view.height;
    }
    this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far, this.coordinateSystem);
    this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    data.object.zoom = this.zoom;
    data.object.left = this.left;
    data.object.right = this.right;
    data.object.top = this.top;
    data.object.bottom = this.bottom;
    data.object.near = this.near;
    data.object.far = this.far;
    if (this.view !== null) data.object.view = Object.assign({}, this.view);
    return data;
  }
}
class DirectionalLightShadow extends LightShadow {
  constructor() {
    super(new OrthographicCamera(-5, 5, 5, -5, 0.5, 500));
    this.isDirectionalLightShadow = true;
  }
}
class DirectionalLight extends Light {
  constructor(color2, intensity) {
    super(color2, intensity);
    this.isDirectionalLight = true;
    this.type = "DirectionalLight";
    this.position.copy(Object3D.DEFAULT_UP);
    this.updateMatrix();
    this.target = new Object3D();
    this.shadow = new DirectionalLightShadow();
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(source) {
    super.copy(source);
    this.target = source.target.clone();
    this.shadow = source.shadow.clone();
    return this;
  }
}
class AmbientLight extends Light {
  constructor(color2, intensity) {
    super(color2, intensity);
    this.isAmbientLight = true;
    this.type = "AmbientLight";
  }
}
class RectAreaLight extends Light {
  constructor(color2, intensity, width = 10, height = 10) {
    super(color2, intensity);
    this.isRectAreaLight = true;
    this.type = "RectAreaLight";
    this.width = width;
    this.height = height;
  }
  get power() {
    return this.intensity * this.width * this.height * Math.PI;
  }
  set power(power) {
    this.intensity = power / (this.width * this.height * Math.PI);
  }
  copy(source) {
    super.copy(source);
    this.width = source.width;
    this.height = source.height;
    return this;
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    data.object.width = this.width;
    data.object.height = this.height;
    return data;
  }
}
class SphericalHarmonics3 {
  constructor() {
    this.isSphericalHarmonics3 = true;
    this.coefficients = [];
    for (let i = 0; i < 9; i++) {
      this.coefficients.push(new Vector3$1());
    }
  }
  set(coefficients) {
    for (let i = 0; i < 9; i++) {
      this.coefficients[i].copy(coefficients[i]);
    }
    return this;
  }
  zero() {
    for (let i = 0; i < 9; i++) {
      this.coefficients[i].set(0, 0, 0);
    }
    return this;
  }
  // get the radiance in the direction of the normal
  // target is a Vector3
  getAt(normal, target) {
    const x = normal.x, y = normal.y, z = normal.z;
    const coeff = this.coefficients;
    target.copy(coeff[0]).multiplyScalar(0.282095);
    target.addScaledVector(coeff[1], 0.488603 * y);
    target.addScaledVector(coeff[2], 0.488603 * z);
    target.addScaledVector(coeff[3], 0.488603 * x);
    target.addScaledVector(coeff[4], 1.092548 * (x * y));
    target.addScaledVector(coeff[5], 1.092548 * (y * z));
    target.addScaledVector(coeff[6], 0.315392 * (3 * z * z - 1));
    target.addScaledVector(coeff[7], 1.092548 * (x * z));
    target.addScaledVector(coeff[8], 0.546274 * (x * x - y * y));
    return target;
  }
  // get the irradiance (radiance convolved with cosine lobe) in the direction of the normal
  // target is a Vector3
  // https://graphics.stanford.edu/papers/envmap/envmap.pdf
  getIrradianceAt(normal, target) {
    const x = normal.x, y = normal.y, z = normal.z;
    const coeff = this.coefficients;
    target.copy(coeff[0]).multiplyScalar(0.886227);
    target.addScaledVector(coeff[1], 2 * 0.511664 * y);
    target.addScaledVector(coeff[2], 2 * 0.511664 * z);
    target.addScaledVector(coeff[3], 2 * 0.511664 * x);
    target.addScaledVector(coeff[4], 2 * 0.429043 * x * y);
    target.addScaledVector(coeff[5], 2 * 0.429043 * y * z);
    target.addScaledVector(coeff[6], 0.743125 * z * z - 0.247708);
    target.addScaledVector(coeff[7], 2 * 0.429043 * x * z);
    target.addScaledVector(coeff[8], 0.429043 * (x * x - y * y));
    return target;
  }
  add(sh) {
    for (let i = 0; i < 9; i++) {
      this.coefficients[i].add(sh.coefficients[i]);
    }
    return this;
  }
  addScaledSH(sh, s) {
    for (let i = 0; i < 9; i++) {
      this.coefficients[i].addScaledVector(sh.coefficients[i], s);
    }
    return this;
  }
  scale(s) {
    for (let i = 0; i < 9; i++) {
      this.coefficients[i].multiplyScalar(s);
    }
    return this;
  }
  lerp(sh, alpha) {
    for (let i = 0; i < 9; i++) {
      this.coefficients[i].lerp(sh.coefficients[i], alpha);
    }
    return this;
  }
  equals(sh) {
    for (let i = 0; i < 9; i++) {
      if (!this.coefficients[i].equals(sh.coefficients[i])) {
        return false;
      }
    }
    return true;
  }
  copy(sh) {
    return this.set(sh.coefficients);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  fromArray(array, offset = 0) {
    const coefficients = this.coefficients;
    for (let i = 0; i < 9; i++) {
      coefficients[i].fromArray(array, offset + i * 3);
    }
    return this;
  }
  toArray(array = [], offset = 0) {
    const coefficients = this.coefficients;
    for (let i = 0; i < 9; i++) {
      coefficients[i].toArray(array, offset + i * 3);
    }
    return array;
  }
  // evaluate the basis functions
  // shBasis is an Array[ 9 ]
  static getBasisAt(normal, shBasis) {
    const x = normal.x, y = normal.y, z = normal.z;
    shBasis[0] = 0.282095;
    shBasis[1] = 0.488603 * y;
    shBasis[2] = 0.488603 * z;
    shBasis[3] = 0.488603 * x;
    shBasis[4] = 1.092548 * x * y;
    shBasis[5] = 1.092548 * y * z;
    shBasis[6] = 0.315392 * (3 * z * z - 1);
    shBasis[7] = 1.092548 * x * z;
    shBasis[8] = 0.546274 * (x * x - y * y);
  }
}
class LightProbe extends Light {
  constructor(sh = new SphericalHarmonics3(), intensity = 1) {
    super(void 0, intensity);
    this.isLightProbe = true;
    this.sh = sh;
  }
  copy(source) {
    super.copy(source);
    this.sh.copy(source.sh);
    return this;
  }
  fromJSON(json) {
    this.intensity = json.intensity;
    this.sh.fromArray(json.sh);
    return this;
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    data.object.sh = this.sh.toArray();
    return data;
  }
}
class MaterialLoader extends Loader {
  constructor(manager) {
    super(manager);
    this.textures = {};
  }
  load(url, onLoad, onProgress, onError) {
    const scope = this;
    const loader = new FileLoader(scope.manager);
    loader.setPath(scope.path);
    loader.setRequestHeader(scope.requestHeader);
    loader.setWithCredentials(scope.withCredentials);
    loader.load(url, function(text) {
      try {
        onLoad(scope.parse(JSON.parse(text)));
      } catch (e) {
        if (onError) {
          onError(e);
        } else {
          console.error(e);
        }
        scope.manager.itemError(url);
      }
    }, onProgress, onError);
  }
  parse(json) {
    const textures = this.textures;
    function getTexture(name) {
      if (textures[name] === void 0) {
        console.warn("THREE.MaterialLoader: Undefined texture", name);
      }
      return textures[name];
    }
    const material = this.createMaterialFromType(json.type);
    if (json.uuid !== void 0) material.uuid = json.uuid;
    if (json.name !== void 0) material.name = json.name;
    if (json.color !== void 0 && material.color !== void 0) material.color.setHex(json.color);
    if (json.roughness !== void 0) material.roughness = json.roughness;
    if (json.metalness !== void 0) material.metalness = json.metalness;
    if (json.sheen !== void 0) material.sheen = json.sheen;
    if (json.sheenColor !== void 0) material.sheenColor = new Color$1().setHex(json.sheenColor);
    if (json.sheenRoughness !== void 0) material.sheenRoughness = json.sheenRoughness;
    if (json.emissive !== void 0 && material.emissive !== void 0) material.emissive.setHex(json.emissive);
    if (json.specular !== void 0 && material.specular !== void 0) material.specular.setHex(json.specular);
    if (json.specularIntensity !== void 0) material.specularIntensity = json.specularIntensity;
    if (json.specularColor !== void 0 && material.specularColor !== void 0) material.specularColor.setHex(json.specularColor);
    if (json.shininess !== void 0) material.shininess = json.shininess;
    if (json.clearcoat !== void 0) material.clearcoat = json.clearcoat;
    if (json.clearcoatRoughness !== void 0) material.clearcoatRoughness = json.clearcoatRoughness;
    if (json.dispersion !== void 0) material.dispersion = json.dispersion;
    if (json.iridescence !== void 0) material.iridescence = json.iridescence;
    if (json.iridescenceIOR !== void 0) material.iridescenceIOR = json.iridescenceIOR;
    if (json.iridescenceThicknessRange !== void 0) material.iridescenceThicknessRange = json.iridescenceThicknessRange;
    if (json.transmission !== void 0) material.transmission = json.transmission;
    if (json.thickness !== void 0) material.thickness = json.thickness;
    if (json.attenuationDistance !== void 0) material.attenuationDistance = json.attenuationDistance;
    if (json.attenuationColor !== void 0 && material.attenuationColor !== void 0) material.attenuationColor.setHex(json.attenuationColor);
    if (json.anisotropy !== void 0) material.anisotropy = json.anisotropy;
    if (json.anisotropyRotation !== void 0) material.anisotropyRotation = json.anisotropyRotation;
    if (json.fog !== void 0) material.fog = json.fog;
    if (json.flatShading !== void 0) material.flatShading = json.flatShading;
    if (json.blending !== void 0) material.blending = json.blending;
    if (json.combine !== void 0) material.combine = json.combine;
    if (json.side !== void 0) material.side = json.side;
    if (json.shadowSide !== void 0) material.shadowSide = json.shadowSide;
    if (json.opacity !== void 0) material.opacity = json.opacity;
    if (json.transparent !== void 0) material.transparent = json.transparent;
    if (json.alphaTest !== void 0) material.alphaTest = json.alphaTest;
    if (json.alphaHash !== void 0) material.alphaHash = json.alphaHash;
    if (json.depthFunc !== void 0) material.depthFunc = json.depthFunc;
    if (json.depthTest !== void 0) material.depthTest = json.depthTest;
    if (json.depthWrite !== void 0) material.depthWrite = json.depthWrite;
    if (json.colorWrite !== void 0) material.colorWrite = json.colorWrite;
    if (json.blendSrc !== void 0) material.blendSrc = json.blendSrc;
    if (json.blendDst !== void 0) material.blendDst = json.blendDst;
    if (json.blendEquation !== void 0) material.blendEquation = json.blendEquation;
    if (json.blendSrcAlpha !== void 0) material.blendSrcAlpha = json.blendSrcAlpha;
    if (json.blendDstAlpha !== void 0) material.blendDstAlpha = json.blendDstAlpha;
    if (json.blendEquationAlpha !== void 0) material.blendEquationAlpha = json.blendEquationAlpha;
    if (json.blendColor !== void 0 && material.blendColor !== void 0) material.blendColor.setHex(json.blendColor);
    if (json.blendAlpha !== void 0) material.blendAlpha = json.blendAlpha;
    if (json.stencilWriteMask !== void 0) material.stencilWriteMask = json.stencilWriteMask;
    if (json.stencilFunc !== void 0) material.stencilFunc = json.stencilFunc;
    if (json.stencilRef !== void 0) material.stencilRef = json.stencilRef;
    if (json.stencilFuncMask !== void 0) material.stencilFuncMask = json.stencilFuncMask;
    if (json.stencilFail !== void 0) material.stencilFail = json.stencilFail;
    if (json.stencilZFail !== void 0) material.stencilZFail = json.stencilZFail;
    if (json.stencilZPass !== void 0) material.stencilZPass = json.stencilZPass;
    if (json.stencilWrite !== void 0) material.stencilWrite = json.stencilWrite;
    if (json.wireframe !== void 0) material.wireframe = json.wireframe;
    if (json.wireframeLinewidth !== void 0) material.wireframeLinewidth = json.wireframeLinewidth;
    if (json.wireframeLinecap !== void 0) material.wireframeLinecap = json.wireframeLinecap;
    if (json.wireframeLinejoin !== void 0) material.wireframeLinejoin = json.wireframeLinejoin;
    if (json.rotation !== void 0) material.rotation = json.rotation;
    if (json.linewidth !== void 0) material.linewidth = json.linewidth;
    if (json.dashSize !== void 0) material.dashSize = json.dashSize;
    if (json.gapSize !== void 0) material.gapSize = json.gapSize;
    if (json.scale !== void 0) material.scale = json.scale;
    if (json.polygonOffset !== void 0) material.polygonOffset = json.polygonOffset;
    if (json.polygonOffsetFactor !== void 0) material.polygonOffsetFactor = json.polygonOffsetFactor;
    if (json.polygonOffsetUnits !== void 0) material.polygonOffsetUnits = json.polygonOffsetUnits;
    if (json.dithering !== void 0) material.dithering = json.dithering;
    if (json.alphaToCoverage !== void 0) material.alphaToCoverage = json.alphaToCoverage;
    if (json.premultipliedAlpha !== void 0) material.premultipliedAlpha = json.premultipliedAlpha;
    if (json.forceSinglePass !== void 0) material.forceSinglePass = json.forceSinglePass;
    if (json.visible !== void 0) material.visible = json.visible;
    if (json.toneMapped !== void 0) material.toneMapped = json.toneMapped;
    if (json.userData !== void 0) material.userData = json.userData;
    if (json.vertexColors !== void 0) {
      if (typeof json.vertexColors === "number") {
        material.vertexColors = json.vertexColors > 0 ? true : false;
      } else {
        material.vertexColors = json.vertexColors;
      }
    }
    if (json.uniforms !== void 0) {
      for (const name in json.uniforms) {
        const uniform2 = json.uniforms[name];
        material.uniforms[name] = {};
        switch (uniform2.type) {
          case "t":
            material.uniforms[name].value = getTexture(uniform2.value);
            break;
          case "c":
            material.uniforms[name].value = new Color$1().setHex(uniform2.value);
            break;
          case "v2":
            material.uniforms[name].value = new Vector2$1().fromArray(uniform2.value);
            break;
          case "v3":
            material.uniforms[name].value = new Vector3$1().fromArray(uniform2.value);
            break;
          case "v4":
            material.uniforms[name].value = new Vector4$1().fromArray(uniform2.value);
            break;
          case "m3":
            material.uniforms[name].value = new Matrix3$1().fromArray(uniform2.value);
            break;
          case "m4":
            material.uniforms[name].value = new Matrix4$1().fromArray(uniform2.value);
            break;
          default:
            material.uniforms[name].value = uniform2.value;
        }
      }
    }
    if (json.defines !== void 0) material.defines = json.defines;
    if (json.vertexShader !== void 0) material.vertexShader = json.vertexShader;
    if (json.fragmentShader !== void 0) material.fragmentShader = json.fragmentShader;
    if (json.glslVersion !== void 0) material.glslVersion = json.glslVersion;
    if (json.extensions !== void 0) {
      for (const key in json.extensions) {
        material.extensions[key] = json.extensions[key];
      }
    }
    if (json.lights !== void 0) material.lights = json.lights;
    if (json.clipping !== void 0) material.clipping = json.clipping;
    if (json.size !== void 0) material.size = json.size;
    if (json.sizeAttenuation !== void 0) material.sizeAttenuation = json.sizeAttenuation;
    if (json.map !== void 0) material.map = getTexture(json.map);
    if (json.matcap !== void 0) material.matcap = getTexture(json.matcap);
    if (json.alphaMap !== void 0) material.alphaMap = getTexture(json.alphaMap);
    if (json.bumpMap !== void 0) material.bumpMap = getTexture(json.bumpMap);
    if (json.bumpScale !== void 0) material.bumpScale = json.bumpScale;
    if (json.normalMap !== void 0) material.normalMap = getTexture(json.normalMap);
    if (json.normalMapType !== void 0) material.normalMapType = json.normalMapType;
    if (json.normalScale !== void 0) {
      let normalScale = json.normalScale;
      if (Array.isArray(normalScale) === false) {
        normalScale = [normalScale, normalScale];
      }
      material.normalScale = new Vector2$1().fromArray(normalScale);
    }
    if (json.displacementMap !== void 0) material.displacementMap = getTexture(json.displacementMap);
    if (json.displacementScale !== void 0) material.displacementScale = json.displacementScale;
    if (json.displacementBias !== void 0) material.displacementBias = json.displacementBias;
    if (json.roughnessMap !== void 0) material.roughnessMap = getTexture(json.roughnessMap);
    if (json.metalnessMap !== void 0) material.metalnessMap = getTexture(json.metalnessMap);
    if (json.emissiveMap !== void 0) material.emissiveMap = getTexture(json.emissiveMap);
    if (json.emissiveIntensity !== void 0) material.emissiveIntensity = json.emissiveIntensity;
    if (json.specularMap !== void 0) material.specularMap = getTexture(json.specularMap);
    if (json.specularIntensityMap !== void 0) material.specularIntensityMap = getTexture(json.specularIntensityMap);
    if (json.specularColorMap !== void 0) material.specularColorMap = getTexture(json.specularColorMap);
    if (json.envMap !== void 0) material.envMap = getTexture(json.envMap);
    if (json.envMapRotation !== void 0) material.envMapRotation.fromArray(json.envMapRotation);
    if (json.envMapIntensity !== void 0) material.envMapIntensity = json.envMapIntensity;
    if (json.reflectivity !== void 0) material.reflectivity = json.reflectivity;
    if (json.refractionRatio !== void 0) material.refractionRatio = json.refractionRatio;
    if (json.lightMap !== void 0) material.lightMap = getTexture(json.lightMap);
    if (json.lightMapIntensity !== void 0) material.lightMapIntensity = json.lightMapIntensity;
    if (json.aoMap !== void 0) material.aoMap = getTexture(json.aoMap);
    if (json.aoMapIntensity !== void 0) material.aoMapIntensity = json.aoMapIntensity;
    if (json.gradientMap !== void 0) material.gradientMap = getTexture(json.gradientMap);
    if (json.clearcoatMap !== void 0) material.clearcoatMap = getTexture(json.clearcoatMap);
    if (json.clearcoatRoughnessMap !== void 0) material.clearcoatRoughnessMap = getTexture(json.clearcoatRoughnessMap);
    if (json.clearcoatNormalMap !== void 0) material.clearcoatNormalMap = getTexture(json.clearcoatNormalMap);
    if (json.clearcoatNormalScale !== void 0) material.clearcoatNormalScale = new Vector2$1().fromArray(json.clearcoatNormalScale);
    if (json.iridescenceMap !== void 0) material.iridescenceMap = getTexture(json.iridescenceMap);
    if (json.iridescenceThicknessMap !== void 0) material.iridescenceThicknessMap = getTexture(json.iridescenceThicknessMap);
    if (json.transmissionMap !== void 0) material.transmissionMap = getTexture(json.transmissionMap);
    if (json.thicknessMap !== void 0) material.thicknessMap = getTexture(json.thicknessMap);
    if (json.anisotropyMap !== void 0) material.anisotropyMap = getTexture(json.anisotropyMap);
    if (json.sheenColorMap !== void 0) material.sheenColorMap = getTexture(json.sheenColorMap);
    if (json.sheenRoughnessMap !== void 0) material.sheenRoughnessMap = getTexture(json.sheenRoughnessMap);
    return material;
  }
  setTextures(value) {
    this.textures = value;
    return this;
  }
  createMaterialFromType(type) {
    return MaterialLoader.createMaterialFromType(type);
  }
  static createMaterialFromType(type) {
    const materialLib = {
      ShadowMaterial,
      SpriteMaterial,
      RawShaderMaterial,
      ShaderMaterial,
      PointsMaterial,
      MeshPhysicalMaterial,
      MeshStandardMaterial,
      MeshPhongMaterial,
      MeshToonMaterial,
      MeshNormalMaterial,
      MeshLambertMaterial,
      MeshDepthMaterial,
      MeshDistanceMaterial,
      MeshBasicMaterial,
      MeshMatcapMaterial,
      LineDashedMaterial,
      LineBasicMaterial,
      Material
    };
    return new materialLib[type]();
  }
}
class LoaderUtils {
  static decodeText(array) {
    console.warn("THREE.LoaderUtils: decodeText() has been deprecated with r165 and will be removed with r175. Use TextDecoder instead.");
    if (typeof TextDecoder !== "undefined") {
      return new TextDecoder().decode(array);
    }
    let s = "";
    for (let i = 0, il = array.length; i < il; i++) {
      s += String.fromCharCode(array[i]);
    }
    try {
      return decodeURIComponent(escape(s));
    } catch (e) {
      return s;
    }
  }
  static extractUrlBase(url) {
    const index = url.lastIndexOf("/");
    if (index === -1) return "./";
    return url.slice(0, index + 1);
  }
  static resolveURL(url, path) {
    if (typeof url !== "string" || url === "") return "";
    if (/^https?:\/\//i.test(path) && /^\//.test(url)) {
      path = path.replace(/(^https?:\/\/[^\/]+).*/i, "$1");
    }
    if (/^(https?:)?\/\//i.test(url)) return url;
    if (/^data:.*,.*$/i.test(url)) return url;
    if (/^blob:.*$/i.test(url)) return url;
    return path + url;
  }
}
class InstancedBufferGeometry extends BufferGeometry {
  constructor() {
    super();
    this.isInstancedBufferGeometry = true;
    this.type = "InstancedBufferGeometry";
    this.instanceCount = Infinity;
  }
  copy(source) {
    super.copy(source);
    this.instanceCount = source.instanceCount;
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.instanceCount = this.instanceCount;
    data.isInstancedBufferGeometry = true;
    return data;
  }
}
class BufferGeometryLoader extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    const scope = this;
    const loader = new FileLoader(scope.manager);
    loader.setPath(scope.path);
    loader.setRequestHeader(scope.requestHeader);
    loader.setWithCredentials(scope.withCredentials);
    loader.load(url, function(text) {
      try {
        onLoad(scope.parse(JSON.parse(text)));
      } catch (e) {
        if (onError) {
          onError(e);
        } else {
          console.error(e);
        }
        scope.manager.itemError(url);
      }
    }, onProgress, onError);
  }
  parse(json) {
    const interleavedBufferMap = {};
    const arrayBufferMap = {};
    function getInterleavedBuffer(json2, uuid) {
      if (interleavedBufferMap[uuid] !== void 0) return interleavedBufferMap[uuid];
      const interleavedBuffers = json2.interleavedBuffers;
      const interleavedBuffer = interleavedBuffers[uuid];
      const buffer = getArrayBuffer(json2, interleavedBuffer.buffer);
      const array = getTypedArray(interleavedBuffer.type, buffer);
      const ib = new InterleavedBuffer$1(array, interleavedBuffer.stride);
      ib.uuid = interleavedBuffer.uuid;
      interleavedBufferMap[uuid] = ib;
      return ib;
    }
    function getArrayBuffer(json2, uuid) {
      if (arrayBufferMap[uuid] !== void 0) return arrayBufferMap[uuid];
      const arrayBuffers = json2.arrayBuffers;
      const arrayBuffer = arrayBuffers[uuid];
      const ab = new Uint32Array(arrayBuffer).buffer;
      arrayBufferMap[uuid] = ab;
      return ab;
    }
    const geometry = json.isInstancedBufferGeometry ? new InstancedBufferGeometry() : new BufferGeometry();
    const index = json.data.index;
    if (index !== void 0) {
      const typedArray = getTypedArray(index.type, index.array);
      geometry.setIndex(new BufferAttribute$1(typedArray, 1));
    }
    const attributes = json.data.attributes;
    for (const key in attributes) {
      const attribute = attributes[key];
      let bufferAttribute2;
      if (attribute.isInterleavedBufferAttribute) {
        const interleavedBuffer = getInterleavedBuffer(json.data, attribute.data);
        bufferAttribute2 = new InterleavedBufferAttribute$1(interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized);
      } else {
        const typedArray = getTypedArray(attribute.type, attribute.array);
        const bufferAttributeConstr = attribute.isInstancedBufferAttribute ? InstancedBufferAttribute : BufferAttribute$1;
        bufferAttribute2 = new bufferAttributeConstr(typedArray, attribute.itemSize, attribute.normalized);
      }
      if (attribute.name !== void 0) bufferAttribute2.name = attribute.name;
      if (attribute.usage !== void 0) bufferAttribute2.setUsage(attribute.usage);
      geometry.setAttribute(key, bufferAttribute2);
    }
    const morphAttributes = json.data.morphAttributes;
    if (morphAttributes) {
      for (const key in morphAttributes) {
        const attributeArray = morphAttributes[key];
        const array = [];
        for (let i = 0, il = attributeArray.length; i < il; i++) {
          const attribute = attributeArray[i];
          let bufferAttribute2;
          if (attribute.isInterleavedBufferAttribute) {
            const interleavedBuffer = getInterleavedBuffer(json.data, attribute.data);
            bufferAttribute2 = new InterleavedBufferAttribute$1(interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized);
          } else {
            const typedArray = getTypedArray(attribute.type, attribute.array);
            bufferAttribute2 = new BufferAttribute$1(typedArray, attribute.itemSize, attribute.normalized);
          }
          if (attribute.name !== void 0) bufferAttribute2.name = attribute.name;
          array.push(bufferAttribute2);
        }
        geometry.morphAttributes[key] = array;
      }
    }
    const morphTargetsRelative = json.data.morphTargetsRelative;
    if (morphTargetsRelative) {
      geometry.morphTargetsRelative = true;
    }
    const groups = json.data.groups || json.data.drawcalls || json.data.offsets;
    if (groups !== void 0) {
      for (let i = 0, n = groups.length; i !== n; ++i) {
        const group = groups[i];
        geometry.addGroup(group.start, group.count, group.materialIndex);
      }
    }
    const boundingSphere = json.data.boundingSphere;
    if (boundingSphere !== void 0) {
      const center = new Vector3$1();
      if (boundingSphere.center !== void 0) {
        center.fromArray(boundingSphere.center);
      }
      geometry.boundingSphere = new Sphere(center, boundingSphere.radius);
    }
    if (json.name) geometry.name = json.name;
    if (json.userData) geometry.userData = json.userData;
    return geometry;
  }
}
class ObjectLoader extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    const scope = this;
    const path = this.path === "" ? LoaderUtils.extractUrlBase(url) : this.path;
    this.resourcePath = this.resourcePath || path;
    const loader = new FileLoader(this.manager);
    loader.setPath(this.path);
    loader.setRequestHeader(this.requestHeader);
    loader.setWithCredentials(this.withCredentials);
    loader.load(url, function(text) {
      let json = null;
      try {
        json = JSON.parse(text);
      } catch (error2) {
        if (onError !== void 0) onError(error2);
        console.error("THREE:ObjectLoader: Can't parse " + url + ".", error2.message);
        return;
      }
      const metadata = json.metadata;
      if (metadata === void 0 || metadata.type === void 0 || metadata.type.toLowerCase() === "geometry") {
        if (onError !== void 0) onError(new Error("THREE.ObjectLoader: Can't load " + url));
        console.error("THREE.ObjectLoader: Can't load " + url);
        return;
      }
      scope.parse(json, onLoad);
    }, onProgress, onError);
  }
  async loadAsync(url, onProgress) {
    const scope = this;
    const path = this.path === "" ? LoaderUtils.extractUrlBase(url) : this.path;
    this.resourcePath = this.resourcePath || path;
    const loader = new FileLoader(this.manager);
    loader.setPath(this.path);
    loader.setRequestHeader(this.requestHeader);
    loader.setWithCredentials(this.withCredentials);
    const text = await loader.loadAsync(url, onProgress);
    const json = JSON.parse(text);
    const metadata = json.metadata;
    if (metadata === void 0 || metadata.type === void 0 || metadata.type.toLowerCase() === "geometry") {
      throw new Error("THREE.ObjectLoader: Can't load " + url);
    }
    return await scope.parseAsync(json);
  }
  parse(json, onLoad) {
    const animations = this.parseAnimations(json.animations);
    const shapes = this.parseShapes(json.shapes);
    const geometries = this.parseGeometries(json.geometries, shapes);
    const images = this.parseImages(json.images, function() {
      if (onLoad !== void 0) onLoad(object);
    });
    const textures = this.parseTextures(json.textures, images);
    const materials = this.parseMaterials(json.materials, textures);
    const object = this.parseObject(json.object, geometries, materials, textures, animations);
    const skeletons = this.parseSkeletons(json.skeletons, object);
    this.bindSkeletons(object, skeletons);
    this.bindLightTargets(object);
    if (onLoad !== void 0) {
      let hasImages = false;
      for (const uuid in images) {
        if (images[uuid].data instanceof HTMLImageElement) {
          hasImages = true;
          break;
        }
      }
      if (hasImages === false) onLoad(object);
    }
    return object;
  }
  async parseAsync(json) {
    const animations = this.parseAnimations(json.animations);
    const shapes = this.parseShapes(json.shapes);
    const geometries = this.parseGeometries(json.geometries, shapes);
    const images = await this.parseImagesAsync(json.images);
    const textures = this.parseTextures(json.textures, images);
    const materials = this.parseMaterials(json.materials, textures);
    const object = this.parseObject(json.object, geometries, materials, textures, animations);
    const skeletons = this.parseSkeletons(json.skeletons, object);
    this.bindSkeletons(object, skeletons);
    this.bindLightTargets(object);
    return object;
  }
  parseShapes(json) {
    const shapes = {};
    if (json !== void 0) {
      for (let i = 0, l = json.length; i < l; i++) {
        const shape = new Shape$1().fromJSON(json[i]);
        shapes[shape.uuid] = shape;
      }
    }
    return shapes;
  }
  parseSkeletons(json, object) {
    const skeletons = {};
    const bones = {};
    object.traverse(function(child) {
      if (child.isBone) bones[child.uuid] = child;
    });
    if (json !== void 0) {
      for (let i = 0, l = json.length; i < l; i++) {
        const skeleton = new Skeleton().fromJSON(json[i], bones);
        skeletons[skeleton.uuid] = skeleton;
      }
    }
    return skeletons;
  }
  parseGeometries(json, shapes) {
    const geometries = {};
    if (json !== void 0) {
      const bufferGeometryLoader = new BufferGeometryLoader();
      for (let i = 0, l = json.length; i < l; i++) {
        let geometry;
        const data = json[i];
        switch (data.type) {
          case "BufferGeometry":
          case "InstancedBufferGeometry":
            geometry = bufferGeometryLoader.parse(data);
            break;
          default:
            if (data.type in Geometries) {
              geometry = Geometries[data.type].fromJSON(data, shapes);
            } else {
              console.warn(`THREE.ObjectLoader: Unsupported geometry type "${data.type}"`);
            }
        }
        geometry.uuid = data.uuid;
        if (data.name !== void 0) geometry.name = data.name;
        if (data.userData !== void 0) geometry.userData = data.userData;
        geometries[data.uuid] = geometry;
      }
    }
    return geometries;
  }
  parseMaterials(json, textures) {
    const cache2 = {};
    const materials = {};
    if (json !== void 0) {
      const loader = new MaterialLoader();
      loader.setTextures(textures);
      for (let i = 0, l = json.length; i < l; i++) {
        const data = json[i];
        if (cache2[data.uuid] === void 0) {
          cache2[data.uuid] = loader.parse(data);
        }
        materials[data.uuid] = cache2[data.uuid];
      }
    }
    return materials;
  }
  parseAnimations(json) {
    const animations = {};
    if (json !== void 0) {
      for (let i = 0; i < json.length; i++) {
        const data = json[i];
        const clip = AnimationClip.parse(data);
        animations[clip.uuid] = clip;
      }
    }
    return animations;
  }
  parseImages(json, onLoad) {
    const scope = this;
    const images = {};
    let loader;
    function loadImage(url) {
      scope.manager.itemStart(url);
      return loader.load(url, function() {
        scope.manager.itemEnd(url);
      }, void 0, function() {
        scope.manager.itemError(url);
        scope.manager.itemEnd(url);
      });
    }
    function deserializeImage(image) {
      if (typeof image === "string") {
        const url = image;
        const path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(url) ? url : scope.resourcePath + url;
        return loadImage(path);
      } else {
        if (image.data) {
          return {
            data: getTypedArray(image.type, image.data),
            width: image.width,
            height: image.height
          };
        } else {
          return null;
        }
      }
    }
    if (json !== void 0 && json.length > 0) {
      const manager = new LoadingManager(onLoad);
      loader = new ImageLoader(manager);
      loader.setCrossOrigin(this.crossOrigin);
      for (let i = 0, il = json.length; i < il; i++) {
        const image = json[i];
        const url = image.url;
        if (Array.isArray(url)) {
          const imageArray = [];
          for (let j = 0, jl = url.length; j < jl; j++) {
            const currentUrl = url[j];
            const deserializedImage = deserializeImage(currentUrl);
            if (deserializedImage !== null) {
              if (deserializedImage instanceof HTMLImageElement) {
                imageArray.push(deserializedImage);
              } else {
                imageArray.push(new DataTexture(deserializedImage.data, deserializedImage.width, deserializedImage.height));
              }
            }
          }
          images[image.uuid] = new Source(imageArray);
        } else {
          const deserializedImage = deserializeImage(image.url);
          images[image.uuid] = new Source(deserializedImage);
        }
      }
    }
    return images;
  }
  async parseImagesAsync(json) {
    const scope = this;
    const images = {};
    let loader;
    async function deserializeImage(image) {
      if (typeof image === "string") {
        const url = image;
        const path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(url) ? url : scope.resourcePath + url;
        return await loader.loadAsync(path);
      } else {
        if (image.data) {
          return {
            data: getTypedArray(image.type, image.data),
            width: image.width,
            height: image.height
          };
        } else {
          return null;
        }
      }
    }
    if (json !== void 0 && json.length > 0) {
      loader = new ImageLoader(this.manager);
      loader.setCrossOrigin(this.crossOrigin);
      for (let i = 0, il = json.length; i < il; i++) {
        const image = json[i];
        const url = image.url;
        if (Array.isArray(url)) {
          const imageArray = [];
          for (let j = 0, jl = url.length; j < jl; j++) {
            const currentUrl = url[j];
            const deserializedImage = await deserializeImage(currentUrl);
            if (deserializedImage !== null) {
              if (deserializedImage instanceof HTMLImageElement) {
                imageArray.push(deserializedImage);
              } else {
                imageArray.push(new DataTexture(deserializedImage.data, deserializedImage.width, deserializedImage.height));
              }
            }
          }
          images[image.uuid] = new Source(imageArray);
        } else {
          const deserializedImage = await deserializeImage(image.url);
          images[image.uuid] = new Source(deserializedImage);
        }
      }
    }
    return images;
  }
  parseTextures(json, images) {
    function parseConstant(value, type) {
      if (typeof value === "number") return value;
      console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", value);
      return type[value];
    }
    const textures = {};
    if (json !== void 0) {
      for (let i = 0, l = json.length; i < l; i++) {
        const data = json[i];
        if (data.image === void 0) {
          console.warn('THREE.ObjectLoader: No "image" specified for', data.uuid);
        }
        if (images[data.image] === void 0) {
          console.warn("THREE.ObjectLoader: Undefined image", data.image);
        }
        const source = images[data.image];
        const image = source.data;
        let texture;
        if (Array.isArray(image)) {
          texture = new CubeTexture();
          if (image.length === 6) texture.needsUpdate = true;
        } else {
          if (image && image.data) {
            texture = new DataTexture();
          } else {
            texture = new Texture();
          }
          if (image) texture.needsUpdate = true;
        }
        texture.source = source;
        texture.uuid = data.uuid;
        if (data.name !== void 0) texture.name = data.name;
        if (data.mapping !== void 0) texture.mapping = parseConstant(data.mapping, TEXTURE_MAPPING);
        if (data.channel !== void 0) texture.channel = data.channel;
        if (data.offset !== void 0) texture.offset.fromArray(data.offset);
        if (data.repeat !== void 0) texture.repeat.fromArray(data.repeat);
        if (data.center !== void 0) texture.center.fromArray(data.center);
        if (data.rotation !== void 0) texture.rotation = data.rotation;
        if (data.wrap !== void 0) {
          texture.wrapS = parseConstant(data.wrap[0], TEXTURE_WRAPPING);
          texture.wrapT = parseConstant(data.wrap[1], TEXTURE_WRAPPING);
        }
        if (data.format !== void 0) texture.format = data.format;
        if (data.internalFormat !== void 0) texture.internalFormat = data.internalFormat;
        if (data.type !== void 0) texture.type = data.type;
        if (data.colorSpace !== void 0) texture.colorSpace = data.colorSpace;
        if (data.minFilter !== void 0) texture.minFilter = parseConstant(data.minFilter, TEXTURE_FILTER);
        if (data.magFilter !== void 0) texture.magFilter = parseConstant(data.magFilter, TEXTURE_FILTER);
        if (data.anisotropy !== void 0) texture.anisotropy = data.anisotropy;
        if (data.flipY !== void 0) texture.flipY = data.flipY;
        if (data.generateMipmaps !== void 0) texture.generateMipmaps = data.generateMipmaps;
        if (data.premultiplyAlpha !== void 0) texture.premultiplyAlpha = data.premultiplyAlpha;
        if (data.unpackAlignment !== void 0) texture.unpackAlignment = data.unpackAlignment;
        if (data.compareFunction !== void 0) texture.compareFunction = data.compareFunction;
        if (data.userData !== void 0) texture.userData = data.userData;
        textures[data.uuid] = texture;
      }
    }
    return textures;
  }
  parseObject(data, geometries, materials, textures, animations) {
    let object;
    function getGeometry(name) {
      if (geometries[name] === void 0) {
        console.warn("THREE.ObjectLoader: Undefined geometry", name);
      }
      return geometries[name];
    }
    function getMaterial(name) {
      if (name === void 0) return void 0;
      if (Array.isArray(name)) {
        const array = [];
        for (let i = 0, l = name.length; i < l; i++) {
          const uuid = name[i];
          if (materials[uuid] === void 0) {
            console.warn("THREE.ObjectLoader: Undefined material", uuid);
          }
          array.push(materials[uuid]);
        }
        return array;
      }
      if (materials[name] === void 0) {
        console.warn("THREE.ObjectLoader: Undefined material", name);
      }
      return materials[name];
    }
    function getTexture(uuid) {
      if (textures[uuid] === void 0) {
        console.warn("THREE.ObjectLoader: Undefined texture", uuid);
      }
      return textures[uuid];
    }
    let geometry, material;
    switch (data.type) {
      case "Scene":
        object = new Scene();
        if (data.background !== void 0) {
          if (Number.isInteger(data.background)) {
            object.background = new Color$1(data.background);
          } else {
            object.background = getTexture(data.background);
          }
        }
        if (data.environment !== void 0) {
          object.environment = getTexture(data.environment);
        }
        if (data.fog !== void 0) {
          if (data.fog.type === "Fog") {
            object.fog = new Fog(data.fog.color, data.fog.near, data.fog.far);
          } else if (data.fog.type === "FogExp2") {
            object.fog = new FogExp2(data.fog.color, data.fog.density);
          }
          if (data.fog.name !== "") {
            object.fog.name = data.fog.name;
          }
        }
        if (data.backgroundBlurriness !== void 0) object.backgroundBlurriness = data.backgroundBlurriness;
        if (data.backgroundIntensity !== void 0) object.backgroundIntensity = data.backgroundIntensity;
        if (data.backgroundRotation !== void 0) object.backgroundRotation.fromArray(data.backgroundRotation);
        if (data.environmentIntensity !== void 0) object.environmentIntensity = data.environmentIntensity;
        if (data.environmentRotation !== void 0) object.environmentRotation.fromArray(data.environmentRotation);
        break;
      case "PerspectiveCamera":
        object = new PerspectiveCamera(data.fov, data.aspect, data.near, data.far);
        if (data.focus !== void 0) object.focus = data.focus;
        if (data.zoom !== void 0) object.zoom = data.zoom;
        if (data.filmGauge !== void 0) object.filmGauge = data.filmGauge;
        if (data.filmOffset !== void 0) object.filmOffset = data.filmOffset;
        if (data.view !== void 0) object.view = Object.assign({}, data.view);
        break;
      case "OrthographicCamera":
        object = new OrthographicCamera(data.left, data.right, data.top, data.bottom, data.near, data.far);
        if (data.zoom !== void 0) object.zoom = data.zoom;
        if (data.view !== void 0) object.view = Object.assign({}, data.view);
        break;
      case "AmbientLight":
        object = new AmbientLight(data.color, data.intensity);
        break;
      case "DirectionalLight":
        object = new DirectionalLight(data.color, data.intensity);
        object.target = data.target || "";
        break;
      case "PointLight":
        object = new PointLight(data.color, data.intensity, data.distance, data.decay);
        break;
      case "RectAreaLight":
        object = new RectAreaLight(data.color, data.intensity, data.width, data.height);
        break;
      case "SpotLight":
        object = new SpotLight(data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay);
        object.target = data.target || "";
        break;
      case "HemisphereLight":
        object = new HemisphereLight(data.color, data.groundColor, data.intensity);
        break;
      case "LightProbe":
        object = new LightProbe().fromJSON(data);
        break;
      case "SkinnedMesh":
        geometry = getGeometry(data.geometry);
        material = getMaterial(data.material);
        object = new SkinnedMesh(geometry, material);
        if (data.bindMode !== void 0) object.bindMode = data.bindMode;
        if (data.bindMatrix !== void 0) object.bindMatrix.fromArray(data.bindMatrix);
        if (data.skeleton !== void 0) object.skeleton = data.skeleton;
        break;
      case "Mesh":
        geometry = getGeometry(data.geometry);
        material = getMaterial(data.material);
        object = new Mesh(geometry, material);
        break;
      case "InstancedMesh":
        geometry = getGeometry(data.geometry);
        material = getMaterial(data.material);
        const count = data.count;
        const instanceMatrix = data.instanceMatrix;
        const instanceColor = data.instanceColor;
        object = new InstancedMesh(geometry, material, count);
        object.instanceMatrix = new InstancedBufferAttribute(new Float32Array(instanceMatrix.array), 16);
        if (instanceColor !== void 0) object.instanceColor = new InstancedBufferAttribute(new Float32Array(instanceColor.array), instanceColor.itemSize);
        break;
      case "BatchedMesh":
        geometry = getGeometry(data.geometry);
        material = getMaterial(data.material);
        object = new BatchedMesh(data.maxInstanceCount, data.maxVertexCount, data.maxIndexCount, material);
        object.geometry = geometry;
        object.perObjectFrustumCulled = data.perObjectFrustumCulled;
        object.sortObjects = data.sortObjects;
        object._drawRanges = data.drawRanges;
        object._reservedRanges = data.reservedRanges;
        object._visibility = data.visibility;
        object._active = data.active;
        object._bounds = data.bounds.map((bound) => {
          const box = new Box3();
          box.min.fromArray(bound.boxMin);
          box.max.fromArray(bound.boxMax);
          const sphere = new Sphere();
          sphere.radius = bound.sphereRadius;
          sphere.center.fromArray(bound.sphereCenter);
          return {
            boxInitialized: bound.boxInitialized,
            box,
            sphereInitialized: bound.sphereInitialized,
            sphere
          };
        });
        object._maxInstanceCount = data.maxInstanceCount;
        object._maxVertexCount = data.maxVertexCount;
        object._maxIndexCount = data.maxIndexCount;
        object._geometryInitialized = data.geometryInitialized;
        object._geometryCount = data.geometryCount;
        object._matricesTexture = getTexture(data.matricesTexture.uuid);
        if (data.colorsTexture !== void 0) object._colorsTexture = getTexture(data.colorsTexture.uuid);
        break;
      case "LOD":
        object = new LOD();
        break;
      case "Line":
        object = new Line(getGeometry(data.geometry), getMaterial(data.material));
        break;
      case "LineLoop":
        object = new LineLoop(getGeometry(data.geometry), getMaterial(data.material));
        break;
      case "LineSegments":
        object = new LineSegments(getGeometry(data.geometry), getMaterial(data.material));
        break;
      case "PointCloud":
      case "Points":
        object = new Points(getGeometry(data.geometry), getMaterial(data.material));
        break;
      case "Sprite":
        object = new Sprite(getMaterial(data.material));
        break;
      case "Group":
        object = new Group$1();
        break;
      case "Bone":
        object = new Bone();
        break;
      default:
        object = new Object3D();
    }
    object.uuid = data.uuid;
    if (data.name !== void 0) object.name = data.name;
    if (data.matrix !== void 0) {
      object.matrix.fromArray(data.matrix);
      if (data.matrixAutoUpdate !== void 0) object.matrixAutoUpdate = data.matrixAutoUpdate;
      if (object.matrixAutoUpdate) object.matrix.decompose(object.position, object.quaternion, object.scale);
    } else {
      if (data.position !== void 0) object.position.fromArray(data.position);
      if (data.rotation !== void 0) object.rotation.fromArray(data.rotation);
      if (data.quaternion !== void 0) object.quaternion.fromArray(data.quaternion);
      if (data.scale !== void 0) object.scale.fromArray(data.scale);
    }
    if (data.up !== void 0) object.up.fromArray(data.up);
    if (data.castShadow !== void 0) object.castShadow = data.castShadow;
    if (data.receiveShadow !== void 0) object.receiveShadow = data.receiveShadow;
    if (data.shadow) {
      if (data.shadow.intensity !== void 0) object.shadow.intensity = data.shadow.intensity;
      if (data.shadow.bias !== void 0) object.shadow.bias = data.shadow.bias;
      if (data.shadow.normalBias !== void 0) object.shadow.normalBias = data.shadow.normalBias;
      if (data.shadow.radius !== void 0) object.shadow.radius = data.shadow.radius;
      if (data.shadow.mapSize !== void 0) object.shadow.mapSize.fromArray(data.shadow.mapSize);
      if (data.shadow.camera !== void 0) object.shadow.camera = this.parseObject(data.shadow.camera);
    }
    if (data.visible !== void 0) object.visible = data.visible;
    if (data.frustumCulled !== void 0) object.frustumCulled = data.frustumCulled;
    if (data.renderOrder !== void 0) object.renderOrder = data.renderOrder;
    if (data.userData !== void 0) object.userData = data.userData;
    if (data.layers !== void 0) object.layers.mask = data.layers;
    if (data.children !== void 0) {
      const children = data.children;
      for (let i = 0; i < children.length; i++) {
        object.add(this.parseObject(children[i], geometries, materials, textures, animations));
      }
    }
    if (data.animations !== void 0) {
      const objectAnimations = data.animations;
      for (let i = 0; i < objectAnimations.length; i++) {
        const uuid = objectAnimations[i];
        object.animations.push(animations[uuid]);
      }
    }
    if (data.type === "LOD") {
      if (data.autoUpdate !== void 0) object.autoUpdate = data.autoUpdate;
      const levels = data.levels;
      for (let l = 0; l < levels.length; l++) {
        const level = levels[l];
        const child = object.getObjectByProperty("uuid", level.object);
        if (child !== void 0) {
          object.addLevel(child, level.distance, level.hysteresis);
        }
      }
    }
    return object;
  }
  bindSkeletons(object, skeletons) {
    if (Object.keys(skeletons).length === 0) return;
    object.traverse(function(child) {
      if (child.isSkinnedMesh === true && child.skeleton !== void 0) {
        const skeleton = skeletons[child.skeleton];
        if (skeleton === void 0) {
          console.warn("THREE.ObjectLoader: No skeleton found with UUID:", child.skeleton);
        } else {
          child.bind(skeleton, child.bindMatrix);
        }
      }
    });
  }
  bindLightTargets(object) {
    object.traverse(function(child) {
      if (child.isDirectionalLight || child.isSpotLight) {
        const uuid = child.target;
        const target = object.getObjectByProperty("uuid", uuid);
        if (target !== void 0) {
          child.target = target;
        } else {
          child.target = new Object3D();
        }
      }
    });
  }
}
const TEXTURE_MAPPING = {
  UVMapping,
  CubeReflectionMapping,
  CubeRefractionMapping,
  EquirectangularReflectionMapping,
  EquirectangularRefractionMapping,
  CubeUVReflectionMapping
};
const TEXTURE_WRAPPING = {
  RepeatWrapping,
  ClampToEdgeWrapping,
  MirroredRepeatWrapping
};
const TEXTURE_FILTER = {
  NearestFilter,
  NearestMipmapNearestFilter,
  NearestMipmapLinearFilter,
  LinearFilter,
  LinearMipmapNearestFilter,
  LinearMipmapLinearFilter
};
class ImageBitmapLoader extends Loader {
  constructor(manager) {
    super(manager);
    this.isImageBitmapLoader = true;
    if (typeof createImageBitmap === "undefined") {
      console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported.");
    }
    if (typeof fetch === "undefined") {
      console.warn("THREE.ImageBitmapLoader: fetch() not supported.");
    }
    this.options = { premultiplyAlpha: "none" };
  }
  setOptions(options) {
    this.options = options;
    return this;
  }
  load(url, onLoad, onProgress, onError) {
    if (url === void 0) url = "";
    if (this.path !== void 0) url = this.path + url;
    url = this.manager.resolveURL(url);
    const scope = this;
    const cached = Cache.get(url);
    if (cached !== void 0) {
      scope.manager.itemStart(url);
      if (cached.then) {
        cached.then((imageBitmap) => {
          if (onLoad) onLoad(imageBitmap);
          scope.manager.itemEnd(url);
        }).catch((e) => {
          if (onError) onError(e);
        });
        return;
      }
      setTimeout(function() {
        if (onLoad) onLoad(cached);
        scope.manager.itemEnd(url);
      }, 0);
      return cached;
    }
    const fetchOptions = {};
    fetchOptions.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include";
    fetchOptions.headers = this.requestHeader;
    const promise = fetch(url, fetchOptions).then(function(res) {
      return res.blob();
    }).then(function(blob) {
      return createImageBitmap(blob, Object.assign(scope.options, { colorSpaceConversion: "none" }));
    }).then(function(imageBitmap) {
      Cache.add(url, imageBitmap);
      if (onLoad) onLoad(imageBitmap);
      scope.manager.itemEnd(url);
      return imageBitmap;
    }).catch(function(e) {
      if (onError) onError(e);
      Cache.remove(url);
      scope.manager.itemError(url);
      scope.manager.itemEnd(url);
    });
    Cache.add(url, promise);
    scope.manager.itemStart(url);
  }
}
let _context;
class AudioContext {
  static getContext() {
    if (_context === void 0) {
      _context = new (window.AudioContext || window.webkitAudioContext)();
    }
    return _context;
  }
  static setContext(value) {
    _context = value;
  }
}
class AudioLoader extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    const scope = this;
    const loader = new FileLoader(this.manager);
    loader.setResponseType("arraybuffer");
    loader.setPath(this.path);
    loader.setRequestHeader(this.requestHeader);
    loader.setWithCredentials(this.withCredentials);
    loader.load(url, function(buffer) {
      try {
        const bufferCopy = buffer.slice(0);
        const context2 = AudioContext.getContext();
        context2.decodeAudioData(bufferCopy, function(audioBuffer) {
          onLoad(audioBuffer);
        }).catch(handleError);
      } catch (e) {
        handleError(e);
      }
    }, onProgress, onError);
    function handleError(e) {
      if (onError) {
        onError(e);
      } else {
        console.error(e);
      }
      scope.manager.itemError(url);
    }
  }
}
const _eyeRight = /* @__PURE__ */ new Matrix4$1();
const _eyeLeft = /* @__PURE__ */ new Matrix4$1();
const _projectionMatrix = /* @__PURE__ */ new Matrix4$1();
class StereoCamera {
  constructor() {
    this.type = "StereoCamera";
    this.aspect = 1;
    this.eyeSep = 0.064;
    this.cameraL = new PerspectiveCamera();
    this.cameraL.layers.enable(1);
    this.cameraL.matrixAutoUpdate = false;
    this.cameraR = new PerspectiveCamera();
    this.cameraR.layers.enable(2);
    this.cameraR.matrixAutoUpdate = false;
    this._cache = {
      focus: null,
      fov: null,
      aspect: null,
      near: null,
      far: null,
      zoom: null,
      eyeSep: null
    };
  }
  update(camera) {
    const cache2 = this._cache;
    const needsUpdate = cache2.focus !== camera.focus || cache2.fov !== camera.fov || cache2.aspect !== camera.aspect * this.aspect || cache2.near !== camera.near || cache2.far !== camera.far || cache2.zoom !== camera.zoom || cache2.eyeSep !== this.eyeSep;
    if (needsUpdate) {
      cache2.focus = camera.focus;
      cache2.fov = camera.fov;
      cache2.aspect = camera.aspect * this.aspect;
      cache2.near = camera.near;
      cache2.far = camera.far;
      cache2.zoom = camera.zoom;
      cache2.eyeSep = this.eyeSep;
      _projectionMatrix.copy(camera.projectionMatrix);
      const eyeSepHalf = cache2.eyeSep / 2;
      const eyeSepOnProjection = eyeSepHalf * cache2.near / cache2.focus;
      const ymax = cache2.near * Math.tan(DEG2RAD$1 * cache2.fov * 0.5) / cache2.zoom;
      let xmin, xmax;
      _eyeLeft.elements[12] = -eyeSepHalf;
      _eyeRight.elements[12] = eyeSepHalf;
      xmin = -ymax * cache2.aspect + eyeSepOnProjection;
      xmax = ymax * cache2.aspect + eyeSepOnProjection;
      _projectionMatrix.elements[0] = 2 * cache2.near / (xmax - xmin);
      _projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
      this.cameraL.projectionMatrix.copy(_projectionMatrix);
      xmin = -ymax * cache2.aspect - eyeSepOnProjection;
      xmax = ymax * cache2.aspect - eyeSepOnProjection;
      _projectionMatrix.elements[0] = 2 * cache2.near / (xmax - xmin);
      _projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
      this.cameraR.projectionMatrix.copy(_projectionMatrix);
    }
    this.cameraL.matrixWorld.copy(camera.matrixWorld).multiply(_eyeLeft);
    this.cameraR.matrixWorld.copy(camera.matrixWorld).multiply(_eyeRight);
  }
}
class ArrayCamera extends PerspectiveCamera {
  constructor(array = []) {
    super();
    this.isArrayCamera = true;
    this.cameras = array;
  }
}
class Clock {
  constructor(autoStart = true) {
    this.autoStart = autoStart;
    this.startTime = 0;
    this.oldTime = 0;
    this.elapsedTime = 0;
    this.running = false;
  }
  start() {
    this.startTime = now$1();
    this.oldTime = this.startTime;
    this.elapsedTime = 0;
    this.running = true;
  }
  stop() {
    this.getElapsedTime();
    this.running = false;
    this.autoStart = false;
  }
  getElapsedTime() {
    this.getDelta();
    return this.elapsedTime;
  }
  getDelta() {
    let diff = 0;
    if (this.autoStart && !this.running) {
      this.start();
      return 0;
    }
    if (this.running) {
      const newTime = now$1();
      diff = (newTime - this.oldTime) / 1e3;
      this.oldTime = newTime;
      this.elapsedTime += diff;
    }
    return diff;
  }
}
function now$1() {
  return performance.now();
}
const _position$1 = /* @__PURE__ */ new Vector3$1();
const _quaternion$1 = /* @__PURE__ */ new Quaternion$1();
const _scale$1 = /* @__PURE__ */ new Vector3$1();
const _orientation$1 = /* @__PURE__ */ new Vector3$1();
class AudioListener extends Object3D {
  constructor() {
    super();
    this.type = "AudioListener";
    this.context = AudioContext.getContext();
    this.gain = this.context.createGain();
    this.gain.connect(this.context.destination);
    this.filter = null;
    this.timeDelta = 0;
    this._clock = new Clock();
  }
  getInput() {
    return this.gain;
  }
  removeFilter() {
    if (this.filter !== null) {
      this.gain.disconnect(this.filter);
      this.filter.disconnect(this.context.destination);
      this.gain.connect(this.context.destination);
      this.filter = null;
    }
    return this;
  }
  getFilter() {
    return this.filter;
  }
  setFilter(value) {
    if (this.filter !== null) {
      this.gain.disconnect(this.filter);
      this.filter.disconnect(this.context.destination);
    } else {
      this.gain.disconnect(this.context.destination);
    }
    this.filter = value;
    this.gain.connect(this.filter);
    this.filter.connect(this.context.destination);
    return this;
  }
  getMasterVolume() {
    return this.gain.gain.value;
  }
  setMasterVolume(value) {
    this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
    return this;
  }
  updateMatrixWorld(force) {
    super.updateMatrixWorld(force);
    const listener = this.context.listener;
    const up = this.up;
    this.timeDelta = this._clock.getDelta();
    this.matrixWorld.decompose(_position$1, _quaternion$1, _scale$1);
    _orientation$1.set(0, 0, -1).applyQuaternion(_quaternion$1);
    if (listener.positionX) {
      const endTime = this.context.currentTime + this.timeDelta;
      listener.positionX.linearRampToValueAtTime(_position$1.x, endTime);
      listener.positionY.linearRampToValueAtTime(_position$1.y, endTime);
      listener.positionZ.linearRampToValueAtTime(_position$1.z, endTime);
      listener.forwardX.linearRampToValueAtTime(_orientation$1.x, endTime);
      listener.forwardY.linearRampToValueAtTime(_orientation$1.y, endTime);
      listener.forwardZ.linearRampToValueAtTime(_orientation$1.z, endTime);
      listener.upX.linearRampToValueAtTime(up.x, endTime);
      listener.upY.linearRampToValueAtTime(up.y, endTime);
      listener.upZ.linearRampToValueAtTime(up.z, endTime);
    } else {
      listener.setPosition(_position$1.x, _position$1.y, _position$1.z);
      listener.setOrientation(_orientation$1.x, _orientation$1.y, _orientation$1.z, up.x, up.y, up.z);
    }
  }
}
class Audio extends Object3D {
  constructor(listener) {
    super();
    this.type = "Audio";
    this.listener = listener;
    this.context = listener.context;
    this.gain = this.context.createGain();
    this.gain.connect(listener.getInput());
    this.autoplay = false;
    this.buffer = null;
    this.detune = 0;
    this.loop = false;
    this.loopStart = 0;
    this.loopEnd = 0;
    this.offset = 0;
    this.duration = void 0;
    this.playbackRate = 1;
    this.isPlaying = false;
    this.hasPlaybackControl = true;
    this.source = null;
    this.sourceType = "empty";
    this._startedAt = 0;
    this._progress = 0;
    this._connected = false;
    this.filters = [];
  }
  getOutput() {
    return this.gain;
  }
  setNodeSource(audioNode) {
    this.hasPlaybackControl = false;
    this.sourceType = "audioNode";
    this.source = audioNode;
    this.connect();
    return this;
  }
  setMediaElementSource(mediaElement) {
    this.hasPlaybackControl = false;
    this.sourceType = "mediaNode";
    this.source = this.context.createMediaElementSource(mediaElement);
    this.connect();
    return this;
  }
  setMediaStreamSource(mediaStream) {
    this.hasPlaybackControl = false;
    this.sourceType = "mediaStreamNode";
    this.source = this.context.createMediaStreamSource(mediaStream);
    this.connect();
    return this;
  }
  setBuffer(audioBuffer) {
    this.buffer = audioBuffer;
    this.sourceType = "buffer";
    if (this.autoplay) this.play();
    return this;
  }
  play(delay = 0) {
    if (this.isPlaying === true) {
      console.warn("THREE.Audio: Audio is already playing.");
      return;
    }
    if (this.hasPlaybackControl === false) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this._startedAt = this.context.currentTime + delay;
    const source = this.context.createBufferSource();
    source.buffer = this.buffer;
    source.loop = this.loop;
    source.loopStart = this.loopStart;
    source.loopEnd = this.loopEnd;
    source.onended = this.onEnded.bind(this);
    source.start(this._startedAt, this._progress + this.offset, this.duration);
    this.isPlaying = true;
    this.source = source;
    this.setDetune(this.detune);
    this.setPlaybackRate(this.playbackRate);
    return this.connect();
  }
  pause() {
    if (this.hasPlaybackControl === false) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    if (this.isPlaying === true) {
      this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate;
      if (this.loop === true) {
        this._progress = this._progress % (this.duration || this.buffer.duration);
      }
      this.source.stop();
      this.source.onended = null;
      this.isPlaying = false;
    }
    return this;
  }
  stop(delay = 0) {
    if (this.hasPlaybackControl === false) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this._progress = 0;
    if (this.source !== null) {
      this.source.stop(this.context.currentTime + delay);
      this.source.onended = null;
    }
    this.isPlaying = false;
    return this;
  }
  connect() {
    if (this.filters.length > 0) {
      this.source.connect(this.filters[0]);
      for (let i = 1, l = this.filters.length; i < l; i++) {
        this.filters[i - 1].connect(this.filters[i]);
      }
      this.filters[this.filters.length - 1].connect(this.getOutput());
    } else {
      this.source.connect(this.getOutput());
    }
    this._connected = true;
    return this;
  }
  disconnect() {
    if (this._connected === false) {
      return;
    }
    if (this.filters.length > 0) {
      this.source.disconnect(this.filters[0]);
      for (let i = 1, l = this.filters.length; i < l; i++) {
        this.filters[i - 1].disconnect(this.filters[i]);
      }
      this.filters[this.filters.length - 1].disconnect(this.getOutput());
    } else {
      this.source.disconnect(this.getOutput());
    }
    this._connected = false;
    return this;
  }
  getFilters() {
    return this.filters;
  }
  setFilters(value) {
    if (!value) value = [];
    if (this._connected === true) {
      this.disconnect();
      this.filters = value.slice();
      this.connect();
    } else {
      this.filters = value.slice();
    }
    return this;
  }
  setDetune(value) {
    this.detune = value;
    if (this.isPlaying === true && this.source.detune !== void 0) {
      this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01);
    }
    return this;
  }
  getDetune() {
    return this.detune;
  }
  getFilter() {
    return this.getFilters()[0];
  }
  setFilter(filter) {
    return this.setFilters(filter ? [filter] : []);
  }
  setPlaybackRate(value) {
    if (this.hasPlaybackControl === false) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this.playbackRate = value;
    if (this.isPlaying === true) {
      this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01);
    }
    return this;
  }
  getPlaybackRate() {
    return this.playbackRate;
  }
  onEnded() {
    this.isPlaying = false;
    this._progress = 0;
  }
  getLoop() {
    if (this.hasPlaybackControl === false) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return false;
    }
    return this.loop;
  }
  setLoop(value) {
    if (this.hasPlaybackControl === false) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this.loop = value;
    if (this.isPlaying === true) {
      this.source.loop = this.loop;
    }
    return this;
  }
  setLoopStart(value) {
    this.loopStart = value;
    return this;
  }
  setLoopEnd(value) {
    this.loopEnd = value;
    return this;
  }
  getVolume() {
    return this.gain.gain.value;
  }
  setVolume(value) {
    this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
    return this;
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    if (source.sourceType !== "buffer") {
      console.warn("THREE.Audio: Audio source type cannot be copied.");
      return this;
    }
    this.autoplay = source.autoplay;
    this.buffer = source.buffer;
    this.detune = source.detune;
    this.loop = source.loop;
    this.loopStart = source.loopStart;
    this.loopEnd = source.loopEnd;
    this.offset = source.offset;
    this.duration = source.duration;
    this.playbackRate = source.playbackRate;
    this.hasPlaybackControl = source.hasPlaybackControl;
    this.sourceType = source.sourceType;
    this.filters = source.filters.slice();
    return this;
  }
  clone(recursive) {
    return new this.constructor(this.listener).copy(this, recursive);
  }
}
const _position = /* @__PURE__ */ new Vector3$1();
const _quaternion$5 = /* @__PURE__ */ new Quaternion$1();
const _scale = /* @__PURE__ */ new Vector3$1();
const _orientation = /* @__PURE__ */ new Vector3$1();
class PositionalAudio extends Audio {
  constructor(listener) {
    super(listener);
    this.panner = this.context.createPanner();
    this.panner.panningModel = "HRTF";
    this.panner.connect(this.gain);
  }
  connect() {
    super.connect();
    this.panner.connect(this.gain);
  }
  disconnect() {
    super.disconnect();
    this.panner.disconnect(this.gain);
  }
  getOutput() {
    return this.panner;
  }
  getRefDistance() {
    return this.panner.refDistance;
  }
  setRefDistance(value) {
    this.panner.refDistance = value;
    return this;
  }
  getRolloffFactor() {
    return this.panner.rolloffFactor;
  }
  setRolloffFactor(value) {
    this.panner.rolloffFactor = value;
    return this;
  }
  getDistanceModel() {
    return this.panner.distanceModel;
  }
  setDistanceModel(value) {
    this.panner.distanceModel = value;
    return this;
  }
  getMaxDistance() {
    return this.panner.maxDistance;
  }
  setMaxDistance(value) {
    this.panner.maxDistance = value;
    return this;
  }
  setDirectionalCone(coneInnerAngle, coneOuterAngle, coneOuterGain) {
    this.panner.coneInnerAngle = coneInnerAngle;
    this.panner.coneOuterAngle = coneOuterAngle;
    this.panner.coneOuterGain = coneOuterGain;
    return this;
  }
  updateMatrixWorld(force) {
    super.updateMatrixWorld(force);
    if (this.hasPlaybackControl === true && this.isPlaying === false) return;
    this.matrixWorld.decompose(_position, _quaternion$5, _scale);
    _orientation.set(0, 0, 1).applyQuaternion(_quaternion$5);
    const panner = this.panner;
    if (panner.positionX) {
      const endTime = this.context.currentTime + this.listener.timeDelta;
      panner.positionX.linearRampToValueAtTime(_position.x, endTime);
      panner.positionY.linearRampToValueAtTime(_position.y, endTime);
      panner.positionZ.linearRampToValueAtTime(_position.z, endTime);
      panner.orientationX.linearRampToValueAtTime(_orientation.x, endTime);
      panner.orientationY.linearRampToValueAtTime(_orientation.y, endTime);
      panner.orientationZ.linearRampToValueAtTime(_orientation.z, endTime);
    } else {
      panner.setPosition(_position.x, _position.y, _position.z);
      panner.setOrientation(_orientation.x, _orientation.y, _orientation.z);
    }
  }
}
class AudioAnalyser {
  constructor(audio, fftSize = 2048) {
    this.analyser = audio.context.createAnalyser();
    this.analyser.fftSize = fftSize;
    this.data = new Uint8Array(this.analyser.frequencyBinCount);
    audio.getOutput().connect(this.analyser);
  }
  getFrequencyData() {
    this.analyser.getByteFrequencyData(this.data);
    return this.data;
  }
  getAverageFrequency() {
    let value = 0;
    const data = this.getFrequencyData();
    for (let i = 0; i < data.length; i++) {
      value += data[i];
    }
    return value / data.length;
  }
}
class PropertyMixer {
  constructor(binding, typeName, valueSize) {
    this.binding = binding;
    this.valueSize = valueSize;
    let mixFunction, mixFunctionAdditive, setIdentity;
    switch (typeName) {
      case "quaternion":
        mixFunction = this._slerp;
        mixFunctionAdditive = this._slerpAdditive;
        setIdentity = this._setAdditiveIdentityQuaternion;
        this.buffer = new Float64Array(valueSize * 6);
        this._workIndex = 5;
        break;
      case "string":
      case "bool":
        mixFunction = this._select;
        mixFunctionAdditive = this._select;
        setIdentity = this._setAdditiveIdentityOther;
        this.buffer = new Array(valueSize * 5);
        break;
      default:
        mixFunction = this._lerp;
        mixFunctionAdditive = this._lerpAdditive;
        setIdentity = this._setAdditiveIdentityNumeric;
        this.buffer = new Float64Array(valueSize * 5);
    }
    this._mixBufferRegion = mixFunction;
    this._mixBufferRegionAdditive = mixFunctionAdditive;
    this._setIdentity = setIdentity;
    this._origIndex = 3;
    this._addIndex = 4;
    this.cumulativeWeight = 0;
    this.cumulativeWeightAdditive = 0;
    this.useCount = 0;
    this.referenceCount = 0;
  }
  // accumulate data in the 'incoming' region into 'accu<i>'
  accumulate(accuIndex, weight) {
    const buffer = this.buffer, stride = this.valueSize, offset = accuIndex * stride + stride;
    let currentWeight = this.cumulativeWeight;
    if (currentWeight === 0) {
      for (let i = 0; i !== stride; ++i) {
        buffer[offset + i] = buffer[i];
      }
      currentWeight = weight;
    } else {
      currentWeight += weight;
      const mix2 = weight / currentWeight;
      this._mixBufferRegion(buffer, offset, 0, mix2, stride);
    }
    this.cumulativeWeight = currentWeight;
  }
  // accumulate data in the 'incoming' region into 'add'
  accumulateAdditive(weight) {
    const buffer = this.buffer, stride = this.valueSize, offset = stride * this._addIndex;
    if (this.cumulativeWeightAdditive === 0) {
      this._setIdentity();
    }
    this._mixBufferRegionAdditive(buffer, offset, 0, weight, stride);
    this.cumulativeWeightAdditive += weight;
  }
  // apply the state of 'accu<i>' to the binding when accus differ
  apply(accuIndex) {
    const stride = this.valueSize, buffer = this.buffer, offset = accuIndex * stride + stride, weight = this.cumulativeWeight, weightAdditive = this.cumulativeWeightAdditive, binding = this.binding;
    this.cumulativeWeight = 0;
    this.cumulativeWeightAdditive = 0;
    if (weight < 1) {
      const originalValueOffset = stride * this._origIndex;
      this._mixBufferRegion(
        buffer,
        offset,
        originalValueOffset,
        1 - weight,
        stride
      );
    }
    if (weightAdditive > 0) {
      this._mixBufferRegionAdditive(buffer, offset, this._addIndex * stride, 1, stride);
    }
    for (let i = stride, e = stride + stride; i !== e; ++i) {
      if (buffer[i] !== buffer[i + stride]) {
        binding.setValue(buffer, offset);
        break;
      }
    }
  }
  // remember the state of the bound property and copy it to both accus
  saveOriginalState() {
    const binding = this.binding;
    const buffer = this.buffer, stride = this.valueSize, originalValueOffset = stride * this._origIndex;
    binding.getValue(buffer, originalValueOffset);
    for (let i = stride, e = originalValueOffset; i !== e; ++i) {
      buffer[i] = buffer[originalValueOffset + i % stride];
    }
    this._setIdentity();
    this.cumulativeWeight = 0;
    this.cumulativeWeightAdditive = 0;
  }
  // apply the state previously taken via 'saveOriginalState' to the binding
  restoreOriginalState() {
    const originalValueOffset = this.valueSize * 3;
    this.binding.setValue(this.buffer, originalValueOffset);
  }
  _setAdditiveIdentityNumeric() {
    const startIndex = this._addIndex * this.valueSize;
    const endIndex = startIndex + this.valueSize;
    for (let i = startIndex; i < endIndex; i++) {
      this.buffer[i] = 0;
    }
  }
  _setAdditiveIdentityQuaternion() {
    this._setAdditiveIdentityNumeric();
    this.buffer[this._addIndex * this.valueSize + 3] = 1;
  }
  _setAdditiveIdentityOther() {
    const startIndex = this._origIndex * this.valueSize;
    const targetIndex = this._addIndex * this.valueSize;
    for (let i = 0; i < this.valueSize; i++) {
      this.buffer[targetIndex + i] = this.buffer[startIndex + i];
    }
  }
  // mix functions
  _select(buffer, dstOffset, srcOffset, t, stride) {
    if (t >= 0.5) {
      for (let i = 0; i !== stride; ++i) {
        buffer[dstOffset + i] = buffer[srcOffset + i];
      }
    }
  }
  _slerp(buffer, dstOffset, srcOffset, t) {
    Quaternion$1.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t);
  }
  _slerpAdditive(buffer, dstOffset, srcOffset, t, stride) {
    const workOffset = this._workIndex * stride;
    Quaternion$1.multiplyQuaternionsFlat(buffer, workOffset, buffer, dstOffset, buffer, srcOffset);
    Quaternion$1.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, workOffset, t);
  }
  _lerp(buffer, dstOffset, srcOffset, t, stride) {
    const s = 1 - t;
    for (let i = 0; i !== stride; ++i) {
      const j = dstOffset + i;
      buffer[j] = buffer[j] * s + buffer[srcOffset + i] * t;
    }
  }
  _lerpAdditive(buffer, dstOffset, srcOffset, t, stride) {
    for (let i = 0; i !== stride; ++i) {
      const j = dstOffset + i;
      buffer[j] = buffer[j] + buffer[srcOffset + i] * t;
    }
  }
}
const _RESERVED_CHARS_RE = "\\[\\]\\.:\\/";
const _reservedRe = new RegExp("[" + _RESERVED_CHARS_RE + "]", "g");
const _wordChar = "[^" + _RESERVED_CHARS_RE + "]";
const _wordCharOrDot = "[^" + _RESERVED_CHARS_RE.replace("\\.", "") + "]";
const _directoryRe = /* @__PURE__ */ /((?:WC+[\/:])*)/.source.replace("WC", _wordChar);
const _nodeRe = /* @__PURE__ */ /(WCOD+)?/.source.replace("WCOD", _wordCharOrDot);
const _objectRe = /* @__PURE__ */ /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", _wordChar);
const _propertyRe = /* @__PURE__ */ /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", _wordChar);
const _trackRe = new RegExp(
  "^" + _directoryRe + _nodeRe + _objectRe + _propertyRe + "$"
);
const _supportedObjectNames = ["material", "materials", "bones", "map"];
class Composite {
  constructor(targetGroup, path, optionalParsedPath) {
    const parsedPath = optionalParsedPath || PropertyBinding.parseTrackName(path);
    this._targetGroup = targetGroup;
    this._bindings = targetGroup.subscribe_(path, parsedPath);
  }
  getValue(array, offset) {
    this.bind();
    const firstValidIndex = this._targetGroup.nCachedObjects_, binding = this._bindings[firstValidIndex];
    if (binding !== void 0) binding.getValue(array, offset);
  }
  setValue(array, offset) {
    const bindings = this._bindings;
    for (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
      bindings[i].setValue(array, offset);
    }
  }
  bind() {
    const bindings = this._bindings;
    for (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
      bindings[i].bind();
    }
  }
  unbind() {
    const bindings = this._bindings;
    for (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
      bindings[i].unbind();
    }
  }
}
class PropertyBinding {
  constructor(rootNode, path, parsedPath) {
    this.path = path;
    this.parsedPath = parsedPath || PropertyBinding.parseTrackName(path);
    this.node = PropertyBinding.findNode(rootNode, this.parsedPath.nodeName);
    this.rootNode = rootNode;
    this.getValue = this._getValue_unbound;
    this.setValue = this._setValue_unbound;
  }
  static create(root, path, parsedPath) {
    if (!(root && root.isAnimationObjectGroup)) {
      return new PropertyBinding(root, path, parsedPath);
    } else {
      return new PropertyBinding.Composite(root, path, parsedPath);
    }
  }
  /**
   * Replaces spaces with underscores and removes unsupported characters from
   * node names, to ensure compatibility with parseTrackName().
   *
   * @param {string} name Node name to be sanitized.
   * @return {string}
   */
  static sanitizeNodeName(name) {
    return name.replace(/\s/g, "_").replace(_reservedRe, "");
  }
  static parseTrackName(trackName) {
    const matches = _trackRe.exec(trackName);
    if (matches === null) {
      throw new Error("PropertyBinding: Cannot parse trackName: " + trackName);
    }
    const results = {
      // directoryName: matches[ 1 ], // (tschw) currently unused
      nodeName: matches[2],
      objectName: matches[3],
      objectIndex: matches[4],
      propertyName: matches[5],
      // required
      propertyIndex: matches[6]
    };
    const lastDot = results.nodeName && results.nodeName.lastIndexOf(".");
    if (lastDot !== void 0 && lastDot !== -1) {
      const objectName = results.nodeName.substring(lastDot + 1);
      if (_supportedObjectNames.indexOf(objectName) !== -1) {
        results.nodeName = results.nodeName.substring(0, lastDot);
        results.objectName = objectName;
      }
    }
    if (results.propertyName === null || results.propertyName.length === 0) {
      throw new Error("PropertyBinding: can not parse propertyName from trackName: " + trackName);
    }
    return results;
  }
  static findNode(root, nodeName) {
    if (nodeName === void 0 || nodeName === "" || nodeName === "." || nodeName === -1 || nodeName === root.name || nodeName === root.uuid) {
      return root;
    }
    if (root.skeleton) {
      const bone = root.skeleton.getBoneByName(nodeName);
      if (bone !== void 0) {
        return bone;
      }
    }
    if (root.children) {
      const searchNodeSubtree = function(children) {
        for (let i = 0; i < children.length; i++) {
          const childNode = children[i];
          if (childNode.name === nodeName || childNode.uuid === nodeName) {
            return childNode;
          }
          const result = searchNodeSubtree(childNode.children);
          if (result) return result;
        }
        return null;
      };
      const subTreeNode = searchNodeSubtree(root.children);
      if (subTreeNode) {
        return subTreeNode;
      }
    }
    return null;
  }
  // these are used to "bind" a nonexistent property
  _getValue_unavailable() {
  }
  _setValue_unavailable() {
  }
  // Getters
  _getValue_direct(buffer, offset) {
    buffer[offset] = this.targetObject[this.propertyName];
  }
  _getValue_array(buffer, offset) {
    const source = this.resolvedProperty;
    for (let i = 0, n = source.length; i !== n; ++i) {
      buffer[offset++] = source[i];
    }
  }
  _getValue_arrayElement(buffer, offset) {
    buffer[offset] = this.resolvedProperty[this.propertyIndex];
  }
  _getValue_toArray(buffer, offset) {
    this.resolvedProperty.toArray(buffer, offset);
  }
  // Direct
  _setValue_direct(buffer, offset) {
    this.targetObject[this.propertyName] = buffer[offset];
  }
  _setValue_direct_setNeedsUpdate(buffer, offset) {
    this.targetObject[this.propertyName] = buffer[offset];
    this.targetObject.needsUpdate = true;
  }
  _setValue_direct_setMatrixWorldNeedsUpdate(buffer, offset) {
    this.targetObject[this.propertyName] = buffer[offset];
    this.targetObject.matrixWorldNeedsUpdate = true;
  }
  // EntireArray
  _setValue_array(buffer, offset) {
    const dest = this.resolvedProperty;
    for (let i = 0, n = dest.length; i !== n; ++i) {
      dest[i] = buffer[offset++];
    }
  }
  _setValue_array_setNeedsUpdate(buffer, offset) {
    const dest = this.resolvedProperty;
    for (let i = 0, n = dest.length; i !== n; ++i) {
      dest[i] = buffer[offset++];
    }
    this.targetObject.needsUpdate = true;
  }
  _setValue_array_setMatrixWorldNeedsUpdate(buffer, offset) {
    const dest = this.resolvedProperty;
    for (let i = 0, n = dest.length; i !== n; ++i) {
      dest[i] = buffer[offset++];
    }
    this.targetObject.matrixWorldNeedsUpdate = true;
  }
  // ArrayElement
  _setValue_arrayElement(buffer, offset) {
    this.resolvedProperty[this.propertyIndex] = buffer[offset];
  }
  _setValue_arrayElement_setNeedsUpdate(buffer, offset) {
    this.resolvedProperty[this.propertyIndex] = buffer[offset];
    this.targetObject.needsUpdate = true;
  }
  _setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer, offset) {
    this.resolvedProperty[this.propertyIndex] = buffer[offset];
    this.targetObject.matrixWorldNeedsUpdate = true;
  }
  // HasToFromArray
  _setValue_fromArray(buffer, offset) {
    this.resolvedProperty.fromArray(buffer, offset);
  }
  _setValue_fromArray_setNeedsUpdate(buffer, offset) {
    this.resolvedProperty.fromArray(buffer, offset);
    this.targetObject.needsUpdate = true;
  }
  _setValue_fromArray_setMatrixWorldNeedsUpdate(buffer, offset) {
    this.resolvedProperty.fromArray(buffer, offset);
    this.targetObject.matrixWorldNeedsUpdate = true;
  }
  _getValue_unbound(targetArray, offset) {
    this.bind();
    this.getValue(targetArray, offset);
  }
  _setValue_unbound(sourceArray, offset) {
    this.bind();
    this.setValue(sourceArray, offset);
  }
  // create getter / setter pair for a property in the scene graph
  bind() {
    let targetObject = this.node;
    const parsedPath = this.parsedPath;
    const objectName = parsedPath.objectName;
    const propertyName = parsedPath.propertyName;
    let propertyIndex = parsedPath.propertyIndex;
    if (!targetObject) {
      targetObject = PropertyBinding.findNode(this.rootNode, parsedPath.nodeName);
      this.node = targetObject;
    }
    this.getValue = this._getValue_unavailable;
    this.setValue = this._setValue_unavailable;
    if (!targetObject) {
      console.warn("THREE.PropertyBinding: No target node found for track: " + this.path + ".");
      return;
    }
    if (objectName) {
      let objectIndex = parsedPath.objectIndex;
      switch (objectName) {
        case "materials":
          if (!targetObject.material) {
            console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
            return;
          }
          if (!targetObject.material.materials) {
            console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
            return;
          }
          targetObject = targetObject.material.materials;
          break;
        case "bones":
          if (!targetObject.skeleton) {
            console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
            return;
          }
          targetObject = targetObject.skeleton.bones;
          for (let i = 0; i < targetObject.length; i++) {
            if (targetObject[i].name === objectIndex) {
              objectIndex = i;
              break;
            }
          }
          break;
        case "map":
          if ("map" in targetObject) {
            targetObject = targetObject.map;
            break;
          }
          if (!targetObject.material) {
            console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
            return;
          }
          if (!targetObject.material.map) {
            console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
            return;
          }
          targetObject = targetObject.material.map;
          break;
        default:
          if (targetObject[objectName] === void 0) {
            console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
            return;
          }
          targetObject = targetObject[objectName];
      }
      if (objectIndex !== void 0) {
        if (targetObject[objectIndex] === void 0) {
          console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, targetObject);
          return;
        }
        targetObject = targetObject[objectIndex];
      }
    }
    const nodeProperty = targetObject[propertyName];
    if (nodeProperty === void 0) {
      const nodeName = parsedPath.nodeName;
      console.error("THREE.PropertyBinding: Trying to update property for track: " + nodeName + "." + propertyName + " but it wasn't found.", targetObject);
      return;
    }
    let versioning = this.Versioning.None;
    this.targetObject = targetObject;
    if (targetObject.isMaterial === true) {
      versioning = this.Versioning.NeedsUpdate;
    } else if (targetObject.isObject3D === true) {
      versioning = this.Versioning.MatrixWorldNeedsUpdate;
    }
    let bindingType = this.BindingType.Direct;
    if (propertyIndex !== void 0) {
      if (propertyName === "morphTargetInfluences") {
        if (!targetObject.geometry) {
          console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
          return;
        }
        if (!targetObject.geometry.morphAttributes) {
          console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
          return;
        }
        if (targetObject.morphTargetDictionary[propertyIndex] !== void 0) {
          propertyIndex = targetObject.morphTargetDictionary[propertyIndex];
        }
      }
      bindingType = this.BindingType.ArrayElement;
      this.resolvedProperty = nodeProperty;
      this.propertyIndex = propertyIndex;
    } else if (nodeProperty.fromArray !== void 0 && nodeProperty.toArray !== void 0) {
      bindingType = this.BindingType.HasFromToArray;
      this.resolvedProperty = nodeProperty;
    } else if (Array.isArray(nodeProperty)) {
      bindingType = this.BindingType.EntireArray;
      this.resolvedProperty = nodeProperty;
    } else {
      this.propertyName = propertyName;
    }
    this.getValue = this.GetterByBindingType[bindingType];
    this.setValue = this.SetterByBindingTypeAndVersioning[bindingType][versioning];
  }
  unbind() {
    this.node = null;
    this.getValue = this._getValue_unbound;
    this.setValue = this._setValue_unbound;
  }
}
PropertyBinding.Composite = Composite;
PropertyBinding.prototype.BindingType = {
  Direct: 0,
  EntireArray: 1,
  ArrayElement: 2,
  HasFromToArray: 3
};
PropertyBinding.prototype.Versioning = {
  None: 0,
  NeedsUpdate: 1,
  MatrixWorldNeedsUpdate: 2
};
PropertyBinding.prototype.GetterByBindingType = [
  PropertyBinding.prototype._getValue_direct,
  PropertyBinding.prototype._getValue_array,
  PropertyBinding.prototype._getValue_arrayElement,
  PropertyBinding.prototype._getValue_toArray
];
PropertyBinding.prototype.SetterByBindingTypeAndVersioning = [
  [
    // Direct
    PropertyBinding.prototype._setValue_direct,
    PropertyBinding.prototype._setValue_direct_setNeedsUpdate,
    PropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate
  ],
  [
    // EntireArray
    PropertyBinding.prototype._setValue_array,
    PropertyBinding.prototype._setValue_array_setNeedsUpdate,
    PropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate
  ],
  [
    // ArrayElement
    PropertyBinding.prototype._setValue_arrayElement,
    PropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate,
    PropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate
  ],
  [
    // HasToFromArray
    PropertyBinding.prototype._setValue_fromArray,
    PropertyBinding.prototype._setValue_fromArray_setNeedsUpdate,
    PropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate
  ]
];
class AnimationObjectGroup {
  constructor() {
    this.isAnimationObjectGroup = true;
    this.uuid = generateUUID$1();
    this._objects = Array.prototype.slice.call(arguments);
    this.nCachedObjects_ = 0;
    const indices = {};
    this._indicesByUUID = indices;
    for (let i = 0, n = arguments.length; i !== n; ++i) {
      indices[arguments[i].uuid] = i;
    }
    this._paths = [];
    this._parsedPaths = [];
    this._bindings = [];
    this._bindingsIndicesByPath = {};
    const scope = this;
    this.stats = {
      objects: {
        get total() {
          return scope._objects.length;
        },
        get inUse() {
          return this.total - scope.nCachedObjects_;
        }
      },
      get bindingsPerObject() {
        return scope._bindings.length;
      }
    };
  }
  add() {
    const objects = this._objects, indicesByUUID = this._indicesByUUID, paths = this._paths, parsedPaths = this._parsedPaths, bindings = this._bindings, nBindings = bindings.length;
    let knownObject = void 0, nObjects = objects.length, nCachedObjects = this.nCachedObjects_;
    for (let i = 0, n = arguments.length; i !== n; ++i) {
      const object = arguments[i], uuid = object.uuid;
      let index = indicesByUUID[uuid];
      if (index === void 0) {
        index = nObjects++;
        indicesByUUID[uuid] = index;
        objects.push(object);
        for (let j = 0, m = nBindings; j !== m; ++j) {
          bindings[j].push(new PropertyBinding(object, paths[j], parsedPaths[j]));
        }
      } else if (index < nCachedObjects) {
        knownObject = objects[index];
        const firstActiveIndex = --nCachedObjects, lastCachedObject = objects[firstActiveIndex];
        indicesByUUID[lastCachedObject.uuid] = index;
        objects[index] = lastCachedObject;
        indicesByUUID[uuid] = firstActiveIndex;
        objects[firstActiveIndex] = object;
        for (let j = 0, m = nBindings; j !== m; ++j) {
          const bindingsForPath = bindings[j], lastCached = bindingsForPath[firstActiveIndex];
          let binding = bindingsForPath[index];
          bindingsForPath[index] = lastCached;
          if (binding === void 0) {
            binding = new PropertyBinding(object, paths[j], parsedPaths[j]);
          }
          bindingsForPath[firstActiveIndex] = binding;
        }
      } else if (objects[index] !== knownObject) {
        console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.");
      }
    }
    this.nCachedObjects_ = nCachedObjects;
  }
  remove() {
    const objects = this._objects, indicesByUUID = this._indicesByUUID, bindings = this._bindings, nBindings = bindings.length;
    let nCachedObjects = this.nCachedObjects_;
    for (let i = 0, n = arguments.length; i !== n; ++i) {
      const object = arguments[i], uuid = object.uuid, index = indicesByUUID[uuid];
      if (index !== void 0 && index >= nCachedObjects) {
        const lastCachedIndex = nCachedObjects++, firstActiveObject = objects[lastCachedIndex];
        indicesByUUID[firstActiveObject.uuid] = index;
        objects[index] = firstActiveObject;
        indicesByUUID[uuid] = lastCachedIndex;
        objects[lastCachedIndex] = object;
        for (let j = 0, m = nBindings; j !== m; ++j) {
          const bindingsForPath = bindings[j], firstActive = bindingsForPath[lastCachedIndex], binding = bindingsForPath[index];
          bindingsForPath[index] = firstActive;
          bindingsForPath[lastCachedIndex] = binding;
        }
      }
    }
    this.nCachedObjects_ = nCachedObjects;
  }
  // remove & forget
  uncache() {
    const objects = this._objects, indicesByUUID = this._indicesByUUID, bindings = this._bindings, nBindings = bindings.length;
    let nCachedObjects = this.nCachedObjects_, nObjects = objects.length;
    for (let i = 0, n = arguments.length; i !== n; ++i) {
      const object = arguments[i], uuid = object.uuid, index = indicesByUUID[uuid];
      if (index !== void 0) {
        delete indicesByUUID[uuid];
        if (index < nCachedObjects) {
          const firstActiveIndex = --nCachedObjects, lastCachedObject = objects[firstActiveIndex], lastIndex = --nObjects, lastObject = objects[lastIndex];
          indicesByUUID[lastCachedObject.uuid] = index;
          objects[index] = lastCachedObject;
          indicesByUUID[lastObject.uuid] = firstActiveIndex;
          objects[firstActiveIndex] = lastObject;
          objects.pop();
          for (let j = 0, m = nBindings; j !== m; ++j) {
            const bindingsForPath = bindings[j], lastCached = bindingsForPath[firstActiveIndex], last = bindingsForPath[lastIndex];
            bindingsForPath[index] = lastCached;
            bindingsForPath[firstActiveIndex] = last;
            bindingsForPath.pop();
          }
        } else {
          const lastIndex = --nObjects, lastObject = objects[lastIndex];
          if (lastIndex > 0) {
            indicesByUUID[lastObject.uuid] = index;
          }
          objects[index] = lastObject;
          objects.pop();
          for (let j = 0, m = nBindings; j !== m; ++j) {
            const bindingsForPath = bindings[j];
            bindingsForPath[index] = bindingsForPath[lastIndex];
            bindingsForPath.pop();
          }
        }
      }
    }
    this.nCachedObjects_ = nCachedObjects;
  }
  // Internal interface used by befriended PropertyBinding.Composite:
  subscribe_(path, parsedPath) {
    const indicesByPath = this._bindingsIndicesByPath;
    let index = indicesByPath[path];
    const bindings = this._bindings;
    if (index !== void 0) return bindings[index];
    const paths = this._paths, parsedPaths = this._parsedPaths, objects = this._objects, nObjects = objects.length, nCachedObjects = this.nCachedObjects_, bindingsForPath = new Array(nObjects);
    index = bindings.length;
    indicesByPath[path] = index;
    paths.push(path);
    parsedPaths.push(parsedPath);
    bindings.push(bindingsForPath);
    for (let i = nCachedObjects, n = objects.length; i !== n; ++i) {
      const object = objects[i];
      bindingsForPath[i] = new PropertyBinding(object, path, parsedPath);
    }
    return bindingsForPath;
  }
  unsubscribe_(path) {
    const indicesByPath = this._bindingsIndicesByPath, index = indicesByPath[path];
    if (index !== void 0) {
      const paths = this._paths, parsedPaths = this._parsedPaths, bindings = this._bindings, lastBindingsIndex = bindings.length - 1, lastBindings = bindings[lastBindingsIndex], lastBindingsPath = path[lastBindingsIndex];
      indicesByPath[lastBindingsPath] = index;
      bindings[index] = lastBindings;
      bindings.pop();
      parsedPaths[index] = parsedPaths[lastBindingsIndex];
      parsedPaths.pop();
      paths[index] = paths[lastBindingsIndex];
      paths.pop();
    }
  }
}
class AnimationAction {
  constructor(mixer, clip, localRoot = null, blendMode = clip.blendMode) {
    this._mixer = mixer;
    this._clip = clip;
    this._localRoot = localRoot;
    this.blendMode = blendMode;
    const tracks = clip.tracks, nTracks = tracks.length, interpolants = new Array(nTracks);
    const interpolantSettings = {
      endingStart: ZeroCurvatureEnding,
      endingEnd: ZeroCurvatureEnding
    };
    for (let i = 0; i !== nTracks; ++i) {
      const interpolant = tracks[i].createInterpolant(null);
      interpolants[i] = interpolant;
      interpolant.settings = interpolantSettings;
    }
    this._interpolantSettings = interpolantSettings;
    this._interpolants = interpolants;
    this._propertyBindings = new Array(nTracks);
    this._cacheIndex = null;
    this._byClipCacheIndex = null;
    this._timeScaleInterpolant = null;
    this._weightInterpolant = null;
    this.loop = LoopRepeat;
    this._loopCount = -1;
    this._startTime = null;
    this.time = 0;
    this.timeScale = 1;
    this._effectiveTimeScale = 1;
    this.weight = 1;
    this._effectiveWeight = 1;
    this.repetitions = Infinity;
    this.paused = false;
    this.enabled = true;
    this.clampWhenFinished = false;
    this.zeroSlopeAtStart = true;
    this.zeroSlopeAtEnd = true;
  }
  // State & Scheduling
  play() {
    this._mixer._activateAction(this);
    return this;
  }
  stop() {
    this._mixer._deactivateAction(this);
    return this.reset();
  }
  reset() {
    this.paused = false;
    this.enabled = true;
    this.time = 0;
    this._loopCount = -1;
    this._startTime = null;
    return this.stopFading().stopWarping();
  }
  isRunning() {
    return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
  }
  // return true when play has been called
  isScheduled() {
    return this._mixer._isActiveAction(this);
  }
  startAt(time) {
    this._startTime = time;
    return this;
  }
  setLoop(mode, repetitions) {
    this.loop = mode;
    this.repetitions = repetitions;
    return this;
  }
  // Weight
  // set the weight stopping any scheduled fading
  // although .enabled = false yields an effective weight of zero, this
  // method does *not* change .enabled, because it would be confusing
  setEffectiveWeight(weight) {
    this.weight = weight;
    this._effectiveWeight = this.enabled ? weight : 0;
    return this.stopFading();
  }
  // return the weight considering fading and .enabled
  getEffectiveWeight() {
    return this._effectiveWeight;
  }
  fadeIn(duration) {
    return this._scheduleFading(duration, 0, 1);
  }
  fadeOut(duration) {
    return this._scheduleFading(duration, 1, 0);
  }
  crossFadeFrom(fadeOutAction, duration, warp) {
    fadeOutAction.fadeOut(duration);
    this.fadeIn(duration);
    if (warp) {
      const fadeInDuration = this._clip.duration, fadeOutDuration = fadeOutAction._clip.duration, startEndRatio = fadeOutDuration / fadeInDuration, endStartRatio = fadeInDuration / fadeOutDuration;
      fadeOutAction.warp(1, startEndRatio, duration);
      this.warp(endStartRatio, 1, duration);
    }
    return this;
  }
  crossFadeTo(fadeInAction, duration, warp) {
    return fadeInAction.crossFadeFrom(this, duration, warp);
  }
  stopFading() {
    const weightInterpolant = this._weightInterpolant;
    if (weightInterpolant !== null) {
      this._weightInterpolant = null;
      this._mixer._takeBackControlInterpolant(weightInterpolant);
    }
    return this;
  }
  // Time Scale Control
  // set the time scale stopping any scheduled warping
  // although .paused = true yields an effective time scale of zero, this
  // method does *not* change .paused, because it would be confusing
  setEffectiveTimeScale(timeScale) {
    this.timeScale = timeScale;
    this._effectiveTimeScale = this.paused ? 0 : timeScale;
    return this.stopWarping();
  }
  // return the time scale considering warping and .paused
  getEffectiveTimeScale() {
    return this._effectiveTimeScale;
  }
  setDuration(duration) {
    this.timeScale = this._clip.duration / duration;
    return this.stopWarping();
  }
  syncWith(action) {
    this.time = action.time;
    this.timeScale = action.timeScale;
    return this.stopWarping();
  }
  halt(duration) {
    return this.warp(this._effectiveTimeScale, 0, duration);
  }
  warp(startTimeScale, endTimeScale, duration) {
    const mixer = this._mixer, now2 = mixer.time, timeScale = this.timeScale;
    let interpolant = this._timeScaleInterpolant;
    if (interpolant === null) {
      interpolant = mixer._lendControlInterpolant();
      this._timeScaleInterpolant = interpolant;
    }
    const times = interpolant.parameterPositions, values = interpolant.sampleValues;
    times[0] = now2;
    times[1] = now2 + duration;
    values[0] = startTimeScale / timeScale;
    values[1] = endTimeScale / timeScale;
    return this;
  }
  stopWarping() {
    const timeScaleInterpolant = this._timeScaleInterpolant;
    if (timeScaleInterpolant !== null) {
      this._timeScaleInterpolant = null;
      this._mixer._takeBackControlInterpolant(timeScaleInterpolant);
    }
    return this;
  }
  // Object Accessors
  getMixer() {
    return this._mixer;
  }
  getClip() {
    return this._clip;
  }
  getRoot() {
    return this._localRoot || this._mixer._root;
  }
  // Interna
  _update(time, deltaTime, timeDirection, accuIndex) {
    if (!this.enabled) {
      this._updateWeight(time);
      return;
    }
    const startTime = this._startTime;
    if (startTime !== null) {
      const timeRunning = (time - startTime) * timeDirection;
      if (timeRunning < 0 || timeDirection === 0) {
        deltaTime = 0;
      } else {
        this._startTime = null;
        deltaTime = timeDirection * timeRunning;
      }
    }
    deltaTime *= this._updateTimeScale(time);
    const clipTime = this._updateTime(deltaTime);
    const weight = this._updateWeight(time);
    if (weight > 0) {
      const interpolants = this._interpolants;
      const propertyMixers = this._propertyBindings;
      switch (this.blendMode) {
        case AdditiveAnimationBlendMode:
          for (let j = 0, m = interpolants.length; j !== m; ++j) {
            interpolants[j].evaluate(clipTime);
            propertyMixers[j].accumulateAdditive(weight);
          }
          break;
        case NormalAnimationBlendMode:
        default:
          for (let j = 0, m = interpolants.length; j !== m; ++j) {
            interpolants[j].evaluate(clipTime);
            propertyMixers[j].accumulate(accuIndex, weight);
          }
      }
    }
  }
  _updateWeight(time) {
    let weight = 0;
    if (this.enabled) {
      weight = this.weight;
      const interpolant = this._weightInterpolant;
      if (interpolant !== null) {
        const interpolantValue = interpolant.evaluate(time)[0];
        weight *= interpolantValue;
        if (time > interpolant.parameterPositions[1]) {
          this.stopFading();
          if (interpolantValue === 0) {
            this.enabled = false;
          }
        }
      }
    }
    this._effectiveWeight = weight;
    return weight;
  }
  _updateTimeScale(time) {
    let timeScale = 0;
    if (!this.paused) {
      timeScale = this.timeScale;
      const interpolant = this._timeScaleInterpolant;
      if (interpolant !== null) {
        const interpolantValue = interpolant.evaluate(time)[0];
        timeScale *= interpolantValue;
        if (time > interpolant.parameterPositions[1]) {
          this.stopWarping();
          if (timeScale === 0) {
            this.paused = true;
          } else {
            this.timeScale = timeScale;
          }
        }
      }
    }
    this._effectiveTimeScale = timeScale;
    return timeScale;
  }
  _updateTime(deltaTime) {
    const duration = this._clip.duration;
    const loop = this.loop;
    let time = this.time + deltaTime;
    let loopCount = this._loopCount;
    const pingPong = loop === LoopPingPong;
    if (deltaTime === 0) {
      if (loopCount === -1) return time;
      return pingPong && (loopCount & 1) === 1 ? duration - time : time;
    }
    if (loop === LoopOnce) {
      if (loopCount === -1) {
        this._loopCount = 0;
        this._setEndings(true, true, false);
      }
      handle_stop: {
        if (time >= duration) {
          time = duration;
        } else if (time < 0) {
          time = 0;
        } else {
          this.time = time;
          break handle_stop;
        }
        if (this.clampWhenFinished) this.paused = true;
        else this.enabled = false;
        this.time = time;
        this._mixer.dispatchEvent({
          type: "finished",
          action: this,
          direction: deltaTime < 0 ? -1 : 1
        });
      }
    } else {
      if (loopCount === -1) {
        if (deltaTime >= 0) {
          loopCount = 0;
          this._setEndings(true, this.repetitions === 0, pingPong);
        } else {
          this._setEndings(this.repetitions === 0, true, pingPong);
        }
      }
      if (time >= duration || time < 0) {
        const loopDelta = Math.floor(time / duration);
        time -= duration * loopDelta;
        loopCount += Math.abs(loopDelta);
        const pending = this.repetitions - loopCount;
        if (pending <= 0) {
          if (this.clampWhenFinished) this.paused = true;
          else this.enabled = false;
          time = deltaTime > 0 ? duration : 0;
          this.time = time;
          this._mixer.dispatchEvent({
            type: "finished",
            action: this,
            direction: deltaTime > 0 ? 1 : -1
          });
        } else {
          if (pending === 1) {
            const atStart = deltaTime < 0;
            this._setEndings(atStart, !atStart, pingPong);
          } else {
            this._setEndings(false, false, pingPong);
          }
          this._loopCount = loopCount;
          this.time = time;
          this._mixer.dispatchEvent({
            type: "loop",
            action: this,
            loopDelta
          });
        }
      } else {
        this.time = time;
      }
      if (pingPong && (loopCount & 1) === 1) {
        return duration - time;
      }
    }
    return time;
  }
  _setEndings(atStart, atEnd, pingPong) {
    const settings = this._interpolantSettings;
    if (pingPong) {
      settings.endingStart = ZeroSlopeEnding;
      settings.endingEnd = ZeroSlopeEnding;
    } else {
      if (atStart) {
        settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;
      } else {
        settings.endingStart = WrapAroundEnding;
      }
      if (atEnd) {
        settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;
      } else {
        settings.endingEnd = WrapAroundEnding;
      }
    }
  }
  _scheduleFading(duration, weightNow, weightThen) {
    const mixer = this._mixer, now2 = mixer.time;
    let interpolant = this._weightInterpolant;
    if (interpolant === null) {
      interpolant = mixer._lendControlInterpolant();
      this._weightInterpolant = interpolant;
    }
    const times = interpolant.parameterPositions, values = interpolant.sampleValues;
    times[0] = now2;
    values[0] = weightNow;
    times[1] = now2 + duration;
    values[1] = weightThen;
    return this;
  }
}
const _controlInterpolantsResultBuffer = new Float32Array(1);
class AnimationMixer extends EventDispatcher$1 {
  constructor(root) {
    super();
    this._root = root;
    this._initMemoryManager();
    this._accuIndex = 0;
    this.time = 0;
    this.timeScale = 1;
  }
  _bindAction(action, prototypeAction) {
    const root = action._localRoot || this._root, tracks = action._clip.tracks, nTracks = tracks.length, bindings = action._propertyBindings, interpolants = action._interpolants, rootUuid = root.uuid, bindingsByRoot = this._bindingsByRootAndName;
    let bindingsByName = bindingsByRoot[rootUuid];
    if (bindingsByName === void 0) {
      bindingsByName = {};
      bindingsByRoot[rootUuid] = bindingsByName;
    }
    for (let i = 0; i !== nTracks; ++i) {
      const track = tracks[i], trackName = track.name;
      let binding = bindingsByName[trackName];
      if (binding !== void 0) {
        ++binding.referenceCount;
        bindings[i] = binding;
      } else {
        binding = bindings[i];
        if (binding !== void 0) {
          if (binding._cacheIndex === null) {
            ++binding.referenceCount;
            this._addInactiveBinding(binding, rootUuid, trackName);
          }
          continue;
        }
        const path = prototypeAction && prototypeAction._propertyBindings[i].binding.parsedPath;
        binding = new PropertyMixer(
          PropertyBinding.create(root, trackName, path),
          track.ValueTypeName,
          track.getValueSize()
        );
        ++binding.referenceCount;
        this._addInactiveBinding(binding, rootUuid, trackName);
        bindings[i] = binding;
      }
      interpolants[i].resultBuffer = binding.buffer;
    }
  }
  _activateAction(action) {
    if (!this._isActiveAction(action)) {
      if (action._cacheIndex === null) {
        const rootUuid = (action._localRoot || this._root).uuid, clipUuid = action._clip.uuid, actionsForClip = this._actionsByClip[clipUuid];
        this._bindAction(
          action,
          actionsForClip && actionsForClip.knownActions[0]
        );
        this._addInactiveAction(action, clipUuid, rootUuid);
      }
      const bindings = action._propertyBindings;
      for (let i = 0, n = bindings.length; i !== n; ++i) {
        const binding = bindings[i];
        if (binding.useCount++ === 0) {
          this._lendBinding(binding);
          binding.saveOriginalState();
        }
      }
      this._lendAction(action);
    }
  }
  _deactivateAction(action) {
    if (this._isActiveAction(action)) {
      const bindings = action._propertyBindings;
      for (let i = 0, n = bindings.length; i !== n; ++i) {
        const binding = bindings[i];
        if (--binding.useCount === 0) {
          binding.restoreOriginalState();
          this._takeBackBinding(binding);
        }
      }
      this._takeBackAction(action);
    }
  }
  // Memory manager
  _initMemoryManager() {
    this._actions = [];
    this._nActiveActions = 0;
    this._actionsByClip = {};
    this._bindings = [];
    this._nActiveBindings = 0;
    this._bindingsByRootAndName = {};
    this._controlInterpolants = [];
    this._nActiveControlInterpolants = 0;
    const scope = this;
    this.stats = {
      actions: {
        get total() {
          return scope._actions.length;
        },
        get inUse() {
          return scope._nActiveActions;
        }
      },
      bindings: {
        get total() {
          return scope._bindings.length;
        },
        get inUse() {
          return scope._nActiveBindings;
        }
      },
      controlInterpolants: {
        get total() {
          return scope._controlInterpolants.length;
        },
        get inUse() {
          return scope._nActiveControlInterpolants;
        }
      }
    };
  }
  // Memory management for AnimationAction objects
  _isActiveAction(action) {
    const index = action._cacheIndex;
    return index !== null && index < this._nActiveActions;
  }
  _addInactiveAction(action, clipUuid, rootUuid) {
    const actions = this._actions, actionsByClip = this._actionsByClip;
    let actionsForClip = actionsByClip[clipUuid];
    if (actionsForClip === void 0) {
      actionsForClip = {
        knownActions: [action],
        actionByRoot: {}
      };
      action._byClipCacheIndex = 0;
      actionsByClip[clipUuid] = actionsForClip;
    } else {
      const knownActions = actionsForClip.knownActions;
      action._byClipCacheIndex = knownActions.length;
      knownActions.push(action);
    }
    action._cacheIndex = actions.length;
    actions.push(action);
    actionsForClip.actionByRoot[rootUuid] = action;
  }
  _removeInactiveAction(action) {
    const actions = this._actions, lastInactiveAction = actions[actions.length - 1], cacheIndex = action._cacheIndex;
    lastInactiveAction._cacheIndex = cacheIndex;
    actions[cacheIndex] = lastInactiveAction;
    actions.pop();
    action._cacheIndex = null;
    const clipUuid = action._clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid], knownActionsForClip = actionsForClip.knownActions, lastKnownAction = knownActionsForClip[knownActionsForClip.length - 1], byClipCacheIndex = action._byClipCacheIndex;
    lastKnownAction._byClipCacheIndex = byClipCacheIndex;
    knownActionsForClip[byClipCacheIndex] = lastKnownAction;
    knownActionsForClip.pop();
    action._byClipCacheIndex = null;
    const actionByRoot = actionsForClip.actionByRoot, rootUuid = (action._localRoot || this._root).uuid;
    delete actionByRoot[rootUuid];
    if (knownActionsForClip.length === 0) {
      delete actionsByClip[clipUuid];
    }
    this._removeInactiveBindingsForAction(action);
  }
  _removeInactiveBindingsForAction(action) {
    const bindings = action._propertyBindings;
    for (let i = 0, n = bindings.length; i !== n; ++i) {
      const binding = bindings[i];
      if (--binding.referenceCount === 0) {
        this._removeInactiveBinding(binding);
      }
    }
  }
  _lendAction(action) {
    const actions = this._actions, prevIndex = action._cacheIndex, lastActiveIndex = this._nActiveActions++, firstInactiveAction = actions[lastActiveIndex];
    action._cacheIndex = lastActiveIndex;
    actions[lastActiveIndex] = action;
    firstInactiveAction._cacheIndex = prevIndex;
    actions[prevIndex] = firstInactiveAction;
  }
  _takeBackAction(action) {
    const actions = this._actions, prevIndex = action._cacheIndex, firstInactiveIndex = --this._nActiveActions, lastActiveAction = actions[firstInactiveIndex];
    action._cacheIndex = firstInactiveIndex;
    actions[firstInactiveIndex] = action;
    lastActiveAction._cacheIndex = prevIndex;
    actions[prevIndex] = lastActiveAction;
  }
  // Memory management for PropertyMixer objects
  _addInactiveBinding(binding, rootUuid, trackName) {
    const bindingsByRoot = this._bindingsByRootAndName, bindings = this._bindings;
    let bindingByName = bindingsByRoot[rootUuid];
    if (bindingByName === void 0) {
      bindingByName = {};
      bindingsByRoot[rootUuid] = bindingByName;
    }
    bindingByName[trackName] = binding;
    binding._cacheIndex = bindings.length;
    bindings.push(binding);
  }
  _removeInactiveBinding(binding) {
    const bindings = this._bindings, propBinding = binding.binding, rootUuid = propBinding.rootNode.uuid, trackName = propBinding.path, bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid], lastInactiveBinding = bindings[bindings.length - 1], cacheIndex = binding._cacheIndex;
    lastInactiveBinding._cacheIndex = cacheIndex;
    bindings[cacheIndex] = lastInactiveBinding;
    bindings.pop();
    delete bindingByName[trackName];
    if (Object.keys(bindingByName).length === 0) {
      delete bindingsByRoot[rootUuid];
    }
  }
  _lendBinding(binding) {
    const bindings = this._bindings, prevIndex = binding._cacheIndex, lastActiveIndex = this._nActiveBindings++, firstInactiveBinding = bindings[lastActiveIndex];
    binding._cacheIndex = lastActiveIndex;
    bindings[lastActiveIndex] = binding;
    firstInactiveBinding._cacheIndex = prevIndex;
    bindings[prevIndex] = firstInactiveBinding;
  }
  _takeBackBinding(binding) {
    const bindings = this._bindings, prevIndex = binding._cacheIndex, firstInactiveIndex = --this._nActiveBindings, lastActiveBinding = bindings[firstInactiveIndex];
    binding._cacheIndex = firstInactiveIndex;
    bindings[firstInactiveIndex] = binding;
    lastActiveBinding._cacheIndex = prevIndex;
    bindings[prevIndex] = lastActiveBinding;
  }
  // Memory management of Interpolants for weight and time scale
  _lendControlInterpolant() {
    const interpolants = this._controlInterpolants, lastActiveIndex = this._nActiveControlInterpolants++;
    let interpolant = interpolants[lastActiveIndex];
    if (interpolant === void 0) {
      interpolant = new LinearInterpolant(
        new Float32Array(2),
        new Float32Array(2),
        1,
        _controlInterpolantsResultBuffer
      );
      interpolant.__cacheIndex = lastActiveIndex;
      interpolants[lastActiveIndex] = interpolant;
    }
    return interpolant;
  }
  _takeBackControlInterpolant(interpolant) {
    const interpolants = this._controlInterpolants, prevIndex = interpolant.__cacheIndex, firstInactiveIndex = --this._nActiveControlInterpolants, lastActiveInterpolant = interpolants[firstInactiveIndex];
    interpolant.__cacheIndex = firstInactiveIndex;
    interpolants[firstInactiveIndex] = interpolant;
    lastActiveInterpolant.__cacheIndex = prevIndex;
    interpolants[prevIndex] = lastActiveInterpolant;
  }
  // return an action for a clip optionally using a custom root target
  // object (this method allocates a lot of dynamic memory in case a
  // previously unknown clip/root combination is specified)
  clipAction(clip, optionalRoot, blendMode) {
    const root = optionalRoot || this._root, rootUuid = root.uuid;
    let clipObject = typeof clip === "string" ? AnimationClip.findByName(root, clip) : clip;
    const clipUuid = clipObject !== null ? clipObject.uuid : clip;
    const actionsForClip = this._actionsByClip[clipUuid];
    let prototypeAction = null;
    if (blendMode === void 0) {
      if (clipObject !== null) {
        blendMode = clipObject.blendMode;
      } else {
        blendMode = NormalAnimationBlendMode;
      }
    }
    if (actionsForClip !== void 0) {
      const existingAction = actionsForClip.actionByRoot[rootUuid];
      if (existingAction !== void 0 && existingAction.blendMode === blendMode) {
        return existingAction;
      }
      prototypeAction = actionsForClip.knownActions[0];
      if (clipObject === null)
        clipObject = prototypeAction._clip;
    }
    if (clipObject === null) return null;
    const newAction = new AnimationAction(this, clipObject, optionalRoot, blendMode);
    this._bindAction(newAction, prototypeAction);
    this._addInactiveAction(newAction, clipUuid, rootUuid);
    return newAction;
  }
  // get an existing action
  existingAction(clip, optionalRoot) {
    const root = optionalRoot || this._root, rootUuid = root.uuid, clipObject = typeof clip === "string" ? AnimationClip.findByName(root, clip) : clip, clipUuid = clipObject ? clipObject.uuid : clip, actionsForClip = this._actionsByClip[clipUuid];
    if (actionsForClip !== void 0) {
      return actionsForClip.actionByRoot[rootUuid] || null;
    }
    return null;
  }
  // deactivates all previously scheduled actions
  stopAllAction() {
    const actions = this._actions, nActions = this._nActiveActions;
    for (let i = nActions - 1; i >= 0; --i) {
      actions[i].stop();
    }
    return this;
  }
  // advance the time and update apply the animation
  update(deltaTime) {
    deltaTime *= this.timeScale;
    const actions = this._actions, nActions = this._nActiveActions, time = this.time += deltaTime, timeDirection = Math.sign(deltaTime), accuIndex = this._accuIndex ^= 1;
    for (let i = 0; i !== nActions; ++i) {
      const action = actions[i];
      action._update(time, deltaTime, timeDirection, accuIndex);
    }
    const bindings = this._bindings, nBindings = this._nActiveBindings;
    for (let i = 0; i !== nBindings; ++i) {
      bindings[i].apply(accuIndex);
    }
    return this;
  }
  // Allows you to seek to a specific time in an animation.
  setTime(timeInSeconds) {
    this.time = 0;
    for (let i = 0; i < this._actions.length; i++) {
      this._actions[i].time = 0;
    }
    return this.update(timeInSeconds);
  }
  // return this mixer's root target object
  getRoot() {
    return this._root;
  }
  // free all resources specific to a particular clip
  uncacheClip(clip) {
    const actions = this._actions, clipUuid = clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid];
    if (actionsForClip !== void 0) {
      const actionsToRemove = actionsForClip.knownActions;
      for (let i = 0, n = actionsToRemove.length; i !== n; ++i) {
        const action = actionsToRemove[i];
        this._deactivateAction(action);
        const cacheIndex = action._cacheIndex, lastInactiveAction = actions[actions.length - 1];
        action._cacheIndex = null;
        action._byClipCacheIndex = null;
        lastInactiveAction._cacheIndex = cacheIndex;
        actions[cacheIndex] = lastInactiveAction;
        actions.pop();
        this._removeInactiveBindingsForAction(action);
      }
      delete actionsByClip[clipUuid];
    }
  }
  // free all resources specific to a particular root target object
  uncacheRoot(root) {
    const rootUuid = root.uuid, actionsByClip = this._actionsByClip;
    for (const clipUuid in actionsByClip) {
      const actionByRoot = actionsByClip[clipUuid].actionByRoot, action = actionByRoot[rootUuid];
      if (action !== void 0) {
        this._deactivateAction(action);
        this._removeInactiveAction(action);
      }
    }
    const bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid];
    if (bindingByName !== void 0) {
      for (const trackName in bindingByName) {
        const binding = bindingByName[trackName];
        binding.restoreOriginalState();
        this._removeInactiveBinding(binding);
      }
    }
  }
  // remove a targeted clip from the cache
  uncacheAction(clip, optionalRoot) {
    const action = this.existingAction(clip, optionalRoot);
    if (action !== null) {
      this._deactivateAction(action);
      this._removeInactiveAction(action);
    }
  }
}
class RenderTarget3D extends RenderTarget {
  constructor(width = 1, height = 1, depth = 1, options = {}) {
    super(width, height, options);
    this.isRenderTarget3D = true;
    this.depth = depth;
    this.texture = new Data3DTexture(null, width, height, depth);
    this.texture.isRenderTargetTexture = true;
  }
}
class RenderTargetArray extends RenderTarget {
  constructor(width = 1, height = 1, depth = 1, options = {}) {
    super(width, height, options);
    this.isRenderTargetArray = true;
    this.depth = depth;
    this.texture = new DataArrayTexture(null, width, height, depth);
    this.texture.isRenderTargetTexture = true;
  }
}
class Uniform {
  constructor(value) {
    this.value = value;
  }
  clone() {
    return new Uniform(this.value.clone === void 0 ? this.value : this.value.clone());
  }
}
let _id$2 = 0;
class UniformsGroup extends EventDispatcher$1 {
  constructor() {
    super();
    this.isUniformsGroup = true;
    Object.defineProperty(this, "id", { value: _id$2++ });
    this.name = "";
    this.usage = StaticDrawUsage$1;
    this.uniforms = [];
  }
  add(uniform2) {
    this.uniforms.push(uniform2);
    return this;
  }
  remove(uniform2) {
    const index = this.uniforms.indexOf(uniform2);
    if (index !== -1) this.uniforms.splice(index, 1);
    return this;
  }
  setName(name) {
    this.name = name;
    return this;
  }
  setUsage(value) {
    this.usage = value;
    return this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
    return this;
  }
  copy(source) {
    this.name = source.name;
    this.usage = source.usage;
    const uniformsSource = source.uniforms;
    this.uniforms.length = 0;
    for (let i = 0, l = uniformsSource.length; i < l; i++) {
      const uniforms = Array.isArray(uniformsSource[i]) ? uniformsSource[i] : [uniformsSource[i]];
      for (let j = 0; j < uniforms.length; j++) {
        this.uniforms.push(uniforms[j].clone());
      }
    }
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class InstancedInterleavedBuffer extends InterleavedBuffer$1 {
  constructor(array, stride, meshPerAttribute = 1) {
    super(array, stride);
    this.isInstancedInterleavedBuffer = true;
    this.meshPerAttribute = meshPerAttribute;
  }
  copy(source) {
    super.copy(source);
    this.meshPerAttribute = source.meshPerAttribute;
    return this;
  }
  clone(data) {
    const ib = super.clone(data);
    ib.meshPerAttribute = this.meshPerAttribute;
    return ib;
  }
  toJSON(data) {
    const json = super.toJSON(data);
    json.isInstancedInterleavedBuffer = true;
    json.meshPerAttribute = this.meshPerAttribute;
    return json;
  }
}
class GLBufferAttribute {
  constructor(buffer, type, itemSize, elementSize, count) {
    this.isGLBufferAttribute = true;
    this.name = "";
    this.buffer = buffer;
    this.type = type;
    this.itemSize = itemSize;
    this.elementSize = elementSize;
    this.count = count;
    this.version = 0;
  }
  set needsUpdate(value) {
    if (value === true) this.version++;
  }
  setBuffer(buffer) {
    this.buffer = buffer;
    return this;
  }
  setType(type, elementSize) {
    this.type = type;
    this.elementSize = elementSize;
    return this;
  }
  setItemSize(itemSize) {
    this.itemSize = itemSize;
    return this;
  }
  setCount(count) {
    this.count = count;
    return this;
  }
}
const _matrix = /* @__PURE__ */ new Matrix4$1();
class Raycaster {
  constructor(origin, direction, near = 0, far = Infinity) {
    this.ray = new Ray(origin, direction);
    this.near = near;
    this.far = far;
    this.camera = null;
    this.layers = new Layers();
    this.params = {
      Mesh: {},
      Line: { threshold: 1 },
      LOD: {},
      Points: { threshold: 1 },
      Sprite: {}
    };
  }
  set(origin, direction) {
    this.ray.set(origin, direction);
  }
  setFromCamera(coords, camera) {
    if (camera.isPerspectiveCamera) {
      this.ray.origin.setFromMatrixPosition(camera.matrixWorld);
      this.ray.direction.set(coords.x, coords.y, 0.5).unproject(camera).sub(this.ray.origin).normalize();
      this.camera = camera;
    } else if (camera.isOrthographicCamera) {
      this.ray.origin.set(coords.x, coords.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera);
      this.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld);
      this.camera = camera;
    } else {
      console.error("THREE.Raycaster: Unsupported camera type: " + camera.type);
    }
  }
  setFromXRController(controller) {
    _matrix.identity().extractRotation(controller.matrixWorld);
    this.ray.origin.setFromMatrixPosition(controller.matrixWorld);
    this.ray.direction.set(0, 0, -1).applyMatrix4(_matrix);
    return this;
  }
  intersectObject(object, recursive = true, intersects2 = []) {
    intersect(object, this, intersects2, recursive);
    intersects2.sort(ascSort);
    return intersects2;
  }
  intersectObjects(objects, recursive = true, intersects2 = []) {
    for (let i = 0, l = objects.length; i < l; i++) {
      intersect(objects[i], this, intersects2, recursive);
    }
    intersects2.sort(ascSort);
    return intersects2;
  }
}
function ascSort(a, b) {
  return a.distance - b.distance;
}
function intersect(object, raycaster, intersects2, recursive) {
  let propagate = true;
  if (object.layers.test(raycaster.layers)) {
    const result = object.raycast(raycaster, intersects2);
    if (result === false) propagate = false;
  }
  if (propagate === true && recursive === true) {
    const children = object.children;
    for (let i = 0, l = children.length; i < l; i++) {
      intersect(children[i], raycaster, intersects2, true);
    }
  }
}
class Spherical {
  constructor(radius = 1, phi = 0, theta = 0) {
    this.radius = radius;
    this.phi = phi;
    this.theta = theta;
    return this;
  }
  set(radius, phi, theta) {
    this.radius = radius;
    this.phi = phi;
    this.theta = theta;
    return this;
  }
  copy(other) {
    this.radius = other.radius;
    this.phi = other.phi;
    this.theta = other.theta;
    return this;
  }
  // restrict phi to be between EPS and PI-EPS
  makeSafe() {
    const EPS = 1e-6;
    this.phi = clamp$2(this.phi, EPS, Math.PI - EPS);
    return this;
  }
  setFromVector3(v) {
    return this.setFromCartesianCoords(v.x, v.y, v.z);
  }
  setFromCartesianCoords(x, y, z) {
    this.radius = Math.sqrt(x * x + y * y + z * z);
    if (this.radius === 0) {
      this.theta = 0;
      this.phi = 0;
    } else {
      this.theta = Math.atan2(x, z);
      this.phi = Math.acos(clamp$2(y / this.radius, -1, 1));
    }
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class Cylindrical {
  constructor(radius = 1, theta = 0, y = 0) {
    this.radius = radius;
    this.theta = theta;
    this.y = y;
    return this;
  }
  set(radius, theta, y) {
    this.radius = radius;
    this.theta = theta;
    this.y = y;
    return this;
  }
  copy(other) {
    this.radius = other.radius;
    this.theta = other.theta;
    this.y = other.y;
    return this;
  }
  setFromVector3(v) {
    return this.setFromCartesianCoords(v.x, v.y, v.z);
  }
  setFromCartesianCoords(x, y, z) {
    this.radius = Math.sqrt(x * x + z * z);
    this.theta = Math.atan2(x, z);
    this.y = y;
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class Matrix2 {
  constructor(n11, n12, n21, n22) {
    Matrix2.prototype.isMatrix2 = true;
    this.elements = [
      1,
      0,
      0,
      1
    ];
    if (n11 !== void 0) {
      this.set(n11, n12, n21, n22);
    }
  }
  identity() {
    this.set(
      1,
      0,
      0,
      1
    );
    return this;
  }
  fromArray(array, offset = 0) {
    for (let i = 0; i < 4; i++) {
      this.elements[i] = array[i + offset];
    }
    return this;
  }
  set(n11, n12, n21, n22) {
    const te = this.elements;
    te[0] = n11;
    te[2] = n12;
    te[1] = n21;
    te[3] = n22;
    return this;
  }
}
const _vector$4 = /* @__PURE__ */ new Vector2$1();
class Box2 {
  constructor(min2 = new Vector2$1(Infinity, Infinity), max2 = new Vector2$1(-Infinity, -Infinity)) {
    this.isBox2 = true;
    this.min = min2;
    this.max = max2;
  }
  set(min2, max2) {
    this.min.copy(min2);
    this.max.copy(max2);
    return this;
  }
  setFromPoints(points) {
    this.makeEmpty();
    for (let i = 0, il = points.length; i < il; i++) {
      this.expandByPoint(points[i]);
    }
    return this;
  }
  setFromCenterAndSize(center, size) {
    const halfSize = _vector$4.copy(size).multiplyScalar(0.5);
    this.min.copy(center).sub(halfSize);
    this.max.copy(center).add(halfSize);
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(box) {
    this.min.copy(box.min);
    this.max.copy(box.max);
    return this;
  }
  makeEmpty() {
    this.min.x = this.min.y = Infinity;
    this.max.x = this.max.y = -Infinity;
    return this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y;
  }
  getCenter(target) {
    return this.isEmpty() ? target.set(0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(target) {
    return this.isEmpty() ? target.set(0, 0) : target.subVectors(this.max, this.min);
  }
  expandByPoint(point) {
    this.min.min(point);
    this.max.max(point);
    return this;
  }
  expandByVector(vector) {
    this.min.sub(vector);
    this.max.add(vector);
    return this;
  }
  expandByScalar(scalar) {
    this.min.addScalar(-scalar);
    this.max.addScalar(scalar);
    return this;
  }
  containsPoint(point) {
    return point.x >= this.min.x && point.x <= this.max.x && point.y >= this.min.y && point.y <= this.max.y;
  }
  containsBox(box) {
    return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y;
  }
  getParameter(point, target) {
    return target.set(
      (point.x - this.min.x) / (this.max.x - this.min.x),
      (point.y - this.min.y) / (this.max.y - this.min.y)
    );
  }
  intersectsBox(box) {
    return box.max.x >= this.min.x && box.min.x <= this.max.x && box.max.y >= this.min.y && box.min.y <= this.max.y;
  }
  clampPoint(point, target) {
    return target.copy(point).clamp(this.min, this.max);
  }
  distanceToPoint(point) {
    return this.clampPoint(point, _vector$4).distanceTo(point);
  }
  intersect(box) {
    this.min.max(box.min);
    this.max.min(box.max);
    if (this.isEmpty()) this.makeEmpty();
    return this;
  }
  union(box) {
    this.min.min(box.min);
    this.max.max(box.max);
    return this;
  }
  translate(offset) {
    this.min.add(offset);
    this.max.add(offset);
    return this;
  }
  equals(box) {
    return box.min.equals(this.min) && box.max.equals(this.max);
  }
}
const _startP = /* @__PURE__ */ new Vector3$1();
const _startEnd = /* @__PURE__ */ new Vector3$1();
class Line3 {
  constructor(start = new Vector3$1(), end = new Vector3$1()) {
    this.start = start;
    this.end = end;
  }
  set(start, end) {
    this.start.copy(start);
    this.end.copy(end);
    return this;
  }
  copy(line) {
    this.start.copy(line.start);
    this.end.copy(line.end);
    return this;
  }
  getCenter(target) {
    return target.addVectors(this.start, this.end).multiplyScalar(0.5);
  }
  delta(target) {
    return target.subVectors(this.end, this.start);
  }
  distanceSq() {
    return this.start.distanceToSquared(this.end);
  }
  distance() {
    return this.start.distanceTo(this.end);
  }
  at(t, target) {
    return this.delta(target).multiplyScalar(t).add(this.start);
  }
  closestPointToPointParameter(point, clampToLine) {
    _startP.subVectors(point, this.start);
    _startEnd.subVectors(this.end, this.start);
    const startEnd2 = _startEnd.dot(_startEnd);
    const startEnd_startP = _startEnd.dot(_startP);
    let t = startEnd_startP / startEnd2;
    if (clampToLine) {
      t = clamp$2(t, 0, 1);
    }
    return t;
  }
  closestPointToPoint(point, clampToLine, target) {
    const t = this.closestPointToPointParameter(point, clampToLine);
    return this.delta(target).multiplyScalar(t).add(this.start);
  }
  applyMatrix4(matrix) {
    this.start.applyMatrix4(matrix);
    this.end.applyMatrix4(matrix);
    return this;
  }
  equals(line) {
    return line.start.equals(this.start) && line.end.equals(this.end);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const _vector$3 = /* @__PURE__ */ new Vector3$1();
class SpotLightHelper extends Object3D {
  constructor(light, color2) {
    super();
    this.light = light;
    this.matrixAutoUpdate = false;
    this.color = color2;
    this.type = "SpotLightHelper";
    const geometry = new BufferGeometry();
    const positions = [
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1,
      0,
      1,
      0,
      0,
      0,
      -1,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      1,
      0,
      0,
      0,
      0,
      -1,
      1
    ];
    for (let i = 0, j = 1, l = 32; i < l; i++, j++) {
      const p1 = i / l * Math.PI * 2;
      const p2 = j / l * Math.PI * 2;
      positions.push(
        Math.cos(p1),
        Math.sin(p1),
        1,
        Math.cos(p2),
        Math.sin(p2),
        1
      );
    }
    geometry.setAttribute("position", new Float32BufferAttribute(positions, 3));
    const material = new LineBasicMaterial({ fog: false, toneMapped: false });
    this.cone = new LineSegments(geometry, material);
    this.add(this.cone);
    this.update();
  }
  dispose() {
    this.cone.geometry.dispose();
    this.cone.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(true, false);
    this.light.target.updateWorldMatrix(true, false);
    if (this.parent) {
      this.parent.updateWorldMatrix(true);
      this.matrix.copy(this.parent.matrixWorld).invert().multiply(this.light.matrixWorld);
    } else {
      this.matrix.copy(this.light.matrixWorld);
    }
    this.matrixWorld.copy(this.light.matrixWorld);
    const coneLength = this.light.distance ? this.light.distance : 1e3;
    const coneWidth = coneLength * Math.tan(this.light.angle);
    this.cone.scale.set(coneWidth, coneWidth, coneLength);
    _vector$3.setFromMatrixPosition(this.light.target.matrixWorld);
    this.cone.lookAt(_vector$3);
    if (this.color !== void 0) {
      this.cone.material.color.set(this.color);
    } else {
      this.cone.material.color.copy(this.light.color);
    }
  }
}
const _vector$2$1 = /* @__PURE__ */ new Vector3$1();
const _boneMatrix = /* @__PURE__ */ new Matrix4$1();
const _matrixWorldInv = /* @__PURE__ */ new Matrix4$1();
class SkeletonHelper extends LineSegments {
  constructor(object) {
    const bones = getBoneList(object);
    const geometry = new BufferGeometry();
    const vertices = [];
    const colors = [];
    const color1 = new Color$1(0, 0, 1);
    const color2 = new Color$1(0, 1, 0);
    for (let i = 0; i < bones.length; i++) {
      const bone = bones[i];
      if (bone.parent && bone.parent.isBone) {
        vertices.push(0, 0, 0);
        vertices.push(0, 0, 0);
        colors.push(color1.r, color1.g, color1.b);
        colors.push(color2.r, color2.g, color2.b);
      }
    }
    geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
    const material = new LineBasicMaterial({ vertexColors: true, depthTest: false, depthWrite: false, toneMapped: false, transparent: true });
    super(geometry, material);
    this.isSkeletonHelper = true;
    this.type = "SkeletonHelper";
    this.root = object;
    this.bones = bones;
    this.matrix = object.matrixWorld;
    this.matrixAutoUpdate = false;
  }
  updateMatrixWorld(force) {
    const bones = this.bones;
    const geometry = this.geometry;
    const position = geometry.getAttribute("position");
    _matrixWorldInv.copy(this.root.matrixWorld).invert();
    for (let i = 0, j = 0; i < bones.length; i++) {
      const bone = bones[i];
      if (bone.parent && bone.parent.isBone) {
        _boneMatrix.multiplyMatrices(_matrixWorldInv, bone.matrixWorld);
        _vector$2$1.setFromMatrixPosition(_boneMatrix);
        position.setXYZ(j, _vector$2$1.x, _vector$2$1.y, _vector$2$1.z);
        _boneMatrix.multiplyMatrices(_matrixWorldInv, bone.parent.matrixWorld);
        _vector$2$1.setFromMatrixPosition(_boneMatrix);
        position.setXYZ(j + 1, _vector$2$1.x, _vector$2$1.y, _vector$2$1.z);
        j += 2;
      }
    }
    geometry.getAttribute("position").needsUpdate = true;
    super.updateMatrixWorld(force);
  }
  dispose() {
    this.geometry.dispose();
    this.material.dispose();
  }
}
function getBoneList(object) {
  const boneList = [];
  if (object.isBone === true) {
    boneList.push(object);
  }
  for (let i = 0; i < object.children.length; i++) {
    boneList.push.apply(boneList, getBoneList(object.children[i]));
  }
  return boneList;
}
class PointLightHelper extends Mesh {
  constructor(light, sphereSize, color2) {
    const geometry = new SphereGeometry(sphereSize, 4, 2);
    const material = new MeshBasicMaterial({ wireframe: true, fog: false, toneMapped: false });
    super(geometry, material);
    this.light = light;
    this.color = color2;
    this.type = "PointLightHelper";
    this.matrix = this.light.matrixWorld;
    this.matrixAutoUpdate = false;
    this.update();
  }
  dispose() {
    this.geometry.dispose();
    this.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(true, false);
    if (this.color !== void 0) {
      this.material.color.set(this.color);
    } else {
      this.material.color.copy(this.light.color);
    }
  }
}
const _vector$1$1 = /* @__PURE__ */ new Vector3$1();
const _color1 = /* @__PURE__ */ new Color$1();
const _color2 = /* @__PURE__ */ new Color$1();
class HemisphereLightHelper extends Object3D {
  constructor(light, size, color2) {
    super();
    this.light = light;
    this.matrix = light.matrixWorld;
    this.matrixAutoUpdate = false;
    this.color = color2;
    this.type = "HemisphereLightHelper";
    const geometry = new OctahedronGeometry(size);
    geometry.rotateY(Math.PI * 0.5);
    this.material = new MeshBasicMaterial({ wireframe: true, fog: false, toneMapped: false });
    if (this.color === void 0) this.material.vertexColors = true;
    const position = geometry.getAttribute("position");
    const colors = new Float32Array(position.count * 3);
    geometry.setAttribute("color", new BufferAttribute$1(colors, 3));
    this.add(new Mesh(geometry, this.material));
    this.update();
  }
  dispose() {
    this.children[0].geometry.dispose();
    this.children[0].material.dispose();
  }
  update() {
    const mesh = this.children[0];
    if (this.color !== void 0) {
      this.material.color.set(this.color);
    } else {
      const colors = mesh.geometry.getAttribute("color");
      _color1.copy(this.light.color);
      _color2.copy(this.light.groundColor);
      for (let i = 0, l = colors.count; i < l; i++) {
        const color2 = i < l / 2 ? _color1 : _color2;
        colors.setXYZ(i, color2.r, color2.g, color2.b);
      }
      colors.needsUpdate = true;
    }
    this.light.updateWorldMatrix(true, false);
    mesh.lookAt(_vector$1$1.setFromMatrixPosition(this.light.matrixWorld).negate());
  }
}
class GridHelper extends LineSegments {
  constructor(size = 10, divisions = 10, color1 = 4473924, color2 = 8947848) {
    color1 = new Color$1(color1);
    color2 = new Color$1(color2);
    const center = divisions / 2;
    const step2 = size / divisions;
    const halfSize = size / 2;
    const vertices = [], colors = [];
    for (let i = 0, j = 0, k = -halfSize; i <= divisions; i++, k += step2) {
      vertices.push(-halfSize, 0, k, halfSize, 0, k);
      vertices.push(k, 0, -halfSize, k, 0, halfSize);
      const color3 = i === center ? color1 : color2;
      color3.toArray(colors, j);
      j += 3;
      color3.toArray(colors, j);
      j += 3;
      color3.toArray(colors, j);
      j += 3;
      color3.toArray(colors, j);
      j += 3;
    }
    const geometry = new BufferGeometry();
    geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
    const material = new LineBasicMaterial({ vertexColors: true, toneMapped: false });
    super(geometry, material);
    this.type = "GridHelper";
  }
  dispose() {
    this.geometry.dispose();
    this.material.dispose();
  }
}
class PolarGridHelper extends LineSegments {
  constructor(radius = 10, sectors = 16, rings = 8, divisions = 64, color1 = 4473924, color2 = 8947848) {
    color1 = new Color$1(color1);
    color2 = new Color$1(color2);
    const vertices = [];
    const colors = [];
    if (sectors > 1) {
      for (let i = 0; i < sectors; i++) {
        const v = i / sectors * (Math.PI * 2);
        const x = Math.sin(v) * radius;
        const z = Math.cos(v) * radius;
        vertices.push(0, 0, 0);
        vertices.push(x, 0, z);
        const color3 = i & 1 ? color1 : color2;
        colors.push(color3.r, color3.g, color3.b);
        colors.push(color3.r, color3.g, color3.b);
      }
    }
    for (let i = 0; i < rings; i++) {
      const color3 = i & 1 ? color1 : color2;
      const r = radius - radius / rings * i;
      for (let j = 0; j < divisions; j++) {
        let v = j / divisions * (Math.PI * 2);
        let x = Math.sin(v) * r;
        let z = Math.cos(v) * r;
        vertices.push(x, 0, z);
        colors.push(color3.r, color3.g, color3.b);
        v = (j + 1) / divisions * (Math.PI * 2);
        x = Math.sin(v) * r;
        z = Math.cos(v) * r;
        vertices.push(x, 0, z);
        colors.push(color3.r, color3.g, color3.b);
      }
    }
    const geometry = new BufferGeometry();
    geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
    const material = new LineBasicMaterial({ vertexColors: true, toneMapped: false });
    super(geometry, material);
    this.type = "PolarGridHelper";
  }
  dispose() {
    this.geometry.dispose();
    this.material.dispose();
  }
}
const _v1$8 = /* @__PURE__ */ new Vector3$1();
const _v2 = /* @__PURE__ */ new Vector3$1();
const _v3 = /* @__PURE__ */ new Vector3$1();
class DirectionalLightHelper extends Object3D {
  constructor(light, size, color2) {
    super();
    this.light = light;
    this.matrix = light.matrixWorld;
    this.matrixAutoUpdate = false;
    this.color = color2;
    this.type = "DirectionalLightHelper";
    if (size === void 0) size = 1;
    let geometry = new BufferGeometry();
    geometry.setAttribute("position", new Float32BufferAttribute([
      -size,
      size,
      0,
      size,
      size,
      0,
      size,
      -size,
      0,
      -size,
      -size,
      0,
      -size,
      size,
      0
    ], 3));
    const material = new LineBasicMaterial({ fog: false, toneMapped: false });
    this.lightPlane = new Line(geometry, material);
    this.add(this.lightPlane);
    geometry = new BufferGeometry();
    geometry.setAttribute("position", new Float32BufferAttribute([0, 0, 0, 0, 0, 1], 3));
    this.targetLine = new Line(geometry, material);
    this.add(this.targetLine);
    this.update();
  }
  dispose() {
    this.lightPlane.geometry.dispose();
    this.lightPlane.material.dispose();
    this.targetLine.geometry.dispose();
    this.targetLine.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(true, false);
    this.light.target.updateWorldMatrix(true, false);
    _v1$8.setFromMatrixPosition(this.light.matrixWorld);
    _v2.setFromMatrixPosition(this.light.target.matrixWorld);
    _v3.subVectors(_v2, _v1$8);
    this.lightPlane.lookAt(_v2);
    if (this.color !== void 0) {
      this.lightPlane.material.color.set(this.color);
      this.targetLine.material.color.set(this.color);
    } else {
      this.lightPlane.material.color.copy(this.light.color);
      this.targetLine.material.color.copy(this.light.color);
    }
    this.targetLine.lookAt(_v2);
    this.targetLine.scale.z = _v3.length();
  }
}
const _vector$d = /* @__PURE__ */ new Vector3$1();
const _camera = /* @__PURE__ */ new Camera();
class CameraHelper extends LineSegments {
  constructor(camera) {
    const geometry = new BufferGeometry();
    const material = new LineBasicMaterial({ color: 16777215, vertexColors: true, toneMapped: false });
    const vertices = [];
    const colors = [];
    const pointMap = {};
    addLine("n1", "n2");
    addLine("n2", "n4");
    addLine("n4", "n3");
    addLine("n3", "n1");
    addLine("f1", "f2");
    addLine("f2", "f4");
    addLine("f4", "f3");
    addLine("f3", "f1");
    addLine("n1", "f1");
    addLine("n2", "f2");
    addLine("n3", "f3");
    addLine("n4", "f4");
    addLine("p", "n1");
    addLine("p", "n2");
    addLine("p", "n3");
    addLine("p", "n4");
    addLine("u1", "u2");
    addLine("u2", "u3");
    addLine("u3", "u1");
    addLine("c", "t");
    addLine("p", "c");
    addLine("cn1", "cn2");
    addLine("cn3", "cn4");
    addLine("cf1", "cf2");
    addLine("cf3", "cf4");
    function addLine(a, b) {
      addPoint(a);
      addPoint(b);
    }
    function addPoint(id) {
      vertices.push(0, 0, 0);
      colors.push(0, 0, 0);
      if (pointMap[id] === void 0) {
        pointMap[id] = [];
      }
      pointMap[id].push(vertices.length / 3 - 1);
    }
    geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
    super(geometry, material);
    this.type = "CameraHelper";
    this.camera = camera;
    if (this.camera.updateProjectionMatrix) this.camera.updateProjectionMatrix();
    this.matrix = camera.matrixWorld;
    this.matrixAutoUpdate = false;
    this.pointMap = pointMap;
    this.update();
    const colorFrustum = new Color$1(16755200);
    const colorCone = new Color$1(16711680);
    const colorUp = new Color$1(43775);
    const colorTarget = new Color$1(16777215);
    const colorCross = new Color$1(3355443);
    this.setColors(colorFrustum, colorCone, colorUp, colorTarget, colorCross);
  }
  setColors(frustum, cone, up, target, cross2) {
    const geometry = this.geometry;
    const colorAttribute = geometry.getAttribute("color");
    colorAttribute.setXYZ(0, frustum.r, frustum.g, frustum.b);
    colorAttribute.setXYZ(1, frustum.r, frustum.g, frustum.b);
    colorAttribute.setXYZ(2, frustum.r, frustum.g, frustum.b);
    colorAttribute.setXYZ(3, frustum.r, frustum.g, frustum.b);
    colorAttribute.setXYZ(4, frustum.r, frustum.g, frustum.b);
    colorAttribute.setXYZ(5, frustum.r, frustum.g, frustum.b);
    colorAttribute.setXYZ(6, frustum.r, frustum.g, frustum.b);
    colorAttribute.setXYZ(7, frustum.r, frustum.g, frustum.b);
    colorAttribute.setXYZ(8, frustum.r, frustum.g, frustum.b);
    colorAttribute.setXYZ(9, frustum.r, frustum.g, frustum.b);
    colorAttribute.setXYZ(10, frustum.r, frustum.g, frustum.b);
    colorAttribute.setXYZ(11, frustum.r, frustum.g, frustum.b);
    colorAttribute.setXYZ(12, frustum.r, frustum.g, frustum.b);
    colorAttribute.setXYZ(13, frustum.r, frustum.g, frustum.b);
    colorAttribute.setXYZ(14, frustum.r, frustum.g, frustum.b);
    colorAttribute.setXYZ(15, frustum.r, frustum.g, frustum.b);
    colorAttribute.setXYZ(16, frustum.r, frustum.g, frustum.b);
    colorAttribute.setXYZ(17, frustum.r, frustum.g, frustum.b);
    colorAttribute.setXYZ(18, frustum.r, frustum.g, frustum.b);
    colorAttribute.setXYZ(19, frustum.r, frustum.g, frustum.b);
    colorAttribute.setXYZ(20, frustum.r, frustum.g, frustum.b);
    colorAttribute.setXYZ(21, frustum.r, frustum.g, frustum.b);
    colorAttribute.setXYZ(22, frustum.r, frustum.g, frustum.b);
    colorAttribute.setXYZ(23, frustum.r, frustum.g, frustum.b);
    colorAttribute.setXYZ(24, cone.r, cone.g, cone.b);
    colorAttribute.setXYZ(25, cone.r, cone.g, cone.b);
    colorAttribute.setXYZ(26, cone.r, cone.g, cone.b);
    colorAttribute.setXYZ(27, cone.r, cone.g, cone.b);
    colorAttribute.setXYZ(28, cone.r, cone.g, cone.b);
    colorAttribute.setXYZ(29, cone.r, cone.g, cone.b);
    colorAttribute.setXYZ(30, cone.r, cone.g, cone.b);
    colorAttribute.setXYZ(31, cone.r, cone.g, cone.b);
    colorAttribute.setXYZ(32, up.r, up.g, up.b);
    colorAttribute.setXYZ(33, up.r, up.g, up.b);
    colorAttribute.setXYZ(34, up.r, up.g, up.b);
    colorAttribute.setXYZ(35, up.r, up.g, up.b);
    colorAttribute.setXYZ(36, up.r, up.g, up.b);
    colorAttribute.setXYZ(37, up.r, up.g, up.b);
    colorAttribute.setXYZ(38, target.r, target.g, target.b);
    colorAttribute.setXYZ(39, target.r, target.g, target.b);
    colorAttribute.setXYZ(40, cross2.r, cross2.g, cross2.b);
    colorAttribute.setXYZ(41, cross2.r, cross2.g, cross2.b);
    colorAttribute.setXYZ(42, cross2.r, cross2.g, cross2.b);
    colorAttribute.setXYZ(43, cross2.r, cross2.g, cross2.b);
    colorAttribute.setXYZ(44, cross2.r, cross2.g, cross2.b);
    colorAttribute.setXYZ(45, cross2.r, cross2.g, cross2.b);
    colorAttribute.setXYZ(46, cross2.r, cross2.g, cross2.b);
    colorAttribute.setXYZ(47, cross2.r, cross2.g, cross2.b);
    colorAttribute.setXYZ(48, cross2.r, cross2.g, cross2.b);
    colorAttribute.setXYZ(49, cross2.r, cross2.g, cross2.b);
    colorAttribute.needsUpdate = true;
  }
  update() {
    const geometry = this.geometry;
    const pointMap = this.pointMap;
    const w = 1, h = 1;
    _camera.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse);
    const nearZ = this.camera.coordinateSystem === WebGLCoordinateSystem$1 ? -1 : 0;
    setPoint("c", pointMap, geometry, _camera, 0, 0, nearZ);
    setPoint("t", pointMap, geometry, _camera, 0, 0, 1);
    setPoint("n1", pointMap, geometry, _camera, -1, -1, nearZ);
    setPoint("n2", pointMap, geometry, _camera, w, -1, nearZ);
    setPoint("n3", pointMap, geometry, _camera, -1, h, nearZ);
    setPoint("n4", pointMap, geometry, _camera, w, h, nearZ);
    setPoint("f1", pointMap, geometry, _camera, -1, -1, 1);
    setPoint("f2", pointMap, geometry, _camera, w, -1, 1);
    setPoint("f3", pointMap, geometry, _camera, -1, h, 1);
    setPoint("f4", pointMap, geometry, _camera, w, h, 1);
    setPoint("u1", pointMap, geometry, _camera, w * 0.7, h * 1.1, nearZ);
    setPoint("u2", pointMap, geometry, _camera, -1 * 0.7, h * 1.1, nearZ);
    setPoint("u3", pointMap, geometry, _camera, 0, h * 2, nearZ);
    setPoint("cf1", pointMap, geometry, _camera, -1, 0, 1);
    setPoint("cf2", pointMap, geometry, _camera, w, 0, 1);
    setPoint("cf3", pointMap, geometry, _camera, 0, -1, 1);
    setPoint("cf4", pointMap, geometry, _camera, 0, h, 1);
    setPoint("cn1", pointMap, geometry, _camera, -1, 0, nearZ);
    setPoint("cn2", pointMap, geometry, _camera, w, 0, nearZ);
    setPoint("cn3", pointMap, geometry, _camera, 0, -1, nearZ);
    setPoint("cn4", pointMap, geometry, _camera, 0, h, nearZ);
    geometry.getAttribute("position").needsUpdate = true;
  }
  dispose() {
    this.geometry.dispose();
    this.material.dispose();
  }
}
function setPoint(point, pointMap, geometry, camera, x, y, z) {
  _vector$d.set(x, y, z).unproject(camera);
  const points = pointMap[point];
  if (points !== void 0) {
    const position = geometry.getAttribute("position");
    for (let i = 0, l = points.length; i < l; i++) {
      position.setXYZ(points[i], _vector$d.x, _vector$d.y, _vector$d.z);
    }
  }
}
const _box = /* @__PURE__ */ new Box3();
class BoxHelper extends LineSegments {
  constructor(object, color2 = 16776960) {
    const indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
    const positions = new Float32Array(8 * 3);
    const geometry = new BufferGeometry();
    geometry.setIndex(new BufferAttribute$1(indices, 1));
    geometry.setAttribute("position", new BufferAttribute$1(positions, 3));
    super(geometry, new LineBasicMaterial({ color: color2, toneMapped: false }));
    this.object = object;
    this.type = "BoxHelper";
    this.matrixAutoUpdate = false;
    this.update();
  }
  update(object) {
    if (object !== void 0) {
      console.warn("THREE.BoxHelper: .update() has no longer arguments.");
    }
    if (this.object !== void 0) {
      _box.setFromObject(this.object);
    }
    if (_box.isEmpty()) return;
    const min2 = _box.min;
    const max2 = _box.max;
    const position = this.geometry.attributes.position;
    const array = position.array;
    array[0] = max2.x;
    array[1] = max2.y;
    array[2] = max2.z;
    array[3] = min2.x;
    array[4] = max2.y;
    array[5] = max2.z;
    array[6] = min2.x;
    array[7] = min2.y;
    array[8] = max2.z;
    array[9] = max2.x;
    array[10] = min2.y;
    array[11] = max2.z;
    array[12] = max2.x;
    array[13] = max2.y;
    array[14] = min2.z;
    array[15] = min2.x;
    array[16] = max2.y;
    array[17] = min2.z;
    array[18] = min2.x;
    array[19] = min2.y;
    array[20] = min2.z;
    array[21] = max2.x;
    array[22] = min2.y;
    array[23] = min2.z;
    position.needsUpdate = true;
    this.geometry.computeBoundingSphere();
  }
  setFromObject(object) {
    this.object = object;
    this.update();
    return this;
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.object = source.object;
    return this;
  }
  dispose() {
    this.geometry.dispose();
    this.material.dispose();
  }
}
class Box3Helper extends LineSegments {
  constructor(box, color2 = 16776960) {
    const indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
    const positions = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1];
    const geometry = new BufferGeometry();
    geometry.setIndex(new BufferAttribute$1(indices, 1));
    geometry.setAttribute("position", new Float32BufferAttribute(positions, 3));
    super(geometry, new LineBasicMaterial({ color: color2, toneMapped: false }));
    this.box = box;
    this.type = "Box3Helper";
    this.geometry.computeBoundingSphere();
  }
  updateMatrixWorld(force) {
    const box = this.box;
    if (box.isEmpty()) return;
    box.getCenter(this.position);
    box.getSize(this.scale);
    this.scale.multiplyScalar(0.5);
    super.updateMatrixWorld(force);
  }
  dispose() {
    this.geometry.dispose();
    this.material.dispose();
  }
}
class PlaneHelper extends Line {
  constructor(plane, size = 1, hex = 16776960) {
    const color2 = hex;
    const positions = [1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0];
    const geometry = new BufferGeometry();
    geometry.setAttribute("position", new Float32BufferAttribute(positions, 3));
    geometry.computeBoundingSphere();
    super(geometry, new LineBasicMaterial({ color: color2, toneMapped: false }));
    this.type = "PlaneHelper";
    this.plane = plane;
    this.size = size;
    const positions2 = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0];
    const geometry2 = new BufferGeometry();
    geometry2.setAttribute("position", new Float32BufferAttribute(positions2, 3));
    geometry2.computeBoundingSphere();
    this.add(new Mesh(geometry2, new MeshBasicMaterial({ color: color2, opacity: 0.2, transparent: true, depthWrite: false, toneMapped: false })));
  }
  updateMatrixWorld(force) {
    this.position.set(0, 0, 0);
    this.scale.set(0.5 * this.size, 0.5 * this.size, 1);
    this.lookAt(this.plane.normal);
    this.translateZ(-this.plane.constant);
    super.updateMatrixWorld(force);
  }
  dispose() {
    this.geometry.dispose();
    this.material.dispose();
    this.children[0].geometry.dispose();
    this.children[0].material.dispose();
  }
}
const _axis = /* @__PURE__ */ new Vector3$1();
let _lineGeometry, _coneGeometry;
class ArrowHelper extends Object3D {
  // dir is assumed to be normalized
  constructor(dir = new Vector3$1(0, 0, 1), origin = new Vector3$1(0, 0, 0), length2 = 1, color2 = 16776960, headLength = length2 * 0.2, headWidth = headLength * 0.2) {
    super();
    this.type = "ArrowHelper";
    if (_lineGeometry === void 0) {
      _lineGeometry = new BufferGeometry();
      _lineGeometry.setAttribute("position", new Float32BufferAttribute([0, 0, 0, 0, 1, 0], 3));
      _coneGeometry = new CylinderGeometry(0, 0.5, 1, 5, 1);
      _coneGeometry.translate(0, -0.5, 0);
    }
    this.position.copy(origin);
    this.line = new Line(_lineGeometry, new LineBasicMaterial({ color: color2, toneMapped: false }));
    this.line.matrixAutoUpdate = false;
    this.add(this.line);
    this.cone = new Mesh(_coneGeometry, new MeshBasicMaterial({ color: color2, toneMapped: false }));
    this.cone.matrixAutoUpdate = false;
    this.add(this.cone);
    this.setDirection(dir);
    this.setLength(length2, headLength, headWidth);
  }
  setDirection(dir) {
    if (dir.y > 0.99999) {
      this.quaternion.set(0, 0, 0, 1);
    } else if (dir.y < -0.99999) {
      this.quaternion.set(1, 0, 0, 0);
    } else {
      _axis.set(dir.z, 0, -dir.x).normalize();
      const radians2 = Math.acos(dir.y);
      this.quaternion.setFromAxisAngle(_axis, radians2);
    }
  }
  setLength(length2, headLength = length2 * 0.2, headWidth = headLength * 0.2) {
    this.line.scale.set(1, Math.max(1e-4, length2 - headLength), 1);
    this.line.updateMatrix();
    this.cone.scale.set(headWidth, headLength, headWidth);
    this.cone.position.y = length2;
    this.cone.updateMatrix();
  }
  setColor(color2) {
    this.line.material.color.set(color2);
    this.cone.material.color.set(color2);
  }
  copy(source) {
    super.copy(source, false);
    this.line.copy(source.line);
    this.cone.copy(source.cone);
    return this;
  }
  dispose() {
    this.line.geometry.dispose();
    this.line.material.dispose();
    this.cone.geometry.dispose();
    this.cone.material.dispose();
  }
}
class AxesHelper extends LineSegments {
  constructor(size = 1) {
    const vertices = [
      0,
      0,
      0,
      size,
      0,
      0,
      0,
      0,
      0,
      0,
      size,
      0,
      0,
      0,
      0,
      0,
      0,
      size
    ];
    const colors = [
      1,
      0,
      0,
      1,
      0.6,
      0,
      0,
      1,
      0,
      0.6,
      1,
      0,
      0,
      0,
      1,
      0,
      0.6,
      1
    ];
    const geometry = new BufferGeometry();
    geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
    const material = new LineBasicMaterial({ vertexColors: true, toneMapped: false });
    super(geometry, material);
    this.type = "AxesHelper";
  }
  setColors(xAxisColor, yAxisColor, zAxisColor) {
    const color2 = new Color$1();
    const array = this.geometry.attributes.color.array;
    color2.set(xAxisColor);
    color2.toArray(array, 0);
    color2.toArray(array, 3);
    color2.set(yAxisColor);
    color2.toArray(array, 6);
    color2.toArray(array, 9);
    color2.set(zAxisColor);
    color2.toArray(array, 12);
    color2.toArray(array, 15);
    this.geometry.attributes.color.needsUpdate = true;
    return this;
  }
  dispose() {
    this.geometry.dispose();
    this.material.dispose();
  }
}
class ShapePath {
  constructor() {
    this.type = "ShapePath";
    this.color = new Color$1();
    this.subPaths = [];
    this.currentPath = null;
  }
  moveTo(x, y) {
    this.currentPath = new Path();
    this.subPaths.push(this.currentPath);
    this.currentPath.moveTo(x, y);
    return this;
  }
  lineTo(x, y) {
    this.currentPath.lineTo(x, y);
    return this;
  }
  quadraticCurveTo(aCPx, aCPy, aX, aY) {
    this.currentPath.quadraticCurveTo(aCPx, aCPy, aX, aY);
    return this;
  }
  bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
    this.currentPath.bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY);
    return this;
  }
  splineThru(pts) {
    this.currentPath.splineThru(pts);
    return this;
  }
  toShapes(isCCW) {
    function toShapesNoHoles(inSubpaths) {
      const shapes2 = [];
      for (let i = 0, l = inSubpaths.length; i < l; i++) {
        const tmpPath2 = inSubpaths[i];
        const tmpShape2 = new Shape$1();
        tmpShape2.curves = tmpPath2.curves;
        shapes2.push(tmpShape2);
      }
      return shapes2;
    }
    function isPointInsidePolygon(inPt, inPolygon) {
      const polyLen = inPolygon.length;
      let inside = false;
      for (let p = polyLen - 1, q = 0; q < polyLen; p = q++) {
        let edgeLowPt = inPolygon[p];
        let edgeHighPt = inPolygon[q];
        let edgeDx = edgeHighPt.x - edgeLowPt.x;
        let edgeDy = edgeHighPt.y - edgeLowPt.y;
        if (Math.abs(edgeDy) > Number.EPSILON) {
          if (edgeDy < 0) {
            edgeLowPt = inPolygon[q];
            edgeDx = -edgeDx;
            edgeHighPt = inPolygon[p];
            edgeDy = -edgeDy;
          }
          if (inPt.y < edgeLowPt.y || inPt.y > edgeHighPt.y) continue;
          if (inPt.y === edgeLowPt.y) {
            if (inPt.x === edgeLowPt.x) return true;
          } else {
            const perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);
            if (perpEdge === 0) return true;
            if (perpEdge < 0) continue;
            inside = !inside;
          }
        } else {
          if (inPt.y !== edgeLowPt.y) continue;
          if (edgeHighPt.x <= inPt.x && inPt.x <= edgeLowPt.x || edgeLowPt.x <= inPt.x && inPt.x <= edgeHighPt.x) return true;
        }
      }
      return inside;
    }
    const isClockWise = ShapeUtils.isClockWise;
    const subPaths = this.subPaths;
    if (subPaths.length === 0) return [];
    let solid, tmpPath, tmpShape;
    const shapes = [];
    if (subPaths.length === 1) {
      tmpPath = subPaths[0];
      tmpShape = new Shape$1();
      tmpShape.curves = tmpPath.curves;
      shapes.push(tmpShape);
      return shapes;
    }
    let holesFirst = !isClockWise(subPaths[0].getPoints());
    holesFirst = isCCW ? !holesFirst : holesFirst;
    const betterShapeHoles = [];
    const newShapes = [];
    let newShapeHoles = [];
    let mainIdx = 0;
    let tmpPoints;
    newShapes[mainIdx] = void 0;
    newShapeHoles[mainIdx] = [];
    for (let i = 0, l = subPaths.length; i < l; i++) {
      tmpPath = subPaths[i];
      tmpPoints = tmpPath.getPoints();
      solid = isClockWise(tmpPoints);
      solid = isCCW ? !solid : solid;
      if (solid) {
        if (!holesFirst && newShapes[mainIdx]) mainIdx++;
        newShapes[mainIdx] = { s: new Shape$1(), p: tmpPoints };
        newShapes[mainIdx].s.curves = tmpPath.curves;
        if (holesFirst) mainIdx++;
        newShapeHoles[mainIdx] = [];
      } else {
        newShapeHoles[mainIdx].push({ h: tmpPath, p: tmpPoints[0] });
      }
    }
    if (!newShapes[0]) return toShapesNoHoles(subPaths);
    if (newShapes.length > 1) {
      let ambiguous = false;
      let toChange = 0;
      for (let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
        betterShapeHoles[sIdx] = [];
      }
      for (let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
        const sho = newShapeHoles[sIdx];
        for (let hIdx = 0; hIdx < sho.length; hIdx++) {
          const ho = sho[hIdx];
          let hole_unassigned = true;
          for (let s2Idx = 0; s2Idx < newShapes.length; s2Idx++) {
            if (isPointInsidePolygon(ho.p, newShapes[s2Idx].p)) {
              if (sIdx !== s2Idx) toChange++;
              if (hole_unassigned) {
                hole_unassigned = false;
                betterShapeHoles[s2Idx].push(ho);
              } else {
                ambiguous = true;
              }
            }
          }
          if (hole_unassigned) {
            betterShapeHoles[sIdx].push(ho);
          }
        }
      }
      if (toChange > 0 && ambiguous === false) {
        newShapeHoles = betterShapeHoles;
      }
    }
    let tmpHoles;
    for (let i = 0, il = newShapes.length; i < il; i++) {
      tmpShape = newShapes[i].s;
      shapes.push(tmpShape);
      tmpHoles = newShapeHoles[i];
      for (let j = 0, jl = tmpHoles.length; j < jl; j++) {
        tmpShape.holes.push(tmpHoles[j].h);
      }
    }
    return shapes;
  }
}
class Controls extends EventDispatcher$1 {
  constructor(object, domElement = null) {
    super();
    this.object = object;
    this.domElement = domElement;
    this.enabled = true;
    this.state = -1;
    this.keys = {};
    this.mouseButtons = { LEFT: null, MIDDLE: null, RIGHT: null };
    this.touches = { ONE: null, TWO: null };
  }
  connect() {
  }
  disconnect() {
  }
  dispose() {
  }
  update() {
  }
}
function contain(texture, aspect2) {
  const imageAspect = texture.image && texture.image.width ? texture.image.width / texture.image.height : 1;
  if (imageAspect > aspect2) {
    texture.repeat.x = 1;
    texture.repeat.y = imageAspect / aspect2;
    texture.offset.x = 0;
    texture.offset.y = (1 - texture.repeat.y) / 2;
  } else {
    texture.repeat.x = aspect2 / imageAspect;
    texture.repeat.y = 1;
    texture.offset.x = (1 - texture.repeat.x) / 2;
    texture.offset.y = 0;
  }
  return texture;
}
function cover(texture, aspect2) {
  const imageAspect = texture.image && texture.image.width ? texture.image.width / texture.image.height : 1;
  if (imageAspect > aspect2) {
    texture.repeat.x = aspect2 / imageAspect;
    texture.repeat.y = 1;
    texture.offset.x = (1 - texture.repeat.x) / 2;
    texture.offset.y = 0;
  } else {
    texture.repeat.x = 1;
    texture.repeat.y = imageAspect / aspect2;
    texture.offset.x = 0;
    texture.offset.y = (1 - texture.repeat.y) / 2;
  }
  return texture;
}
function fill(texture) {
  texture.repeat.x = 1;
  texture.repeat.y = 1;
  texture.offset.x = 0;
  texture.offset.y = 0;
  return texture;
}
function getByteLength(width, height, format, type) {
  const typeByteLength = getTextureTypeByteLength(type);
  switch (format) {
    // https://registry.khronos.org/OpenGL-Refpages/es3.0/html/glTexImage2D.xhtml
    case AlphaFormat:
      return width * height;
    case LuminanceFormat:
      return width * height;
    case LuminanceAlphaFormat:
      return width * height * 2;
    case RedFormat:
      return width * height / typeByteLength.components * typeByteLength.byteLength;
    case RedIntegerFormat:
      return width * height / typeByteLength.components * typeByteLength.byteLength;
    case RGFormat:
      return width * height * 2 / typeByteLength.components * typeByteLength.byteLength;
    case RGIntegerFormat:
      return width * height * 2 / typeByteLength.components * typeByteLength.byteLength;
    case RGBFormat:
      return width * height * 3 / typeByteLength.components * typeByteLength.byteLength;
    case RGBAFormat:
      return width * height * 4 / typeByteLength.components * typeByteLength.byteLength;
    case RGBAIntegerFormat:
      return width * height * 4 / typeByteLength.components * typeByteLength.byteLength;
    // https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_s3tc_srgb/
    case RGB_S3TC_DXT1_Format:
    case RGBA_S3TC_DXT1_Format:
      return Math.floor((width + 3) / 4) * Math.floor((height + 3) / 4) * 8;
    case RGBA_S3TC_DXT3_Format:
    case RGBA_S3TC_DXT5_Format:
      return Math.floor((width + 3) / 4) * Math.floor((height + 3) / 4) * 16;
    // https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_pvrtc/
    case RGB_PVRTC_2BPPV1_Format:
    case RGBA_PVRTC_2BPPV1_Format:
      return Math.max(width, 16) * Math.max(height, 8) / 4;
    case RGB_PVRTC_4BPPV1_Format:
    case RGBA_PVRTC_4BPPV1_Format:
      return Math.max(width, 8) * Math.max(height, 8) / 2;
    // https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_etc/
    case RGB_ETC1_Format:
    case RGB_ETC2_Format:
      return Math.floor((width + 3) / 4) * Math.floor((height + 3) / 4) * 8;
    case RGBA_ETC2_EAC_Format:
      return Math.floor((width + 3) / 4) * Math.floor((height + 3) / 4) * 16;
    // https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_astc/
    case RGBA_ASTC_4x4_Format:
      return Math.floor((width + 3) / 4) * Math.floor((height + 3) / 4) * 16;
    case RGBA_ASTC_5x4_Format:
      return Math.floor((width + 4) / 5) * Math.floor((height + 3) / 4) * 16;
    case RGBA_ASTC_5x5_Format:
      return Math.floor((width + 4) / 5) * Math.floor((height + 4) / 5) * 16;
    case RGBA_ASTC_6x5_Format:
      return Math.floor((width + 5) / 6) * Math.floor((height + 4) / 5) * 16;
    case RGBA_ASTC_6x6_Format:
      return Math.floor((width + 5) / 6) * Math.floor((height + 5) / 6) * 16;
    case RGBA_ASTC_8x5_Format:
      return Math.floor((width + 7) / 8) * Math.floor((height + 4) / 5) * 16;
    case RGBA_ASTC_8x6_Format:
      return Math.floor((width + 7) / 8) * Math.floor((height + 5) / 6) * 16;
    case RGBA_ASTC_8x8_Format:
      return Math.floor((width + 7) / 8) * Math.floor((height + 7) / 8) * 16;
    case RGBA_ASTC_10x5_Format:
      return Math.floor((width + 9) / 10) * Math.floor((height + 4) / 5) * 16;
    case RGBA_ASTC_10x6_Format:
      return Math.floor((width + 9) / 10) * Math.floor((height + 5) / 6) * 16;
    case RGBA_ASTC_10x8_Format:
      return Math.floor((width + 9) / 10) * Math.floor((height + 7) / 8) * 16;
    case RGBA_ASTC_10x10_Format:
      return Math.floor((width + 9) / 10) * Math.floor((height + 9) / 10) * 16;
    case RGBA_ASTC_12x10_Format:
      return Math.floor((width + 11) / 12) * Math.floor((height + 9) / 10) * 16;
    case RGBA_ASTC_12x12_Format:
      return Math.floor((width + 11) / 12) * Math.floor((height + 11) / 12) * 16;
    // https://registry.khronos.org/webgl/extensions/EXT_texture_compression_bptc/
    case RGBA_BPTC_Format:
    case RGB_BPTC_SIGNED_Format:
    case RGB_BPTC_UNSIGNED_Format:
      return Math.ceil(width / 4) * Math.ceil(height / 4) * 16;
    // https://registry.khronos.org/webgl/extensions/EXT_texture_compression_rgtc/
    case RED_RGTC1_Format:
    case SIGNED_RED_RGTC1_Format:
      return Math.ceil(width / 4) * Math.ceil(height / 4) * 8;
    case RED_GREEN_RGTC2_Format:
    case SIGNED_RED_GREEN_RGTC2_Format:
      return Math.ceil(width / 4) * Math.ceil(height / 4) * 16;
  }
  throw new Error(
    `Unable to determine texture byte length for ${format} format.`
  );
}
function getTextureTypeByteLength(type) {
  switch (type) {
    case UnsignedByteType:
    case ByteType:
      return { byteLength: 1, components: 1 };
    case UnsignedShortType:
    case ShortType:
    case HalfFloatType:
      return { byteLength: 2, components: 1 };
    case UnsignedShort4444Type:
    case UnsignedShort5551Type:
      return { byteLength: 2, components: 4 };
    case UnsignedIntType:
    case IntType:
    case FloatType$1:
      return { byteLength: 4, components: 1 };
    case UnsignedInt5999Type:
      return { byteLength: 4, components: 3 };
  }
  throw new Error(`Unknown texture type ${type}.`);
}
const TextureUtils = {
  contain,
  cover,
  fill,
  getByteLength
};
if (typeof __THREE_DEVTOOLS__ !== "undefined") {
  __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: {
    revision: REVISION
  } }));
}
if (typeof window !== "undefined") {
  if (window.__THREE__) {
    console.warn("WARNING: Multiple instances of Three.js being imported.");
  } else {
    window.__THREE__ = REVISION;
  }
}
/**
 * @license
 * Copyright 2010-2024 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
function WebGLAnimation() {
  let context2 = null;
  let isAnimating = false;
  let animationLoop = null;
  let requestId = null;
  function onAnimationFrame(time, frame) {
    animationLoop(time, frame);
    requestId = context2.requestAnimationFrame(onAnimationFrame);
  }
  return {
    start: function() {
      if (isAnimating === true) return;
      if (animationLoop === null) return;
      requestId = context2.requestAnimationFrame(onAnimationFrame);
      isAnimating = true;
    },
    stop: function() {
      context2.cancelAnimationFrame(requestId);
      isAnimating = false;
    },
    setAnimationLoop: function(callback) {
      animationLoop = callback;
    },
    setContext: function(value) {
      context2 = value;
    }
  };
}
function WebGLAttributes(gl) {
  const buffers = /* @__PURE__ */ new WeakMap();
  function createBuffer(attribute, bufferType) {
    const array = attribute.array;
    const usage = attribute.usage;
    const size = array.byteLength;
    const buffer = gl.createBuffer();
    gl.bindBuffer(bufferType, buffer);
    gl.bufferData(bufferType, array, usage);
    attribute.onUploadCallback();
    let type;
    if (array instanceof Float32Array) {
      type = gl.FLOAT;
    } else if (array instanceof Uint16Array) {
      if (attribute.isFloat16BufferAttribute) {
        type = gl.HALF_FLOAT;
      } else {
        type = gl.UNSIGNED_SHORT;
      }
    } else if (array instanceof Int16Array) {
      type = gl.SHORT;
    } else if (array instanceof Uint32Array) {
      type = gl.UNSIGNED_INT;
    } else if (array instanceof Int32Array) {
      type = gl.INT;
    } else if (array instanceof Int8Array) {
      type = gl.BYTE;
    } else if (array instanceof Uint8Array) {
      type = gl.UNSIGNED_BYTE;
    } else if (array instanceof Uint8ClampedArray) {
      type = gl.UNSIGNED_BYTE;
    } else {
      throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + array);
    }
    return {
      buffer,
      type,
      bytesPerElement: array.BYTES_PER_ELEMENT,
      version: attribute.version,
      size
    };
  }
  function updateBuffer(buffer, attribute, bufferType) {
    const array = attribute.array;
    const updateRanges = attribute.updateRanges;
    gl.bindBuffer(bufferType, buffer);
    if (updateRanges.length === 0) {
      gl.bufferSubData(bufferType, 0, array);
    } else {
      updateRanges.sort((a, b) => a.start - b.start);
      let mergeIndex = 0;
      for (let i = 1; i < updateRanges.length; i++) {
        const previousRange = updateRanges[mergeIndex];
        const range = updateRanges[i];
        if (range.start <= previousRange.start + previousRange.count + 1) {
          previousRange.count = Math.max(
            previousRange.count,
            range.start + range.count - previousRange.start
          );
        } else {
          ++mergeIndex;
          updateRanges[mergeIndex] = range;
        }
      }
      updateRanges.length = mergeIndex + 1;
      for (let i = 0, l = updateRanges.length; i < l; i++) {
        const range = updateRanges[i];
        gl.bufferSubData(
          bufferType,
          range.start * array.BYTES_PER_ELEMENT,
          array,
          range.start,
          range.count
        );
      }
      attribute.clearUpdateRanges();
    }
    attribute.onUploadCallback();
  }
  function get(attribute) {
    if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
    return buffers.get(attribute);
  }
  function remove(attribute) {
    if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
    const data = buffers.get(attribute);
    if (data) {
      gl.deleteBuffer(data.buffer);
      buffers.delete(attribute);
    }
  }
  function update(attribute, bufferType) {
    if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
    if (attribute.isGLBufferAttribute) {
      const cached = buffers.get(attribute);
      if (!cached || cached.version < attribute.version) {
        buffers.set(attribute, {
          buffer: attribute.buffer,
          type: attribute.type,
          bytesPerElement: attribute.elementSize,
          version: attribute.version
        });
      }
      return;
    }
    const data = buffers.get(attribute);
    if (data === void 0) {
      buffers.set(attribute, createBuffer(attribute, bufferType));
    } else if (data.version < attribute.version) {
      if (data.size !== attribute.array.byteLength) {
        throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");
      }
      updateBuffer(data.buffer, attribute, bufferType);
      data.version = attribute.version;
    }
  }
  return {
    get,
    remove,
    update
  };
}
var alphahash_fragment = "#ifdef USE_ALPHAHASH\n	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;\n#endif";
var alphahash_pars_fragment = "#ifdef USE_ALPHAHASH\n	const float ALPHA_HASH_SCALE = 0.05;\n	float hash2D( vec2 value ) {\n		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );\n	}\n	float hash3D( vec3 value ) {\n		return hash2D( vec2( hash2D( value.xy ), value.z ) );\n	}\n	float getAlphaHashThreshold( vec3 position ) {\n		float maxDeriv = max(\n			length( dFdx( position.xyz ) ),\n			length( dFdy( position.xyz ) )\n		);\n		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );\n		vec2 pixScales = vec2(\n			exp2( floor( log2( pixScale ) ) ),\n			exp2( ceil( log2( pixScale ) ) )\n		);\n		vec2 alpha = vec2(\n			hash3D( floor( pixScales.x * position.xyz ) ),\n			hash3D( floor( pixScales.y * position.xyz ) )\n		);\n		float lerpFactor = fract( log2( pixScale ) );\n		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;\n		float a = min( lerpFactor, 1.0 - lerpFactor );\n		vec3 cases = vec3(\n			x * x / ( 2.0 * a * ( 1.0 - a ) ),\n			( x - 0.5 * a ) / ( 1.0 - a ),\n			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )\n		);\n		float threshold = ( x < ( 1.0 - a ) )\n			? ( ( x < a ) ? cases.x : cases.y )\n			: cases.z;\n		return clamp( threshold , 1.0e-6, 1.0 );\n	}\n#endif";
var alphamap_fragment = "#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;\n#endif";
var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif";
var alphatest_fragment = "#ifdef USE_ALPHATEST\n	#ifdef ALPHA_TO_COVERAGE\n	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );\n	if ( diffuseColor.a == 0.0 ) discard;\n	#else\n	if ( diffuseColor.a < alphaTest ) discard;\n	#endif\n#endif";
var alphatest_pars_fragment = "#ifdef USE_ALPHATEST\n	uniform float alphaTest;\n#endif";
var aomap_fragment = "#ifdef USE_AOMAP\n	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;\n	reflectedLight.indirectDiffuse *= ambientOcclusion;\n	#if defined( USE_CLEARCOAT ) \n		clearcoatSpecularIndirect *= ambientOcclusion;\n	#endif\n	#if defined( USE_SHEEN ) \n		sheenSpecularIndirect *= ambientOcclusion;\n	#endif\n	#if defined( USE_ENVMAP ) && defined( STANDARD )\n		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );\n		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n	#endif\n#endif";
var aomap_pars_fragment = "#ifdef USE_AOMAP\n	uniform sampler2D aoMap;\n	uniform float aoMapIntensity;\n#endif";
var batching_pars_vertex = "#ifdef USE_BATCHING\n	#if ! defined( GL_ANGLE_multi_draw )\n	#define gl_DrawID _gl_DrawID\n	uniform int _gl_DrawID;\n	#endif\n	uniform highp sampler2D batchingTexture;\n	uniform highp usampler2D batchingIdTexture;\n	mat4 getBatchingMatrix( const in float i ) {\n		int size = textureSize( batchingTexture, 0 ).x;\n		int j = int( i ) * 4;\n		int x = j % size;\n		int y = j / size;\n		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );\n		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );\n		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );\n		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );\n		return mat4( v1, v2, v3, v4 );\n	}\n	float getIndirectIndex( const in int i ) {\n		int size = textureSize( batchingIdTexture, 0 ).x;\n		int x = i % size;\n		int y = i / size;\n		return float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );\n	}\n#endif\n#ifdef USE_BATCHING_COLOR\n	uniform sampler2D batchingColorTexture;\n	vec3 getBatchingColor( const in float i ) {\n		int size = textureSize( batchingColorTexture, 0 ).x;\n		int j = int( i );\n		int x = j % size;\n		int y = j / size;\n		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;\n	}\n#endif";
var batching_vertex = "#ifdef USE_BATCHING\n	mat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );\n#endif";
var begin_vertex = "vec3 transformed = vec3( position );\n#ifdef USE_ALPHAHASH\n	vPosition = vec3( position );\n#endif";
var beginnormal_vertex = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n	vec3 objectTangent = vec3( tangent.xyz );\n#endif";
var bsdfs = "float G_BlinnPhong_Implicit( ) {\n	return 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = F_Schlick( specularColor, 1.0, dotVH );\n	float G = G_BlinnPhong_Implicit( );\n	float D = D_BlinnPhong( shininess, dotNH );\n	return F * ( G * D );\n} // validated";
var iridescence_fragment = "#ifdef USE_IRIDESCENCE\n	const mat3 XYZ_TO_REC709 = mat3(\n		 3.2404542, -0.9692660,  0.0556434,\n		-1.5371385,  1.8760108, -0.2040259,\n		-0.4985314,  0.0415560,  1.0572252\n	);\n	vec3 Fresnel0ToIor( vec3 fresnel0 ) {\n		vec3 sqrtF0 = sqrt( fresnel0 );\n		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n	}\n	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n	}\n	float IorToFresnel0( float transmittedIor, float incidentIor ) {\n		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n	}\n	vec3 evalSensitivity( float OPD, vec3 shift ) {\n		float phase = 2.0 * PI * OPD * 1.0e-9;\n		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n		xyz /= 1.0685e-7;\n		vec3 rgb = XYZ_TO_REC709 * xyz;\n		return rgb;\n	}\n	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n		vec3 I;\n		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n		float cosTheta2Sq = 1.0 - sinTheta2Sq;\n		if ( cosTheta2Sq < 0.0 ) {\n			return vec3( 1.0 );\n		}\n		float cosTheta2 = sqrt( cosTheta2Sq );\n		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n		float R12 = F_Schlick( R0, 1.0, cosTheta1 );\n		float T121 = 1.0 - R12;\n		float phi12 = 0.0;\n		if ( iridescenceIOR < outsideIOR ) phi12 = PI;\n		float phi21 = PI - phi12;\n		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n		vec3 phi23 = vec3( 0.0 );\n		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n		vec3 phi = vec3( phi21 ) + phi23;\n		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n		vec3 r123 = sqrt( R123 );\n		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n		vec3 C0 = R12 + Rs;\n		I = C0;\n		vec3 Cm = Rs - T121;\n		for ( int m = 1; m <= 2; ++ m ) {\n			Cm *= r123;\n			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n			I += Cm * Sm;\n		}\n		return max( I, vec3( 0.0 ) );\n	}\n#endif";
var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n	vec2 dHdxy_fwd() {\n		vec2 dSTdx = dFdx( vBumpMapUv );\n		vec2 dSTdy = dFdy( vBumpMapUv );\n		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;\n		return vec2( dBx, dBy );\n	}\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );\n		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );\n		vec3 vN = surf_norm;\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n		float fDet = dot( vSigmaX, R1 ) * faceDirection;\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n	}\n#endif";
var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n	vec4 plane;\n	#ifdef ALPHA_TO_COVERAGE\n		float distanceToPlane, distanceGradient;\n		float clipOpacity = 1.0;\n		#pragma unroll_loop_start\n		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n			plane = clippingPlanes[ i ];\n			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n			distanceGradient = fwidth( distanceToPlane ) / 2.0;\n			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n			if ( clipOpacity == 0.0 ) discard;\n		}\n		#pragma unroll_loop_end\n		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n			float unionClipOpacity = 1.0;\n			#pragma unroll_loop_start\n			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n				plane = clippingPlanes[ i ];\n				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n				distanceGradient = fwidth( distanceToPlane ) / 2.0;\n				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n			}\n			#pragma unroll_loop_end\n			clipOpacity *= 1.0 - unionClipOpacity;\n		#endif\n		diffuseColor.a *= clipOpacity;\n		if ( diffuseColor.a == 0.0 ) discard;\n	#else\n		#pragma unroll_loop_start\n		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n			plane = clippingPlanes[ i ];\n			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n		}\n		#pragma unroll_loop_end\n		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n			bool clipped = true;\n			#pragma unroll_loop_start\n			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n				plane = clippingPlanes[ i ];\n				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n			}\n			#pragma unroll_loop_end\n			if ( clipped ) discard;\n		#endif\n	#endif\n#endif";
var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";
var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n#endif";
var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0\n	vClipPosition = - mvPosition.xyz;\n#endif";
var color_fragment = "#if defined( USE_COLOR_ALPHA )\n	diffuseColor *= vColor;\n#elif defined( USE_COLOR )\n	diffuseColor.rgb *= vColor;\n#endif";
var color_pars_fragment = "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR )\n	varying vec3 vColor;\n#endif";
var color_pars_vertex = "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )\n	varying vec3 vColor;\n#endif";
var color_vertex = "#if defined( USE_COLOR_ALPHA )\n	vColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )\n	vColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n	vColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n	vColor.xyz *= instanceColor.xyz;\n#endif\n#ifdef USE_BATCHING_COLOR\n	vec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );\n	vColor.xyz *= batchingColor.xyz;\n#endif";
var common = "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n	const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n	return fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n	float precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n	float precisionSafeLength( vec3 v ) {\n		float maxComponent = max3( abs( v ) );\n		return length( v / maxComponent ) * maxComponent;\n	}\n#endif\nstruct IncidentLight {\n	vec3 color;\n	vec3 direction;\n	bool visible;\n};\nstruct ReflectedLight {\n	vec3 directDiffuse;\n	vec3 directSpecular;\n	vec3 indirectDiffuse;\n	vec3 indirectSpecular;\n};\n#ifdef USE_ALPHAHASH\n	varying vec3 vPosition;\n#endif\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n	mat3 tmp;\n	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n	return tmp;\n}\nbool isPerspectiveMatrix( mat4 m ) {\n	return m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n	return vec2( u, v );\n}\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n	return RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n} // validated";
var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n	#define cubeUV_minMipLevel 4.0\n	#define cubeUV_minTileSize 16.0\n	float getFace( vec3 direction ) {\n		vec3 absDirection = abs( direction );\n		float face = - 1.0;\n		if ( absDirection.x > absDirection.z ) {\n			if ( absDirection.x > absDirection.y )\n				face = direction.x > 0.0 ? 0.0 : 3.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		} else {\n			if ( absDirection.z > absDirection.y )\n				face = direction.z > 0.0 ? 2.0 : 5.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		}\n		return face;\n	}\n	vec2 getUV( vec3 direction, float face ) {\n		vec2 uv;\n		if ( face == 0.0 ) {\n			uv = vec2( direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 1.0 ) {\n			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n		} else if ( face == 2.0 ) {\n			uv = vec2( - direction.x, direction.y ) / abs( direction.z );\n		} else if ( face == 3.0 ) {\n			uv = vec2( - direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 4.0 ) {\n			uv = vec2( - direction.x, direction.z ) / abs( direction.y );\n		} else {\n			uv = vec2( direction.x, direction.y ) / abs( direction.z );\n		}\n		return 0.5 * ( uv + 1.0 );\n	}\n	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n		float face = getFace( direction );\n		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n		mipInt = max( mipInt, cubeUV_minMipLevel );\n		float faceSize = exp2( mipInt );\n		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n		if ( face > 2.0 ) {\n			uv.y += faceSize;\n			face -= 3.0;\n		}\n		uv.x += face * faceSize;\n		uv.x += filterInt * 3.0 * cubeUV_minTileSize;\n		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n		uv.x *= CUBEUV_TEXEL_WIDTH;\n		uv.y *= CUBEUV_TEXEL_HEIGHT;\n		#ifdef texture2DGradEXT\n			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n		#else\n			return texture2D( envMap, uv ).rgb;\n		#endif\n	}\n	#define cubeUV_r0 1.0\n	#define cubeUV_m0 - 2.0\n	#define cubeUV_r1 0.8\n	#define cubeUV_m1 - 1.0\n	#define cubeUV_r4 0.4\n	#define cubeUV_m4 2.0\n	#define cubeUV_r5 0.305\n	#define cubeUV_m5 3.0\n	#define cubeUV_r6 0.21\n	#define cubeUV_m6 4.0\n	float roughnessToMip( float roughness ) {\n		float mip = 0.0;\n		if ( roughness >= cubeUV_r1 ) {\n			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\n		} else if ( roughness >= cubeUV_r4 ) {\n			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\n		} else if ( roughness >= cubeUV_r5 ) {\n			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\n		} else if ( roughness >= cubeUV_r6 ) {\n			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\n		} else {\n			mip = - 2.0 * log2( 1.16 * roughness );		}\n		return mip;\n	}\n	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n		float mipF = fract( mip );\n		float mipInt = floor( mip );\n		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n		if ( mipF == 0.0 ) {\n			return vec4( color0, 1.0 );\n		} else {\n			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n			return vec4( mix( color0, color1, mipF ), 1.0 );\n		}\n	}\n#endif";
var defaultnormal_vertex = "vec3 transformedNormal = objectNormal;\n#ifdef USE_TANGENT\n	vec3 transformedTangent = objectTangent;\n#endif\n#ifdef USE_BATCHING\n	mat3 bm = mat3( batchingMatrix );\n	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );\n	transformedNormal = bm * transformedNormal;\n	#ifdef USE_TANGENT\n		transformedTangent = bm * transformedTangent;\n	#endif\n#endif\n#ifdef USE_INSTANCING\n	mat3 im = mat3( instanceMatrix );\n	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );\n	transformedNormal = im * transformedNormal;\n	#ifdef USE_TANGENT\n		transformedTangent = im * transformedTangent;\n	#endif\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n	transformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;\n	#ifdef FLIP_SIDED\n		transformedTangent = - transformedTangent;\n	#endif\n#endif";
var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n	uniform sampler2D displacementMap;\n	uniform float displacementScale;\n	uniform float displacementBias;\n#endif";
var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );\n#endif";
var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );\n	#ifdef DECODE_VIDEO_TEXTURE_EMISSIVE\n		emissiveColor = sRGBTransferEOTF( emissiveColor );\n	#endif\n	totalEmissiveRadiance *= emissiveColor.rgb;\n#endif";
var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n	uniform sampler2D emissiveMap;\n#endif";
var colorspace_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );";
var colorspace_pars_fragment = "vec4 LinearTransferOETF( in vec4 value ) {\n	return value;\n}\nvec4 sRGBTransferEOTF( in vec4 value ) {\n	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 sRGBTransferOETF( in vec4 value ) {\n	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}";
var envmap_fragment = "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vec3 cameraToFrag;\n		if ( isOrthographic ) {\n			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToFrag = normalize( vWorldPosition - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( cameraToFrag, worldNormal );\n		#else\n			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n		#endif\n	#else\n		vec3 reflectVec = vReflect;\n	#endif\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n	#else\n		vec4 envColor = vec4( 0.0 );\n	#endif\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_MIX )\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_ADD )\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n	#endif\n#endif";
var envmap_common_pars_fragment = "#ifdef USE_ENVMAP\n	uniform float envMapIntensity;\n	uniform float flipEnvMap;\n	uniform mat3 envMapRotation;\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	\n#endif";
var envmap_pars_fragment = "#ifdef USE_ENVMAP\n	uniform float reflectivity;\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		varying vec3 vWorldPosition;\n		uniform float refractionRatio;\n	#else\n		varying vec3 vReflect;\n	#endif\n#endif";
var envmap_pars_vertex = "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		\n		varying vec3 vWorldPosition;\n	#else\n		varying vec3 vReflect;\n		uniform float refractionRatio;\n	#endif\n#endif";
var envmap_vertex = "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vWorldPosition = worldPosition.xyz;\n	#else\n		vec3 cameraToVertex;\n		if ( isOrthographic ) {\n			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vReflect = reflect( cameraToVertex, worldNormal );\n		#else\n			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n		#endif\n	#endif\n#endif";
var fog_vertex = "#ifdef USE_FOG\n	vFogDepth = - mvPosition.z;\n#endif";
var fog_pars_vertex = "#ifdef USE_FOG\n	varying float vFogDepth;\n#endif";
var fog_fragment = "#ifdef USE_FOG\n	#ifdef FOG_EXP2\n		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n	#else\n		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n	#endif\n	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif";
var fog_pars_fragment = "#ifdef USE_FOG\n	uniform vec3 fogColor;\n	varying float vFogDepth;\n	#ifdef FOG_EXP2\n		uniform float fogDensity;\n	#else\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n#endif";
var gradientmap_pars_fragment = "#ifdef USE_GRADIENTMAP\n	uniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n	float dotNL = dot( normal, lightDirection );\n	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n	#ifdef USE_GRADIENTMAP\n		return vec3( texture2D( gradientMap, coord ).r );\n	#else\n		vec2 fw = fwidth( coord ) * 0.5;\n		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );\n	#endif\n}";
var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n	uniform sampler2D lightMap;\n	uniform float lightMapIntensity;\n#endif";
var lights_lambert_fragment = "LambertMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularStrength = specularStrength;";
var lights_lambert_pars_fragment = "varying vec3 vViewPosition;\nstruct LambertMaterial {\n	vec3 diffuseColor;\n	float specularStrength;\n};\nvoid RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_Lambert\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert";
var lights_pars_begin = "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\n#if defined( USE_LIGHT_PROBES )\n	uniform vec3 lightProbe[ 9 ];\n#endif\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n	float x = normal.x, y = normal.y, z = normal.z;\n	vec3 result = shCoefficients[ 0 ] * 0.886227;\n	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n	return result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n	return irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n	vec3 irradiance = ambientLightColor;\n	return irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n	if ( cutoffDistance > 0.0 ) {\n		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n	}\n	return distanceFalloff;\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n	return smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n	struct DirectionalLight {\n		vec3 direction;\n		vec3 color;\n	};\n	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {\n		light.color = directionalLight.color;\n		light.direction = directionalLight.direction;\n		light.visible = true;\n	}\n#endif\n#if NUM_POINT_LIGHTS > 0\n	struct PointLight {\n		vec3 position;\n		vec3 color;\n		float distance;\n		float decay;\n	};\n	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {\n		vec3 lVector = pointLight.position - geometryPosition;\n		light.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		light.color = pointLight.color;\n		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n		light.visible = ( light.color != vec3( 0.0 ) );\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	struct SpotLight {\n		vec3 position;\n		vec3 direction;\n		vec3 color;\n		float distance;\n		float decay;\n		float coneCos;\n		float penumbraCos;\n	};\n	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {\n		vec3 lVector = spotLight.position - geometryPosition;\n		light.direction = normalize( lVector );\n		float angleCos = dot( light.direction, spotLight.direction );\n		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n		if ( spotAttenuation > 0.0 ) {\n			float lightDistance = length( lVector );\n			light.color = spotLight.color * spotAttenuation;\n			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n			light.visible = ( light.color != vec3( 0.0 ) );\n		} else {\n			light.color = vec3( 0.0 );\n			light.visible = false;\n		}\n	}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n	struct RectAreaLight {\n		vec3 color;\n		vec3 position;\n		vec3 halfWidth;\n		vec3 halfHeight;\n	};\n	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;\n	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	struct HemisphereLight {\n		vec3 direction;\n		vec3 skyColor;\n		vec3 groundColor;\n	};\n	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n		float dotNL = dot( normal, hemiLight.direction );\n		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n		return irradiance;\n	}\n#endif";
var envmap_physical_pars_fragment = "#ifdef USE_ENVMAP\n	vec3 getIBLIrradiance( const in vec3 normal ) {\n		#ifdef ENVMAP_TYPE_CUBE_UV\n			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );\n			return PI * envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n		#ifdef ENVMAP_TYPE_CUBE_UV\n			vec3 reflectVec = reflect( - viewDir, normal );\n			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );\n			return envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n	#ifdef USE_ANISOTROPY\n		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {\n			#ifdef ENVMAP_TYPE_CUBE_UV\n				vec3 bentNormal = cross( bitangent, viewDir );\n				bentNormal = normalize( cross( bentNormal, bitangent ) );\n				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );\n				return getIBLRadiance( viewDir, bentNormal, roughness );\n			#else\n				return vec3( 0.0 );\n			#endif\n		}\n	#endif\n#endif";
var lights_toon_fragment = "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;";
var lights_toon_pars_fragment = "varying vec3 vViewPosition;\nstruct ToonMaterial {\n	vec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_Toon\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon";
var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";
var lights_phong_pars_fragment = "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n	vec3 diffuseColor;\n	vec3 specularColor;\n	float specularShininess;\n	float specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_BlinnPhong\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong";
var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n	material.ior = ior;\n	#ifdef USE_SPECULAR\n		float specularIntensityFactor = specularIntensity;\n		vec3 specularColorFactor = specularColor;\n		#ifdef USE_SPECULAR_COLORMAP\n			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;\n		#endif\n		#ifdef USE_SPECULAR_INTENSITYMAP\n			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;\n		#endif\n		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n	#else\n		float specularIntensityFactor = 1.0;\n		vec3 specularColorFactor = vec3( 1.0 );\n		material.specularF90 = 1.0;\n	#endif\n	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n	material.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n	material.clearcoat = clearcoat;\n	material.clearcoatRoughness = clearcoatRoughness;\n	material.clearcoatF0 = vec3( 0.04 );\n	material.clearcoatF90 = 1.0;\n	#ifdef USE_CLEARCOATMAP\n		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;\n	#endif\n	#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;\n	#endif\n	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n	material.clearcoatRoughness += geometryRoughness;\n	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_DISPERSION\n	material.dispersion = dispersion;\n#endif\n#ifdef USE_IRIDESCENCE\n	material.iridescence = iridescence;\n	material.iridescenceIOR = iridescenceIOR;\n	#ifdef USE_IRIDESCENCEMAP\n		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;\n	#endif\n	#ifdef USE_IRIDESCENCE_THICKNESSMAP\n		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;\n	#else\n		material.iridescenceThickness = iridescenceThicknessMaximum;\n	#endif\n#endif\n#ifdef USE_SHEEN\n	material.sheenColor = sheenColor;\n	#ifdef USE_SHEEN_COLORMAP\n		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;\n	#endif\n	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n	#ifdef USE_SHEEN_ROUGHNESSMAP\n		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;\n	#endif\n#endif\n#ifdef USE_ANISOTROPY\n	#ifdef USE_ANISOTROPYMAP\n		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );\n		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;\n		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;\n	#else\n		vec2 anisotropyV = anisotropyVector;\n	#endif\n	material.anisotropy = length( anisotropyV );\n	if( material.anisotropy == 0.0 ) {\n		anisotropyV = vec2( 1.0, 0.0 );\n	} else {\n		anisotropyV /= material.anisotropy;\n		material.anisotropy = saturate( material.anisotropy );\n	}\n	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );\n	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;\n	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;\n#endif";
var lights_physical_pars_fragment = "struct PhysicalMaterial {\n	vec3 diffuseColor;\n	float roughness;\n	vec3 specularColor;\n	float specularF90;\n	float dispersion;\n	#ifdef USE_CLEARCOAT\n		float clearcoat;\n		float clearcoatRoughness;\n		vec3 clearcoatF0;\n		float clearcoatF90;\n	#endif\n	#ifdef USE_IRIDESCENCE\n		float iridescence;\n		float iridescenceIOR;\n		float iridescenceThickness;\n		vec3 iridescenceFresnel;\n		vec3 iridescenceF0;\n	#endif\n	#ifdef USE_SHEEN\n		vec3 sheenColor;\n		float sheenRoughness;\n	#endif\n	#ifdef IOR\n		float ior;\n	#endif\n	#ifdef USE_TRANSMISSION\n		float transmission;\n		float transmissionAlpha;\n		float thickness;\n		float attenuationDistance;\n		vec3 attenuationColor;\n	#endif\n	#ifdef USE_ANISOTROPY\n		float anisotropy;\n		float alphaT;\n		vec3 anisotropyT;\n		vec3 anisotropyB;\n	#endif\n};\nvec3 clearcoatSpecularDirect = vec3( 0.0 );\nvec3 clearcoatSpecularIndirect = vec3( 0.0 );\nvec3 sheenSpecularDirect = vec3( 0.0 );\nvec3 sheenSpecularIndirect = vec3(0.0 );\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	return 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n	float a2 = pow2( alpha );\n	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n	return RECIPROCAL_PI * a2 / pow2( denom );\n}\n#ifdef USE_ANISOTROPY\n	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {\n		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );\n		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );\n		float v = 0.5 / ( gv + gl );\n		return saturate(v);\n	}\n	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {\n		float a2 = alphaT * alphaB;\n		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );\n		highp float v2 = dot( v, v );\n		float w2 = a2 / v2;\n		return RECIPROCAL_PI * a2 * pow2 ( w2 );\n	}\n#endif\n#ifdef USE_CLEARCOAT\n	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {\n		vec3 f0 = material.clearcoatF0;\n		float f90 = material.clearcoatF90;\n		float roughness = material.clearcoatRoughness;\n		float alpha = pow2( roughness );\n		vec3 halfDir = normalize( lightDir + viewDir );\n		float dotNL = saturate( dot( normal, lightDir ) );\n		float dotNV = saturate( dot( normal, viewDir ) );\n		float dotNH = saturate( dot( normal, halfDir ) );\n		float dotVH = saturate( dot( viewDir, halfDir ) );\n		vec3 F = F_Schlick( f0, f90, dotVH );\n		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n		float D = D_GGX( alpha, dotNH );\n		return F * ( V * D );\n	}\n#endif\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {\n	vec3 f0 = material.specularColor;\n	float f90 = material.specularF90;\n	float roughness = material.roughness;\n	float alpha = pow2( roughness );\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = F_Schlick( f0, f90, dotVH );\n	#ifdef USE_IRIDESCENCE\n		F = mix( F, material.iridescenceFresnel, material.iridescence );\n	#endif\n	#ifdef USE_ANISOTROPY\n		float dotTL = dot( material.anisotropyT, lightDir );\n		float dotTV = dot( material.anisotropyT, viewDir );\n		float dotTH = dot( material.anisotropyT, halfDir );\n		float dotBL = dot( material.anisotropyB, lightDir );\n		float dotBV = dot( material.anisotropyB, viewDir );\n		float dotBH = dot( material.anisotropyB, halfDir );\n		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );\n		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );\n	#else\n		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n		float D = D_GGX( alpha, dotNH );\n	#endif\n	return F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n	const float LUT_SIZE = 64.0;\n	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n	const float LUT_BIAS = 0.5 / LUT_SIZE;\n	float dotNV = saturate( dot( N, V ) );\n	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n	uv = uv * LUT_SCALE + LUT_BIAS;\n	return uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n	float l = length( f );\n	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n	float x = dot( v1, v2 );\n	float y = abs( x );\n	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n	float b = 3.4175940 + ( 4.1616724 + y ) * y;\n	float v = a / b;\n	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n	return cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n	vec3 lightNormal = cross( v1, v2 );\n	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n	vec3 T1, T2;\n	T1 = normalize( V - N * dot( V, N ) );\n	T2 = - cross( N, T1 );\n	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n	vec3 coords[ 4 ];\n	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n	coords[ 0 ] = normalize( coords[ 0 ] );\n	coords[ 1 ] = normalize( coords[ 1 ] );\n	coords[ 2 ] = normalize( coords[ 2 ] );\n	coords[ 3 ] = normalize( coords[ 3 ] );\n	vec3 vectorFormFactor = vec3( 0.0 );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n	return vec3( result );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n	float alpha = pow2( roughness );\n	float invAlpha = 1.0 / alpha;\n	float cos2h = dotNH * dotNH;\n	float sin2h = max( 1.0 - cos2h, 0.0078125 );\n	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float D = D_Charlie( sheenRoughness, dotNH );\n	float V = V_Neubelt( dotNV, dotNL );\n	return sheenColor * ( D * V );\n}\n#endif\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float r2 = roughness * roughness;\n	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n	return saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n	vec4 r = roughness * c0 + c1;\n	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n	return fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n	vec2 fab = DFGApprox( normal, viewDir, roughness );\n	return specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n	vec2 fab = DFGApprox( normal, viewDir, roughness );\n	#ifdef USE_IRIDESCENCE\n		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n	#else\n		vec3 Fr = specularColor;\n	#endif\n	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n	float Ess = fab.x + fab.y;\n	float Ems = 1.0 - Ess;\n	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n	singleScatter += FssEss;\n	multiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n		vec3 normal = geometryNormal;\n		vec3 viewDir = geometryViewDir;\n		vec3 position = geometryPosition;\n		vec3 lightPos = rectAreaLight.position;\n		vec3 halfWidth = rectAreaLight.halfWidth;\n		vec3 halfHeight = rectAreaLight.halfHeight;\n		vec3 lightColor = rectAreaLight.color;\n		float roughness = material.roughness;\n		vec3 rectCoords[ 4 ];\n		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n		vec2 uv = LTC_Uv( normal, viewDir, roughness );\n		vec4 t1 = texture2D( ltc_1, uv );\n		vec4 t2 = texture2D( ltc_2, uv );\n		mat3 mInv = mat3(\n			vec3( t1.x, 0, t1.y ),\n			vec3(    0, 1,    0 ),\n			vec3( t1.z, 0, t1.w )\n		);\n		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n	}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifdef USE_CLEARCOAT\n		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );\n		vec3 ccIrradiance = dotNLcc * directLight.color;\n		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );\n	#endif\n	#ifdef USE_SHEEN\n		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );\n	#endif\n	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n	#ifdef USE_CLEARCOAT\n		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n	#endif\n	#ifdef USE_SHEEN\n		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );\n	#endif\n	vec3 singleScattering = vec3( 0.0 );\n	vec3 multiScattering = vec3( 0.0 );\n	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n	#ifdef USE_IRIDESCENCE\n		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n	#else\n		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n	#endif\n	vec3 totalScattering = singleScattering + multiScattering;\n	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n	reflectedLight.indirectSpecular += radiance * singleScattering;\n	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct				RE_Direct_Physical\n#define RE_Direct_RectArea		RE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular		RE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";
var lights_fragment_begin = "\nvec3 geometryPosition = - vViewPosition;\nvec3 geometryNormal = normal;\nvec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\nvec3 geometryClearcoatNormal = vec3( 0.0 );\n#ifdef USE_CLEARCOAT\n	geometryClearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n	float dotNVi = saturate( dot( normal, geometryViewDir ) );\n	if ( material.iridescenceThickness == 0.0 ) {\n		material.iridescence = 0.0;\n	} else {\n		material.iridescence = saturate( material.iridescence );\n	}\n	if ( material.iridescence > 0.0 ) {\n		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n	}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n	PointLight pointLight;\n	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		pointLight = pointLights[ i ];\n		getPointLightInfo( pointLight, geometryPosition, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n		pointLightShadow = pointLightShadows[ i ];\n		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n	SpotLight spotLight;\n	vec4 spotColor;\n	vec3 spotLightCoord;\n	bool inSpotLightMap;\n	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		spotLight = spotLights[ i ];\n		getSpotLightInfo( spotLight, geometryPosition, directLight );\n		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n		#else\n		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n		#endif\n		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n		#endif\n		#undef SPOT_LIGHT_MAP_INDEX\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n		spotLightShadow = spotLightShadows[ i ];\n		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n	DirectionalLight directionalLight;\n	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		getDirectionalLightInfo( directionalLight, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n		directionalLightShadow = directionalLightShadows[ i ];\n		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n	RectAreaLight rectAreaLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n		rectAreaLight = rectAreaLights[ i ];\n		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n	vec3 iblIrradiance = vec3( 0.0 );\n	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n	#if defined( USE_LIGHT_PROBES )\n		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );\n	#endif\n	#if ( NUM_HEMI_LIGHTS > 0 )\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );\n		}\n		#pragma unroll_loop_end\n	#endif\n#endif\n#if defined( RE_IndirectSpecular )\n	vec3 radiance = vec3( 0.0 );\n	vec3 clearcoatRadiance = vec3( 0.0 );\n#endif";
var lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n		irradiance += lightMapIrradiance;\n	#endif\n	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n		iblIrradiance += getIBLIrradiance( geometryNormal );\n	#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n	#ifdef USE_ANISOTROPY\n		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );\n	#else\n		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );\n	#endif\n	#ifdef USE_CLEARCOAT\n		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );\n	#endif\n#endif";
var lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif";
var logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF )\n	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";
var logdepthbuf_pars_fragment = "#if defined( USE_LOGDEPTHBUF )\n	uniform float logDepthBufFC;\n	varying float vFragDepth;\n	varying float vIsPerspective;\n#endif";
var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n	varying float vFragDepth;\n	varying float vIsPerspective;\n#endif";
var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n	vFragDepth = 1.0 + gl_Position.w;\n	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n#endif";
var map_fragment = "#ifdef USE_MAP\n	vec4 sampledDiffuseColor = texture2D( map, vMapUv );\n	#ifdef DECODE_VIDEO_TEXTURE\n		sampledDiffuseColor = sRGBTransferEOTF( sampledDiffuseColor );\n	#endif\n	diffuseColor *= sampledDiffuseColor;\n#endif";
var map_pars_fragment = "#ifdef USE_MAP\n	uniform sampler2D map;\n#endif";
var map_particle_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	#if defined( USE_POINTS_UV )\n		vec2 uv = vUv;\n	#else\n		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n	#endif\n#endif\n#ifdef USE_MAP\n	diffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif";
var map_particle_pars_fragment = "#if defined( USE_POINTS_UV )\n	varying vec2 vUv;\n#else\n	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n		uniform mat3 uvTransform;\n	#endif\n#endif\n#ifdef USE_MAP\n	uniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif";
var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );\n	metalnessFactor *= texelMetalness.b;\n#endif";
var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n	uniform sampler2D metalnessMap;\n#endif";
var morphinstance_vertex = "#ifdef USE_INSTANCING_MORPH\n	float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;\n	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;\n	}\n#endif";
var morphcolor_vertex = "#if defined( USE_MORPHCOLORS )\n	vColor *= morphTargetBaseInfluence;\n	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n		#if defined( USE_COLOR_ALPHA )\n			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n		#elif defined( USE_COLOR )\n			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n		#endif\n	}\n#endif";
var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n	objectNormal *= morphTargetBaseInfluence;\n	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n	}\n#endif";
var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n	#ifndef USE_INSTANCING_MORPH\n		uniform float morphTargetBaseInfluence;\n		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n	#endif\n	uniform sampler2DArray morphTargetsTexture;\n	uniform ivec2 morphTargetsTextureSize;\n	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n		int y = texelIndex / morphTargetsTextureSize.x;\n		int x = texelIndex - y * morphTargetsTextureSize.x;\n		ivec3 morphUV = ivec3( x, y, morphTargetIndex );\n		return texelFetch( morphTargetsTexture, morphUV, 0 );\n	}\n#endif";
var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n	transformed *= morphTargetBaseInfluence;\n	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n	}\n#endif";
var normal_fragment_begin = "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n	vec3 fdx = dFdx( vViewPosition );\n	vec3 fdy = dFdy( vViewPosition );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n#else\n	vec3 normal = normalize( vNormal );\n	#ifdef DOUBLE_SIDED\n		normal *= faceDirection;\n	#endif\n#endif\n#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )\n	#ifdef USE_TANGENT\n		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n	#else\n		mat3 tbn = getTangentFrame( - vViewPosition, normal,\n		#if defined( USE_NORMALMAP )\n			vNormalMapUv\n		#elif defined( USE_CLEARCOAT_NORMALMAP )\n			vClearcoatNormalMapUv\n		#else\n			vUv\n		#endif\n		);\n	#endif\n	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n		tbn[0] *= faceDirection;\n		tbn[1] *= faceDirection;\n	#endif\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	#ifdef USE_TANGENT\n		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n	#else\n		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );\n	#endif\n	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n		tbn2[0] *= faceDirection;\n		tbn2[1] *= faceDirection;\n	#endif\n#endif\nvec3 nonPerturbedNormal = normal;";
var normal_fragment_maps = "#ifdef USE_NORMALMAP_OBJECTSPACE\n	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n	#ifdef FLIP_SIDED\n		normal = - normal;\n	#endif\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	normal = normalize( normalMatrix * normal );\n#elif defined( USE_NORMALMAP_TANGENTSPACE )\n	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n	mapN.xy *= normalScale;\n	normal = normalize( tbn * mapN );\n#elif defined( USE_BUMPMAP )\n	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif";
var normal_pars_fragment = "#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif";
var normal_pars_vertex = "#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif";
var normal_vertex = "#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n	#ifdef USE_TANGENT\n		vTangent = normalize( transformedTangent );\n		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n	#endif\n#endif";
var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n#endif\n#ifdef USE_NORMALMAP_OBJECTSPACE\n	uniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )\n	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {\n		vec3 q0 = dFdx( eye_pos.xyz );\n		vec3 q1 = dFdy( eye_pos.xyz );\n		vec2 st0 = dFdx( uv.st );\n		vec2 st1 = dFdy( uv.st );\n		vec3 N = surf_norm;\n		vec3 q1perp = cross( q1, N );\n		vec3 q0perp = cross( N, q0 );\n		vec3 T = q1perp * st0.x + q0perp * st1.x;\n		vec3 B = q1perp * st0.y + q0perp * st1.y;\n		float det = max( dot( T, T ), dot( B, B ) );\n		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );\n		return mat3( T * scale, B * scale, N );\n	}\n#endif";
var clearcoat_normal_fragment_begin = "#ifdef USE_CLEARCOAT\n	vec3 clearcoatNormal = nonPerturbedNormal;\n#endif";
var clearcoat_normal_fragment_maps = "#ifdef USE_CLEARCOAT_NORMALMAP\n	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;\n	clearcoatMapN.xy *= clearcoatNormalScale;\n	clearcoatNormal = normalize( tbn2 * clearcoatMapN );\n#endif";
var clearcoat_pars_fragment = "#ifdef USE_CLEARCOATMAP\n	uniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	uniform sampler2D clearcoatNormalMap;\n	uniform vec2 clearcoatNormalScale;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	uniform sampler2D clearcoatRoughnessMap;\n#endif";
var iridescence_pars_fragment = "#ifdef USE_IRIDESCENCEMAP\n	uniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n	uniform sampler2D iridescenceThicknessMap;\n#endif";
var opaque_fragment = "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );";
var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n	return normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n	return 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;\nconst float Inv255 = 1. / 255.;\nconst vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );\nconst vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );\nconst vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );\nconst vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );\nvec4 packDepthToRGBA( const in float v ) {\n	if( v <= 0.0 )\n		return vec4( 0., 0., 0., 0. );\n	if( v >= 1.0 )\n		return vec4( 1., 1., 1., 1. );\n	float vuf;\n	float af = modf( v * PackFactors.a, vuf );\n	float bf = modf( vuf * ShiftRight8, vuf );\n	float gf = modf( vuf * ShiftRight8, vuf );\n	return vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );\n}\nvec3 packDepthToRGB( const in float v ) {\n	if( v <= 0.0 )\n		return vec3( 0., 0., 0. );\n	if( v >= 1.0 )\n		return vec3( 1., 1., 1. );\n	float vuf;\n	float bf = modf( v * PackFactors.b, vuf );\n	float gf = modf( vuf * ShiftRight8, vuf );\n	return vec3( vuf * Inv255, gf * PackUpscale, bf );\n}\nvec2 packDepthToRG( const in float v ) {\n	if( v <= 0.0 )\n		return vec2( 0., 0. );\n	if( v >= 1.0 )\n		return vec2( 1., 1. );\n	float vuf;\n	float gf = modf( v * 256., vuf );\n	return vec2( vuf * Inv255, gf );\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n	return dot( v, UnpackFactors4 );\n}\nfloat unpackRGBToDepth( const in vec3 v ) {\n	return dot( v, UnpackFactors3 );\n}\nfloat unpackRGToDepth( const in vec2 v ) {\n	return v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;\n}\nvec4 pack2HalfToRGBA( const in vec2 v ) {\n	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( const in vec4 v ) {\n	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {\n	return depth * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {\n	return ( near * far ) / ( ( far - near ) * depth - far );\n}";
var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n	gl_FragColor.rgb *= gl_FragColor.a;\n#endif";
var project_vertex = "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_BATCHING\n	mvPosition = batchingMatrix * mvPosition;\n#endif\n#ifdef USE_INSTANCING\n	mvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;";
var dithering_fragment = "#ifdef DITHERING\n	gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif";
var dithering_pars_fragment = "#ifdef DITHERING\n	vec3 dithering( vec3 color ) {\n		float grid_position = rand( gl_FragCoord.xy );\n		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n		return color + dither_shift_RGB;\n	}\n#endif";
var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );\n	roughnessFactor *= texelRoughness.g;\n#endif";
var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n	uniform sampler2D roughnessMap;\n#endif";
var shadowmap_pars_fragment = "#if NUM_SPOT_LIGHT_COORDS > 0\n	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#if NUM_SPOT_LIGHT_MAPS > 0\n	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\n#endif\n#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowIntensity;\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowIntensity;\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowIntensity;\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n	}\n	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n		return unpackRGBATo2Half( texture2D( shadow, uv ) );\n	}\n	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n		float occlusion = 1.0;\n		vec2 distribution = texture2DDistribution( shadow, uv );\n		float hard_shadow = step( compare , distribution.x );\n		if (hard_shadow != 1.0 ) {\n			float distance = compare - distribution.x ;\n			float variance = max( 0.00000, distribution.y * distribution.y );\n			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n		}\n		return occlusion;\n	}\n	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n		float shadow = 1.0;\n		shadowCoord.xyz /= shadowCoord.w;\n		shadowCoord.z += shadowBias;\n		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;\n		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;\n		if ( frustumTest ) {\n		#if defined( SHADOWMAP_TYPE_PCF )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			float dx2 = dx0 / 2.0;\n			float dy2 = dy0 / 2.0;\n			float dx3 = dx1 / 2.0;\n			float dy3 = dy1 / 2.0;\n			shadow = (\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 17.0 );\n		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx = texelSize.x;\n			float dy = texelSize.y;\n			vec2 uv = shadowCoord.xy;\n			vec2 f = fract( uv * shadowMapSize + 0.5 );\n			uv -= f * texelSize;\n			shadow = (\n				texture2DCompare( shadowMap, uv, shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n						  f.x ),\n					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n						  f.x ),\n					 f.y )\n			) * ( 1.0 / 9.0 );\n		#elif defined( SHADOWMAP_TYPE_VSM )\n			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#else\n			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#endif\n		}\n		return mix( 1.0, shadow, shadowIntensity );\n	}\n	vec2 cubeToUV( vec3 v, float texelSizeY ) {\n		vec3 absV = abs( v );\n		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n		absV *= scaleToCube;\n		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n		vec2 planar = v.xy;\n		float almostATexel = 1.5 * texelSizeY;\n		float almostOne = 1.0 - almostATexel;\n		if ( absV.z >= almostOne ) {\n			if ( v.z > 0.0 )\n				planar.x = 4.0 - v.x;\n		} else if ( absV.x >= almostOne ) {\n			float signX = sign( v.x );\n			planar.x = v.z * signX + 2.0 * signX;\n		} else if ( absV.y >= almostOne ) {\n			float signY = sign( v.y );\n			planar.x = v.x + 2.0 * signY + 2.0;\n			planar.y = v.z * signY - 2.0;\n		}\n		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n	}\n	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n		float shadow = 1.0;\n		vec3 lightToPosition = shadowCoord.xyz;\n		\n		float lightToPositionLength = length( lightToPosition );\n		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {\n			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;\n			vec3 bd3D = normalize( lightToPosition );\n			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n				shadow = (\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n				) * ( 1.0 / 9.0 );\n			#else\n				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n			#endif\n		}\n		return mix( 1.0, shadow, shadowIntensity );\n	}\n#endif";
var shadowmap_pars_vertex = "#if NUM_SPOT_LIGHT_COORDS > 0\n	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\n	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowIntensity;\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		struct SpotLightShadow {\n			float shadowIntensity;\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowIntensity;\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n#endif";
var shadowmap_vertex = "#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )\n	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n	vec4 shadowWorldPosition;\n#endif\n#if defined( USE_SHADOWMAP )\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n		}\n		#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n		}\n		#pragma unroll_loop_end\n	#endif\n#endif\n#if NUM_SPOT_LIGHT_COORDS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {\n		shadowWorldPosition = worldPosition;\n		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\n		#endif\n		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n#endif";
var shadowmask_pars_fragment = "float getShadowMask() {\n	float shadow = 1.0;\n	#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		directionalLight = directionalLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		spotLight = spotLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		pointLight = pointLightShadows[ i ];\n		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#endif\n	return shadow;\n}";
var skinbase_vertex = "#ifdef USE_SKINNING\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";
var skinning_pars_vertex = "#ifdef USE_SKINNING\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n	uniform highp sampler2D boneTexture;\n	mat4 getBoneMatrix( const in float i ) {\n		int size = textureSize( boneTexture, 0 ).x;\n		int j = int( i ) * 4;\n		int x = j % size;\n		int y = j / size;\n		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );\n		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );\n		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );\n		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );\n		return mat4( v1, v2, v3, v4 );\n	}\n#endif";
var skinning_vertex = "#ifdef USE_SKINNING\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	transformed = ( bindMatrixInverse * skinned ).xyz;\n#endif";
var skinnormal_vertex = "#ifdef USE_SKINNING\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n	#ifdef USE_TANGENT\n		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#endif\n#endif";
var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );\n	specularStrength = texelSpecular.r;\n#else\n	specularStrength = 1.0;\n#endif";
var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n	uniform sampler2D specularMap;\n#endif";
var tonemapping_fragment = "#if defined( TONE_MAPPING )\n	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif";
var tonemapping_pars_fragment = "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n	return saturate( toneMappingExposure * color );\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	return saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 CineonToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	color = max( vec3( 0.0 ), color - 0.004 );\n	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n	return a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n	const mat3 ACESInputMat = mat3(\n		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),\n		vec3( 0.04823, 0.01566, 0.83777 )\n	);\n	const mat3 ACESOutputMat = mat3(\n		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),\n		vec3( -0.07367, -0.00605,  1.07602 )\n	);\n	color *= toneMappingExposure / 0.6;\n	color = ACESInputMat * color;\n	color = RRTAndODTFit( color );\n	color = ACESOutputMat * color;\n	return saturate( color );\n}\nconst mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(\n	vec3( 1.6605, - 0.1246, - 0.0182 ),\n	vec3( - 0.5876, 1.1329, - 0.1006 ),\n	vec3( - 0.0728, - 0.0083, 1.1187 )\n);\nconst mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(\n	vec3( 0.6274, 0.0691, 0.0164 ),\n	vec3( 0.3293, 0.9195, 0.0880 ),\n	vec3( 0.0433, 0.0113, 0.8956 )\n);\nvec3 agxDefaultContrastApprox( vec3 x ) {\n	vec3 x2 = x * x;\n	vec3 x4 = x2 * x2;\n	return + 15.5 * x4 * x2\n		- 40.14 * x4 * x\n		+ 31.96 * x4\n		- 6.868 * x2 * x\n		+ 0.4298 * x2\n		+ 0.1191 * x\n		- 0.00232;\n}\nvec3 AgXToneMapping( vec3 color ) {\n	const mat3 AgXInsetMatrix = mat3(\n		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),\n		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),\n		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )\n	);\n	const mat3 AgXOutsetMatrix = mat3(\n		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),\n		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),\n		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )\n	);\n	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;\n	color *= toneMappingExposure;\n	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;\n	color = AgXInsetMatrix * color;\n	color = max( color, 1e-10 );	color = log2( color );\n	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );\n	color = clamp( color, 0.0, 1.0 );\n	color = agxDefaultContrastApprox( color );\n	color = AgXOutsetMatrix * color;\n	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );\n	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;\n	color = clamp( color, 0.0, 1.0 );\n	return color;\n}\nvec3 NeutralToneMapping( vec3 color ) {\n	const float StartCompression = 0.8 - 0.04;\n	const float Desaturation = 0.15;\n	color *= toneMappingExposure;\n	float x = min( color.r, min( color.g, color.b ) );\n	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;\n	color -= offset;\n	float peak = max( color.r, max( color.g, color.b ) );\n	if ( peak < StartCompression ) return color;\n	float d = 1. - StartCompression;\n	float newPeak = 1. - d * d / ( peak + d - StartCompression );\n	color *= newPeak / peak;\n	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );\n	return mix( color, vec3( newPeak ), g );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }";
var transmission_fragment = "#ifdef USE_TRANSMISSION\n	material.transmission = transmission;\n	material.transmissionAlpha = 1.0;\n	material.thickness = thickness;\n	material.attenuationDistance = attenuationDistance;\n	material.attenuationColor = attenuationColor;\n	#ifdef USE_TRANSMISSIONMAP\n		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;\n	#endif\n	vec3 pos = vWorldPosition;\n	vec3 v = normalize( cameraPosition - pos );\n	vec3 n = inverseTransformDirection( normal, viewMatrix );\n	vec4 transmitted = getIBLVolumeRefraction(\n		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,\n		material.attenuationColor, material.attenuationDistance );\n	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );\n	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );\n#endif";
var transmission_pars_fragment = "#ifdef USE_TRANSMISSION\n	uniform float transmission;\n	uniform float thickness;\n	uniform float attenuationDistance;\n	uniform vec3 attenuationColor;\n	#ifdef USE_TRANSMISSIONMAP\n		uniform sampler2D transmissionMap;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		uniform sampler2D thicknessMap;\n	#endif\n	uniform vec2 transmissionSamplerSize;\n	uniform sampler2D transmissionSamplerMap;\n	uniform mat4 modelMatrix;\n	uniform mat4 projectionMatrix;\n	varying vec3 vWorldPosition;\n	float w0( float a ) {\n		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );\n	}\n	float w1( float a ) {\n		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );\n	}\n	float w2( float a ){\n		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );\n	}\n	float w3( float a ) {\n		return ( 1.0 / 6.0 ) * ( a * a * a );\n	}\n	float g0( float a ) {\n		return w0( a ) + w1( a );\n	}\n	float g1( float a ) {\n		return w2( a ) + w3( a );\n	}\n	float h0( float a ) {\n		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );\n	}\n	float h1( float a ) {\n		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );\n	}\n	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {\n		uv = uv * texelSize.zw + 0.5;\n		vec2 iuv = floor( uv );\n		vec2 fuv = fract( uv );\n		float g0x = g0( fuv.x );\n		float g1x = g1( fuv.x );\n		float h0x = h0( fuv.x );\n		float h1x = h1( fuv.x );\n		float h0y = h0( fuv.y );\n		float h1y = h1( fuv.y );\n		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +\n			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );\n	}\n	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {\n		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );\n		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );\n		vec2 fLodSizeInv = 1.0 / fLodSize;\n		vec2 cLodSizeInv = 1.0 / cLodSize;\n		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );\n		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );\n		return mix( fSample, cSample, fract( lod ) );\n	}\n	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n		vec3 modelScale;\n		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n		return normalize( refractionVector ) * thickness * modelScale;\n	}\n	float applyIorToRoughness( const in float roughness, const in float ior ) {\n		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n	}\n	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );\n	}\n	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n		if ( isinf( attenuationDistance ) ) {\n			return vec3( 1.0 );\n		} else {\n			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;\n		}\n	}\n	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,\n		const in vec3 attenuationColor, const in float attenuationDistance ) {\n		vec4 transmittedLight;\n		vec3 transmittance;\n		#ifdef USE_DISPERSION\n			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;\n			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );\n			for ( int i = 0; i < 3; i ++ ) {\n				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );\n				vec3 refractedRayExit = position + transmissionRay;\n				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n				vec2 refractionCoords = ndcPos.xy / ndcPos.w;\n				refractionCoords += 1.0;\n				refractionCoords /= 2.0;\n				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );\n				transmittedLight[ i ] = transmissionSample[ i ];\n				transmittedLight.a += transmissionSample.a;\n				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];\n			}\n			transmittedLight.a /= 3.0;\n		#else\n			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n			vec3 refractedRayExit = position + transmissionRay;\n			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n			vec2 refractionCoords = ndcPos.xy / ndcPos.w;\n			refractionCoords += 1.0;\n			refractionCoords /= 2.0;\n			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );\n		#endif\n		vec3 attenuatedColor = transmittance * transmittedLight.rgb;\n		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;\n		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );\n	}\n#endif";
var uv_pars_fragment = "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n	varying vec2 vUv;\n#endif\n#ifdef USE_MAP\n	varying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n	varying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n	varying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n	varying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n	varying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n	varying vec2 vNormalMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n	varying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n	varying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n	varying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n	varying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n	varying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	varying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	varying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n	varying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n	varying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n	varying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n	varying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n	varying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n	varying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n	varying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n	uniform mat3 transmissionMapTransform;\n	varying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n	uniform mat3 thicknessMapTransform;\n	varying vec2 vThicknessMapUv;\n#endif";
var uv_pars_vertex = "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n	varying vec2 vUv;\n#endif\n#ifdef USE_MAP\n	uniform mat3 mapTransform;\n	varying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n	uniform mat3 alphaMapTransform;\n	varying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n	uniform mat3 lightMapTransform;\n	varying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n	uniform mat3 aoMapTransform;\n	varying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n	uniform mat3 bumpMapTransform;\n	varying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n	uniform mat3 normalMapTransform;\n	varying vec2 vNormalMapUv;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n	uniform mat3 displacementMapTransform;\n	varying vec2 vDisplacementMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n	uniform mat3 emissiveMapTransform;\n	varying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n	uniform mat3 metalnessMapTransform;\n	varying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n	uniform mat3 roughnessMapTransform;\n	varying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n	uniform mat3 anisotropyMapTransform;\n	varying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n	uniform mat3 clearcoatMapTransform;\n	varying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	uniform mat3 clearcoatNormalMapTransform;\n	varying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	uniform mat3 clearcoatRoughnessMapTransform;\n	varying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n	uniform mat3 sheenColorMapTransform;\n	varying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n	uniform mat3 sheenRoughnessMapTransform;\n	varying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n	uniform mat3 iridescenceMapTransform;\n	varying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n	uniform mat3 iridescenceThicknessMapTransform;\n	varying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n	uniform mat3 specularMapTransform;\n	varying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n	uniform mat3 specularColorMapTransform;\n	varying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n	uniform mat3 specularIntensityMapTransform;\n	varying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n	uniform mat3 transmissionMapTransform;\n	varying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n	uniform mat3 thicknessMapTransform;\n	varying vec2 vThicknessMapUv;\n#endif";
var uv_vertex = "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n	vUv = vec3( uv, 1 ).xy;\n#endif\n#ifdef USE_MAP\n	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ALPHAMAP\n	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_LIGHTMAP\n	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_AOMAP\n	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_BUMPMAP\n	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_NORMALMAP\n	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_EMISSIVEMAP\n	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_METALNESSMAP\n	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ROUGHNESSMAP\n	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ANISOTROPYMAP\n	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOATMAP\n	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULARMAP\n	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_THICKNESSMAP\n	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;\n#endif";
var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0\n	vec4 worldPosition = vec4( transformed, 1.0 );\n	#ifdef USE_BATCHING\n		worldPosition = batchingMatrix * worldPosition;\n	#endif\n	#ifdef USE_INSTANCING\n		worldPosition = instanceMatrix * worldPosition;\n	#endif\n	worldPosition = modelMatrix * worldPosition;\n#endif";
const vertex$h = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n	gl_Position = vec4( position.xy, 1.0, 1.0 );\n}";
const fragment$h = "uniform sampler2D t2D;\nuniform float backgroundIntensity;\nvarying vec2 vUv;\nvoid main() {\n	vec4 texColor = texture2D( t2D, vUv );\n	#ifdef DECODE_VIDEO_TEXTURE\n		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );\n	#endif\n	texColor.rgb *= backgroundIntensity;\n	gl_FragColor = texColor;\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n}";
const vertex$g = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	gl_Position.z = gl_Position.w;\n}";
const fragment$g = "#ifdef ENVMAP_TYPE_CUBE\n	uniform samplerCube envMap;\n#elif defined( ENVMAP_TYPE_CUBE_UV )\n	uniform sampler2D envMap;\n#endif\nuniform float flipEnvMap;\nuniform float backgroundBlurriness;\nuniform float backgroundIntensity;\nuniform mat3 backgroundRotation;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );\n	#elif defined( ENVMAP_TYPE_CUBE_UV )\n		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );\n	#else\n		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n	#endif\n	texColor.rgb *= backgroundIntensity;\n	gl_FragColor = texColor;\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n}";
const vertex$f = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	gl_Position.z = gl_Position.w;\n}";
const fragment$f = "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n	gl_FragColor = texColor;\n	gl_FragColor.a *= opacity;\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n}";
const vertex$e = "#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <uv_vertex>\n	#include <batching_vertex>\n	#include <skinbase_vertex>\n	#include <morphinstance_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vHighPrecisionZW = gl_Position.zw;\n}";
const fragment$e = "#if DEPTH_PACKING == 3200\n	uniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	vec4 diffuseColor = vec4( 1.0 );\n	#include <clipping_planes_fragment>\n	#if DEPTH_PACKING == 3200\n		diffuseColor.a = opacity;\n	#endif\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <logdepthbuf_fragment>\n	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n	#if DEPTH_PACKING == 3200\n		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n	#elif DEPTH_PACKING == 3201\n		gl_FragColor = packDepthToRGBA( fragCoordZ );\n	#elif DEPTH_PACKING == 3202\n		gl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );\n	#elif DEPTH_PACKING == 3203\n		gl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );\n	#endif\n}";
const vertex$d = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <batching_vertex>\n	#include <skinbase_vertex>\n	#include <morphinstance_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	vWorldPosition = worldPosition.xyz;\n}";
const fragment$d = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n	vec4 diffuseColor = vec4( 1.0 );\n	#include <clipping_planes_fragment>\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	float dist = length( vWorldPosition - referencePosition );\n	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n	dist = saturate( dist );\n	gl_FragColor = packDepthToRGBA( dist );\n}";
const vertex$c = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n}";
const fragment$c = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vec3 direction = normalize( vWorldDirection );\n	vec2 sampleUV = equirectUv( direction );\n	gl_FragColor = texture2D( tEquirect, sampleUV );\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n}";
const vertex$b = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	vLineDistance = scale * lineDistance;\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}";
const fragment$b = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	if ( mod( vLineDistance, totalSize ) > dashSize ) {\n		discard;\n	}\n	vec3 outgoingLight = vec3( 0.0 );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}";
const vertex$a = "#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinbase_vertex>\n		#include <skinnormal_vertex>\n		#include <defaultnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <fog_vertex>\n}";
const fragment$a = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <specularmap_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n	#else\n		reflectedLight.indirectDiffuse += vec3( 1.0 );\n	#endif\n	#include <aomap_fragment>\n	reflectedLight.indirectDiffuse *= diffuseColor.rgb;\n	vec3 outgoingLight = reflectedLight.indirectDiffuse;\n	#include <envmap_fragment>\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
const vertex$9 = "#define LAMBERT\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
const fragment$9 = "#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_lambert_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
const vertex$8 = "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n	vViewPosition = - mvPosition.xyz;\n}";
const fragment$8 = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	vec3 viewDir = normalize( vViewPosition );\n	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n	vec3 y = cross( viewDir, x );\n	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n	#ifdef USE_MATCAP\n		vec4 matcapColor = texture2D( matcap, uv );\n	#else\n		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n	#endif\n	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
const vertex$7 = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n	varying vec3 vViewPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphinstance_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n	vViewPosition = - mvPosition.xyz;\n#endif\n}";
const fragment$7 = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n	varying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );\n	#ifdef OPAQUE\n		gl_FragColor.a = 1.0;\n	#endif\n}";
const vertex$6 = "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphinstance_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
const fragment$6 = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_phong_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
const vertex$5 = "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n	varying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n	vWorldPosition = worldPosition.xyz;\n#endif\n}";
const fragment$5 = "#define STANDARD\n#ifdef PHYSICAL\n	#define IOR\n	#define USE_SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n	uniform float ior;\n#endif\n#ifdef USE_SPECULAR\n	uniform float specularIntensity;\n	uniform vec3 specularColor;\n	#ifdef USE_SPECULAR_COLORMAP\n		uniform sampler2D specularColorMap;\n	#endif\n	#ifdef USE_SPECULAR_INTENSITYMAP\n		uniform sampler2D specularIntensityMap;\n	#endif\n#endif\n#ifdef USE_CLEARCOAT\n	uniform float clearcoat;\n	uniform float clearcoatRoughness;\n#endif\n#ifdef USE_DISPERSION\n	uniform float dispersion;\n#endif\n#ifdef USE_IRIDESCENCE\n	uniform float iridescence;\n	uniform float iridescenceIOR;\n	uniform float iridescenceThicknessMinimum;\n	uniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n	uniform vec3 sheenColor;\n	uniform float sheenRoughness;\n	#ifdef USE_SHEEN_COLORMAP\n		uniform sampler2D sheenColorMap;\n	#endif\n	#ifdef USE_SHEEN_ROUGHNESSMAP\n		uniform sampler2D sheenRoughnessMap;\n	#endif\n#endif\n#ifdef USE_ANISOTROPY\n	uniform vec2 anisotropyVector;\n	#ifdef USE_ANISOTROPYMAP\n		uniform sampler2D anisotropyMap;\n	#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <roughnessmap_fragment>\n	#include <metalnessmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <clearcoat_normal_fragment_begin>\n	#include <clearcoat_normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_physical_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n	#include <transmission_fragment>\n	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n	#ifdef USE_SHEEN\n		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;\n	#endif\n	#ifdef USE_CLEARCOAT\n		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );\n		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;\n	#endif\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
const vertex$4 = "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
const fragment$4 = "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_toon_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
const vertex$3 = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#ifdef USE_POINTS_UV\n	varying vec2 vUv;\n	uniform mat3 uvTransform;\n#endif\nvoid main() {\n	#ifdef USE_POINTS_UV\n		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n	#endif\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	gl_PointSize = size;\n	#ifdef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n	#endif\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <fog_vertex>\n}";
const fragment$3 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	#include <logdepthbuf_fragment>\n	#include <map_particle_fragment>\n	#include <color_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}";
const vertex$2 = "#include <common>\n#include <batching_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphinstance_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
const fragment$2 = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <logdepthbuf_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n	#include <logdepthbuf_fragment>\n	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n}";
const vertex$1 = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	vec4 mvPosition = modelViewMatrix[ 3 ];\n	vec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );\n	#ifndef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) scale *= - mvPosition.z;\n	#endif\n	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n	vec2 rotatedPosition;\n	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n	mvPosition.xy += rotatedPosition;\n	gl_Position = projectionMatrix * mvPosition;\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}";
const fragment$1 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n}";
const ShaderChunk = {
  alphahash_fragment,
  alphahash_pars_fragment,
  alphamap_fragment,
  alphamap_pars_fragment,
  alphatest_fragment,
  alphatest_pars_fragment,
  aomap_fragment,
  aomap_pars_fragment,
  batching_pars_vertex,
  batching_vertex,
  begin_vertex,
  beginnormal_vertex,
  bsdfs,
  iridescence_fragment,
  bumpmap_pars_fragment,
  clipping_planes_fragment,
  clipping_planes_pars_fragment,
  clipping_planes_pars_vertex,
  clipping_planes_vertex,
  color_fragment,
  color_pars_fragment,
  color_pars_vertex,
  color_vertex,
  common,
  cube_uv_reflection_fragment,
  defaultnormal_vertex,
  displacementmap_pars_vertex,
  displacementmap_vertex,
  emissivemap_fragment,
  emissivemap_pars_fragment,
  colorspace_fragment,
  colorspace_pars_fragment,
  envmap_fragment,
  envmap_common_pars_fragment,
  envmap_pars_fragment,
  envmap_pars_vertex,
  envmap_physical_pars_fragment,
  envmap_vertex,
  fog_vertex,
  fog_pars_vertex,
  fog_fragment,
  fog_pars_fragment,
  gradientmap_pars_fragment,
  lightmap_pars_fragment,
  lights_lambert_fragment,
  lights_lambert_pars_fragment,
  lights_pars_begin,
  lights_toon_fragment,
  lights_toon_pars_fragment,
  lights_phong_fragment,
  lights_phong_pars_fragment,
  lights_physical_fragment,
  lights_physical_pars_fragment,
  lights_fragment_begin,
  lights_fragment_maps,
  lights_fragment_end,
  logdepthbuf_fragment,
  logdepthbuf_pars_fragment,
  logdepthbuf_pars_vertex,
  logdepthbuf_vertex,
  map_fragment,
  map_pars_fragment,
  map_particle_fragment,
  map_particle_pars_fragment,
  metalnessmap_fragment,
  metalnessmap_pars_fragment,
  morphinstance_vertex,
  morphcolor_vertex,
  morphnormal_vertex,
  morphtarget_pars_vertex,
  morphtarget_vertex,
  normal_fragment_begin,
  normal_fragment_maps,
  normal_pars_fragment,
  normal_pars_vertex,
  normal_vertex,
  normalmap_pars_fragment,
  clearcoat_normal_fragment_begin,
  clearcoat_normal_fragment_maps,
  clearcoat_pars_fragment,
  iridescence_pars_fragment,
  opaque_fragment,
  packing,
  premultiplied_alpha_fragment,
  project_vertex,
  dithering_fragment,
  dithering_pars_fragment,
  roughnessmap_fragment,
  roughnessmap_pars_fragment,
  shadowmap_pars_fragment,
  shadowmap_pars_vertex,
  shadowmap_vertex,
  shadowmask_pars_fragment,
  skinbase_vertex,
  skinning_pars_vertex,
  skinning_vertex,
  skinnormal_vertex,
  specularmap_fragment,
  specularmap_pars_fragment,
  tonemapping_fragment,
  tonemapping_pars_fragment,
  transmission_fragment,
  transmission_pars_fragment,
  uv_pars_fragment,
  uv_pars_vertex,
  uv_vertex,
  worldpos_vertex,
  background_vert: vertex$h,
  background_frag: fragment$h,
  backgroundCube_vert: vertex$g,
  backgroundCube_frag: fragment$g,
  cube_vert: vertex$f,
  cube_frag: fragment$f,
  depth_vert: vertex$e,
  depth_frag: fragment$e,
  distanceRGBA_vert: vertex$d,
  distanceRGBA_frag: fragment$d,
  equirect_vert: vertex$c,
  equirect_frag: fragment$c,
  linedashed_vert: vertex$b,
  linedashed_frag: fragment$b,
  meshbasic_vert: vertex$a,
  meshbasic_frag: fragment$a,
  meshlambert_vert: vertex$9,
  meshlambert_frag: fragment$9,
  meshmatcap_vert: vertex$8,
  meshmatcap_frag: fragment$8,
  meshnormal_vert: vertex$7,
  meshnormal_frag: fragment$7,
  meshphong_vert: vertex$6,
  meshphong_frag: fragment$6,
  meshphysical_vert: vertex$5,
  meshphysical_frag: fragment$5,
  meshtoon_vert: vertex$4,
  meshtoon_frag: fragment$4,
  points_vert: vertex$3,
  points_frag: fragment$3,
  shadow_vert: vertex$2,
  shadow_frag: fragment$2,
  sprite_vert: vertex$1,
  sprite_frag: fragment$1
};
const UniformsLib = {
  common: {
    diffuse: { value: /* @__PURE__ */ new Color$1(16777215) },
    opacity: { value: 1 },
    map: { value: null },
    mapTransform: { value: /* @__PURE__ */ new Matrix3$1() },
    alphaMap: { value: null },
    alphaMapTransform: { value: /* @__PURE__ */ new Matrix3$1() },
    alphaTest: { value: 0 }
  },
  specularmap: {
    specularMap: { value: null },
    specularMapTransform: { value: /* @__PURE__ */ new Matrix3$1() }
  },
  envmap: {
    envMap: { value: null },
    envMapRotation: { value: /* @__PURE__ */ new Matrix3$1() },
    flipEnvMap: { value: -1 },
    reflectivity: { value: 1 },
    // basic, lambert, phong
    ior: { value: 1.5 },
    // physical
    refractionRatio: { value: 0.98 }
    // basic, lambert, phong
  },
  aomap: {
    aoMap: { value: null },
    aoMapIntensity: { value: 1 },
    aoMapTransform: { value: /* @__PURE__ */ new Matrix3$1() }
  },
  lightmap: {
    lightMap: { value: null },
    lightMapIntensity: { value: 1 },
    lightMapTransform: { value: /* @__PURE__ */ new Matrix3$1() }
  },
  bumpmap: {
    bumpMap: { value: null },
    bumpMapTransform: { value: /* @__PURE__ */ new Matrix3$1() },
    bumpScale: { value: 1 }
  },
  normalmap: {
    normalMap: { value: null },
    normalMapTransform: { value: /* @__PURE__ */ new Matrix3$1() },
    normalScale: { value: /* @__PURE__ */ new Vector2$1(1, 1) }
  },
  displacementmap: {
    displacementMap: { value: null },
    displacementMapTransform: { value: /* @__PURE__ */ new Matrix3$1() },
    displacementScale: { value: 1 },
    displacementBias: { value: 0 }
  },
  emissivemap: {
    emissiveMap: { value: null },
    emissiveMapTransform: { value: /* @__PURE__ */ new Matrix3$1() }
  },
  metalnessmap: {
    metalnessMap: { value: null },
    metalnessMapTransform: { value: /* @__PURE__ */ new Matrix3$1() }
  },
  roughnessmap: {
    roughnessMap: { value: null },
    roughnessMapTransform: { value: /* @__PURE__ */ new Matrix3$1() }
  },
  gradientmap: {
    gradientMap: { value: null }
  },
  fog: {
    fogDensity: { value: 25e-5 },
    fogNear: { value: 1 },
    fogFar: { value: 2e3 },
    fogColor: { value: /* @__PURE__ */ new Color$1(16777215) }
  },
  lights: {
    ambientLightColor: { value: [] },
    lightProbe: { value: [] },
    directionalLights: { value: [], properties: {
      direction: {},
      color: {}
    } },
    directionalLightShadows: { value: [], properties: {
      shadowIntensity: 1,
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    directionalShadowMap: { value: [] },
    directionalShadowMatrix: { value: [] },
    spotLights: { value: [], properties: {
      color: {},
      position: {},
      direction: {},
      distance: {},
      coneCos: {},
      penumbraCos: {},
      decay: {}
    } },
    spotLightShadows: { value: [], properties: {
      shadowIntensity: 1,
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    spotLightMap: { value: [] },
    spotShadowMap: { value: [] },
    spotLightMatrix: { value: [] },
    pointLights: { value: [], properties: {
      color: {},
      position: {},
      decay: {},
      distance: {}
    } },
    pointLightShadows: { value: [], properties: {
      shadowIntensity: 1,
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {},
      shadowCameraNear: {},
      shadowCameraFar: {}
    } },
    pointShadowMap: { value: [] },
    pointShadowMatrix: { value: [] },
    hemisphereLights: { value: [], properties: {
      direction: {},
      skyColor: {},
      groundColor: {}
    } },
    // TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
    rectAreaLights: { value: [], properties: {
      color: {},
      position: {},
      width: {},
      height: {}
    } },
    ltc_1: { value: null },
    ltc_2: { value: null }
  },
  points: {
    diffuse: { value: /* @__PURE__ */ new Color$1(16777215) },
    opacity: { value: 1 },
    size: { value: 1 },
    scale: { value: 1 },
    map: { value: null },
    alphaMap: { value: null },
    alphaMapTransform: { value: /* @__PURE__ */ new Matrix3$1() },
    alphaTest: { value: 0 },
    uvTransform: { value: /* @__PURE__ */ new Matrix3$1() }
  },
  sprite: {
    diffuse: { value: /* @__PURE__ */ new Color$1(16777215) },
    opacity: { value: 1 },
    center: { value: /* @__PURE__ */ new Vector2$1(0.5, 0.5) },
    rotation: { value: 0 },
    map: { value: null },
    mapTransform: { value: /* @__PURE__ */ new Matrix3$1() },
    alphaMap: { value: null },
    alphaMapTransform: { value: /* @__PURE__ */ new Matrix3$1() },
    alphaTest: { value: 0 }
  }
};
const ShaderLib = {
  basic: {
    uniforms: /* @__PURE__ */ mergeUniforms([
      UniformsLib.common,
      UniformsLib.specularmap,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.fog
    ]),
    vertexShader: ShaderChunk.meshbasic_vert,
    fragmentShader: ShaderChunk.meshbasic_frag
  },
  lambert: {
    uniforms: /* @__PURE__ */ mergeUniforms([
      UniformsLib.common,
      UniformsLib.specularmap,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: { value: /* @__PURE__ */ new Color$1(0) }
      }
    ]),
    vertexShader: ShaderChunk.meshlambert_vert,
    fragmentShader: ShaderChunk.meshlambert_frag
  },
  phong: {
    uniforms: /* @__PURE__ */ mergeUniforms([
      UniformsLib.common,
      UniformsLib.specularmap,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: { value: /* @__PURE__ */ new Color$1(0) },
        specular: { value: /* @__PURE__ */ new Color$1(1118481) },
        shininess: { value: 30 }
      }
    ]),
    vertexShader: ShaderChunk.meshphong_vert,
    fragmentShader: ShaderChunk.meshphong_frag
  },
  standard: {
    uniforms: /* @__PURE__ */ mergeUniforms([
      UniformsLib.common,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.roughnessmap,
      UniformsLib.metalnessmap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: { value: /* @__PURE__ */ new Color$1(0) },
        roughness: { value: 1 },
        metalness: { value: 0 },
        envMapIntensity: { value: 1 }
      }
    ]),
    vertexShader: ShaderChunk.meshphysical_vert,
    fragmentShader: ShaderChunk.meshphysical_frag
  },
  toon: {
    uniforms: /* @__PURE__ */ mergeUniforms([
      UniformsLib.common,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.gradientmap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: { value: /* @__PURE__ */ new Color$1(0) }
      }
    ]),
    vertexShader: ShaderChunk.meshtoon_vert,
    fragmentShader: ShaderChunk.meshtoon_frag
  },
  matcap: {
    uniforms: /* @__PURE__ */ mergeUniforms([
      UniformsLib.common,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.fog,
      {
        matcap: { value: null }
      }
    ]),
    vertexShader: ShaderChunk.meshmatcap_vert,
    fragmentShader: ShaderChunk.meshmatcap_frag
  },
  points: {
    uniforms: /* @__PURE__ */ mergeUniforms([
      UniformsLib.points,
      UniformsLib.fog
    ]),
    vertexShader: ShaderChunk.points_vert,
    fragmentShader: ShaderChunk.points_frag
  },
  dashed: {
    uniforms: /* @__PURE__ */ mergeUniforms([
      UniformsLib.common,
      UniformsLib.fog,
      {
        scale: { value: 1 },
        dashSize: { value: 1 },
        totalSize: { value: 2 }
      }
    ]),
    vertexShader: ShaderChunk.linedashed_vert,
    fragmentShader: ShaderChunk.linedashed_frag
  },
  depth: {
    uniforms: /* @__PURE__ */ mergeUniforms([
      UniformsLib.common,
      UniformsLib.displacementmap
    ]),
    vertexShader: ShaderChunk.depth_vert,
    fragmentShader: ShaderChunk.depth_frag
  },
  normal: {
    uniforms: /* @__PURE__ */ mergeUniforms([
      UniformsLib.common,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      {
        opacity: { value: 1 }
      }
    ]),
    vertexShader: ShaderChunk.meshnormal_vert,
    fragmentShader: ShaderChunk.meshnormal_frag
  },
  sprite: {
    uniforms: /* @__PURE__ */ mergeUniforms([
      UniformsLib.sprite,
      UniformsLib.fog
    ]),
    vertexShader: ShaderChunk.sprite_vert,
    fragmentShader: ShaderChunk.sprite_frag
  },
  background: {
    uniforms: {
      uvTransform: { value: /* @__PURE__ */ new Matrix3$1() },
      t2D: { value: null },
      backgroundIntensity: { value: 1 }
    },
    vertexShader: ShaderChunk.background_vert,
    fragmentShader: ShaderChunk.background_frag
  },
  backgroundCube: {
    uniforms: {
      envMap: { value: null },
      flipEnvMap: { value: -1 },
      backgroundBlurriness: { value: 0 },
      backgroundIntensity: { value: 1 },
      backgroundRotation: { value: /* @__PURE__ */ new Matrix3$1() }
    },
    vertexShader: ShaderChunk.backgroundCube_vert,
    fragmentShader: ShaderChunk.backgroundCube_frag
  },
  cube: {
    uniforms: {
      tCube: { value: null },
      tFlip: { value: -1 },
      opacity: { value: 1 }
    },
    vertexShader: ShaderChunk.cube_vert,
    fragmentShader: ShaderChunk.cube_frag
  },
  equirect: {
    uniforms: {
      tEquirect: { value: null }
    },
    vertexShader: ShaderChunk.equirect_vert,
    fragmentShader: ShaderChunk.equirect_frag
  },
  distanceRGBA: {
    uniforms: /* @__PURE__ */ mergeUniforms([
      UniformsLib.common,
      UniformsLib.displacementmap,
      {
        referencePosition: { value: /* @__PURE__ */ new Vector3$1() },
        nearDistance: { value: 1 },
        farDistance: { value: 1e3 }
      }
    ]),
    vertexShader: ShaderChunk.distanceRGBA_vert,
    fragmentShader: ShaderChunk.distanceRGBA_frag
  },
  shadow: {
    uniforms: /* @__PURE__ */ mergeUniforms([
      UniformsLib.lights,
      UniformsLib.fog,
      {
        color: { value: /* @__PURE__ */ new Color$1(0) },
        opacity: { value: 1 }
      }
    ]),
    vertexShader: ShaderChunk.shadow_vert,
    fragmentShader: ShaderChunk.shadow_frag
  }
};
ShaderLib.physical = {
  uniforms: /* @__PURE__ */ mergeUniforms([
    ShaderLib.standard.uniforms,
    {
      clearcoat: { value: 0 },
      clearcoatMap: { value: null },
      clearcoatMapTransform: { value: /* @__PURE__ */ new Matrix3$1() },
      clearcoatNormalMap: { value: null },
      clearcoatNormalMapTransform: { value: /* @__PURE__ */ new Matrix3$1() },
      clearcoatNormalScale: { value: /* @__PURE__ */ new Vector2$1(1, 1) },
      clearcoatRoughness: { value: 0 },
      clearcoatRoughnessMap: { value: null },
      clearcoatRoughnessMapTransform: { value: /* @__PURE__ */ new Matrix3$1() },
      dispersion: { value: 0 },
      iridescence: { value: 0 },
      iridescenceMap: { value: null },
      iridescenceMapTransform: { value: /* @__PURE__ */ new Matrix3$1() },
      iridescenceIOR: { value: 1.3 },
      iridescenceThicknessMinimum: { value: 100 },
      iridescenceThicknessMaximum: { value: 400 },
      iridescenceThicknessMap: { value: null },
      iridescenceThicknessMapTransform: { value: /* @__PURE__ */ new Matrix3$1() },
      sheen: { value: 0 },
      sheenColor: { value: /* @__PURE__ */ new Color$1(0) },
      sheenColorMap: { value: null },
      sheenColorMapTransform: { value: /* @__PURE__ */ new Matrix3$1() },
      sheenRoughness: { value: 1 },
      sheenRoughnessMap: { value: null },
      sheenRoughnessMapTransform: { value: /* @__PURE__ */ new Matrix3$1() },
      transmission: { value: 0 },
      transmissionMap: { value: null },
      transmissionMapTransform: { value: /* @__PURE__ */ new Matrix3$1() },
      transmissionSamplerSize: { value: /* @__PURE__ */ new Vector2$1() },
      transmissionSamplerMap: { value: null },
      thickness: { value: 0 },
      thicknessMap: { value: null },
      thicknessMapTransform: { value: /* @__PURE__ */ new Matrix3$1() },
      attenuationDistance: { value: 0 },
      attenuationColor: { value: /* @__PURE__ */ new Color$1(0) },
      specularColor: { value: /* @__PURE__ */ new Color$1(1, 1, 1) },
      specularColorMap: { value: null },
      specularColorMapTransform: { value: /* @__PURE__ */ new Matrix3$1() },
      specularIntensity: { value: 1 },
      specularIntensityMap: { value: null },
      specularIntensityMapTransform: { value: /* @__PURE__ */ new Matrix3$1() },
      anisotropyVector: { value: /* @__PURE__ */ new Vector2$1() },
      anisotropyMap: { value: null },
      anisotropyMapTransform: { value: /* @__PURE__ */ new Matrix3$1() }
    }
  ]),
  vertexShader: ShaderChunk.meshphysical_vert,
  fragmentShader: ShaderChunk.meshphysical_frag
};
const _rgb = { r: 0, b: 0, g: 0 };
const _e1$1 = /* @__PURE__ */ new Euler();
const _m1$1 = /* @__PURE__ */ new Matrix4$1();
function WebGLBackground(renderer, cubemaps, cubeuvmaps, state, objects, alpha, premultipliedAlpha) {
  const clearColor = new Color$1(0);
  let clearAlpha = alpha === true ? 0 : 1;
  let planeMesh;
  let boxMesh;
  let currentBackground = null;
  let currentBackgroundVersion = 0;
  let currentTonemapping = null;
  function getBackground(scene) {
    let background = scene.isScene === true ? scene.background : null;
    if (background && background.isTexture) {
      const usePMREM = scene.backgroundBlurriness > 0;
      background = (usePMREM ? cubeuvmaps : cubemaps).get(background);
    }
    return background;
  }
  function render(scene) {
    let forceClear = false;
    const background = getBackground(scene);
    if (background === null) {
      setClear(clearColor, clearAlpha);
    } else if (background && background.isColor) {
      setClear(background, 1);
      forceClear = true;
    }
    const environmentBlendMode = renderer.xr.getEnvironmentBlendMode();
    if (environmentBlendMode === "additive") {
      state.buffers.color.setClear(0, 0, 0, 1, premultipliedAlpha);
    } else if (environmentBlendMode === "alpha-blend") {
      state.buffers.color.setClear(0, 0, 0, 0, premultipliedAlpha);
    }
    if (renderer.autoClear || forceClear) {
      state.buffers.depth.setTest(true);
      state.buffers.depth.setMask(true);
      state.buffers.color.setMask(true);
      renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
    }
  }
  function addToRenderList(renderList, scene) {
    const background = getBackground(scene);
    if (background && (background.isCubeTexture || background.mapping === CubeUVReflectionMapping)) {
      if (boxMesh === void 0) {
        boxMesh = new Mesh(
          new BoxGeometry(1, 1, 1),
          new ShaderMaterial({
            name: "BackgroundCubeMaterial",
            uniforms: cloneUniforms(ShaderLib.backgroundCube.uniforms),
            vertexShader: ShaderLib.backgroundCube.vertexShader,
            fragmentShader: ShaderLib.backgroundCube.fragmentShader,
            side: BackSide,
            depthTest: false,
            depthWrite: false,
            fog: false
          })
        );
        boxMesh.geometry.deleteAttribute("normal");
        boxMesh.geometry.deleteAttribute("uv");
        boxMesh.onBeforeRender = function(renderer2, scene2, camera) {
          this.matrixWorld.copyPosition(camera.matrixWorld);
        };
        Object.defineProperty(boxMesh.material, "envMap", {
          get: function() {
            return this.uniforms.envMap.value;
          }
        });
        objects.update(boxMesh);
      }
      _e1$1.copy(scene.backgroundRotation);
      _e1$1.x *= -1;
      _e1$1.y *= -1;
      _e1$1.z *= -1;
      if (background.isCubeTexture && background.isRenderTargetTexture === false) {
        _e1$1.y *= -1;
        _e1$1.z *= -1;
      }
      boxMesh.material.uniforms.envMap.value = background;
      boxMesh.material.uniforms.flipEnvMap.value = background.isCubeTexture && background.isRenderTargetTexture === false ? -1 : 1;
      boxMesh.material.uniforms.backgroundBlurriness.value = scene.backgroundBlurriness;
      boxMesh.material.uniforms.backgroundIntensity.value = scene.backgroundIntensity;
      boxMesh.material.uniforms.backgroundRotation.value.setFromMatrix4(_m1$1.makeRotationFromEuler(_e1$1));
      boxMesh.material.toneMapped = ColorManagement$1.getTransfer(background.colorSpace) !== SRGBTransfer$1;
      if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
        boxMesh.material.needsUpdate = true;
        currentBackground = background;
        currentBackgroundVersion = background.version;
        currentTonemapping = renderer.toneMapping;
      }
      boxMesh.layers.enableAll();
      renderList.unshift(boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null);
    } else if (background && background.isTexture) {
      if (planeMesh === void 0) {
        planeMesh = new Mesh(
          new PlaneGeometry(2, 2),
          new ShaderMaterial({
            name: "BackgroundMaterial",
            uniforms: cloneUniforms(ShaderLib.background.uniforms),
            vertexShader: ShaderLib.background.vertexShader,
            fragmentShader: ShaderLib.background.fragmentShader,
            side: FrontSide,
            depthTest: false,
            depthWrite: false,
            fog: false
          })
        );
        planeMesh.geometry.deleteAttribute("normal");
        Object.defineProperty(planeMesh.material, "map", {
          get: function() {
            return this.uniforms.t2D.value;
          }
        });
        objects.update(planeMesh);
      }
      planeMesh.material.uniforms.t2D.value = background;
      planeMesh.material.uniforms.backgroundIntensity.value = scene.backgroundIntensity;
      planeMesh.material.toneMapped = ColorManagement$1.getTransfer(background.colorSpace) !== SRGBTransfer$1;
      if (background.matrixAutoUpdate === true) {
        background.updateMatrix();
      }
      planeMesh.material.uniforms.uvTransform.value.copy(background.matrix);
      if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
        planeMesh.material.needsUpdate = true;
        currentBackground = background;
        currentBackgroundVersion = background.version;
        currentTonemapping = renderer.toneMapping;
      }
      planeMesh.layers.enableAll();
      renderList.unshift(planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null);
    }
  }
  function setClear(color2, alpha2) {
    color2.getRGB(_rgb, getUnlitUniformColorSpace(renderer));
    state.buffers.color.setClear(_rgb.r, _rgb.g, _rgb.b, alpha2, premultipliedAlpha);
  }
  function dispose() {
    if (boxMesh !== void 0) {
      boxMesh.geometry.dispose();
      boxMesh.material.dispose();
    }
    if (planeMesh !== void 0) {
      planeMesh.geometry.dispose();
      planeMesh.material.dispose();
    }
  }
  return {
    getClearColor: function() {
      return clearColor;
    },
    setClearColor: function(color2, alpha2 = 1) {
      clearColor.set(color2);
      clearAlpha = alpha2;
      setClear(clearColor, clearAlpha);
    },
    getClearAlpha: function() {
      return clearAlpha;
    },
    setClearAlpha: function(alpha2) {
      clearAlpha = alpha2;
      setClear(clearColor, clearAlpha);
    },
    render,
    addToRenderList,
    dispose
  };
}
function WebGLBindingStates(gl, attributes) {
  const maxVertexAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
  const bindingStates = {};
  const defaultState = createBindingState(null);
  let currentState = defaultState;
  let forceUpdate = false;
  function setup(object, material, program, geometry, index) {
    let updateBuffers = false;
    const state = getBindingState(geometry, program, material);
    if (currentState !== state) {
      currentState = state;
      bindVertexArrayObject(currentState.object);
    }
    updateBuffers = needsUpdate(object, geometry, program, index);
    if (updateBuffers) saveCache(object, geometry, program, index);
    if (index !== null) {
      attributes.update(index, gl.ELEMENT_ARRAY_BUFFER);
    }
    if (updateBuffers || forceUpdate) {
      forceUpdate = false;
      setupVertexAttributes(object, material, program, geometry);
      if (index !== null) {
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, attributes.get(index).buffer);
      }
    }
  }
  function createVertexArrayObject() {
    return gl.createVertexArray();
  }
  function bindVertexArrayObject(vao) {
    return gl.bindVertexArray(vao);
  }
  function deleteVertexArrayObject(vao) {
    return gl.deleteVertexArray(vao);
  }
  function getBindingState(geometry, program, material) {
    const wireframe = material.wireframe === true;
    let programMap = bindingStates[geometry.id];
    if (programMap === void 0) {
      programMap = {};
      bindingStates[geometry.id] = programMap;
    }
    let stateMap = programMap[program.id];
    if (stateMap === void 0) {
      stateMap = {};
      programMap[program.id] = stateMap;
    }
    let state = stateMap[wireframe];
    if (state === void 0) {
      state = createBindingState(createVertexArrayObject());
      stateMap[wireframe] = state;
    }
    return state;
  }
  function createBindingState(vao) {
    const newAttributes = [];
    const enabledAttributes = [];
    const attributeDivisors = [];
    for (let i = 0; i < maxVertexAttributes; i++) {
      newAttributes[i] = 0;
      enabledAttributes[i] = 0;
      attributeDivisors[i] = 0;
    }
    return {
      // for backward compatibility on non-VAO support browser
      geometry: null,
      program: null,
      wireframe: false,
      newAttributes,
      enabledAttributes,
      attributeDivisors,
      object: vao,
      attributes: {},
      index: null
    };
  }
  function needsUpdate(object, geometry, program, index) {
    const cachedAttributes = currentState.attributes;
    const geometryAttributes = geometry.attributes;
    let attributesNum = 0;
    const programAttributes = program.getAttributes();
    for (const name in programAttributes) {
      const programAttribute = programAttributes[name];
      if (programAttribute.location >= 0) {
        const cachedAttribute = cachedAttributes[name];
        let geometryAttribute = geometryAttributes[name];
        if (geometryAttribute === void 0) {
          if (name === "instanceMatrix" && object.instanceMatrix) geometryAttribute = object.instanceMatrix;
          if (name === "instanceColor" && object.instanceColor) geometryAttribute = object.instanceColor;
        }
        if (cachedAttribute === void 0) return true;
        if (cachedAttribute.attribute !== geometryAttribute) return true;
        if (geometryAttribute && cachedAttribute.data !== geometryAttribute.data) return true;
        attributesNum++;
      }
    }
    if (currentState.attributesNum !== attributesNum) return true;
    if (currentState.index !== index) return true;
    return false;
  }
  function saveCache(object, geometry, program, index) {
    const cache2 = {};
    const attributes2 = geometry.attributes;
    let attributesNum = 0;
    const programAttributes = program.getAttributes();
    for (const name in programAttributes) {
      const programAttribute = programAttributes[name];
      if (programAttribute.location >= 0) {
        let attribute = attributes2[name];
        if (attribute === void 0) {
          if (name === "instanceMatrix" && object.instanceMatrix) attribute = object.instanceMatrix;
          if (name === "instanceColor" && object.instanceColor) attribute = object.instanceColor;
        }
        const data = {};
        data.attribute = attribute;
        if (attribute && attribute.data) {
          data.data = attribute.data;
        }
        cache2[name] = data;
        attributesNum++;
      }
    }
    currentState.attributes = cache2;
    currentState.attributesNum = attributesNum;
    currentState.index = index;
  }
  function initAttributes() {
    const newAttributes = currentState.newAttributes;
    for (let i = 0, il = newAttributes.length; i < il; i++) {
      newAttributes[i] = 0;
    }
  }
  function enableAttribute(attribute) {
    enableAttributeAndDivisor(attribute, 0);
  }
  function enableAttributeAndDivisor(attribute, meshPerAttribute) {
    const newAttributes = currentState.newAttributes;
    const enabledAttributes = currentState.enabledAttributes;
    const attributeDivisors = currentState.attributeDivisors;
    newAttributes[attribute] = 1;
    if (enabledAttributes[attribute] === 0) {
      gl.enableVertexAttribArray(attribute);
      enabledAttributes[attribute] = 1;
    }
    if (attributeDivisors[attribute] !== meshPerAttribute) {
      gl.vertexAttribDivisor(attribute, meshPerAttribute);
      attributeDivisors[attribute] = meshPerAttribute;
    }
  }
  function disableUnusedAttributes() {
    const newAttributes = currentState.newAttributes;
    const enabledAttributes = currentState.enabledAttributes;
    for (let i = 0, il = enabledAttributes.length; i < il; i++) {
      if (enabledAttributes[i] !== newAttributes[i]) {
        gl.disableVertexAttribArray(i);
        enabledAttributes[i] = 0;
      }
    }
  }
  function vertexAttribPointer(index, size, type, normalized, stride, offset, integer) {
    if (integer === true) {
      gl.vertexAttribIPointer(index, size, type, stride, offset);
    } else {
      gl.vertexAttribPointer(index, size, type, normalized, stride, offset);
    }
  }
  function setupVertexAttributes(object, material, program, geometry) {
    initAttributes();
    const geometryAttributes = geometry.attributes;
    const programAttributes = program.getAttributes();
    const materialDefaultAttributeValues = material.defaultAttributeValues;
    for (const name in programAttributes) {
      const programAttribute = programAttributes[name];
      if (programAttribute.location >= 0) {
        let geometryAttribute = geometryAttributes[name];
        if (geometryAttribute === void 0) {
          if (name === "instanceMatrix" && object.instanceMatrix) geometryAttribute = object.instanceMatrix;
          if (name === "instanceColor" && object.instanceColor) geometryAttribute = object.instanceColor;
        }
        if (geometryAttribute !== void 0) {
          const normalized = geometryAttribute.normalized;
          const size = geometryAttribute.itemSize;
          const attribute = attributes.get(geometryAttribute);
          if (attribute === void 0) continue;
          const buffer = attribute.buffer;
          const type = attribute.type;
          const bytesPerElement = attribute.bytesPerElement;
          const integer = type === gl.INT || type === gl.UNSIGNED_INT || geometryAttribute.gpuType === IntType;
          if (geometryAttribute.isInterleavedBufferAttribute) {
            const data = geometryAttribute.data;
            const stride = data.stride;
            const offset = geometryAttribute.offset;
            if (data.isInstancedInterleavedBuffer) {
              for (let i = 0; i < programAttribute.locationSize; i++) {
                enableAttributeAndDivisor(programAttribute.location + i, data.meshPerAttribute);
              }
              if (object.isInstancedMesh !== true && geometry._maxInstanceCount === void 0) {
                geometry._maxInstanceCount = data.meshPerAttribute * data.count;
              }
            } else {
              for (let i = 0; i < programAttribute.locationSize; i++) {
                enableAttribute(programAttribute.location + i);
              }
            }
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            for (let i = 0; i < programAttribute.locationSize; i++) {
              vertexAttribPointer(
                programAttribute.location + i,
                size / programAttribute.locationSize,
                type,
                normalized,
                stride * bytesPerElement,
                (offset + size / programAttribute.locationSize * i) * bytesPerElement,
                integer
              );
            }
          } else {
            if (geometryAttribute.isInstancedBufferAttribute) {
              for (let i = 0; i < programAttribute.locationSize; i++) {
                enableAttributeAndDivisor(programAttribute.location + i, geometryAttribute.meshPerAttribute);
              }
              if (object.isInstancedMesh !== true && geometry._maxInstanceCount === void 0) {
                geometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;
              }
            } else {
              for (let i = 0; i < programAttribute.locationSize; i++) {
                enableAttribute(programAttribute.location + i);
              }
            }
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            for (let i = 0; i < programAttribute.locationSize; i++) {
              vertexAttribPointer(
                programAttribute.location + i,
                size / programAttribute.locationSize,
                type,
                normalized,
                size * bytesPerElement,
                size / programAttribute.locationSize * i * bytesPerElement,
                integer
              );
            }
          }
        } else if (materialDefaultAttributeValues !== void 0) {
          const value = materialDefaultAttributeValues[name];
          if (value !== void 0) {
            switch (value.length) {
              case 2:
                gl.vertexAttrib2fv(programAttribute.location, value);
                break;
              case 3:
                gl.vertexAttrib3fv(programAttribute.location, value);
                break;
              case 4:
                gl.vertexAttrib4fv(programAttribute.location, value);
                break;
              default:
                gl.vertexAttrib1fv(programAttribute.location, value);
            }
          }
        }
      }
    }
    disableUnusedAttributes();
  }
  function dispose() {
    reset();
    for (const geometryId in bindingStates) {
      const programMap = bindingStates[geometryId];
      for (const programId in programMap) {
        const stateMap = programMap[programId];
        for (const wireframe in stateMap) {
          deleteVertexArrayObject(stateMap[wireframe].object);
          delete stateMap[wireframe];
        }
        delete programMap[programId];
      }
      delete bindingStates[geometryId];
    }
  }
  function releaseStatesOfGeometry(geometry) {
    if (bindingStates[geometry.id] === void 0) return;
    const programMap = bindingStates[geometry.id];
    for (const programId in programMap) {
      const stateMap = programMap[programId];
      for (const wireframe in stateMap) {
        deleteVertexArrayObject(stateMap[wireframe].object);
        delete stateMap[wireframe];
      }
      delete programMap[programId];
    }
    delete bindingStates[geometry.id];
  }
  function releaseStatesOfProgram(program) {
    for (const geometryId in bindingStates) {
      const programMap = bindingStates[geometryId];
      if (programMap[program.id] === void 0) continue;
      const stateMap = programMap[program.id];
      for (const wireframe in stateMap) {
        deleteVertexArrayObject(stateMap[wireframe].object);
        delete stateMap[wireframe];
      }
      delete programMap[program.id];
    }
  }
  function reset() {
    resetDefaultState();
    forceUpdate = true;
    if (currentState === defaultState) return;
    currentState = defaultState;
    bindVertexArrayObject(currentState.object);
  }
  function resetDefaultState() {
    defaultState.geometry = null;
    defaultState.program = null;
    defaultState.wireframe = false;
  }
  return {
    setup,
    reset,
    resetDefaultState,
    dispose,
    releaseStatesOfGeometry,
    releaseStatesOfProgram,
    initAttributes,
    enableAttribute,
    disableUnusedAttributes
  };
}
function WebGLBufferRenderer(gl, extensions, info) {
  let mode;
  function setMode(value) {
    mode = value;
  }
  function render(start, count) {
    gl.drawArrays(mode, start, count);
    info.update(count, mode, 1);
  }
  function renderInstances(start, count, primcount) {
    if (primcount === 0) return;
    gl.drawArraysInstanced(mode, start, count, primcount);
    info.update(count, mode, primcount);
  }
  function renderMultiDraw(starts, counts, drawCount) {
    if (drawCount === 0) return;
    const extension = extensions.get("WEBGL_multi_draw");
    extension.multiDrawArraysWEBGL(mode, starts, 0, counts, 0, drawCount);
    let elementCount = 0;
    for (let i = 0; i < drawCount; i++) {
      elementCount += counts[i];
    }
    info.update(elementCount, mode, 1);
  }
  function renderMultiDrawInstances(starts, counts, drawCount, primcount) {
    if (drawCount === 0) return;
    const extension = extensions.get("WEBGL_multi_draw");
    if (extension === null) {
      for (let i = 0; i < starts.length; i++) {
        renderInstances(starts[i], counts[i], primcount[i]);
      }
    } else {
      extension.multiDrawArraysInstancedWEBGL(mode, starts, 0, counts, 0, primcount, 0, drawCount);
      let elementCount = 0;
      for (let i = 0; i < drawCount; i++) {
        elementCount += counts[i] * primcount[i];
      }
      info.update(elementCount, mode, 1);
    }
  }
  this.setMode = setMode;
  this.render = render;
  this.renderInstances = renderInstances;
  this.renderMultiDraw = renderMultiDraw;
  this.renderMultiDrawInstances = renderMultiDrawInstances;
}
function WebGLCapabilities(gl, extensions, parameters, utils) {
  let maxAnisotropy;
  function getMaxAnisotropy() {
    if (maxAnisotropy !== void 0) return maxAnisotropy;
    if (extensions.has("EXT_texture_filter_anisotropic") === true) {
      const extension = extensions.get("EXT_texture_filter_anisotropic");
      maxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else {
      maxAnisotropy = 0;
    }
    return maxAnisotropy;
  }
  function textureFormatReadable(textureFormat) {
    if (textureFormat !== RGBAFormat && utils.convert(textureFormat) !== gl.getParameter(gl.IMPLEMENTATION_COLOR_READ_FORMAT)) {
      return false;
    }
    return true;
  }
  function textureTypeReadable(textureType) {
    const halfFloatSupportedByExt = textureType === HalfFloatType && (extensions.has("EXT_color_buffer_half_float") || extensions.has("EXT_color_buffer_float"));
    if (textureType !== UnsignedByteType && utils.convert(textureType) !== gl.getParameter(gl.IMPLEMENTATION_COLOR_READ_TYPE) && // Edge and Chrome Mac < 52 (#9513)
    textureType !== FloatType$1 && !halfFloatSupportedByExt) {
      return false;
    }
    return true;
  }
  function getMaxPrecision(precision2) {
    if (precision2 === "highp") {
      if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT).precision > 0 && gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).precision > 0) {
        return "highp";
      }
      precision2 = "mediump";
    }
    if (precision2 === "mediump") {
      if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT).precision > 0 && gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).precision > 0) {
        return "mediump";
      }
    }
    return "lowp";
  }
  let precision = parameters.precision !== void 0 ? parameters.precision : "highp";
  const maxPrecision = getMaxPrecision(precision);
  if (maxPrecision !== precision) {
    console.warn("THREE.WebGLRenderer:", precision, "not supported, using", maxPrecision, "instead.");
    precision = maxPrecision;
  }
  const logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;
  const reverseDepthBuffer = parameters.reverseDepthBuffer === true && extensions.has("EXT_clip_control");
  const maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
  const maxVertexTextures = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
  const maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
  const maxCubemapSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);
  const maxAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
  const maxVertexUniforms = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);
  const maxVaryings = gl.getParameter(gl.MAX_VARYING_VECTORS);
  const maxFragmentUniforms = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);
  const vertexTextures = maxVertexTextures > 0;
  const maxSamples = gl.getParameter(gl.MAX_SAMPLES);
  return {
    isWebGL2: true,
    // keeping this for backwards compatibility
    getMaxAnisotropy,
    getMaxPrecision,
    textureFormatReadable,
    textureTypeReadable,
    precision,
    logarithmicDepthBuffer,
    reverseDepthBuffer,
    maxTextures,
    maxVertexTextures,
    maxTextureSize,
    maxCubemapSize,
    maxAttributes,
    maxVertexUniforms,
    maxVaryings,
    maxFragmentUniforms,
    vertexTextures,
    maxSamples
  };
}
function WebGLClipping(properties) {
  const scope = this;
  let globalState = null, numGlobalPlanes = 0, localClippingEnabled = false, renderingShadows = false;
  const plane = new Plane(), viewNormalMatrix = new Matrix3$1(), uniform2 = { value: null, needsUpdate: false };
  this.uniform = uniform2;
  this.numPlanes = 0;
  this.numIntersection = 0;
  this.init = function(planes, enableLocalClipping) {
    const enabled = planes.length !== 0 || enableLocalClipping || // enable state of previous frame - the clipping code has to
    // run another frame in order to reset the state:
    numGlobalPlanes !== 0 || localClippingEnabled;
    localClippingEnabled = enableLocalClipping;
    numGlobalPlanes = planes.length;
    return enabled;
  };
  this.beginShadows = function() {
    renderingShadows = true;
    projectPlanes(null);
  };
  this.endShadows = function() {
    renderingShadows = false;
  };
  this.setGlobalState = function(planes, camera) {
    globalState = projectPlanes(planes, camera, 0);
  };
  this.setState = function(material, camera, useCache) {
    const planes = material.clippingPlanes, clipIntersection = material.clipIntersection, clipShadows = material.clipShadows;
    const materialProperties = properties.get(material);
    if (!localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && !clipShadows) {
      if (renderingShadows) {
        projectPlanes(null);
      } else {
        resetGlobalState();
      }
    } else {
      const nGlobal = renderingShadows ? 0 : numGlobalPlanes, lGlobal = nGlobal * 4;
      let dstArray = materialProperties.clippingState || null;
      uniform2.value = dstArray;
      dstArray = projectPlanes(planes, camera, lGlobal, useCache);
      for (let i = 0; i !== lGlobal; ++i) {
        dstArray[i] = globalState[i];
      }
      materialProperties.clippingState = dstArray;
      this.numIntersection = clipIntersection ? this.numPlanes : 0;
      this.numPlanes += nGlobal;
    }
  };
  function resetGlobalState() {
    if (uniform2.value !== globalState) {
      uniform2.value = globalState;
      uniform2.needsUpdate = numGlobalPlanes > 0;
    }
    scope.numPlanes = numGlobalPlanes;
    scope.numIntersection = 0;
  }
  function projectPlanes(planes, camera, dstOffset, skipTransform) {
    const nPlanes = planes !== null ? planes.length : 0;
    let dstArray = null;
    if (nPlanes !== 0) {
      dstArray = uniform2.value;
      if (skipTransform !== true || dstArray === null) {
        const flatSize = dstOffset + nPlanes * 4, viewMatrix = camera.matrixWorldInverse;
        viewNormalMatrix.getNormalMatrix(viewMatrix);
        if (dstArray === null || dstArray.length < flatSize) {
          dstArray = new Float32Array(flatSize);
        }
        for (let i = 0, i4 = dstOffset; i !== nPlanes; ++i, i4 += 4) {
          plane.copy(planes[i]).applyMatrix4(viewMatrix, viewNormalMatrix);
          plane.normal.toArray(dstArray, i4);
          dstArray[i4 + 3] = plane.constant;
        }
      }
      uniform2.value = dstArray;
      uniform2.needsUpdate = true;
    }
    scope.numPlanes = nPlanes;
    scope.numIntersection = 0;
    return dstArray;
  }
}
function WebGLCubeMaps(renderer) {
  let cubemaps = /* @__PURE__ */ new WeakMap();
  function mapTextureMapping(texture, mapping) {
    if (mapping === EquirectangularReflectionMapping) {
      texture.mapping = CubeReflectionMapping;
    } else if (mapping === EquirectangularRefractionMapping) {
      texture.mapping = CubeRefractionMapping;
    }
    return texture;
  }
  function get(texture) {
    if (texture && texture.isTexture) {
      const mapping = texture.mapping;
      if (mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping) {
        if (cubemaps.has(texture)) {
          const cubemap = cubemaps.get(texture).texture;
          return mapTextureMapping(cubemap, texture.mapping);
        } else {
          const image = texture.image;
          if (image && image.height > 0) {
            const renderTarget = new WebGLCubeRenderTarget(image.height);
            renderTarget.fromEquirectangularTexture(renderer, texture);
            cubemaps.set(texture, renderTarget);
            texture.addEventListener("dispose", onTextureDispose);
            return mapTextureMapping(renderTarget.texture, texture.mapping);
          } else {
            return null;
          }
        }
      }
    }
    return texture;
  }
  function onTextureDispose(event) {
    const texture = event.target;
    texture.removeEventListener("dispose", onTextureDispose);
    const cubemap = cubemaps.get(texture);
    if (cubemap !== void 0) {
      cubemaps.delete(texture);
      cubemap.dispose();
    }
  }
  function dispose() {
    cubemaps = /* @__PURE__ */ new WeakMap();
  }
  return {
    get,
    dispose
  };
}
const LOD_MIN = 4;
const EXTRA_LOD_SIGMA = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582];
const MAX_SAMPLES = 20;
const _flatCamera = /* @__PURE__ */ new OrthographicCamera();
const _clearColor = /* @__PURE__ */ new Color$1();
let _oldTarget = null;
let _oldActiveCubeFace = 0;
let _oldActiveMipmapLevel = 0;
let _oldXrEnabled = false;
const PHI = (1 + Math.sqrt(5)) / 2;
const INV_PHI = 1 / PHI;
const _axisDirections = [
  /* @__PURE__ */ new Vector3$1(-PHI, INV_PHI, 0),
  /* @__PURE__ */ new Vector3$1(PHI, INV_PHI, 0),
  /* @__PURE__ */ new Vector3$1(-INV_PHI, 0, PHI),
  /* @__PURE__ */ new Vector3$1(INV_PHI, 0, PHI),
  /* @__PURE__ */ new Vector3$1(0, PHI, -INV_PHI),
  /* @__PURE__ */ new Vector3$1(0, PHI, INV_PHI),
  /* @__PURE__ */ new Vector3$1(-1, 1, -1),
  /* @__PURE__ */ new Vector3$1(1, 1, -1),
  /* @__PURE__ */ new Vector3$1(-1, 1, 1),
  /* @__PURE__ */ new Vector3$1(1, 1, 1)
];
class PMREMGenerator {
  constructor(renderer) {
    this._renderer = renderer;
    this._pingPongRenderTarget = null;
    this._lodMax = 0;
    this._cubeSize = 0;
    this._lodPlanes = [];
    this._sizeLods = [];
    this._sigmas = [];
    this._blurMaterial = null;
    this._cubemapMaterial = null;
    this._equirectMaterial = null;
    this._compileMaterial(this._blurMaterial);
  }
  /**
   * Generates a PMREM from a supplied Scene, which can be faster than using an
   * image if networking bandwidth is low. Optional sigma specifies a blur radius
   * in radians to be applied to the scene before PMREM generation. Optional near
   * and far planes ensure the scene is rendered in its entirety (the cubeCamera
   * is placed at the origin).
   *
   * @param {Scene} scene
   * @param {number} sigma
   * @param {number} near
   * @param {number} far
   * @return {WebGLRenderTarget}
   */
  fromScene(scene, sigma = 0, near = 0.1, far = 100) {
    _oldTarget = this._renderer.getRenderTarget();
    _oldActiveCubeFace = this._renderer.getActiveCubeFace();
    _oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel();
    _oldXrEnabled = this._renderer.xr.enabled;
    this._renderer.xr.enabled = false;
    this._setSize(256);
    const cubeUVRenderTarget = this._allocateTargets();
    cubeUVRenderTarget.depthBuffer = true;
    this._sceneToCubeUV(scene, near, far, cubeUVRenderTarget);
    if (sigma > 0) {
      this._blur(cubeUVRenderTarget, 0, 0, sigma);
    }
    this._applyPMREM(cubeUVRenderTarget);
    this._cleanup(cubeUVRenderTarget);
    return cubeUVRenderTarget;
  }
  /**
   * Generates a PMREM from an equirectangular texture, which can be either LDR
   * or HDR. The ideal input image size is 1k (1024 x 512),
   * as this matches best with the 256 x 256 cubemap output.
   * The smallest supported equirectangular image size is 64 x 32.
   *
   * @param {Texture} equirectangular
   * @param {WebGLRenderTarget} [renderTarget=null] - Optional render target.
   * @return {WebGLRenderTarget}
   */
  fromEquirectangular(equirectangular, renderTarget = null) {
    return this._fromTexture(equirectangular, renderTarget);
  }
  /**
   * Generates a PMREM from an cubemap texture, which can be either LDR
   * or HDR. The ideal input cube size is 256 x 256,
   * as this matches best with the 256 x 256 cubemap output.
   * The smallest supported cube size is 16 x 16.
   *
   * @param {Texture} cubemap
   * @param {null} [renderTarget=null] - Optional render target.
   * @return {WebGLRenderTarget}
   */
  fromCubemap(cubemap, renderTarget = null) {
    return this._fromTexture(cubemap, renderTarget);
  }
  /**
   * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   */
  compileCubemapShader() {
    if (this._cubemapMaterial === null) {
      this._cubemapMaterial = _getCubemapMaterial();
      this._compileMaterial(this._cubemapMaterial);
    }
  }
  /**
   * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   */
  compileEquirectangularShader() {
    if (this._equirectMaterial === null) {
      this._equirectMaterial = _getEquirectMaterial();
      this._compileMaterial(this._equirectMaterial);
    }
  }
  /**
   * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
   * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
   * one of them will cause any others to also become unusable.
   */
  dispose() {
    this._dispose();
    if (this._cubemapMaterial !== null) this._cubemapMaterial.dispose();
    if (this._equirectMaterial !== null) this._equirectMaterial.dispose();
  }
  // private interface
  _setSize(cubeSize) {
    this._lodMax = Math.floor(Math.log2(cubeSize));
    this._cubeSize = Math.pow(2, this._lodMax);
  }
  _dispose() {
    if (this._blurMaterial !== null) this._blurMaterial.dispose();
    if (this._pingPongRenderTarget !== null) this._pingPongRenderTarget.dispose();
    for (let i = 0; i < this._lodPlanes.length; i++) {
      this._lodPlanes[i].dispose();
    }
  }
  _cleanup(outputTarget) {
    this._renderer.setRenderTarget(_oldTarget, _oldActiveCubeFace, _oldActiveMipmapLevel);
    this._renderer.xr.enabled = _oldXrEnabled;
    outputTarget.scissorTest = false;
    _setViewport(outputTarget, 0, 0, outputTarget.width, outputTarget.height);
  }
  _fromTexture(texture, renderTarget) {
    if (texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping) {
      this._setSize(texture.image.length === 0 ? 16 : texture.image[0].width || texture.image[0].image.width);
    } else {
      this._setSize(texture.image.width / 4);
    }
    _oldTarget = this._renderer.getRenderTarget();
    _oldActiveCubeFace = this._renderer.getActiveCubeFace();
    _oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel();
    _oldXrEnabled = this._renderer.xr.enabled;
    this._renderer.xr.enabled = false;
    const cubeUVRenderTarget = renderTarget || this._allocateTargets();
    this._textureToCubeUV(texture, cubeUVRenderTarget);
    this._applyPMREM(cubeUVRenderTarget);
    this._cleanup(cubeUVRenderTarget);
    return cubeUVRenderTarget;
  }
  _allocateTargets() {
    const width = 3 * Math.max(this._cubeSize, 16 * 7);
    const height = 4 * this._cubeSize;
    const params = {
      magFilter: LinearFilter,
      minFilter: LinearFilter,
      generateMipmaps: false,
      type: HalfFloatType,
      format: RGBAFormat,
      colorSpace: LinearSRGBColorSpace$1,
      depthBuffer: false
    };
    const cubeUVRenderTarget = _createRenderTarget(width, height, params);
    if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== width || this._pingPongRenderTarget.height !== height) {
      if (this._pingPongRenderTarget !== null) {
        this._dispose();
      }
      this._pingPongRenderTarget = _createRenderTarget(width, height, params);
      const { _lodMax } = this;
      ({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = _createPlanes(_lodMax));
      this._blurMaterial = _getBlurShader(_lodMax, width, height);
    }
    return cubeUVRenderTarget;
  }
  _compileMaterial(material) {
    const tmpMesh = new Mesh(this._lodPlanes[0], material);
    this._renderer.compile(tmpMesh, _flatCamera);
  }
  _sceneToCubeUV(scene, near, far, cubeUVRenderTarget) {
    const fov2 = 90;
    const aspect2 = 1;
    const cubeCamera = new PerspectiveCamera(fov2, aspect2, near, far);
    const upSign = [1, -1, 1, 1, 1, 1];
    const forwardSign = [1, 1, 1, -1, -1, -1];
    const renderer = this._renderer;
    const originalAutoClear = renderer.autoClear;
    const toneMapping2 = renderer.toneMapping;
    renderer.getClearColor(_clearColor);
    renderer.toneMapping = NoToneMapping$1;
    renderer.autoClear = false;
    const backgroundMaterial = new MeshBasicMaterial({
      name: "PMREM.Background",
      side: BackSide,
      depthWrite: false,
      depthTest: false
    });
    const backgroundBox = new Mesh(new BoxGeometry(), backgroundMaterial);
    let useSolidColor = false;
    const background = scene.background;
    if (background) {
      if (background.isColor) {
        backgroundMaterial.color.copy(background);
        scene.background = null;
        useSolidColor = true;
      }
    } else {
      backgroundMaterial.color.copy(_clearColor);
      useSolidColor = true;
    }
    for (let i = 0; i < 6; i++) {
      const col = i % 3;
      if (col === 0) {
        cubeCamera.up.set(0, upSign[i], 0);
        cubeCamera.lookAt(forwardSign[i], 0, 0);
      } else if (col === 1) {
        cubeCamera.up.set(0, 0, upSign[i]);
        cubeCamera.lookAt(0, forwardSign[i], 0);
      } else {
        cubeCamera.up.set(0, upSign[i], 0);
        cubeCamera.lookAt(0, 0, forwardSign[i]);
      }
      const size = this._cubeSize;
      _setViewport(cubeUVRenderTarget, col * size, i > 2 ? size : 0, size, size);
      renderer.setRenderTarget(cubeUVRenderTarget);
      if (useSolidColor) {
        renderer.render(backgroundBox, cubeCamera);
      }
      renderer.render(scene, cubeCamera);
    }
    backgroundBox.geometry.dispose();
    backgroundBox.material.dispose();
    renderer.toneMapping = toneMapping2;
    renderer.autoClear = originalAutoClear;
    scene.background = background;
  }
  _textureToCubeUV(texture, cubeUVRenderTarget) {
    const renderer = this._renderer;
    const isCubeTexture = texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping;
    if (isCubeTexture) {
      if (this._cubemapMaterial === null) {
        this._cubemapMaterial = _getCubemapMaterial();
      }
      this._cubemapMaterial.uniforms.flipEnvMap.value = texture.isRenderTargetTexture === false ? -1 : 1;
    } else {
      if (this._equirectMaterial === null) {
        this._equirectMaterial = _getEquirectMaterial();
      }
    }
    const material = isCubeTexture ? this._cubemapMaterial : this._equirectMaterial;
    const mesh = new Mesh(this._lodPlanes[0], material);
    const uniforms = material.uniforms;
    uniforms["envMap"].value = texture;
    const size = this._cubeSize;
    _setViewport(cubeUVRenderTarget, 0, 0, 3 * size, 2 * size);
    renderer.setRenderTarget(cubeUVRenderTarget);
    renderer.render(mesh, _flatCamera);
  }
  _applyPMREM(cubeUVRenderTarget) {
    const renderer = this._renderer;
    const autoClear = renderer.autoClear;
    renderer.autoClear = false;
    const n = this._lodPlanes.length;
    for (let i = 1; i < n; i++) {
      const sigma = Math.sqrt(this._sigmas[i] * this._sigmas[i] - this._sigmas[i - 1] * this._sigmas[i - 1]);
      const poleAxis = _axisDirections[(n - i - 1) % _axisDirections.length];
      this._blur(cubeUVRenderTarget, i - 1, i, sigma, poleAxis);
    }
    renderer.autoClear = autoClear;
  }
  /**
   * This is a two-pass Gaussian blur for a cubemap. Normally this is done
   * vertically and horizontally, but this breaks down on a cube. Here we apply
   * the blur latitudinally (around the poles), and then longitudinally (towards
   * the poles) to approximate the orthogonally-separable blur. It is least
   * accurate at the poles, but still does a decent job.
   *
   * @param {WebGLRenderTarget} cubeUVRenderTarget
   * @param {number} lodIn
   * @param {number} lodOut
   * @param {number} sigma
   * @param {Vector3} [poleAxis]
   */
  _blur(cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis) {
    const pingPongRenderTarget = this._pingPongRenderTarget;
    this._halfBlur(
      cubeUVRenderTarget,
      pingPongRenderTarget,
      lodIn,
      lodOut,
      sigma,
      "latitudinal",
      poleAxis
    );
    this._halfBlur(
      pingPongRenderTarget,
      cubeUVRenderTarget,
      lodOut,
      lodOut,
      sigma,
      "longitudinal",
      poleAxis
    );
  }
  _halfBlur(targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis) {
    const renderer = this._renderer;
    const blurMaterial = this._blurMaterial;
    if (direction !== "latitudinal" && direction !== "longitudinal") {
      console.error(
        "blur direction must be either latitudinal or longitudinal!"
      );
    }
    const STANDARD_DEVIATIONS = 3;
    const blurMesh = new Mesh(this._lodPlanes[lodOut], blurMaterial);
    const blurUniforms = blurMaterial.uniforms;
    const pixels = this._sizeLods[lodIn] - 1;
    const radiansPerPixel = isFinite(sigmaRadians) ? Math.PI / (2 * pixels) : 2 * Math.PI / (2 * MAX_SAMPLES - 1);
    const sigmaPixels = sigmaRadians / radiansPerPixel;
    const samples = isFinite(sigmaRadians) ? 1 + Math.floor(STANDARD_DEVIATIONS * sigmaPixels) : MAX_SAMPLES;
    if (samples > MAX_SAMPLES) {
      console.warn(`sigmaRadians, ${sigmaRadians}, is too large and will clip, as it requested ${samples} samples when the maximum is set to ${MAX_SAMPLES}`);
    }
    const weights = [];
    let sum = 0;
    for (let i = 0; i < MAX_SAMPLES; ++i) {
      const x2 = i / sigmaPixels;
      const weight = Math.exp(-x2 * x2 / 2);
      weights.push(weight);
      if (i === 0) {
        sum += weight;
      } else if (i < samples) {
        sum += 2 * weight;
      }
    }
    for (let i = 0; i < weights.length; i++) {
      weights[i] = weights[i] / sum;
    }
    blurUniforms["envMap"].value = targetIn.texture;
    blurUniforms["samples"].value = samples;
    blurUniforms["weights"].value = weights;
    blurUniforms["latitudinal"].value = direction === "latitudinal";
    if (poleAxis) {
      blurUniforms["poleAxis"].value = poleAxis;
    }
    const { _lodMax } = this;
    blurUniforms["dTheta"].value = radiansPerPixel;
    blurUniforms["mipInt"].value = _lodMax - lodIn;
    const outputSize = this._sizeLods[lodOut];
    const x = 3 * outputSize * (lodOut > _lodMax - LOD_MIN ? lodOut - _lodMax + LOD_MIN : 0);
    const y = 4 * (this._cubeSize - outputSize);
    _setViewport(targetOut, x, y, 3 * outputSize, 2 * outputSize);
    renderer.setRenderTarget(targetOut);
    renderer.render(blurMesh, _flatCamera);
  }
}
function _createPlanes(lodMax) {
  const lodPlanes = [];
  const sizeLods = [];
  const sigmas = [];
  let lod = lodMax;
  const totalLods = lodMax - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;
  for (let i = 0; i < totalLods; i++) {
    const sizeLod = Math.pow(2, lod);
    sizeLods.push(sizeLod);
    let sigma = 1 / sizeLod;
    if (i > lodMax - LOD_MIN) {
      sigma = EXTRA_LOD_SIGMA[i - lodMax + LOD_MIN - 1];
    } else if (i === 0) {
      sigma = 0;
    }
    sigmas.push(sigma);
    const texelSize = 1 / (sizeLod - 2);
    const min2 = -texelSize;
    const max2 = 1 + texelSize;
    const uv1 = [min2, min2, max2, min2, max2, max2, min2, min2, max2, max2, min2, max2];
    const cubeFaces = 6;
    const vertices = 6;
    const positionSize = 3;
    const uvSize = 2;
    const faceIndexSize = 1;
    const position = new Float32Array(positionSize * vertices * cubeFaces);
    const uv = new Float32Array(uvSize * vertices * cubeFaces);
    const faceIndex = new Float32Array(faceIndexSize * vertices * cubeFaces);
    for (let face = 0; face < cubeFaces; face++) {
      const x = face % 3 * 2 / 3 - 1;
      const y = face > 2 ? 0 : -1;
      const coordinates = [
        x,
        y,
        0,
        x + 2 / 3,
        y,
        0,
        x + 2 / 3,
        y + 1,
        0,
        x,
        y,
        0,
        x + 2 / 3,
        y + 1,
        0,
        x,
        y + 1,
        0
      ];
      position.set(coordinates, positionSize * vertices * face);
      uv.set(uv1, uvSize * vertices * face);
      const fill2 = [face, face, face, face, face, face];
      faceIndex.set(fill2, faceIndexSize * vertices * face);
    }
    const planes = new BufferGeometry();
    planes.setAttribute("position", new BufferAttribute$1(position, positionSize));
    planes.setAttribute("uv", new BufferAttribute$1(uv, uvSize));
    planes.setAttribute("faceIndex", new BufferAttribute$1(faceIndex, faceIndexSize));
    lodPlanes.push(planes);
    if (lod > LOD_MIN) {
      lod--;
    }
  }
  return { lodPlanes, sizeLods, sigmas };
}
function _createRenderTarget(width, height, params) {
  const cubeUVRenderTarget = new WebGLRenderTarget(width, height, params);
  cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;
  cubeUVRenderTarget.texture.name = "PMREM.cubeUv";
  cubeUVRenderTarget.scissorTest = true;
  return cubeUVRenderTarget;
}
function _setViewport(target, x, y, width, height) {
  target.viewport.set(x, y, width, height);
  target.scissor.set(x, y, width, height);
}
function _getBlurShader(lodMax, width, height) {
  const weights = new Float32Array(MAX_SAMPLES);
  const poleAxis = new Vector3$1(0, 1, 0);
  const shaderMaterial = new ShaderMaterial({
    name: "SphericalGaussianBlur",
    defines: {
      "n": MAX_SAMPLES,
      "CUBEUV_TEXEL_WIDTH": 1 / width,
      "CUBEUV_TEXEL_HEIGHT": 1 / height,
      "CUBEUV_MAX_MIP": `${lodMax}.0`
    },
    uniforms: {
      "envMap": { value: null },
      "samples": { value: 1 },
      "weights": { value: weights },
      "latitudinal": { value: false },
      "dTheta": { value: 0 },
      "mipInt": { value: 0 },
      "poleAxis": { value: poleAxis }
    },
    vertexShader: _getCommonVertexShader(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`
    ),
    blending: NoBlending,
    depthTest: false,
    depthWrite: false
  });
  return shaderMaterial;
}
function _getEquirectMaterial() {
  return new ShaderMaterial({
    name: "EquirectangularToCubeUV",
    uniforms: {
      "envMap": { value: null }
    },
    vertexShader: _getCommonVertexShader(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`
    ),
    blending: NoBlending,
    depthTest: false,
    depthWrite: false
  });
}
function _getCubemapMaterial() {
  return new ShaderMaterial({
    name: "CubemapToCubeUV",
    uniforms: {
      "envMap": { value: null },
      "flipEnvMap": { value: -1 }
    },
    vertexShader: _getCommonVertexShader(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`
    ),
    blending: NoBlending,
    depthTest: false,
    depthWrite: false
  });
}
function _getCommonVertexShader() {
  return (
    /* glsl */
    `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
  );
}
function WebGLCubeUVMaps(renderer) {
  let cubeUVmaps = /* @__PURE__ */ new WeakMap();
  let pmremGenerator = null;
  function get(texture) {
    if (texture && texture.isTexture) {
      const mapping = texture.mapping;
      const isEquirectMap = mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping;
      const isCubeMap = mapping === CubeReflectionMapping || mapping === CubeRefractionMapping;
      if (isEquirectMap || isCubeMap) {
        let renderTarget = cubeUVmaps.get(texture);
        const currentPMREMVersion = renderTarget !== void 0 ? renderTarget.texture.pmremVersion : 0;
        if (texture.isRenderTargetTexture && texture.pmremVersion !== currentPMREMVersion) {
          if (pmremGenerator === null) pmremGenerator = new PMREMGenerator(renderer);
          renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular(texture, renderTarget) : pmremGenerator.fromCubemap(texture, renderTarget);
          renderTarget.texture.pmremVersion = texture.pmremVersion;
          cubeUVmaps.set(texture, renderTarget);
          return renderTarget.texture;
        } else {
          if (renderTarget !== void 0) {
            return renderTarget.texture;
          } else {
            const image = texture.image;
            if (isEquirectMap && image && image.height > 0 || isCubeMap && image && isCubeTextureComplete(image)) {
              if (pmremGenerator === null) pmremGenerator = new PMREMGenerator(renderer);
              renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular(texture) : pmremGenerator.fromCubemap(texture);
              renderTarget.texture.pmremVersion = texture.pmremVersion;
              cubeUVmaps.set(texture, renderTarget);
              texture.addEventListener("dispose", onTextureDispose);
              return renderTarget.texture;
            } else {
              return null;
            }
          }
        }
      }
    }
    return texture;
  }
  function isCubeTextureComplete(image) {
    let count = 0;
    const length2 = 6;
    for (let i = 0; i < length2; i++) {
      if (image[i] !== void 0) count++;
    }
    return count === length2;
  }
  function onTextureDispose(event) {
    const texture = event.target;
    texture.removeEventListener("dispose", onTextureDispose);
    const cubemapUV = cubeUVmaps.get(texture);
    if (cubemapUV !== void 0) {
      cubeUVmaps.delete(texture);
      cubemapUV.dispose();
    }
  }
  function dispose() {
    cubeUVmaps = /* @__PURE__ */ new WeakMap();
    if (pmremGenerator !== null) {
      pmremGenerator.dispose();
      pmremGenerator = null;
    }
  }
  return {
    get,
    dispose
  };
}
function WebGLExtensions(gl) {
  const extensions = {};
  function getExtension(name) {
    if (extensions[name] !== void 0) {
      return extensions[name];
    }
    let extension;
    switch (name) {
      case "WEBGL_depth_texture":
        extension = gl.getExtension("WEBGL_depth_texture") || gl.getExtension("MOZ_WEBGL_depth_texture") || gl.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        extension = gl.getExtension("EXT_texture_filter_anisotropic") || gl.getExtension("MOZ_EXT_texture_filter_anisotropic") || gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        extension = gl.getExtension("WEBGL_compressed_texture_s3tc") || gl.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        extension = gl.getExtension("WEBGL_compressed_texture_pvrtc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        extension = gl.getExtension(name);
    }
    extensions[name] = extension;
    return extension;
  }
  return {
    has: function(name) {
      return getExtension(name) !== null;
    },
    init: function() {
      getExtension("EXT_color_buffer_float");
      getExtension("WEBGL_clip_cull_distance");
      getExtension("OES_texture_float_linear");
      getExtension("EXT_color_buffer_half_float");
      getExtension("WEBGL_multisampled_render_to_texture");
      getExtension("WEBGL_render_shared_exponent");
    },
    get: function(name) {
      const extension = getExtension(name);
      if (extension === null) {
        warnOnce("THREE.WebGLRenderer: " + name + " extension not supported.");
      }
      return extension;
    }
  };
}
function WebGLGeometries(gl, attributes, info, bindingStates) {
  const geometries = {};
  const wireframeAttributes = /* @__PURE__ */ new WeakMap();
  function onGeometryDispose(event) {
    const geometry = event.target;
    if (geometry.index !== null) {
      attributes.remove(geometry.index);
    }
    for (const name in geometry.attributes) {
      attributes.remove(geometry.attributes[name]);
    }
    geometry.removeEventListener("dispose", onGeometryDispose);
    delete geometries[geometry.id];
    const attribute = wireframeAttributes.get(geometry);
    if (attribute) {
      attributes.remove(attribute);
      wireframeAttributes.delete(geometry);
    }
    bindingStates.releaseStatesOfGeometry(geometry);
    if (geometry.isInstancedBufferGeometry === true) {
      delete geometry._maxInstanceCount;
    }
    info.memory.geometries--;
  }
  function get(object, geometry) {
    if (geometries[geometry.id] === true) return geometry;
    geometry.addEventListener("dispose", onGeometryDispose);
    geometries[geometry.id] = true;
    info.memory.geometries++;
    return geometry;
  }
  function update(geometry) {
    const geometryAttributes = geometry.attributes;
    for (const name in geometryAttributes) {
      attributes.update(geometryAttributes[name], gl.ARRAY_BUFFER);
    }
  }
  function updateWireframeAttribute(geometry) {
    const indices = [];
    const geometryIndex = geometry.index;
    const geometryPosition = geometry.attributes.position;
    let version = 0;
    if (geometryIndex !== null) {
      const array = geometryIndex.array;
      version = geometryIndex.version;
      for (let i = 0, l = array.length; i < l; i += 3) {
        const a = array[i + 0];
        const b = array[i + 1];
        const c = array[i + 2];
        indices.push(a, b, b, c, c, a);
      }
    } else if (geometryPosition !== void 0) {
      const array = geometryPosition.array;
      version = geometryPosition.version;
      for (let i = 0, l = array.length / 3 - 1; i < l; i += 3) {
        const a = i + 0;
        const b = i + 1;
        const c = i + 2;
        indices.push(a, b, b, c, c, a);
      }
    } else {
      return;
    }
    const attribute = new (arrayNeedsUint32(indices) ? Uint32BufferAttribute : Uint16BufferAttribute)(indices, 1);
    attribute.version = version;
    const previousAttribute = wireframeAttributes.get(geometry);
    if (previousAttribute) attributes.remove(previousAttribute);
    wireframeAttributes.set(geometry, attribute);
  }
  function getWireframeAttribute(geometry) {
    const currentAttribute = wireframeAttributes.get(geometry);
    if (currentAttribute) {
      const geometryIndex = geometry.index;
      if (geometryIndex !== null) {
        if (currentAttribute.version < geometryIndex.version) {
          updateWireframeAttribute(geometry);
        }
      }
    } else {
      updateWireframeAttribute(geometry);
    }
    return wireframeAttributes.get(geometry);
  }
  return {
    get,
    update,
    getWireframeAttribute
  };
}
function WebGLIndexedBufferRenderer(gl, extensions, info) {
  let mode;
  function setMode(value) {
    mode = value;
  }
  let type, bytesPerElement;
  function setIndex(value) {
    type = value.type;
    bytesPerElement = value.bytesPerElement;
  }
  function render(start, count) {
    gl.drawElements(mode, count, type, start * bytesPerElement);
    info.update(count, mode, 1);
  }
  function renderInstances(start, count, primcount) {
    if (primcount === 0) return;
    gl.drawElementsInstanced(mode, count, type, start * bytesPerElement, primcount);
    info.update(count, mode, primcount);
  }
  function renderMultiDraw(starts, counts, drawCount) {
    if (drawCount === 0) return;
    const extension = extensions.get("WEBGL_multi_draw");
    extension.multiDrawElementsWEBGL(mode, counts, 0, type, starts, 0, drawCount);
    let elementCount = 0;
    for (let i = 0; i < drawCount; i++) {
      elementCount += counts[i];
    }
    info.update(elementCount, mode, 1);
  }
  function renderMultiDrawInstances(starts, counts, drawCount, primcount) {
    if (drawCount === 0) return;
    const extension = extensions.get("WEBGL_multi_draw");
    if (extension === null) {
      for (let i = 0; i < starts.length; i++) {
        renderInstances(starts[i] / bytesPerElement, counts[i], primcount[i]);
      }
    } else {
      extension.multiDrawElementsInstancedWEBGL(mode, counts, 0, type, starts, 0, primcount, 0, drawCount);
      let elementCount = 0;
      for (let i = 0; i < drawCount; i++) {
        elementCount += counts[i] * primcount[i];
      }
      info.update(elementCount, mode, 1);
    }
  }
  this.setMode = setMode;
  this.setIndex = setIndex;
  this.render = render;
  this.renderInstances = renderInstances;
  this.renderMultiDraw = renderMultiDraw;
  this.renderMultiDrawInstances = renderMultiDrawInstances;
}
function WebGLInfo(gl) {
  const memory = {
    geometries: 0,
    textures: 0
  };
  const render = {
    frame: 0,
    calls: 0,
    triangles: 0,
    points: 0,
    lines: 0
  };
  function update(count, mode, instanceCount) {
    render.calls++;
    switch (mode) {
      case gl.TRIANGLES:
        render.triangles += instanceCount * (count / 3);
        break;
      case gl.LINES:
        render.lines += instanceCount * (count / 2);
        break;
      case gl.LINE_STRIP:
        render.lines += instanceCount * (count - 1);
        break;
      case gl.LINE_LOOP:
        render.lines += instanceCount * count;
        break;
      case gl.POINTS:
        render.points += instanceCount * count;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", mode);
        break;
    }
  }
  function reset() {
    render.calls = 0;
    render.triangles = 0;
    render.points = 0;
    render.lines = 0;
  }
  return {
    memory,
    render,
    programs: null,
    autoReset: true,
    reset,
    update
  };
}
function WebGLMorphtargets(gl, capabilities, textures) {
  const morphTextures = /* @__PURE__ */ new WeakMap();
  const morph = new Vector4$1();
  function update(object, geometry, program) {
    const objectInfluences = object.morphTargetInfluences;
    const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
    const morphTargetsCount = morphAttribute !== void 0 ? morphAttribute.length : 0;
    let entry = morphTextures.get(geometry);
    if (entry === void 0 || entry.count !== morphTargetsCount) {
      let disposeTexture = function() {
        texture.dispose();
        morphTextures.delete(geometry);
        geometry.removeEventListener("dispose", disposeTexture);
      };
      if (entry !== void 0) entry.texture.dispose();
      const hasMorphPosition = geometry.morphAttributes.position !== void 0;
      const hasMorphNormals = geometry.morphAttributes.normal !== void 0;
      const hasMorphColors = geometry.morphAttributes.color !== void 0;
      const morphTargets = geometry.morphAttributes.position || [];
      const morphNormals = geometry.morphAttributes.normal || [];
      const morphColors = geometry.morphAttributes.color || [];
      let vertexDataCount = 0;
      if (hasMorphPosition === true) vertexDataCount = 1;
      if (hasMorphNormals === true) vertexDataCount = 2;
      if (hasMorphColors === true) vertexDataCount = 3;
      let width = geometry.attributes.position.count * vertexDataCount;
      let height = 1;
      if (width > capabilities.maxTextureSize) {
        height = Math.ceil(width / capabilities.maxTextureSize);
        width = capabilities.maxTextureSize;
      }
      const buffer = new Float32Array(width * height * 4 * morphTargetsCount);
      const texture = new DataArrayTexture(buffer, width, height, morphTargetsCount);
      texture.type = FloatType$1;
      texture.needsUpdate = true;
      const vertexDataStride = vertexDataCount * 4;
      for (let i = 0; i < morphTargetsCount; i++) {
        const morphTarget = morphTargets[i];
        const morphNormal = morphNormals[i];
        const morphColor = morphColors[i];
        const offset = width * height * 4 * i;
        for (let j = 0; j < morphTarget.count; j++) {
          const stride = j * vertexDataStride;
          if (hasMorphPosition === true) {
            morph.fromBufferAttribute(morphTarget, j);
            buffer[offset + stride + 0] = morph.x;
            buffer[offset + stride + 1] = morph.y;
            buffer[offset + stride + 2] = morph.z;
            buffer[offset + stride + 3] = 0;
          }
          if (hasMorphNormals === true) {
            morph.fromBufferAttribute(morphNormal, j);
            buffer[offset + stride + 4] = morph.x;
            buffer[offset + stride + 5] = morph.y;
            buffer[offset + stride + 6] = morph.z;
            buffer[offset + stride + 7] = 0;
          }
          if (hasMorphColors === true) {
            morph.fromBufferAttribute(morphColor, j);
            buffer[offset + stride + 8] = morph.x;
            buffer[offset + stride + 9] = morph.y;
            buffer[offset + stride + 10] = morph.z;
            buffer[offset + stride + 11] = morphColor.itemSize === 4 ? morph.w : 1;
          }
        }
      }
      entry = {
        count: morphTargetsCount,
        texture,
        size: new Vector2$1(width, height)
      };
      morphTextures.set(geometry, entry);
      geometry.addEventListener("dispose", disposeTexture);
    }
    if (object.isInstancedMesh === true && object.morphTexture !== null) {
      program.getUniforms().setValue(gl, "morphTexture", object.morphTexture, textures);
    } else {
      let morphInfluencesSum = 0;
      for (let i = 0; i < objectInfluences.length; i++) {
        morphInfluencesSum += objectInfluences[i];
      }
      const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
      program.getUniforms().setValue(gl, "morphTargetBaseInfluence", morphBaseInfluence);
      program.getUniforms().setValue(gl, "morphTargetInfluences", objectInfluences);
    }
    program.getUniforms().setValue(gl, "morphTargetsTexture", entry.texture, textures);
    program.getUniforms().setValue(gl, "morphTargetsTextureSize", entry.size);
  }
  return {
    update
  };
}
function WebGLObjects(gl, geometries, attributes, info) {
  let updateMap = /* @__PURE__ */ new WeakMap();
  function update(object) {
    const frame = info.render.frame;
    const geometry = object.geometry;
    const buffergeometry = geometries.get(object, geometry);
    if (updateMap.get(buffergeometry) !== frame) {
      geometries.update(buffergeometry);
      updateMap.set(buffergeometry, frame);
    }
    if (object.isInstancedMesh) {
      if (object.hasEventListener("dispose", onInstancedMeshDispose) === false) {
        object.addEventListener("dispose", onInstancedMeshDispose);
      }
      if (updateMap.get(object) !== frame) {
        attributes.update(object.instanceMatrix, gl.ARRAY_BUFFER);
        if (object.instanceColor !== null) {
          attributes.update(object.instanceColor, gl.ARRAY_BUFFER);
        }
        updateMap.set(object, frame);
      }
    }
    if (object.isSkinnedMesh) {
      const skeleton = object.skeleton;
      if (updateMap.get(skeleton) !== frame) {
        skeleton.update();
        updateMap.set(skeleton, frame);
      }
    }
    return buffergeometry;
  }
  function dispose() {
    updateMap = /* @__PURE__ */ new WeakMap();
  }
  function onInstancedMeshDispose(event) {
    const instancedMesh = event.target;
    instancedMesh.removeEventListener("dispose", onInstancedMeshDispose);
    attributes.remove(instancedMesh.instanceMatrix);
    if (instancedMesh.instanceColor !== null) attributes.remove(instancedMesh.instanceColor);
  }
  return {
    update,
    dispose
  };
}
const emptyTexture = /* @__PURE__ */ new Texture();
const emptyShadowTexture = /* @__PURE__ */ new DepthTexture(1, 1);
const emptyArrayTexture = /* @__PURE__ */ new DataArrayTexture();
const empty3dTexture = /* @__PURE__ */ new Data3DTexture();
const emptyCubeTexture = /* @__PURE__ */ new CubeTexture();
const arrayCacheF32 = [];
const arrayCacheI32 = [];
const mat4array = new Float32Array(16);
const mat3array = new Float32Array(9);
const mat2array = new Float32Array(4);
function flatten(array, nBlocks, blockSize) {
  const firstElem = array[0];
  if (firstElem <= 0 || firstElem > 0) return array;
  const n = nBlocks * blockSize;
  let r = arrayCacheF32[n];
  if (r === void 0) {
    r = new Float32Array(n);
    arrayCacheF32[n] = r;
  }
  if (nBlocks !== 0) {
    firstElem.toArray(r, 0);
    for (let i = 1, offset = 0; i !== nBlocks; ++i) {
      offset += blockSize;
      array[i].toArray(r, offset);
    }
  }
  return r;
}
function arraysEqual(a, b) {
  if (a.length !== b.length) return false;
  for (let i = 0, l = a.length; i < l; i++) {
    if (a[i] !== b[i]) return false;
  }
  return true;
}
function copyArray(a, b) {
  for (let i = 0, l = b.length; i < l; i++) {
    a[i] = b[i];
  }
}
function allocTexUnits(textures, n) {
  let r = arrayCacheI32[n];
  if (r === void 0) {
    r = new Int32Array(n);
    arrayCacheI32[n] = r;
  }
  for (let i = 0; i !== n; ++i) {
    r[i] = textures.allocateTextureUnit();
  }
  return r;
}
function setValueV1f(gl, v) {
  const cache2 = this.cache;
  if (cache2[0] === v) return;
  gl.uniform1f(this.addr, v);
  cache2[0] = v;
}
function setValueV2f(gl, v) {
  const cache2 = this.cache;
  if (v.x !== void 0) {
    if (cache2[0] !== v.x || cache2[1] !== v.y) {
      gl.uniform2f(this.addr, v.x, v.y);
      cache2[0] = v.x;
      cache2[1] = v.y;
    }
  } else {
    if (arraysEqual(cache2, v)) return;
    gl.uniform2fv(this.addr, v);
    copyArray(cache2, v);
  }
}
function setValueV3f(gl, v) {
  const cache2 = this.cache;
  if (v.x !== void 0) {
    if (cache2[0] !== v.x || cache2[1] !== v.y || cache2[2] !== v.z) {
      gl.uniform3f(this.addr, v.x, v.y, v.z);
      cache2[0] = v.x;
      cache2[1] = v.y;
      cache2[2] = v.z;
    }
  } else if (v.r !== void 0) {
    if (cache2[0] !== v.r || cache2[1] !== v.g || cache2[2] !== v.b) {
      gl.uniform3f(this.addr, v.r, v.g, v.b);
      cache2[0] = v.r;
      cache2[1] = v.g;
      cache2[2] = v.b;
    }
  } else {
    if (arraysEqual(cache2, v)) return;
    gl.uniform3fv(this.addr, v);
    copyArray(cache2, v);
  }
}
function setValueV4f(gl, v) {
  const cache2 = this.cache;
  if (v.x !== void 0) {
    if (cache2[0] !== v.x || cache2[1] !== v.y || cache2[2] !== v.z || cache2[3] !== v.w) {
      gl.uniform4f(this.addr, v.x, v.y, v.z, v.w);
      cache2[0] = v.x;
      cache2[1] = v.y;
      cache2[2] = v.z;
      cache2[3] = v.w;
    }
  } else {
    if (arraysEqual(cache2, v)) return;
    gl.uniform4fv(this.addr, v);
    copyArray(cache2, v);
  }
}
function setValueM2(gl, v) {
  const cache2 = this.cache;
  const elements = v.elements;
  if (elements === void 0) {
    if (arraysEqual(cache2, v)) return;
    gl.uniformMatrix2fv(this.addr, false, v);
    copyArray(cache2, v);
  } else {
    if (arraysEqual(cache2, elements)) return;
    mat2array.set(elements);
    gl.uniformMatrix2fv(this.addr, false, mat2array);
    copyArray(cache2, elements);
  }
}
function setValueM3(gl, v) {
  const cache2 = this.cache;
  const elements = v.elements;
  if (elements === void 0) {
    if (arraysEqual(cache2, v)) return;
    gl.uniformMatrix3fv(this.addr, false, v);
    copyArray(cache2, v);
  } else {
    if (arraysEqual(cache2, elements)) return;
    mat3array.set(elements);
    gl.uniformMatrix3fv(this.addr, false, mat3array);
    copyArray(cache2, elements);
  }
}
function setValueM4(gl, v) {
  const cache2 = this.cache;
  const elements = v.elements;
  if (elements === void 0) {
    if (arraysEqual(cache2, v)) return;
    gl.uniformMatrix4fv(this.addr, false, v);
    copyArray(cache2, v);
  } else {
    if (arraysEqual(cache2, elements)) return;
    mat4array.set(elements);
    gl.uniformMatrix4fv(this.addr, false, mat4array);
    copyArray(cache2, elements);
  }
}
function setValueV1i(gl, v) {
  const cache2 = this.cache;
  if (cache2[0] === v) return;
  gl.uniform1i(this.addr, v);
  cache2[0] = v;
}
function setValueV2i(gl, v) {
  const cache2 = this.cache;
  if (v.x !== void 0) {
    if (cache2[0] !== v.x || cache2[1] !== v.y) {
      gl.uniform2i(this.addr, v.x, v.y);
      cache2[0] = v.x;
      cache2[1] = v.y;
    }
  } else {
    if (arraysEqual(cache2, v)) return;
    gl.uniform2iv(this.addr, v);
    copyArray(cache2, v);
  }
}
function setValueV3i(gl, v) {
  const cache2 = this.cache;
  if (v.x !== void 0) {
    if (cache2[0] !== v.x || cache2[1] !== v.y || cache2[2] !== v.z) {
      gl.uniform3i(this.addr, v.x, v.y, v.z);
      cache2[0] = v.x;
      cache2[1] = v.y;
      cache2[2] = v.z;
    }
  } else {
    if (arraysEqual(cache2, v)) return;
    gl.uniform3iv(this.addr, v);
    copyArray(cache2, v);
  }
}
function setValueV4i(gl, v) {
  const cache2 = this.cache;
  if (v.x !== void 0) {
    if (cache2[0] !== v.x || cache2[1] !== v.y || cache2[2] !== v.z || cache2[3] !== v.w) {
      gl.uniform4i(this.addr, v.x, v.y, v.z, v.w);
      cache2[0] = v.x;
      cache2[1] = v.y;
      cache2[2] = v.z;
      cache2[3] = v.w;
    }
  } else {
    if (arraysEqual(cache2, v)) return;
    gl.uniform4iv(this.addr, v);
    copyArray(cache2, v);
  }
}
function setValueV1ui(gl, v) {
  const cache2 = this.cache;
  if (cache2[0] === v) return;
  gl.uniform1ui(this.addr, v);
  cache2[0] = v;
}
function setValueV2ui(gl, v) {
  const cache2 = this.cache;
  if (v.x !== void 0) {
    if (cache2[0] !== v.x || cache2[1] !== v.y) {
      gl.uniform2ui(this.addr, v.x, v.y);
      cache2[0] = v.x;
      cache2[1] = v.y;
    }
  } else {
    if (arraysEqual(cache2, v)) return;
    gl.uniform2uiv(this.addr, v);
    copyArray(cache2, v);
  }
}
function setValueV3ui(gl, v) {
  const cache2 = this.cache;
  if (v.x !== void 0) {
    if (cache2[0] !== v.x || cache2[1] !== v.y || cache2[2] !== v.z) {
      gl.uniform3ui(this.addr, v.x, v.y, v.z);
      cache2[0] = v.x;
      cache2[1] = v.y;
      cache2[2] = v.z;
    }
  } else {
    if (arraysEqual(cache2, v)) return;
    gl.uniform3uiv(this.addr, v);
    copyArray(cache2, v);
  }
}
function setValueV4ui(gl, v) {
  const cache2 = this.cache;
  if (v.x !== void 0) {
    if (cache2[0] !== v.x || cache2[1] !== v.y || cache2[2] !== v.z || cache2[3] !== v.w) {
      gl.uniform4ui(this.addr, v.x, v.y, v.z, v.w);
      cache2[0] = v.x;
      cache2[1] = v.y;
      cache2[2] = v.z;
      cache2[3] = v.w;
    }
  } else {
    if (arraysEqual(cache2, v)) return;
    gl.uniform4uiv(this.addr, v);
    copyArray(cache2, v);
  }
}
function setValueT1(gl, v, textures) {
  const cache2 = this.cache;
  const unit = textures.allocateTextureUnit();
  if (cache2[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache2[0] = unit;
  }
  let emptyTexture2D;
  if (this.type === gl.SAMPLER_2D_SHADOW) {
    emptyShadowTexture.compareFunction = LessEqualCompare;
    emptyTexture2D = emptyShadowTexture;
  } else {
    emptyTexture2D = emptyTexture;
  }
  textures.setTexture2D(v || emptyTexture2D, unit);
}
function setValueT3D1(gl, v, textures) {
  const cache2 = this.cache;
  const unit = textures.allocateTextureUnit();
  if (cache2[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache2[0] = unit;
  }
  textures.setTexture3D(v || empty3dTexture, unit);
}
function setValueT6(gl, v, textures) {
  const cache2 = this.cache;
  const unit = textures.allocateTextureUnit();
  if (cache2[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache2[0] = unit;
  }
  textures.setTextureCube(v || emptyCubeTexture, unit);
}
function setValueT2DArray1(gl, v, textures) {
  const cache2 = this.cache;
  const unit = textures.allocateTextureUnit();
  if (cache2[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache2[0] = unit;
  }
  textures.setTexture2DArray(v || emptyArrayTexture, unit);
}
function getSingularSetter(type) {
  switch (type) {
    case 5126:
      return setValueV1f;
    // FLOAT
    case 35664:
      return setValueV2f;
    // _VEC2
    case 35665:
      return setValueV3f;
    // _VEC3
    case 35666:
      return setValueV4f;
    // _VEC4
    case 35674:
      return setValueM2;
    // _MAT2
    case 35675:
      return setValueM3;
    // _MAT3
    case 35676:
      return setValueM4;
    // _MAT4
    case 5124:
    case 35670:
      return setValueV1i;
    // INT, BOOL
    case 35667:
    case 35671:
      return setValueV2i;
    // _VEC2
    case 35668:
    case 35672:
      return setValueV3i;
    // _VEC3
    case 35669:
    case 35673:
      return setValueV4i;
    // _VEC4
    case 5125:
      return setValueV1ui;
    // UINT
    case 36294:
      return setValueV2ui;
    // _VEC2
    case 36295:
      return setValueV3ui;
    // _VEC3
    case 36296:
      return setValueV4ui;
    // _VEC4
    case 35678:
    // SAMPLER_2D
    case 36198:
    // SAMPLER_EXTERNAL_OES
    case 36298:
    // INT_SAMPLER_2D
    case 36306:
    // UNSIGNED_INT_SAMPLER_2D
    case 35682:
      return setValueT1;
    case 35679:
    // SAMPLER_3D
    case 36299:
    // INT_SAMPLER_3D
    case 36307:
      return setValueT3D1;
    case 35680:
    // SAMPLER_CUBE
    case 36300:
    // INT_SAMPLER_CUBE
    case 36308:
    // UNSIGNED_INT_SAMPLER_CUBE
    case 36293:
      return setValueT6;
    case 36289:
    // SAMPLER_2D_ARRAY
    case 36303:
    // INT_SAMPLER_2D_ARRAY
    case 36311:
    // UNSIGNED_INT_SAMPLER_2D_ARRAY
    case 36292:
      return setValueT2DArray1;
  }
}
function setValueV1fArray(gl, v) {
  gl.uniform1fv(this.addr, v);
}
function setValueV2fArray(gl, v) {
  const data = flatten(v, this.size, 2);
  gl.uniform2fv(this.addr, data);
}
function setValueV3fArray(gl, v) {
  const data = flatten(v, this.size, 3);
  gl.uniform3fv(this.addr, data);
}
function setValueV4fArray(gl, v) {
  const data = flatten(v, this.size, 4);
  gl.uniform4fv(this.addr, data);
}
function setValueM2Array(gl, v) {
  const data = flatten(v, this.size, 4);
  gl.uniformMatrix2fv(this.addr, false, data);
}
function setValueM3Array(gl, v) {
  const data = flatten(v, this.size, 9);
  gl.uniformMatrix3fv(this.addr, false, data);
}
function setValueM4Array(gl, v) {
  const data = flatten(v, this.size, 16);
  gl.uniformMatrix4fv(this.addr, false, data);
}
function setValueV1iArray(gl, v) {
  gl.uniform1iv(this.addr, v);
}
function setValueV2iArray(gl, v) {
  gl.uniform2iv(this.addr, v);
}
function setValueV3iArray(gl, v) {
  gl.uniform3iv(this.addr, v);
}
function setValueV4iArray(gl, v) {
  gl.uniform4iv(this.addr, v);
}
function setValueV1uiArray(gl, v) {
  gl.uniform1uiv(this.addr, v);
}
function setValueV2uiArray(gl, v) {
  gl.uniform2uiv(this.addr, v);
}
function setValueV3uiArray(gl, v) {
  gl.uniform3uiv(this.addr, v);
}
function setValueV4uiArray(gl, v) {
  gl.uniform4uiv(this.addr, v);
}
function setValueT1Array(gl, v, textures) {
  const cache2 = this.cache;
  const n = v.length;
  const units = allocTexUnits(textures, n);
  if (!arraysEqual(cache2, units)) {
    gl.uniform1iv(this.addr, units);
    copyArray(cache2, units);
  }
  for (let i = 0; i !== n; ++i) {
    textures.setTexture2D(v[i] || emptyTexture, units[i]);
  }
}
function setValueT3DArray(gl, v, textures) {
  const cache2 = this.cache;
  const n = v.length;
  const units = allocTexUnits(textures, n);
  if (!arraysEqual(cache2, units)) {
    gl.uniform1iv(this.addr, units);
    copyArray(cache2, units);
  }
  for (let i = 0; i !== n; ++i) {
    textures.setTexture3D(v[i] || empty3dTexture, units[i]);
  }
}
function setValueT6Array(gl, v, textures) {
  const cache2 = this.cache;
  const n = v.length;
  const units = allocTexUnits(textures, n);
  if (!arraysEqual(cache2, units)) {
    gl.uniform1iv(this.addr, units);
    copyArray(cache2, units);
  }
  for (let i = 0; i !== n; ++i) {
    textures.setTextureCube(v[i] || emptyCubeTexture, units[i]);
  }
}
function setValueT2DArrayArray(gl, v, textures) {
  const cache2 = this.cache;
  const n = v.length;
  const units = allocTexUnits(textures, n);
  if (!arraysEqual(cache2, units)) {
    gl.uniform1iv(this.addr, units);
    copyArray(cache2, units);
  }
  for (let i = 0; i !== n; ++i) {
    textures.setTexture2DArray(v[i] || emptyArrayTexture, units[i]);
  }
}
function getPureArraySetter(type) {
  switch (type) {
    case 5126:
      return setValueV1fArray;
    // FLOAT
    case 35664:
      return setValueV2fArray;
    // _VEC2
    case 35665:
      return setValueV3fArray;
    // _VEC3
    case 35666:
      return setValueV4fArray;
    // _VEC4
    case 35674:
      return setValueM2Array;
    // _MAT2
    case 35675:
      return setValueM3Array;
    // _MAT3
    case 35676:
      return setValueM4Array;
    // _MAT4
    case 5124:
    case 35670:
      return setValueV1iArray;
    // INT, BOOL
    case 35667:
    case 35671:
      return setValueV2iArray;
    // _VEC2
    case 35668:
    case 35672:
      return setValueV3iArray;
    // _VEC3
    case 35669:
    case 35673:
      return setValueV4iArray;
    // _VEC4
    case 5125:
      return setValueV1uiArray;
    // UINT
    case 36294:
      return setValueV2uiArray;
    // _VEC2
    case 36295:
      return setValueV3uiArray;
    // _VEC3
    case 36296:
      return setValueV4uiArray;
    // _VEC4
    case 35678:
    // SAMPLER_2D
    case 36198:
    // SAMPLER_EXTERNAL_OES
    case 36298:
    // INT_SAMPLER_2D
    case 36306:
    // UNSIGNED_INT_SAMPLER_2D
    case 35682:
      return setValueT1Array;
    case 35679:
    // SAMPLER_3D
    case 36299:
    // INT_SAMPLER_3D
    case 36307:
      return setValueT3DArray;
    case 35680:
    // SAMPLER_CUBE
    case 36300:
    // INT_SAMPLER_CUBE
    case 36308:
    // UNSIGNED_INT_SAMPLER_CUBE
    case 36293:
      return setValueT6Array;
    case 36289:
    // SAMPLER_2D_ARRAY
    case 36303:
    // INT_SAMPLER_2D_ARRAY
    case 36311:
    // UNSIGNED_INT_SAMPLER_2D_ARRAY
    case 36292:
      return setValueT2DArrayArray;
  }
}
class SingleUniform {
  constructor(id, activeInfo, addr) {
    this.id = id;
    this.addr = addr;
    this.cache = [];
    this.type = activeInfo.type;
    this.setValue = getSingularSetter(activeInfo.type);
  }
}
class PureArrayUniform {
  constructor(id, activeInfo, addr) {
    this.id = id;
    this.addr = addr;
    this.cache = [];
    this.type = activeInfo.type;
    this.size = activeInfo.size;
    this.setValue = getPureArraySetter(activeInfo.type);
  }
}
class StructuredUniform {
  constructor(id) {
    this.id = id;
    this.seq = [];
    this.map = {};
  }
  setValue(gl, value, textures) {
    const seq = this.seq;
    for (let i = 0, n = seq.length; i !== n; ++i) {
      const u = seq[i];
      u.setValue(gl, value[u.id], textures);
    }
  }
}
const RePathPart = /(\w+)(\])?(\[|\.)?/g;
function addUniform(container, uniformObject) {
  container.seq.push(uniformObject);
  container.map[uniformObject.id] = uniformObject;
}
function parseUniform(activeInfo, addr, container) {
  const path = activeInfo.name, pathLength = path.length;
  RePathPart.lastIndex = 0;
  while (true) {
    const match = RePathPart.exec(path), matchEnd = RePathPart.lastIndex;
    let id = match[1];
    const idIsIndex = match[2] === "]", subscript = match[3];
    if (idIsIndex) id = id | 0;
    if (subscript === void 0 || subscript === "[" && matchEnd + 2 === pathLength) {
      addUniform(container, subscript === void 0 ? new SingleUniform(id, activeInfo, addr) : new PureArrayUniform(id, activeInfo, addr));
      break;
    } else {
      const map = container.map;
      let next = map[id];
      if (next === void 0) {
        next = new StructuredUniform(id);
        addUniform(container, next);
      }
      container = next;
    }
  }
}
class WebGLUniforms {
  constructor(gl, program) {
    this.seq = [];
    this.map = {};
    const n = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
    for (let i = 0; i < n; ++i) {
      const info = gl.getActiveUniform(program, i), addr = gl.getUniformLocation(program, info.name);
      parseUniform(info, addr, this);
    }
  }
  setValue(gl, name, value, textures) {
    const u = this.map[name];
    if (u !== void 0) u.setValue(gl, value, textures);
  }
  setOptional(gl, object, name) {
    const v = object[name];
    if (v !== void 0) this.setValue(gl, name, v);
  }
  static upload(gl, seq, values, textures) {
    for (let i = 0, n = seq.length; i !== n; ++i) {
      const u = seq[i], v = values[u.id];
      if (v.needsUpdate !== false) {
        u.setValue(gl, v.value, textures);
      }
    }
  }
  static seqWithValue(seq, values) {
    const r = [];
    for (let i = 0, n = seq.length; i !== n; ++i) {
      const u = seq[i];
      if (u.id in values) r.push(u);
    }
    return r;
  }
}
function WebGLShader(gl, type, string) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, string);
  gl.compileShader(shader);
  return shader;
}
const COMPLETION_STATUS_KHR = 37297;
let programIdCount = 0;
function handleSource(string, errorLine) {
  const lines = string.split("\n");
  const lines2 = [];
  const from = Math.max(errorLine - 6, 0);
  const to = Math.min(errorLine + 6, lines.length);
  for (let i = from; i < to; i++) {
    const line = i + 1;
    lines2.push(`${line === errorLine ? ">" : " "} ${line}: ${lines[i]}`);
  }
  return lines2.join("\n");
}
const _m0 = /* @__PURE__ */ new Matrix3$1();
function getEncodingComponents(colorSpace) {
  ColorManagement$1._getMatrix(_m0, ColorManagement$1.workingColorSpace, colorSpace);
  const encodingMatrix = `mat3( ${_m0.elements.map((v) => v.toFixed(4))} )`;
  switch (ColorManagement$1.getTransfer(colorSpace)) {
    case LinearTransfer$1:
      return [encodingMatrix, "LinearTransferOETF"];
    case SRGBTransfer$1:
      return [encodingMatrix, "sRGBTransferOETF"];
    default:
      console.warn("THREE.WebGLProgram: Unsupported color space: ", colorSpace);
      return [encodingMatrix, "LinearTransferOETF"];
  }
}
function getShaderErrors(gl, shader, type) {
  const status = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
  const errors = gl.getShaderInfoLog(shader).trim();
  if (status && errors === "") return "";
  const errorMatches = /ERROR: 0:(\d+)/.exec(errors);
  if (errorMatches) {
    const errorLine = parseInt(errorMatches[1]);
    return type.toUpperCase() + "\n\n" + errors + "\n\n" + handleSource(gl.getShaderSource(shader), errorLine);
  } else {
    return errors;
  }
}
function getTexelEncodingFunction(functionName, colorSpace) {
  const components = getEncodingComponents(colorSpace);
  return [
    `vec4 ${functionName}( vec4 value ) {`,
    `	return ${components[1]}( vec4( value.rgb * ${components[0]}, value.a ) );`,
    "}"
  ].join("\n");
}
function getToneMappingFunction(functionName, toneMapping2) {
  let toneMappingName;
  switch (toneMapping2) {
    case LinearToneMapping:
      toneMappingName = "Linear";
      break;
    case ReinhardToneMapping:
      toneMappingName = "Reinhard";
      break;
    case CineonToneMapping:
      toneMappingName = "Cineon";
      break;
    case ACESFilmicToneMapping:
      toneMappingName = "ACESFilmic";
      break;
    case AgXToneMapping:
      toneMappingName = "AgX";
      break;
    case NeutralToneMapping:
      toneMappingName = "Neutral";
      break;
    case CustomToneMapping:
      toneMappingName = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", toneMapping2);
      toneMappingName = "Linear";
  }
  return "vec3 " + functionName + "( vec3 color ) { return " + toneMappingName + "ToneMapping( color ); }";
}
const _v0 = /* @__PURE__ */ new Vector3$1();
function getLuminanceFunction() {
  ColorManagement$1.getLuminanceCoefficients(_v0);
  const r = _v0.x.toFixed(4);
  const g = _v0.y.toFixed(4);
  const b = _v0.z.toFixed(4);
  return [
    "float luminance( const in vec3 rgb ) {",
    `	const vec3 weights = vec3( ${r}, ${g}, ${b} );`,
    "	return dot( weights, rgb );",
    "}"
  ].join("\n");
}
function generateVertexExtensions(parameters) {
  const chunks = [
    parameters.extensionClipCullDistance ? "#extension GL_ANGLE_clip_cull_distance : require" : "",
    parameters.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : ""
  ];
  return chunks.filter(filterEmptyLine).join("\n");
}
function generateDefines(defines) {
  const chunks = [];
  for (const name in defines) {
    const value = defines[name];
    if (value === false) continue;
    chunks.push("#define " + name + " " + value);
  }
  return chunks.join("\n");
}
function fetchAttributeLocations(gl, program) {
  const attributes = {};
  const n = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
  for (let i = 0; i < n; i++) {
    const info = gl.getActiveAttrib(program, i);
    const name = info.name;
    let locationSize = 1;
    if (info.type === gl.FLOAT_MAT2) locationSize = 2;
    if (info.type === gl.FLOAT_MAT3) locationSize = 3;
    if (info.type === gl.FLOAT_MAT4) locationSize = 4;
    attributes[name] = {
      type: info.type,
      location: gl.getAttribLocation(program, name),
      locationSize
    };
  }
  return attributes;
}
function filterEmptyLine(string) {
  return string !== "";
}
function replaceLightNums(string, parameters) {
  const numSpotLightCoords = parameters.numSpotLightShadows + parameters.numSpotLightMaps - parameters.numSpotLightShadowsWithMaps;
  return string.replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights).replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, parameters.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, numSpotLightCoords).replace(/NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights).replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, parameters.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows);
}
function replaceClippingPlaneNums(string, parameters) {
  return string.replace(/NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, parameters.numClippingPlanes - parameters.numClipIntersection);
}
const includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;
function resolveIncludes(string) {
  return string.replace(includePattern, includeReplacer);
}
const shaderChunkMap = /* @__PURE__ */ new Map();
function includeReplacer(match, include) {
  let string = ShaderChunk[include];
  if (string === void 0) {
    const newInclude = shaderChunkMap.get(include);
    if (newInclude !== void 0) {
      string = ShaderChunk[newInclude];
      console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', include, newInclude);
    } else {
      throw new Error("Can not resolve #include <" + include + ">");
    }
  }
  return resolveIncludes(string);
}
const unrollLoopPattern = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function unrollLoops(string) {
  return string.replace(unrollLoopPattern, loopReplacer);
}
function loopReplacer(match, start, end, snippet) {
  let string = "";
  for (let i = parseInt(start); i < parseInt(end); i++) {
    string += snippet.replace(/\[\s*i\s*\]/g, "[ " + i + " ]").replace(/UNROLLED_LOOP_INDEX/g, i);
  }
  return string;
}
function generatePrecision(parameters) {
  let precisionstring = `precision ${parameters.precision} float;
	precision ${parameters.precision} int;
	precision ${parameters.precision} sampler2D;
	precision ${parameters.precision} samplerCube;
	precision ${parameters.precision} sampler3D;
	precision ${parameters.precision} sampler2DArray;
	precision ${parameters.precision} sampler2DShadow;
	precision ${parameters.precision} samplerCubeShadow;
	precision ${parameters.precision} sampler2DArrayShadow;
	precision ${parameters.precision} isampler2D;
	precision ${parameters.precision} isampler3D;
	precision ${parameters.precision} isamplerCube;
	precision ${parameters.precision} isampler2DArray;
	precision ${parameters.precision} usampler2D;
	precision ${parameters.precision} usampler3D;
	precision ${parameters.precision} usamplerCube;
	precision ${parameters.precision} usampler2DArray;
	`;
  if (parameters.precision === "highp") {
    precisionstring += "\n#define HIGH_PRECISION";
  } else if (parameters.precision === "mediump") {
    precisionstring += "\n#define MEDIUM_PRECISION";
  } else if (parameters.precision === "lowp") {
    precisionstring += "\n#define LOW_PRECISION";
  }
  return precisionstring;
}
function generateShadowMapTypeDefine(parameters) {
  let shadowMapTypeDefine = "SHADOWMAP_TYPE_BASIC";
  if (parameters.shadowMapType === PCFShadowMap) {
    shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF";
  } else if (parameters.shadowMapType === PCFSoftShadowMap) {
    shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF_SOFT";
  } else if (parameters.shadowMapType === VSMShadowMap) {
    shadowMapTypeDefine = "SHADOWMAP_TYPE_VSM";
  }
  return shadowMapTypeDefine;
}
function generateEnvMapTypeDefine(parameters) {
  let envMapTypeDefine = "ENVMAP_TYPE_CUBE";
  if (parameters.envMap) {
    switch (parameters.envMapMode) {
      case CubeReflectionMapping:
      case CubeRefractionMapping:
        envMapTypeDefine = "ENVMAP_TYPE_CUBE";
        break;
      case CubeUVReflectionMapping:
        envMapTypeDefine = "ENVMAP_TYPE_CUBE_UV";
        break;
    }
  }
  return envMapTypeDefine;
}
function generateEnvMapModeDefine(parameters) {
  let envMapModeDefine = "ENVMAP_MODE_REFLECTION";
  if (parameters.envMap) {
    switch (parameters.envMapMode) {
      case CubeRefractionMapping:
        envMapModeDefine = "ENVMAP_MODE_REFRACTION";
        break;
    }
  }
  return envMapModeDefine;
}
function generateEnvMapBlendingDefine(parameters) {
  let envMapBlendingDefine = "ENVMAP_BLENDING_NONE";
  if (parameters.envMap) {
    switch (parameters.combine) {
      case MultiplyOperation:
        envMapBlendingDefine = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case MixOperation:
        envMapBlendingDefine = "ENVMAP_BLENDING_MIX";
        break;
      case AddOperation:
        envMapBlendingDefine = "ENVMAP_BLENDING_ADD";
        break;
    }
  }
  return envMapBlendingDefine;
}
function generateCubeUVSize(parameters) {
  const imageHeight = parameters.envMapCubeUVHeight;
  if (imageHeight === null) return null;
  const maxMip = Math.log2(imageHeight) - 2;
  const texelHeight = 1 / imageHeight;
  const texelWidth = 1 / (3 * Math.max(Math.pow(2, maxMip), 7 * 16));
  return { texelWidth, texelHeight, maxMip };
}
function WebGLProgram(renderer, cacheKey, parameters, bindingStates) {
  const gl = renderer.getContext();
  const defines = parameters.defines;
  let vertexShader = parameters.vertexShader;
  let fragmentShader = parameters.fragmentShader;
  const shadowMapTypeDefine = generateShadowMapTypeDefine(parameters);
  const envMapTypeDefine = generateEnvMapTypeDefine(parameters);
  const envMapModeDefine = generateEnvMapModeDefine(parameters);
  const envMapBlendingDefine = generateEnvMapBlendingDefine(parameters);
  const envMapCubeUVSize = generateCubeUVSize(parameters);
  const customVertexExtensions = generateVertexExtensions(parameters);
  const customDefines = generateDefines(defines);
  const program = gl.createProgram();
  let prefixVertex, prefixFragment;
  let versionString = parameters.glslVersion ? "#version " + parameters.glslVersion + "\n" : "";
  if (parameters.isRawShaderMaterial) {
    prefixVertex = [
      "#define SHADER_TYPE " + parameters.shaderType,
      "#define SHADER_NAME " + parameters.shaderName,
      customDefines
    ].filter(filterEmptyLine).join("\n");
    if (prefixVertex.length > 0) {
      prefixVertex += "\n";
    }
    prefixFragment = [
      "#define SHADER_TYPE " + parameters.shaderType,
      "#define SHADER_NAME " + parameters.shaderName,
      customDefines
    ].filter(filterEmptyLine).join("\n");
    if (prefixFragment.length > 0) {
      prefixFragment += "\n";
    }
  } else {
    prefixVertex = [
      generatePrecision(parameters),
      "#define SHADER_TYPE " + parameters.shaderType,
      "#define SHADER_NAME " + parameters.shaderName,
      customDefines,
      parameters.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "",
      parameters.batching ? "#define USE_BATCHING" : "",
      parameters.batchingColor ? "#define USE_BATCHING_COLOR" : "",
      parameters.instancing ? "#define USE_INSTANCING" : "",
      parameters.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
      parameters.instancingMorph ? "#define USE_INSTANCING_MORPH" : "",
      parameters.useFog && parameters.fog ? "#define USE_FOG" : "",
      parameters.useFog && parameters.fogExp2 ? "#define FOG_EXP2" : "",
      parameters.map ? "#define USE_MAP" : "",
      parameters.envMap ? "#define USE_ENVMAP" : "",
      parameters.envMap ? "#define " + envMapModeDefine : "",
      parameters.lightMap ? "#define USE_LIGHTMAP" : "",
      parameters.aoMap ? "#define USE_AOMAP" : "",
      parameters.bumpMap ? "#define USE_BUMPMAP" : "",
      parameters.normalMap ? "#define USE_NORMALMAP" : "",
      parameters.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
      parameters.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
      parameters.displacementMap ? "#define USE_DISPLACEMENTMAP" : "",
      parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
      parameters.anisotropy ? "#define USE_ANISOTROPY" : "",
      parameters.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
      parameters.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
      parameters.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
      parameters.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
      parameters.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
      parameters.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
      parameters.specularMap ? "#define USE_SPECULARMAP" : "",
      parameters.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
      parameters.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
      parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
      parameters.metalnessMap ? "#define USE_METALNESSMAP" : "",
      parameters.alphaMap ? "#define USE_ALPHAMAP" : "",
      parameters.alphaHash ? "#define USE_ALPHAHASH" : "",
      parameters.transmission ? "#define USE_TRANSMISSION" : "",
      parameters.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
      parameters.thicknessMap ? "#define USE_THICKNESSMAP" : "",
      parameters.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
      parameters.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
      //
      parameters.mapUv ? "#define MAP_UV " + parameters.mapUv : "",
      parameters.alphaMapUv ? "#define ALPHAMAP_UV " + parameters.alphaMapUv : "",
      parameters.lightMapUv ? "#define LIGHTMAP_UV " + parameters.lightMapUv : "",
      parameters.aoMapUv ? "#define AOMAP_UV " + parameters.aoMapUv : "",
      parameters.emissiveMapUv ? "#define EMISSIVEMAP_UV " + parameters.emissiveMapUv : "",
      parameters.bumpMapUv ? "#define BUMPMAP_UV " + parameters.bumpMapUv : "",
      parameters.normalMapUv ? "#define NORMALMAP_UV " + parameters.normalMapUv : "",
      parameters.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + parameters.displacementMapUv : "",
      parameters.metalnessMapUv ? "#define METALNESSMAP_UV " + parameters.metalnessMapUv : "",
      parameters.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + parameters.roughnessMapUv : "",
      parameters.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + parameters.anisotropyMapUv : "",
      parameters.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + parameters.clearcoatMapUv : "",
      parameters.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + parameters.clearcoatNormalMapUv : "",
      parameters.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + parameters.clearcoatRoughnessMapUv : "",
      parameters.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + parameters.iridescenceMapUv : "",
      parameters.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + parameters.iridescenceThicknessMapUv : "",
      parameters.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + parameters.sheenColorMapUv : "",
      parameters.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + parameters.sheenRoughnessMapUv : "",
      parameters.specularMapUv ? "#define SPECULARMAP_UV " + parameters.specularMapUv : "",
      parameters.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + parameters.specularColorMapUv : "",
      parameters.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + parameters.specularIntensityMapUv : "",
      parameters.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + parameters.transmissionMapUv : "",
      parameters.thicknessMapUv ? "#define THICKNESSMAP_UV " + parameters.thicknessMapUv : "",
      //
      parameters.vertexTangents && parameters.flatShading === false ? "#define USE_TANGENT" : "",
      parameters.vertexColors ? "#define USE_COLOR" : "",
      parameters.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
      parameters.vertexUv1s ? "#define USE_UV1" : "",
      parameters.vertexUv2s ? "#define USE_UV2" : "",
      parameters.vertexUv3s ? "#define USE_UV3" : "",
      parameters.pointsUvs ? "#define USE_POINTS_UV" : "",
      parameters.flatShading ? "#define FLAT_SHADED" : "",
      parameters.skinning ? "#define USE_SKINNING" : "",
      parameters.morphTargets ? "#define USE_MORPHTARGETS" : "",
      parameters.morphNormals && parameters.flatShading === false ? "#define USE_MORPHNORMALS" : "",
      parameters.morphColors ? "#define USE_MORPHCOLORS" : "",
      parameters.morphTargetsCount > 0 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + parameters.morphTextureStride : "",
      parameters.morphTargetsCount > 0 ? "#define MORPHTARGETS_COUNT " + parameters.morphTargetsCount : "",
      parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
      parameters.flipSided ? "#define FLIP_SIDED" : "",
      parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
      parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
      parameters.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
      parameters.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
      parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
      parameters.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "",
      "uniform mat4 modelMatrix;",
      "uniform mat4 modelViewMatrix;",
      "uniform mat4 projectionMatrix;",
      "uniform mat4 viewMatrix;",
      "uniform mat3 normalMatrix;",
      "uniform vec3 cameraPosition;",
      "uniform bool isOrthographic;",
      "#ifdef USE_INSTANCING",
      "	attribute mat4 instanceMatrix;",
      "#endif",
      "#ifdef USE_INSTANCING_COLOR",
      "	attribute vec3 instanceColor;",
      "#endif",
      "#ifdef USE_INSTANCING_MORPH",
      "	uniform sampler2D morphTexture;",
      "#endif",
      "attribute vec3 position;",
      "attribute vec3 normal;",
      "attribute vec2 uv;",
      "#ifdef USE_UV1",
      "	attribute vec2 uv1;",
      "#endif",
      "#ifdef USE_UV2",
      "	attribute vec2 uv2;",
      "#endif",
      "#ifdef USE_UV3",
      "	attribute vec2 uv3;",
      "#endif",
      "#ifdef USE_TANGENT",
      "	attribute vec4 tangent;",
      "#endif",
      "#if defined( USE_COLOR_ALPHA )",
      "	attribute vec4 color;",
      "#elif defined( USE_COLOR )",
      "	attribute vec3 color;",
      "#endif",
      "#ifdef USE_SKINNING",
      "	attribute vec4 skinIndex;",
      "	attribute vec4 skinWeight;",
      "#endif",
      "\n"
    ].filter(filterEmptyLine).join("\n");
    prefixFragment = [
      generatePrecision(parameters),
      "#define SHADER_TYPE " + parameters.shaderType,
      "#define SHADER_NAME " + parameters.shaderName,
      customDefines,
      parameters.useFog && parameters.fog ? "#define USE_FOG" : "",
      parameters.useFog && parameters.fogExp2 ? "#define FOG_EXP2" : "",
      parameters.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "",
      parameters.map ? "#define USE_MAP" : "",
      parameters.matcap ? "#define USE_MATCAP" : "",
      parameters.envMap ? "#define USE_ENVMAP" : "",
      parameters.envMap ? "#define " + envMapTypeDefine : "",
      parameters.envMap ? "#define " + envMapModeDefine : "",
      parameters.envMap ? "#define " + envMapBlendingDefine : "",
      envMapCubeUVSize ? "#define CUBEUV_TEXEL_WIDTH " + envMapCubeUVSize.texelWidth : "",
      envMapCubeUVSize ? "#define CUBEUV_TEXEL_HEIGHT " + envMapCubeUVSize.texelHeight : "",
      envMapCubeUVSize ? "#define CUBEUV_MAX_MIP " + envMapCubeUVSize.maxMip + ".0" : "",
      parameters.lightMap ? "#define USE_LIGHTMAP" : "",
      parameters.aoMap ? "#define USE_AOMAP" : "",
      parameters.bumpMap ? "#define USE_BUMPMAP" : "",
      parameters.normalMap ? "#define USE_NORMALMAP" : "",
      parameters.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
      parameters.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
      parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
      parameters.anisotropy ? "#define USE_ANISOTROPY" : "",
      parameters.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
      parameters.clearcoat ? "#define USE_CLEARCOAT" : "",
      parameters.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
      parameters.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
      parameters.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
      parameters.dispersion ? "#define USE_DISPERSION" : "",
      parameters.iridescence ? "#define USE_IRIDESCENCE" : "",
      parameters.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
      parameters.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
      parameters.specularMap ? "#define USE_SPECULARMAP" : "",
      parameters.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
      parameters.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
      parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
      parameters.metalnessMap ? "#define USE_METALNESSMAP" : "",
      parameters.alphaMap ? "#define USE_ALPHAMAP" : "",
      parameters.alphaTest ? "#define USE_ALPHATEST" : "",
      parameters.alphaHash ? "#define USE_ALPHAHASH" : "",
      parameters.sheen ? "#define USE_SHEEN" : "",
      parameters.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
      parameters.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
      parameters.transmission ? "#define USE_TRANSMISSION" : "",
      parameters.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
      parameters.thicknessMap ? "#define USE_THICKNESSMAP" : "",
      parameters.vertexTangents && parameters.flatShading === false ? "#define USE_TANGENT" : "",
      parameters.vertexColors || parameters.instancingColor || parameters.batchingColor ? "#define USE_COLOR" : "",
      parameters.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
      parameters.vertexUv1s ? "#define USE_UV1" : "",
      parameters.vertexUv2s ? "#define USE_UV2" : "",
      parameters.vertexUv3s ? "#define USE_UV3" : "",
      parameters.pointsUvs ? "#define USE_POINTS_UV" : "",
      parameters.gradientMap ? "#define USE_GRADIENTMAP" : "",
      parameters.flatShading ? "#define FLAT_SHADED" : "",
      parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
      parameters.flipSided ? "#define FLIP_SIDED" : "",
      parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
      parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
      parameters.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
      parameters.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
      parameters.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
      parameters.decodeVideoTextureEmissive ? "#define DECODE_VIDEO_TEXTURE_EMISSIVE" : "",
      parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
      parameters.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "",
      "uniform mat4 viewMatrix;",
      "uniform vec3 cameraPosition;",
      "uniform bool isOrthographic;",
      parameters.toneMapping !== NoToneMapping$1 ? "#define TONE_MAPPING" : "",
      parameters.toneMapping !== NoToneMapping$1 ? ShaderChunk["tonemapping_pars_fragment"] : "",
      // this code is required here because it is used by the toneMapping() function defined below
      parameters.toneMapping !== NoToneMapping$1 ? getToneMappingFunction("toneMapping", parameters.toneMapping) : "",
      parameters.dithering ? "#define DITHERING" : "",
      parameters.opaque ? "#define OPAQUE" : "",
      ShaderChunk["colorspace_pars_fragment"],
      // this code is required here because it is used by the various encoding/decoding function defined below
      getTexelEncodingFunction("linearToOutputTexel", parameters.outputColorSpace),
      getLuminanceFunction(),
      parameters.useDepthPacking ? "#define DEPTH_PACKING " + parameters.depthPacking : "",
      "\n"
    ].filter(filterEmptyLine).join("\n");
  }
  vertexShader = resolveIncludes(vertexShader);
  vertexShader = replaceLightNums(vertexShader, parameters);
  vertexShader = replaceClippingPlaneNums(vertexShader, parameters);
  fragmentShader = resolveIncludes(fragmentShader);
  fragmentShader = replaceLightNums(fragmentShader, parameters);
  fragmentShader = replaceClippingPlaneNums(fragmentShader, parameters);
  vertexShader = unrollLoops(vertexShader);
  fragmentShader = unrollLoops(fragmentShader);
  if (parameters.isRawShaderMaterial !== true) {
    versionString = "#version 300 es\n";
    prefixVertex = [
      customVertexExtensions,
      "#define attribute in",
      "#define varying out",
      "#define texture2D texture"
    ].join("\n") + "\n" + prefixVertex;
    prefixFragment = [
      "#define varying in",
      parameters.glslVersion === GLSL3 ? "" : "layout(location = 0) out highp vec4 pc_fragColor;",
      parameters.glslVersion === GLSL3 ? "" : "#define gl_FragColor pc_fragColor",
      "#define gl_FragDepthEXT gl_FragDepth",
      "#define texture2D texture",
      "#define textureCube texture",
      "#define texture2DProj textureProj",
      "#define texture2DLodEXT textureLod",
      "#define texture2DProjLodEXT textureProjLod",
      "#define textureCubeLodEXT textureLod",
      "#define texture2DGradEXT textureGrad",
      "#define texture2DProjGradEXT textureProjGrad",
      "#define textureCubeGradEXT textureGrad"
    ].join("\n") + "\n" + prefixFragment;
  }
  const vertexGlsl = versionString + prefixVertex + vertexShader;
  const fragmentGlsl = versionString + prefixFragment + fragmentShader;
  const glVertexShader = WebGLShader(gl, gl.VERTEX_SHADER, vertexGlsl);
  const glFragmentShader = WebGLShader(gl, gl.FRAGMENT_SHADER, fragmentGlsl);
  gl.attachShader(program, glVertexShader);
  gl.attachShader(program, glFragmentShader);
  if (parameters.index0AttributeName !== void 0) {
    gl.bindAttribLocation(program, 0, parameters.index0AttributeName);
  } else if (parameters.morphTargets === true) {
    gl.bindAttribLocation(program, 0, "position");
  }
  gl.linkProgram(program);
  function onFirstUse(self2) {
    if (renderer.debug.checkShaderErrors) {
      const programLog = gl.getProgramInfoLog(program).trim();
      const vertexLog = gl.getShaderInfoLog(glVertexShader).trim();
      const fragmentLog = gl.getShaderInfoLog(glFragmentShader).trim();
      let runnable = true;
      let haveDiagnostics = true;
      if (gl.getProgramParameter(program, gl.LINK_STATUS) === false) {
        runnable = false;
        if (typeof renderer.debug.onShaderError === "function") {
          renderer.debug.onShaderError(gl, program, glVertexShader, glFragmentShader);
        } else {
          const vertexErrors = getShaderErrors(gl, glVertexShader, "vertex");
          const fragmentErrors = getShaderErrors(gl, glFragmentShader, "fragment");
          console.error(
            "THREE.WebGLProgram: Shader Error " + gl.getError() + " - VALIDATE_STATUS " + gl.getProgramParameter(program, gl.VALIDATE_STATUS) + "\n\nMaterial Name: " + self2.name + "\nMaterial Type: " + self2.type + "\n\nProgram Info Log: " + programLog + "\n" + vertexErrors + "\n" + fragmentErrors
          );
        }
      } else if (programLog !== "") {
        console.warn("THREE.WebGLProgram: Program Info Log:", programLog);
      } else if (vertexLog === "" || fragmentLog === "") {
        haveDiagnostics = false;
      }
      if (haveDiagnostics) {
        self2.diagnostics = {
          runnable,
          programLog,
          vertexShader: {
            log: vertexLog,
            prefix: prefixVertex
          },
          fragmentShader: {
            log: fragmentLog,
            prefix: prefixFragment
          }
        };
      }
    }
    gl.deleteShader(glVertexShader);
    gl.deleteShader(glFragmentShader);
    cachedUniforms = new WebGLUniforms(gl, program);
    cachedAttributes = fetchAttributeLocations(gl, program);
  }
  let cachedUniforms;
  this.getUniforms = function() {
    if (cachedUniforms === void 0) {
      onFirstUse(this);
    }
    return cachedUniforms;
  };
  let cachedAttributes;
  this.getAttributes = function() {
    if (cachedAttributes === void 0) {
      onFirstUse(this);
    }
    return cachedAttributes;
  };
  let programReady = parameters.rendererExtensionParallelShaderCompile === false;
  this.isReady = function() {
    if (programReady === false) {
      programReady = gl.getProgramParameter(program, COMPLETION_STATUS_KHR);
    }
    return programReady;
  };
  this.destroy = function() {
    bindingStates.releaseStatesOfProgram(this);
    gl.deleteProgram(program);
    this.program = void 0;
  };
  this.type = parameters.shaderType;
  this.name = parameters.shaderName;
  this.id = programIdCount++;
  this.cacheKey = cacheKey;
  this.usedTimes = 1;
  this.program = program;
  this.vertexShader = glVertexShader;
  this.fragmentShader = glFragmentShader;
  return this;
}
let _id = 0;
class WebGLShaderCache {
  constructor() {
    this.shaderCache = /* @__PURE__ */ new Map();
    this.materialCache = /* @__PURE__ */ new Map();
  }
  update(material) {
    const vertexShader = material.vertexShader;
    const fragmentShader = material.fragmentShader;
    const vertexShaderStage = this._getShaderStage(vertexShader);
    const fragmentShaderStage = this._getShaderStage(fragmentShader);
    const materialShaders = this._getShaderCacheForMaterial(material);
    if (materialShaders.has(vertexShaderStage) === false) {
      materialShaders.add(vertexShaderStage);
      vertexShaderStage.usedTimes++;
    }
    if (materialShaders.has(fragmentShaderStage) === false) {
      materialShaders.add(fragmentShaderStage);
      fragmentShaderStage.usedTimes++;
    }
    return this;
  }
  remove(material) {
    const materialShaders = this.materialCache.get(material);
    for (const shaderStage of materialShaders) {
      shaderStage.usedTimes--;
      if (shaderStage.usedTimes === 0) this.shaderCache.delete(shaderStage.code);
    }
    this.materialCache.delete(material);
    return this;
  }
  getVertexShaderID(material) {
    return this._getShaderStage(material.vertexShader).id;
  }
  getFragmentShaderID(material) {
    return this._getShaderStage(material.fragmentShader).id;
  }
  dispose() {
    this.shaderCache.clear();
    this.materialCache.clear();
  }
  _getShaderCacheForMaterial(material) {
    const cache2 = this.materialCache;
    let set = cache2.get(material);
    if (set === void 0) {
      set = /* @__PURE__ */ new Set();
      cache2.set(material, set);
    }
    return set;
  }
  _getShaderStage(code) {
    const cache2 = this.shaderCache;
    let stage = cache2.get(code);
    if (stage === void 0) {
      stage = new WebGLShaderStage(code);
      cache2.set(code, stage);
    }
    return stage;
  }
}
class WebGLShaderStage {
  constructor(code) {
    this.id = _id++;
    this.code = code;
    this.usedTimes = 0;
  }
}
function WebGLPrograms(renderer, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping) {
  const _programLayers = new Layers();
  const _customShaders = new WebGLShaderCache();
  const _activeChannels = /* @__PURE__ */ new Set();
  const programs = [];
  const logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;
  const SUPPORTS_VERTEX_TEXTURES = capabilities.vertexTextures;
  let precision = capabilities.precision;
  const shaderIDs = {
    MeshDepthMaterial: "depth",
    MeshDistanceMaterial: "distanceRGBA",
    MeshNormalMaterial: "normal",
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "toon",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical",
    MeshMatcapMaterial: "matcap",
    LineBasicMaterial: "basic",
    LineDashedMaterial: "dashed",
    PointsMaterial: "points",
    ShadowMaterial: "shadow",
    SpriteMaterial: "sprite"
  };
  function getChannel(value) {
    _activeChannels.add(value);
    if (value === 0) return "uv";
    return `uv${value}`;
  }
  function getParameters(material, lights, shadows, scene, object) {
    const fog = scene.fog;
    const geometry = object.geometry;
    const environment = material.isMeshStandardMaterial ? scene.environment : null;
    const envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || environment);
    const envMapCubeUVHeight = !!envMap && envMap.mapping === CubeUVReflectionMapping ? envMap.image.height : null;
    const shaderID = shaderIDs[material.type];
    if (material.precision !== null) {
      precision = capabilities.getMaxPrecision(material.precision);
      if (precision !== material.precision) {
        console.warn("THREE.WebGLProgram.getParameters:", material.precision, "not supported, using", precision, "instead.");
      }
    }
    const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
    const morphTargetsCount = morphAttribute !== void 0 ? morphAttribute.length : 0;
    let morphTextureStride = 0;
    if (geometry.morphAttributes.position !== void 0) morphTextureStride = 1;
    if (geometry.morphAttributes.normal !== void 0) morphTextureStride = 2;
    if (geometry.morphAttributes.color !== void 0) morphTextureStride = 3;
    let vertexShader, fragmentShader;
    let customVertexShaderID, customFragmentShaderID;
    if (shaderID) {
      const shader = ShaderLib[shaderID];
      vertexShader = shader.vertexShader;
      fragmentShader = shader.fragmentShader;
    } else {
      vertexShader = material.vertexShader;
      fragmentShader = material.fragmentShader;
      _customShaders.update(material);
      customVertexShaderID = _customShaders.getVertexShaderID(material);
      customFragmentShaderID = _customShaders.getFragmentShaderID(material);
    }
    const currentRenderTarget = renderer.getRenderTarget();
    const reverseDepthBuffer = renderer.state.buffers.depth.getReversed();
    const IS_INSTANCEDMESH = object.isInstancedMesh === true;
    const IS_BATCHEDMESH = object.isBatchedMesh === true;
    const HAS_MAP = !!material.map;
    const HAS_MATCAP = !!material.matcap;
    const HAS_ENVMAP = !!envMap;
    const HAS_AOMAP = !!material.aoMap;
    const HAS_LIGHTMAP = !!material.lightMap;
    const HAS_BUMPMAP = !!material.bumpMap;
    const HAS_NORMALMAP = !!material.normalMap;
    const HAS_DISPLACEMENTMAP = !!material.displacementMap;
    const HAS_EMISSIVEMAP = !!material.emissiveMap;
    const HAS_METALNESSMAP = !!material.metalnessMap;
    const HAS_ROUGHNESSMAP = !!material.roughnessMap;
    const HAS_ANISOTROPY = material.anisotropy > 0;
    const HAS_CLEARCOAT = material.clearcoat > 0;
    const HAS_DISPERSION = material.dispersion > 0;
    const HAS_IRIDESCENCE = material.iridescence > 0;
    const HAS_SHEEN = material.sheen > 0;
    const HAS_TRANSMISSION = material.transmission > 0;
    const HAS_ANISOTROPYMAP = HAS_ANISOTROPY && !!material.anisotropyMap;
    const HAS_CLEARCOATMAP = HAS_CLEARCOAT && !!material.clearcoatMap;
    const HAS_CLEARCOAT_NORMALMAP = HAS_CLEARCOAT && !!material.clearcoatNormalMap;
    const HAS_CLEARCOAT_ROUGHNESSMAP = HAS_CLEARCOAT && !!material.clearcoatRoughnessMap;
    const HAS_IRIDESCENCEMAP = HAS_IRIDESCENCE && !!material.iridescenceMap;
    const HAS_IRIDESCENCE_THICKNESSMAP = HAS_IRIDESCENCE && !!material.iridescenceThicknessMap;
    const HAS_SHEEN_COLORMAP = HAS_SHEEN && !!material.sheenColorMap;
    const HAS_SHEEN_ROUGHNESSMAP = HAS_SHEEN && !!material.sheenRoughnessMap;
    const HAS_SPECULARMAP = !!material.specularMap;
    const HAS_SPECULAR_COLORMAP = !!material.specularColorMap;
    const HAS_SPECULAR_INTENSITYMAP = !!material.specularIntensityMap;
    const HAS_TRANSMISSIONMAP = HAS_TRANSMISSION && !!material.transmissionMap;
    const HAS_THICKNESSMAP = HAS_TRANSMISSION && !!material.thicknessMap;
    const HAS_GRADIENTMAP = !!material.gradientMap;
    const HAS_ALPHAMAP = !!material.alphaMap;
    const HAS_ALPHATEST = material.alphaTest > 0;
    const HAS_ALPHAHASH = !!material.alphaHash;
    const HAS_EXTENSIONS = !!material.extensions;
    let toneMapping2 = NoToneMapping$1;
    if (material.toneMapped) {
      if (currentRenderTarget === null || currentRenderTarget.isXRRenderTarget === true) {
        toneMapping2 = renderer.toneMapping;
      }
    }
    const parameters = {
      shaderID,
      shaderType: material.type,
      shaderName: material.name,
      vertexShader,
      fragmentShader,
      defines: material.defines,
      customVertexShaderID,
      customFragmentShaderID,
      isRawShaderMaterial: material.isRawShaderMaterial === true,
      glslVersion: material.glslVersion,
      precision,
      batching: IS_BATCHEDMESH,
      batchingColor: IS_BATCHEDMESH && object._colorsTexture !== null,
      instancing: IS_INSTANCEDMESH,
      instancingColor: IS_INSTANCEDMESH && object.instanceColor !== null,
      instancingMorph: IS_INSTANCEDMESH && object.morphTexture !== null,
      supportsVertexTextures: SUPPORTS_VERTEX_TEXTURES,
      outputColorSpace: currentRenderTarget === null ? renderer.outputColorSpace : currentRenderTarget.isXRRenderTarget === true ? currentRenderTarget.texture.colorSpace : LinearSRGBColorSpace$1,
      alphaToCoverage: !!material.alphaToCoverage,
      map: HAS_MAP,
      matcap: HAS_MATCAP,
      envMap: HAS_ENVMAP,
      envMapMode: HAS_ENVMAP && envMap.mapping,
      envMapCubeUVHeight,
      aoMap: HAS_AOMAP,
      lightMap: HAS_LIGHTMAP,
      bumpMap: HAS_BUMPMAP,
      normalMap: HAS_NORMALMAP,
      displacementMap: SUPPORTS_VERTEX_TEXTURES && HAS_DISPLACEMENTMAP,
      emissiveMap: HAS_EMISSIVEMAP,
      normalMapObjectSpace: HAS_NORMALMAP && material.normalMapType === ObjectSpaceNormalMap,
      normalMapTangentSpace: HAS_NORMALMAP && material.normalMapType === TangentSpaceNormalMap,
      metalnessMap: HAS_METALNESSMAP,
      roughnessMap: HAS_ROUGHNESSMAP,
      anisotropy: HAS_ANISOTROPY,
      anisotropyMap: HAS_ANISOTROPYMAP,
      clearcoat: HAS_CLEARCOAT,
      clearcoatMap: HAS_CLEARCOATMAP,
      clearcoatNormalMap: HAS_CLEARCOAT_NORMALMAP,
      clearcoatRoughnessMap: HAS_CLEARCOAT_ROUGHNESSMAP,
      dispersion: HAS_DISPERSION,
      iridescence: HAS_IRIDESCENCE,
      iridescenceMap: HAS_IRIDESCENCEMAP,
      iridescenceThicknessMap: HAS_IRIDESCENCE_THICKNESSMAP,
      sheen: HAS_SHEEN,
      sheenColorMap: HAS_SHEEN_COLORMAP,
      sheenRoughnessMap: HAS_SHEEN_ROUGHNESSMAP,
      specularMap: HAS_SPECULARMAP,
      specularColorMap: HAS_SPECULAR_COLORMAP,
      specularIntensityMap: HAS_SPECULAR_INTENSITYMAP,
      transmission: HAS_TRANSMISSION,
      transmissionMap: HAS_TRANSMISSIONMAP,
      thicknessMap: HAS_THICKNESSMAP,
      gradientMap: HAS_GRADIENTMAP,
      opaque: material.transparent === false && material.blending === NormalBlending && material.alphaToCoverage === false,
      alphaMap: HAS_ALPHAMAP,
      alphaTest: HAS_ALPHATEST,
      alphaHash: HAS_ALPHAHASH,
      combine: material.combine,
      //
      mapUv: HAS_MAP && getChannel(material.map.channel),
      aoMapUv: HAS_AOMAP && getChannel(material.aoMap.channel),
      lightMapUv: HAS_LIGHTMAP && getChannel(material.lightMap.channel),
      bumpMapUv: HAS_BUMPMAP && getChannel(material.bumpMap.channel),
      normalMapUv: HAS_NORMALMAP && getChannel(material.normalMap.channel),
      displacementMapUv: HAS_DISPLACEMENTMAP && getChannel(material.displacementMap.channel),
      emissiveMapUv: HAS_EMISSIVEMAP && getChannel(material.emissiveMap.channel),
      metalnessMapUv: HAS_METALNESSMAP && getChannel(material.metalnessMap.channel),
      roughnessMapUv: HAS_ROUGHNESSMAP && getChannel(material.roughnessMap.channel),
      anisotropyMapUv: HAS_ANISOTROPYMAP && getChannel(material.anisotropyMap.channel),
      clearcoatMapUv: HAS_CLEARCOATMAP && getChannel(material.clearcoatMap.channel),
      clearcoatNormalMapUv: HAS_CLEARCOAT_NORMALMAP && getChannel(material.clearcoatNormalMap.channel),
      clearcoatRoughnessMapUv: HAS_CLEARCOAT_ROUGHNESSMAP && getChannel(material.clearcoatRoughnessMap.channel),
      iridescenceMapUv: HAS_IRIDESCENCEMAP && getChannel(material.iridescenceMap.channel),
      iridescenceThicknessMapUv: HAS_IRIDESCENCE_THICKNESSMAP && getChannel(material.iridescenceThicknessMap.channel),
      sheenColorMapUv: HAS_SHEEN_COLORMAP && getChannel(material.sheenColorMap.channel),
      sheenRoughnessMapUv: HAS_SHEEN_ROUGHNESSMAP && getChannel(material.sheenRoughnessMap.channel),
      specularMapUv: HAS_SPECULARMAP && getChannel(material.specularMap.channel),
      specularColorMapUv: HAS_SPECULAR_COLORMAP && getChannel(material.specularColorMap.channel),
      specularIntensityMapUv: HAS_SPECULAR_INTENSITYMAP && getChannel(material.specularIntensityMap.channel),
      transmissionMapUv: HAS_TRANSMISSIONMAP && getChannel(material.transmissionMap.channel),
      thicknessMapUv: HAS_THICKNESSMAP && getChannel(material.thicknessMap.channel),
      alphaMapUv: HAS_ALPHAMAP && getChannel(material.alphaMap.channel),
      //
      vertexTangents: !!geometry.attributes.tangent && (HAS_NORMALMAP || HAS_ANISOTROPY),
      vertexColors: material.vertexColors,
      vertexAlphas: material.vertexColors === true && !!geometry.attributes.color && geometry.attributes.color.itemSize === 4,
      pointsUvs: object.isPoints === true && !!geometry.attributes.uv && (HAS_MAP || HAS_ALPHAMAP),
      fog: !!fog,
      useFog: material.fog === true,
      fogExp2: !!fog && fog.isFogExp2,
      flatShading: material.flatShading === true,
      sizeAttenuation: material.sizeAttenuation === true,
      logarithmicDepthBuffer,
      reverseDepthBuffer,
      skinning: object.isSkinnedMesh === true,
      morphTargets: geometry.morphAttributes.position !== void 0,
      morphNormals: geometry.morphAttributes.normal !== void 0,
      morphColors: geometry.morphAttributes.color !== void 0,
      morphTargetsCount,
      morphTextureStride,
      numDirLights: lights.directional.length,
      numPointLights: lights.point.length,
      numSpotLights: lights.spot.length,
      numSpotLightMaps: lights.spotLightMap.length,
      numRectAreaLights: lights.rectArea.length,
      numHemiLights: lights.hemi.length,
      numDirLightShadows: lights.directionalShadowMap.length,
      numPointLightShadows: lights.pointShadowMap.length,
      numSpotLightShadows: lights.spotShadowMap.length,
      numSpotLightShadowsWithMaps: lights.numSpotLightShadowsWithMaps,
      numLightProbes: lights.numLightProbes,
      numClippingPlanes: clipping.numPlanes,
      numClipIntersection: clipping.numIntersection,
      dithering: material.dithering,
      shadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,
      shadowMapType: renderer.shadowMap.type,
      toneMapping: toneMapping2,
      decodeVideoTexture: HAS_MAP && material.map.isVideoTexture === true && ColorManagement$1.getTransfer(material.map.colorSpace) === SRGBTransfer$1,
      decodeVideoTextureEmissive: HAS_EMISSIVEMAP && material.emissiveMap.isVideoTexture === true && ColorManagement$1.getTransfer(material.emissiveMap.colorSpace) === SRGBTransfer$1,
      premultipliedAlpha: material.premultipliedAlpha,
      doubleSided: material.side === DoubleSide,
      flipSided: material.side === BackSide,
      useDepthPacking: material.depthPacking >= 0,
      depthPacking: material.depthPacking || 0,
      index0AttributeName: material.index0AttributeName,
      extensionClipCullDistance: HAS_EXTENSIONS && material.extensions.clipCullDistance === true && extensions.has("WEBGL_clip_cull_distance"),
      extensionMultiDraw: (HAS_EXTENSIONS && material.extensions.multiDraw === true || IS_BATCHEDMESH) && extensions.has("WEBGL_multi_draw"),
      rendererExtensionParallelShaderCompile: extensions.has("KHR_parallel_shader_compile"),
      customProgramCacheKey: material.customProgramCacheKey()
    };
    parameters.vertexUv1s = _activeChannels.has(1);
    parameters.vertexUv2s = _activeChannels.has(2);
    parameters.vertexUv3s = _activeChannels.has(3);
    _activeChannels.clear();
    return parameters;
  }
  function getProgramCacheKey(parameters) {
    const array = [];
    if (parameters.shaderID) {
      array.push(parameters.shaderID);
    } else {
      array.push(parameters.customVertexShaderID);
      array.push(parameters.customFragmentShaderID);
    }
    if (parameters.defines !== void 0) {
      for (const name in parameters.defines) {
        array.push(name);
        array.push(parameters.defines[name]);
      }
    }
    if (parameters.isRawShaderMaterial === false) {
      getProgramCacheKeyParameters(array, parameters);
      getProgramCacheKeyBooleans(array, parameters);
      array.push(renderer.outputColorSpace);
    }
    array.push(parameters.customProgramCacheKey);
    return array.join();
  }
  function getProgramCacheKeyParameters(array, parameters) {
    array.push(parameters.precision);
    array.push(parameters.outputColorSpace);
    array.push(parameters.envMapMode);
    array.push(parameters.envMapCubeUVHeight);
    array.push(parameters.mapUv);
    array.push(parameters.alphaMapUv);
    array.push(parameters.lightMapUv);
    array.push(parameters.aoMapUv);
    array.push(parameters.bumpMapUv);
    array.push(parameters.normalMapUv);
    array.push(parameters.displacementMapUv);
    array.push(parameters.emissiveMapUv);
    array.push(parameters.metalnessMapUv);
    array.push(parameters.roughnessMapUv);
    array.push(parameters.anisotropyMapUv);
    array.push(parameters.clearcoatMapUv);
    array.push(parameters.clearcoatNormalMapUv);
    array.push(parameters.clearcoatRoughnessMapUv);
    array.push(parameters.iridescenceMapUv);
    array.push(parameters.iridescenceThicknessMapUv);
    array.push(parameters.sheenColorMapUv);
    array.push(parameters.sheenRoughnessMapUv);
    array.push(parameters.specularMapUv);
    array.push(parameters.specularColorMapUv);
    array.push(parameters.specularIntensityMapUv);
    array.push(parameters.transmissionMapUv);
    array.push(parameters.thicknessMapUv);
    array.push(parameters.combine);
    array.push(parameters.fogExp2);
    array.push(parameters.sizeAttenuation);
    array.push(parameters.morphTargetsCount);
    array.push(parameters.morphAttributeCount);
    array.push(parameters.numDirLights);
    array.push(parameters.numPointLights);
    array.push(parameters.numSpotLights);
    array.push(parameters.numSpotLightMaps);
    array.push(parameters.numHemiLights);
    array.push(parameters.numRectAreaLights);
    array.push(parameters.numDirLightShadows);
    array.push(parameters.numPointLightShadows);
    array.push(parameters.numSpotLightShadows);
    array.push(parameters.numSpotLightShadowsWithMaps);
    array.push(parameters.numLightProbes);
    array.push(parameters.shadowMapType);
    array.push(parameters.toneMapping);
    array.push(parameters.numClippingPlanes);
    array.push(parameters.numClipIntersection);
    array.push(parameters.depthPacking);
  }
  function getProgramCacheKeyBooleans(array, parameters) {
    _programLayers.disableAll();
    if (parameters.supportsVertexTextures)
      _programLayers.enable(0);
    if (parameters.instancing)
      _programLayers.enable(1);
    if (parameters.instancingColor)
      _programLayers.enable(2);
    if (parameters.instancingMorph)
      _programLayers.enable(3);
    if (parameters.matcap)
      _programLayers.enable(4);
    if (parameters.envMap)
      _programLayers.enable(5);
    if (parameters.normalMapObjectSpace)
      _programLayers.enable(6);
    if (parameters.normalMapTangentSpace)
      _programLayers.enable(7);
    if (parameters.clearcoat)
      _programLayers.enable(8);
    if (parameters.iridescence)
      _programLayers.enable(9);
    if (parameters.alphaTest)
      _programLayers.enable(10);
    if (parameters.vertexColors)
      _programLayers.enable(11);
    if (parameters.vertexAlphas)
      _programLayers.enable(12);
    if (parameters.vertexUv1s)
      _programLayers.enable(13);
    if (parameters.vertexUv2s)
      _programLayers.enable(14);
    if (parameters.vertexUv3s)
      _programLayers.enable(15);
    if (parameters.vertexTangents)
      _programLayers.enable(16);
    if (parameters.anisotropy)
      _programLayers.enable(17);
    if (parameters.alphaHash)
      _programLayers.enable(18);
    if (parameters.batching)
      _programLayers.enable(19);
    if (parameters.dispersion)
      _programLayers.enable(20);
    if (parameters.batchingColor)
      _programLayers.enable(21);
    array.push(_programLayers.mask);
    _programLayers.disableAll();
    if (parameters.fog)
      _programLayers.enable(0);
    if (parameters.useFog)
      _programLayers.enable(1);
    if (parameters.flatShading)
      _programLayers.enable(2);
    if (parameters.logarithmicDepthBuffer)
      _programLayers.enable(3);
    if (parameters.reverseDepthBuffer)
      _programLayers.enable(4);
    if (parameters.skinning)
      _programLayers.enable(5);
    if (parameters.morphTargets)
      _programLayers.enable(6);
    if (parameters.morphNormals)
      _programLayers.enable(7);
    if (parameters.morphColors)
      _programLayers.enable(8);
    if (parameters.premultipliedAlpha)
      _programLayers.enable(9);
    if (parameters.shadowMapEnabled)
      _programLayers.enable(10);
    if (parameters.doubleSided)
      _programLayers.enable(11);
    if (parameters.flipSided)
      _programLayers.enable(12);
    if (parameters.useDepthPacking)
      _programLayers.enable(13);
    if (parameters.dithering)
      _programLayers.enable(14);
    if (parameters.transmission)
      _programLayers.enable(15);
    if (parameters.sheen)
      _programLayers.enable(16);
    if (parameters.opaque)
      _programLayers.enable(17);
    if (parameters.pointsUvs)
      _programLayers.enable(18);
    if (parameters.decodeVideoTexture)
      _programLayers.enable(19);
    if (parameters.decodeVideoTextureEmissive)
      _programLayers.enable(20);
    if (parameters.alphaToCoverage)
      _programLayers.enable(21);
    array.push(_programLayers.mask);
  }
  function getUniforms(material) {
    const shaderID = shaderIDs[material.type];
    let uniforms;
    if (shaderID) {
      const shader = ShaderLib[shaderID];
      uniforms = UniformsUtils.clone(shader.uniforms);
    } else {
      uniforms = material.uniforms;
    }
    return uniforms;
  }
  function acquireProgram(parameters, cacheKey) {
    let program;
    for (let p = 0, pl = programs.length; p < pl; p++) {
      const preexistingProgram = programs[p];
      if (preexistingProgram.cacheKey === cacheKey) {
        program = preexistingProgram;
        ++program.usedTimes;
        break;
      }
    }
    if (program === void 0) {
      program = new WebGLProgram(renderer, cacheKey, parameters, bindingStates);
      programs.push(program);
    }
    return program;
  }
  function releaseProgram(program) {
    if (--program.usedTimes === 0) {
      const i = programs.indexOf(program);
      programs[i] = programs[programs.length - 1];
      programs.pop();
      program.destroy();
    }
  }
  function releaseShaderCache(material) {
    _customShaders.remove(material);
  }
  function dispose() {
    _customShaders.dispose();
  }
  return {
    getParameters,
    getProgramCacheKey,
    getUniforms,
    acquireProgram,
    releaseProgram,
    releaseShaderCache,
    // Exposed for resource monitoring & error feedback via renderer.info:
    programs,
    dispose
  };
}
function WebGLProperties() {
  let properties = /* @__PURE__ */ new WeakMap();
  function has(object) {
    return properties.has(object);
  }
  function get(object) {
    let map = properties.get(object);
    if (map === void 0) {
      map = {};
      properties.set(object, map);
    }
    return map;
  }
  function remove(object) {
    properties.delete(object);
  }
  function update(object, key, value) {
    properties.get(object)[key] = value;
  }
  function dispose() {
    properties = /* @__PURE__ */ new WeakMap();
  }
  return {
    has,
    get,
    remove,
    update,
    dispose
  };
}
function painterSortStable(a, b) {
  if (a.groupOrder !== b.groupOrder) {
    return a.groupOrder - b.groupOrder;
  } else if (a.renderOrder !== b.renderOrder) {
    return a.renderOrder - b.renderOrder;
  } else if (a.material.id !== b.material.id) {
    return a.material.id - b.material.id;
  } else if (a.z !== b.z) {
    return a.z - b.z;
  } else {
    return a.id - b.id;
  }
}
function reversePainterSortStable(a, b) {
  if (a.groupOrder !== b.groupOrder) {
    return a.groupOrder - b.groupOrder;
  } else if (a.renderOrder !== b.renderOrder) {
    return a.renderOrder - b.renderOrder;
  } else if (a.z !== b.z) {
    return b.z - a.z;
  } else {
    return a.id - b.id;
  }
}
function WebGLRenderList() {
  const renderItems = [];
  let renderItemsIndex = 0;
  const opaque = [];
  const transmissive = [];
  const transparent = [];
  function init() {
    renderItemsIndex = 0;
    opaque.length = 0;
    transmissive.length = 0;
    transparent.length = 0;
  }
  function getNextRenderItem(object, geometry, material, groupOrder, z, group) {
    let renderItem = renderItems[renderItemsIndex];
    if (renderItem === void 0) {
      renderItem = {
        id: object.id,
        object,
        geometry,
        material,
        groupOrder,
        renderOrder: object.renderOrder,
        z,
        group
      };
      renderItems[renderItemsIndex] = renderItem;
    } else {
      renderItem.id = object.id;
      renderItem.object = object;
      renderItem.geometry = geometry;
      renderItem.material = material;
      renderItem.groupOrder = groupOrder;
      renderItem.renderOrder = object.renderOrder;
      renderItem.z = z;
      renderItem.group = group;
    }
    renderItemsIndex++;
    return renderItem;
  }
  function push(object, geometry, material, groupOrder, z, group) {
    const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);
    if (material.transmission > 0) {
      transmissive.push(renderItem);
    } else if (material.transparent === true) {
      transparent.push(renderItem);
    } else {
      opaque.push(renderItem);
    }
  }
  function unshift(object, geometry, material, groupOrder, z, group) {
    const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);
    if (material.transmission > 0) {
      transmissive.unshift(renderItem);
    } else if (material.transparent === true) {
      transparent.unshift(renderItem);
    } else {
      opaque.unshift(renderItem);
    }
  }
  function sort(customOpaqueSort, customTransparentSort) {
    if (opaque.length > 1) opaque.sort(customOpaqueSort || painterSortStable);
    if (transmissive.length > 1) transmissive.sort(customTransparentSort || reversePainterSortStable);
    if (transparent.length > 1) transparent.sort(customTransparentSort || reversePainterSortStable);
  }
  function finish() {
    for (let i = renderItemsIndex, il = renderItems.length; i < il; i++) {
      const renderItem = renderItems[i];
      if (renderItem.id === null) break;
      renderItem.id = null;
      renderItem.object = null;
      renderItem.geometry = null;
      renderItem.material = null;
      renderItem.group = null;
    }
  }
  return {
    opaque,
    transmissive,
    transparent,
    init,
    push,
    unshift,
    finish,
    sort
  };
}
function WebGLRenderLists() {
  let lists = /* @__PURE__ */ new WeakMap();
  function get(scene, renderCallDepth) {
    const listArray = lists.get(scene);
    let list;
    if (listArray === void 0) {
      list = new WebGLRenderList();
      lists.set(scene, [list]);
    } else {
      if (renderCallDepth >= listArray.length) {
        list = new WebGLRenderList();
        listArray.push(list);
      } else {
        list = listArray[renderCallDepth];
      }
    }
    return list;
  }
  function dispose() {
    lists = /* @__PURE__ */ new WeakMap();
  }
  return {
    get,
    dispose
  };
}
function UniformsCache() {
  const lights = {};
  return {
    get: function(light) {
      if (lights[light.id] !== void 0) {
        return lights[light.id];
      }
      let uniforms;
      switch (light.type) {
        case "DirectionalLight":
          uniforms = {
            direction: new Vector3$1(),
            color: new Color$1()
          };
          break;
        case "SpotLight":
          uniforms = {
            position: new Vector3$1(),
            direction: new Vector3$1(),
            color: new Color$1(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0
          };
          break;
        case "PointLight":
          uniforms = {
            position: new Vector3$1(),
            color: new Color$1(),
            distance: 0,
            decay: 0
          };
          break;
        case "HemisphereLight":
          uniforms = {
            direction: new Vector3$1(),
            skyColor: new Color$1(),
            groundColor: new Color$1()
          };
          break;
        case "RectAreaLight":
          uniforms = {
            color: new Color$1(),
            position: new Vector3$1(),
            halfWidth: new Vector3$1(),
            halfHeight: new Vector3$1()
          };
          break;
      }
      lights[light.id] = uniforms;
      return uniforms;
    }
  };
}
function ShadowUniformsCache() {
  const lights = {};
  return {
    get: function(light) {
      if (lights[light.id] !== void 0) {
        return lights[light.id];
      }
      let uniforms;
      switch (light.type) {
        case "DirectionalLight":
          uniforms = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2$1()
          };
          break;
        case "SpotLight":
          uniforms = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2$1()
          };
          break;
        case "PointLight":
          uniforms = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2$1(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3
          };
          break;
      }
      lights[light.id] = uniforms;
      return uniforms;
    }
  };
}
let nextVersion = 0;
function shadowCastingAndTexturingLightsFirst(lightA, lightB) {
  return (lightB.castShadow ? 2 : 0) - (lightA.castShadow ? 2 : 0) + (lightB.map ? 1 : 0) - (lightA.map ? 1 : 0);
}
function WebGLLights(extensions) {
  const cache2 = new UniformsCache();
  const shadowCache = ShadowUniformsCache();
  const state = {
    version: 0,
    hash: {
      directionalLength: -1,
      pointLength: -1,
      spotLength: -1,
      rectAreaLength: -1,
      hemiLength: -1,
      numDirectionalShadows: -1,
      numPointShadows: -1,
      numSpotShadows: -1,
      numSpotMaps: -1,
      numLightProbes: -1
    },
    ambient: [0, 0, 0],
    probe: [],
    directional: [],
    directionalShadow: [],
    directionalShadowMap: [],
    directionalShadowMatrix: [],
    spot: [],
    spotLightMap: [],
    spotShadow: [],
    spotShadowMap: [],
    spotLightMatrix: [],
    rectArea: [],
    rectAreaLTC1: null,
    rectAreaLTC2: null,
    point: [],
    pointShadow: [],
    pointShadowMap: [],
    pointShadowMatrix: [],
    hemi: [],
    numSpotLightShadowsWithMaps: 0,
    numLightProbes: 0
  };
  for (let i = 0; i < 9; i++) state.probe.push(new Vector3$1());
  const vector3 = new Vector3$1();
  const matrix4 = new Matrix4$1();
  const matrix42 = new Matrix4$1();
  function setup(lights) {
    let r = 0, g = 0, b = 0;
    for (let i = 0; i < 9; i++) state.probe[i].set(0, 0, 0);
    let directionalLength = 0;
    let pointLength = 0;
    let spotLength = 0;
    let rectAreaLength = 0;
    let hemiLength = 0;
    let numDirectionalShadows = 0;
    let numPointShadows = 0;
    let numSpotShadows = 0;
    let numSpotMaps = 0;
    let numSpotShadowsWithMaps = 0;
    let numLightProbes = 0;
    lights.sort(shadowCastingAndTexturingLightsFirst);
    for (let i = 0, l = lights.length; i < l; i++) {
      const light = lights[i];
      const color2 = light.color;
      const intensity = light.intensity;
      const distance2 = light.distance;
      const shadowMap = light.shadow && light.shadow.map ? light.shadow.map.texture : null;
      if (light.isAmbientLight) {
        r += color2.r * intensity;
        g += color2.g * intensity;
        b += color2.b * intensity;
      } else if (light.isLightProbe) {
        for (let j = 0; j < 9; j++) {
          state.probe[j].addScaledVector(light.sh.coefficients[j], intensity);
        }
        numLightProbes++;
      } else if (light.isDirectionalLight) {
        const uniforms = cache2.get(light);
        uniforms.color.copy(light.color).multiplyScalar(light.intensity);
        if (light.castShadow) {
          const shadow = light.shadow;
          const shadowUniforms = shadowCache.get(light);
          shadowUniforms.shadowIntensity = shadow.intensity;
          shadowUniforms.shadowBias = shadow.bias;
          shadowUniforms.shadowNormalBias = shadow.normalBias;
          shadowUniforms.shadowRadius = shadow.radius;
          shadowUniforms.shadowMapSize = shadow.mapSize;
          state.directionalShadow[directionalLength] = shadowUniforms;
          state.directionalShadowMap[directionalLength] = shadowMap;
          state.directionalShadowMatrix[directionalLength] = light.shadow.matrix;
          numDirectionalShadows++;
        }
        state.directional[directionalLength] = uniforms;
        directionalLength++;
      } else if (light.isSpotLight) {
        const uniforms = cache2.get(light);
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.color.copy(color2).multiplyScalar(intensity);
        uniforms.distance = distance2;
        uniforms.coneCos = Math.cos(light.angle);
        uniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra));
        uniforms.decay = light.decay;
        state.spot[spotLength] = uniforms;
        const shadow = light.shadow;
        if (light.map) {
          state.spotLightMap[numSpotMaps] = light.map;
          numSpotMaps++;
          shadow.updateMatrices(light);
          if (light.castShadow) numSpotShadowsWithMaps++;
        }
        state.spotLightMatrix[spotLength] = shadow.matrix;
        if (light.castShadow) {
          const shadowUniforms = shadowCache.get(light);
          shadowUniforms.shadowIntensity = shadow.intensity;
          shadowUniforms.shadowBias = shadow.bias;
          shadowUniforms.shadowNormalBias = shadow.normalBias;
          shadowUniforms.shadowRadius = shadow.radius;
          shadowUniforms.shadowMapSize = shadow.mapSize;
          state.spotShadow[spotLength] = shadowUniforms;
          state.spotShadowMap[spotLength] = shadowMap;
          numSpotShadows++;
        }
        spotLength++;
      } else if (light.isRectAreaLight) {
        const uniforms = cache2.get(light);
        uniforms.color.copy(color2).multiplyScalar(intensity);
        uniforms.halfWidth.set(light.width * 0.5, 0, 0);
        uniforms.halfHeight.set(0, light.height * 0.5, 0);
        state.rectArea[rectAreaLength] = uniforms;
        rectAreaLength++;
      } else if (light.isPointLight) {
        const uniforms = cache2.get(light);
        uniforms.color.copy(light.color).multiplyScalar(light.intensity);
        uniforms.distance = light.distance;
        uniforms.decay = light.decay;
        if (light.castShadow) {
          const shadow = light.shadow;
          const shadowUniforms = shadowCache.get(light);
          shadowUniforms.shadowIntensity = shadow.intensity;
          shadowUniforms.shadowBias = shadow.bias;
          shadowUniforms.shadowNormalBias = shadow.normalBias;
          shadowUniforms.shadowRadius = shadow.radius;
          shadowUniforms.shadowMapSize = shadow.mapSize;
          shadowUniforms.shadowCameraNear = shadow.camera.near;
          shadowUniforms.shadowCameraFar = shadow.camera.far;
          state.pointShadow[pointLength] = shadowUniforms;
          state.pointShadowMap[pointLength] = shadowMap;
          state.pointShadowMatrix[pointLength] = light.shadow.matrix;
          numPointShadows++;
        }
        state.point[pointLength] = uniforms;
        pointLength++;
      } else if (light.isHemisphereLight) {
        const uniforms = cache2.get(light);
        uniforms.skyColor.copy(light.color).multiplyScalar(intensity);
        uniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity);
        state.hemi[hemiLength] = uniforms;
        hemiLength++;
      }
    }
    if (rectAreaLength > 0) {
      if (extensions.has("OES_texture_float_linear") === true) {
        state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
        state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;
      } else {
        state.rectAreaLTC1 = UniformsLib.LTC_HALF_1;
        state.rectAreaLTC2 = UniformsLib.LTC_HALF_2;
      }
    }
    state.ambient[0] = r;
    state.ambient[1] = g;
    state.ambient[2] = b;
    const hash2 = state.hash;
    if (hash2.directionalLength !== directionalLength || hash2.pointLength !== pointLength || hash2.spotLength !== spotLength || hash2.rectAreaLength !== rectAreaLength || hash2.hemiLength !== hemiLength || hash2.numDirectionalShadows !== numDirectionalShadows || hash2.numPointShadows !== numPointShadows || hash2.numSpotShadows !== numSpotShadows || hash2.numSpotMaps !== numSpotMaps || hash2.numLightProbes !== numLightProbes) {
      state.directional.length = directionalLength;
      state.spot.length = spotLength;
      state.rectArea.length = rectAreaLength;
      state.point.length = pointLength;
      state.hemi.length = hemiLength;
      state.directionalShadow.length = numDirectionalShadows;
      state.directionalShadowMap.length = numDirectionalShadows;
      state.pointShadow.length = numPointShadows;
      state.pointShadowMap.length = numPointShadows;
      state.spotShadow.length = numSpotShadows;
      state.spotShadowMap.length = numSpotShadows;
      state.directionalShadowMatrix.length = numDirectionalShadows;
      state.pointShadowMatrix.length = numPointShadows;
      state.spotLightMatrix.length = numSpotShadows + numSpotMaps - numSpotShadowsWithMaps;
      state.spotLightMap.length = numSpotMaps;
      state.numSpotLightShadowsWithMaps = numSpotShadowsWithMaps;
      state.numLightProbes = numLightProbes;
      hash2.directionalLength = directionalLength;
      hash2.pointLength = pointLength;
      hash2.spotLength = spotLength;
      hash2.rectAreaLength = rectAreaLength;
      hash2.hemiLength = hemiLength;
      hash2.numDirectionalShadows = numDirectionalShadows;
      hash2.numPointShadows = numPointShadows;
      hash2.numSpotShadows = numSpotShadows;
      hash2.numSpotMaps = numSpotMaps;
      hash2.numLightProbes = numLightProbes;
      state.version = nextVersion++;
    }
  }
  function setupView(lights, camera) {
    let directionalLength = 0;
    let pointLength = 0;
    let spotLength = 0;
    let rectAreaLength = 0;
    let hemiLength = 0;
    const viewMatrix = camera.matrixWorldInverse;
    for (let i = 0, l = lights.length; i < l; i++) {
      const light = lights[i];
      if (light.isDirectionalLight) {
        const uniforms = state.directional[directionalLength];
        uniforms.direction.setFromMatrixPosition(light.matrixWorld);
        vector3.setFromMatrixPosition(light.target.matrixWorld);
        uniforms.direction.sub(vector3);
        uniforms.direction.transformDirection(viewMatrix);
        directionalLength++;
      } else if (light.isSpotLight) {
        const uniforms = state.spot[spotLength];
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.position.applyMatrix4(viewMatrix);
        uniforms.direction.setFromMatrixPosition(light.matrixWorld);
        vector3.setFromMatrixPosition(light.target.matrixWorld);
        uniforms.direction.sub(vector3);
        uniforms.direction.transformDirection(viewMatrix);
        spotLength++;
      } else if (light.isRectAreaLight) {
        const uniforms = state.rectArea[rectAreaLength];
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.position.applyMatrix4(viewMatrix);
        matrix42.identity();
        matrix4.copy(light.matrixWorld);
        matrix4.premultiply(viewMatrix);
        matrix42.extractRotation(matrix4);
        uniforms.halfWidth.set(light.width * 0.5, 0, 0);
        uniforms.halfHeight.set(0, light.height * 0.5, 0);
        uniforms.halfWidth.applyMatrix4(matrix42);
        uniforms.halfHeight.applyMatrix4(matrix42);
        rectAreaLength++;
      } else if (light.isPointLight) {
        const uniforms = state.point[pointLength];
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.position.applyMatrix4(viewMatrix);
        pointLength++;
      } else if (light.isHemisphereLight) {
        const uniforms = state.hemi[hemiLength];
        uniforms.direction.setFromMatrixPosition(light.matrixWorld);
        uniforms.direction.transformDirection(viewMatrix);
        hemiLength++;
      }
    }
  }
  return {
    setup,
    setupView,
    state
  };
}
function WebGLRenderState(extensions) {
  const lights = new WebGLLights(extensions);
  const lightsArray = [];
  const shadowsArray = [];
  function init(camera) {
    state.camera = camera;
    lightsArray.length = 0;
    shadowsArray.length = 0;
  }
  function pushLight(light) {
    lightsArray.push(light);
  }
  function pushShadow(shadowLight) {
    shadowsArray.push(shadowLight);
  }
  function setupLights() {
    lights.setup(lightsArray);
  }
  function setupLightsView(camera) {
    lights.setupView(lightsArray, camera);
  }
  const state = {
    lightsArray,
    shadowsArray,
    camera: null,
    lights,
    transmissionRenderTarget: {}
  };
  return {
    init,
    state,
    setupLights,
    setupLightsView,
    pushLight,
    pushShadow
  };
}
function WebGLRenderStates(extensions) {
  let renderStates = /* @__PURE__ */ new WeakMap();
  function get(scene, renderCallDepth = 0) {
    const renderStateArray = renderStates.get(scene);
    let renderState;
    if (renderStateArray === void 0) {
      renderState = new WebGLRenderState(extensions);
      renderStates.set(scene, [renderState]);
    } else {
      if (renderCallDepth >= renderStateArray.length) {
        renderState = new WebGLRenderState(extensions);
        renderStateArray.push(renderState);
      } else {
        renderState = renderStateArray[renderCallDepth];
      }
    }
    return renderState;
  }
  function dispose() {
    renderStates = /* @__PURE__ */ new WeakMap();
  }
  return {
    get,
    dispose
  };
}
const vertex = "void main() {\n	gl_Position = vec4( position, 1.0 );\n}";
const fragment = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n	const float samples = float( VSM_SAMPLES );\n	float mean = 0.0;\n	float squared_mean = 0.0;\n	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n	for ( float i = 0.0; i < samples; i ++ ) {\n		float uvOffset = uvStart + i * uvStride;\n		#ifdef HORIZONTAL_PASS\n			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n			mean += distribution.x;\n			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n		#else\n			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n			mean += depth;\n			squared_mean += depth * depth;\n		#endif\n	}\n	mean = mean / samples;\n	squared_mean = squared_mean / samples;\n	float std_dev = sqrt( squared_mean - mean * mean );\n	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";
function WebGLShadowMap(renderer, objects, capabilities) {
  let _frustum2 = new Frustum();
  const _shadowMapSize = new Vector2$1(), _viewportSize = new Vector2$1(), _viewport = new Vector4$1(), _depthMaterial = new MeshDepthMaterial({ depthPacking: RGBADepthPacking }), _distanceMaterial = new MeshDistanceMaterial(), _materialCache = {}, _maxTextureSize = capabilities.maxTextureSize;
  const shadowSide = { [FrontSide]: BackSide, [BackSide]: FrontSide, [DoubleSide]: DoubleSide };
  const shadowMaterialVertical = new ShaderMaterial({
    defines: {
      VSM_SAMPLES: 8
    },
    uniforms: {
      shadow_pass: { value: null },
      resolution: { value: new Vector2$1() },
      radius: { value: 4 }
    },
    vertexShader: vertex,
    fragmentShader: fragment
  });
  const shadowMaterialHorizontal = shadowMaterialVertical.clone();
  shadowMaterialHorizontal.defines.HORIZONTAL_PASS = 1;
  const fullScreenTri = new BufferGeometry();
  fullScreenTri.setAttribute(
    "position",
    new BufferAttribute$1(
      new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]),
      3
    )
  );
  const fullScreenMesh = new Mesh(fullScreenTri, shadowMaterialVertical);
  const scope = this;
  this.enabled = false;
  this.autoUpdate = true;
  this.needsUpdate = false;
  this.type = PCFShadowMap;
  let _previousType = this.type;
  this.render = function(lights, scene, camera) {
    if (scope.enabled === false) return;
    if (scope.autoUpdate === false && scope.needsUpdate === false) return;
    if (lights.length === 0) return;
    const currentRenderTarget = renderer.getRenderTarget();
    const activeCubeFace = renderer.getActiveCubeFace();
    const activeMipmapLevel = renderer.getActiveMipmapLevel();
    const _state = renderer.state;
    _state.setBlending(NoBlending);
    _state.buffers.color.setClear(1, 1, 1, 1);
    _state.buffers.depth.setTest(true);
    _state.setScissorTest(false);
    const toVSM = _previousType !== VSMShadowMap && this.type === VSMShadowMap;
    const fromVSM = _previousType === VSMShadowMap && this.type !== VSMShadowMap;
    for (let i = 0, il = lights.length; i < il; i++) {
      const light = lights[i];
      const shadow = light.shadow;
      if (shadow === void 0) {
        console.warn("THREE.WebGLShadowMap:", light, "has no shadow.");
        continue;
      }
      if (shadow.autoUpdate === false && shadow.needsUpdate === false) continue;
      _shadowMapSize.copy(shadow.mapSize);
      const shadowFrameExtents = shadow.getFrameExtents();
      _shadowMapSize.multiply(shadowFrameExtents);
      _viewportSize.copy(shadow.mapSize);
      if (_shadowMapSize.x > _maxTextureSize || _shadowMapSize.y > _maxTextureSize) {
        if (_shadowMapSize.x > _maxTextureSize) {
          _viewportSize.x = Math.floor(_maxTextureSize / shadowFrameExtents.x);
          _shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;
          shadow.mapSize.x = _viewportSize.x;
        }
        if (_shadowMapSize.y > _maxTextureSize) {
          _viewportSize.y = Math.floor(_maxTextureSize / shadowFrameExtents.y);
          _shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;
          shadow.mapSize.y = _viewportSize.y;
        }
      }
      if (shadow.map === null || toVSM === true || fromVSM === true) {
        const pars = this.type !== VSMShadowMap ? { minFilter: NearestFilter, magFilter: NearestFilter } : {};
        if (shadow.map !== null) {
          shadow.map.dispose();
        }
        shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
        shadow.map.texture.name = light.name + ".shadowMap";
        shadow.camera.updateProjectionMatrix();
      }
      renderer.setRenderTarget(shadow.map);
      renderer.clear();
      const viewportCount = shadow.getViewportCount();
      for (let vp = 0; vp < viewportCount; vp++) {
        const viewport = shadow.getViewport(vp);
        _viewport.set(
          _viewportSize.x * viewport.x,
          _viewportSize.y * viewport.y,
          _viewportSize.x * viewport.z,
          _viewportSize.y * viewport.w
        );
        _state.viewport(_viewport);
        shadow.updateMatrices(light, vp);
        _frustum2 = shadow.getFrustum();
        renderObject(scene, camera, shadow.camera, light, this.type);
      }
      if (shadow.isPointLightShadow !== true && this.type === VSMShadowMap) {
        VSMPass(shadow, camera);
      }
      shadow.needsUpdate = false;
    }
    _previousType = this.type;
    scope.needsUpdate = false;
    renderer.setRenderTarget(currentRenderTarget, activeCubeFace, activeMipmapLevel);
  };
  function VSMPass(shadow, camera) {
    const geometry = objects.update(fullScreenMesh);
    if (shadowMaterialVertical.defines.VSM_SAMPLES !== shadow.blurSamples) {
      shadowMaterialVertical.defines.VSM_SAMPLES = shadow.blurSamples;
      shadowMaterialHorizontal.defines.VSM_SAMPLES = shadow.blurSamples;
      shadowMaterialVertical.needsUpdate = true;
      shadowMaterialHorizontal.needsUpdate = true;
    }
    if (shadow.mapPass === null) {
      shadow.mapPass = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y);
    }
    shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;
    shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;
    shadowMaterialVertical.uniforms.radius.value = shadow.radius;
    renderer.setRenderTarget(shadow.mapPass);
    renderer.clear();
    renderer.renderBufferDirect(camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null);
    shadowMaterialHorizontal.uniforms.shadow_pass.value = shadow.mapPass.texture;
    shadowMaterialHorizontal.uniforms.resolution.value = shadow.mapSize;
    shadowMaterialHorizontal.uniforms.radius.value = shadow.radius;
    renderer.setRenderTarget(shadow.map);
    renderer.clear();
    renderer.renderBufferDirect(camera, null, geometry, shadowMaterialHorizontal, fullScreenMesh, null);
  }
  function getDepthMaterial(object, material, light, type) {
    let result = null;
    const customMaterial = light.isPointLight === true ? object.customDistanceMaterial : object.customDepthMaterial;
    if (customMaterial !== void 0) {
      result = customMaterial;
    } else {
      result = light.isPointLight === true ? _distanceMaterial : _depthMaterial;
      if (renderer.localClippingEnabled && material.clipShadows === true && Array.isArray(material.clippingPlanes) && material.clippingPlanes.length !== 0 || material.displacementMap && material.displacementScale !== 0 || material.alphaMap && material.alphaTest > 0 || material.map && material.alphaTest > 0) {
        const keyA = result.uuid, keyB = material.uuid;
        let materialsForVariant = _materialCache[keyA];
        if (materialsForVariant === void 0) {
          materialsForVariant = {};
          _materialCache[keyA] = materialsForVariant;
        }
        let cachedMaterial = materialsForVariant[keyB];
        if (cachedMaterial === void 0) {
          cachedMaterial = result.clone();
          materialsForVariant[keyB] = cachedMaterial;
          material.addEventListener("dispose", onMaterialDispose);
        }
        result = cachedMaterial;
      }
    }
    result.visible = material.visible;
    result.wireframe = material.wireframe;
    if (type === VSMShadowMap) {
      result.side = material.shadowSide !== null ? material.shadowSide : material.side;
    } else {
      result.side = material.shadowSide !== null ? material.shadowSide : shadowSide[material.side];
    }
    result.alphaMap = material.alphaMap;
    result.alphaTest = material.alphaTest;
    result.map = material.map;
    result.clipShadows = material.clipShadows;
    result.clippingPlanes = material.clippingPlanes;
    result.clipIntersection = material.clipIntersection;
    result.displacementMap = material.displacementMap;
    result.displacementScale = material.displacementScale;
    result.displacementBias = material.displacementBias;
    result.wireframeLinewidth = material.wireframeLinewidth;
    result.linewidth = material.linewidth;
    if (light.isPointLight === true && result.isMeshDistanceMaterial === true) {
      const materialProperties = renderer.properties.get(result);
      materialProperties.light = light;
    }
    return result;
  }
  function renderObject(object, camera, shadowCamera, light, type) {
    if (object.visible === false) return;
    const visible = object.layers.test(camera.layers);
    if (visible && (object.isMesh || object.isLine || object.isPoints)) {
      if ((object.castShadow || object.receiveShadow && type === VSMShadowMap) && (!object.frustumCulled || _frustum2.intersectsObject(object))) {
        object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);
        const geometry = objects.update(object);
        const material = object.material;
        if (Array.isArray(material)) {
          const groups = geometry.groups;
          for (let k = 0, kl = groups.length; k < kl; k++) {
            const group = groups[k];
            const groupMaterial = material[group.materialIndex];
            if (groupMaterial && groupMaterial.visible) {
              const depthMaterial = getDepthMaterial(object, groupMaterial, light, type);
              object.onBeforeShadow(renderer, object, camera, shadowCamera, geometry, depthMaterial, group);
              renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, group);
              object.onAfterShadow(renderer, object, camera, shadowCamera, geometry, depthMaterial, group);
            }
          }
        } else if (material.visible) {
          const depthMaterial = getDepthMaterial(object, material, light, type);
          object.onBeforeShadow(renderer, object, camera, shadowCamera, geometry, depthMaterial, null);
          renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, null);
          object.onAfterShadow(renderer, object, camera, shadowCamera, geometry, depthMaterial, null);
        }
      }
    }
    const children = object.children;
    for (let i = 0, l = children.length; i < l; i++) {
      renderObject(children[i], camera, shadowCamera, light, type);
    }
  }
  function onMaterialDispose(event) {
    const material = event.target;
    material.removeEventListener("dispose", onMaterialDispose);
    for (const id in _materialCache) {
      const cache2 = _materialCache[id];
      const uuid = event.target.uuid;
      if (uuid in cache2) {
        const shadowMaterial = cache2[uuid];
        shadowMaterial.dispose();
        delete cache2[uuid];
      }
    }
  }
}
const reversedFuncs = {
  [NeverDepth]: AlwaysDepth,
  [LessDepth]: GreaterDepth,
  [EqualDepth]: NotEqualDepth,
  [LessEqualDepth]: GreaterEqualDepth,
  [AlwaysDepth]: NeverDepth,
  [GreaterDepth]: LessDepth,
  [NotEqualDepth]: EqualDepth,
  [GreaterEqualDepth]: LessEqualDepth
};
function WebGLState(gl, extensions) {
  function ColorBuffer() {
    let locked = false;
    const color2 = new Vector4$1();
    let currentColorMask = null;
    const currentColorClear = new Vector4$1(0, 0, 0, 0);
    return {
      setMask: function(colorMask) {
        if (currentColorMask !== colorMask && !locked) {
          gl.colorMask(colorMask, colorMask, colorMask, colorMask);
          currentColorMask = colorMask;
        }
      },
      setLocked: function(lock) {
        locked = lock;
      },
      setClear: function(r, g, b, a, premultipliedAlpha) {
        if (premultipliedAlpha === true) {
          r *= a;
          g *= a;
          b *= a;
        }
        color2.set(r, g, b, a);
        if (currentColorClear.equals(color2) === false) {
          gl.clearColor(r, g, b, a);
          currentColorClear.copy(color2);
        }
      },
      reset: function() {
        locked = false;
        currentColorMask = null;
        currentColorClear.set(-1, 0, 0, 0);
      }
    };
  }
  function DepthBuffer() {
    let locked = false;
    let reversed = false;
    let currentDepthMask = null;
    let currentDepthFunc = null;
    let currentDepthClear = null;
    return {
      setReversed: function(value) {
        if (reversed !== value) {
          const ext = extensions.get("EXT_clip_control");
          if (reversed) {
            ext.clipControlEXT(ext.LOWER_LEFT_EXT, ext.ZERO_TO_ONE_EXT);
          } else {
            ext.clipControlEXT(ext.LOWER_LEFT_EXT, ext.NEGATIVE_ONE_TO_ONE_EXT);
          }
          const oldDepth = currentDepthClear;
          currentDepthClear = null;
          this.setClear(oldDepth);
        }
        reversed = value;
      },
      getReversed: function() {
        return reversed;
      },
      setTest: function(depthTest) {
        if (depthTest) {
          enable(gl.DEPTH_TEST);
        } else {
          disable(gl.DEPTH_TEST);
        }
      },
      setMask: function(depthMask) {
        if (currentDepthMask !== depthMask && !locked) {
          gl.depthMask(depthMask);
          currentDepthMask = depthMask;
        }
      },
      setFunc: function(depthFunc) {
        if (reversed) depthFunc = reversedFuncs[depthFunc];
        if (currentDepthFunc !== depthFunc) {
          switch (depthFunc) {
            case NeverDepth:
              gl.depthFunc(gl.NEVER);
              break;
            case AlwaysDepth:
              gl.depthFunc(gl.ALWAYS);
              break;
            case LessDepth:
              gl.depthFunc(gl.LESS);
              break;
            case LessEqualDepth:
              gl.depthFunc(gl.LEQUAL);
              break;
            case EqualDepth:
              gl.depthFunc(gl.EQUAL);
              break;
            case GreaterEqualDepth:
              gl.depthFunc(gl.GEQUAL);
              break;
            case GreaterDepth:
              gl.depthFunc(gl.GREATER);
              break;
            case NotEqualDepth:
              gl.depthFunc(gl.NOTEQUAL);
              break;
            default:
              gl.depthFunc(gl.LEQUAL);
          }
          currentDepthFunc = depthFunc;
        }
      },
      setLocked: function(lock) {
        locked = lock;
      },
      setClear: function(depth) {
        if (currentDepthClear !== depth) {
          if (reversed) {
            depth = 1 - depth;
          }
          gl.clearDepth(depth);
          currentDepthClear = depth;
        }
      },
      reset: function() {
        locked = false;
        currentDepthMask = null;
        currentDepthFunc = null;
        currentDepthClear = null;
        reversed = false;
      }
    };
  }
  function StencilBuffer() {
    let locked = false;
    let currentStencilMask = null;
    let currentStencilFunc = null;
    let currentStencilRef = null;
    let currentStencilFuncMask = null;
    let currentStencilFail = null;
    let currentStencilZFail = null;
    let currentStencilZPass = null;
    let currentStencilClear = null;
    return {
      setTest: function(stencilTest) {
        if (!locked) {
          if (stencilTest) {
            enable(gl.STENCIL_TEST);
          } else {
            disable(gl.STENCIL_TEST);
          }
        }
      },
      setMask: function(stencilMask) {
        if (currentStencilMask !== stencilMask && !locked) {
          gl.stencilMask(stencilMask);
          currentStencilMask = stencilMask;
        }
      },
      setFunc: function(stencilFunc, stencilRef, stencilMask) {
        if (currentStencilFunc !== stencilFunc || currentStencilRef !== stencilRef || currentStencilFuncMask !== stencilMask) {
          gl.stencilFunc(stencilFunc, stencilRef, stencilMask);
          currentStencilFunc = stencilFunc;
          currentStencilRef = stencilRef;
          currentStencilFuncMask = stencilMask;
        }
      },
      setOp: function(stencilFail, stencilZFail, stencilZPass) {
        if (currentStencilFail !== stencilFail || currentStencilZFail !== stencilZFail || currentStencilZPass !== stencilZPass) {
          gl.stencilOp(stencilFail, stencilZFail, stencilZPass);
          currentStencilFail = stencilFail;
          currentStencilZFail = stencilZFail;
          currentStencilZPass = stencilZPass;
        }
      },
      setLocked: function(lock) {
        locked = lock;
      },
      setClear: function(stencil) {
        if (currentStencilClear !== stencil) {
          gl.clearStencil(stencil);
          currentStencilClear = stencil;
        }
      },
      reset: function() {
        locked = false;
        currentStencilMask = null;
        currentStencilFunc = null;
        currentStencilRef = null;
        currentStencilFuncMask = null;
        currentStencilFail = null;
        currentStencilZFail = null;
        currentStencilZPass = null;
        currentStencilClear = null;
      }
    };
  }
  const colorBuffer = new ColorBuffer();
  const depthBuffer = new DepthBuffer();
  const stencilBuffer = new StencilBuffer();
  const uboBindings = /* @__PURE__ */ new WeakMap();
  const uboProgramMap = /* @__PURE__ */ new WeakMap();
  let enabledCapabilities = {};
  let currentBoundFramebuffers = {};
  let currentDrawbuffers = /* @__PURE__ */ new WeakMap();
  let defaultDrawbuffers = [];
  let currentProgram = null;
  let currentBlendingEnabled = false;
  let currentBlending = null;
  let currentBlendEquation = null;
  let currentBlendSrc = null;
  let currentBlendDst = null;
  let currentBlendEquationAlpha = null;
  let currentBlendSrcAlpha = null;
  let currentBlendDstAlpha = null;
  let currentBlendColor = new Color$1(0, 0, 0);
  let currentBlendAlpha = 0;
  let currentPremultipledAlpha = false;
  let currentFlipSided = null;
  let currentCullFace = null;
  let currentLineWidth = null;
  let currentPolygonOffsetFactor = null;
  let currentPolygonOffsetUnits = null;
  const maxTextures = gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
  let lineWidthAvailable = false;
  let version = 0;
  const glVersion = gl.getParameter(gl.VERSION);
  if (glVersion.indexOf("WebGL") !== -1) {
    version = parseFloat(/^WebGL (\d)/.exec(glVersion)[1]);
    lineWidthAvailable = version >= 1;
  } else if (glVersion.indexOf("OpenGL ES") !== -1) {
    version = parseFloat(/^OpenGL ES (\d)/.exec(glVersion)[1]);
    lineWidthAvailable = version >= 2;
  }
  let currentTextureSlot = null;
  let currentBoundTextures = {};
  const scissorParam = gl.getParameter(gl.SCISSOR_BOX);
  const viewportParam = gl.getParameter(gl.VIEWPORT);
  const currentScissor = new Vector4$1().fromArray(scissorParam);
  const currentViewport = new Vector4$1().fromArray(viewportParam);
  function createTexture(type, target, count, dimensions) {
    const data = new Uint8Array(4);
    const texture = gl.createTexture();
    gl.bindTexture(type, texture);
    gl.texParameteri(type, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(type, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    for (let i = 0; i < count; i++) {
      if (type === gl.TEXTURE_3D || type === gl.TEXTURE_2D_ARRAY) {
        gl.texImage3D(target, 0, gl.RGBA, 1, 1, dimensions, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
      } else {
        gl.texImage2D(target + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
      }
    }
    return texture;
  }
  const emptyTextures = {};
  emptyTextures[gl.TEXTURE_2D] = createTexture(gl.TEXTURE_2D, gl.TEXTURE_2D, 1);
  emptyTextures[gl.TEXTURE_CUBE_MAP] = createTexture(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6);
  emptyTextures[gl.TEXTURE_2D_ARRAY] = createTexture(gl.TEXTURE_2D_ARRAY, gl.TEXTURE_2D_ARRAY, 1, 1);
  emptyTextures[gl.TEXTURE_3D] = createTexture(gl.TEXTURE_3D, gl.TEXTURE_3D, 1, 1);
  colorBuffer.setClear(0, 0, 0, 1);
  depthBuffer.setClear(1);
  stencilBuffer.setClear(0);
  enable(gl.DEPTH_TEST);
  depthBuffer.setFunc(LessEqualDepth);
  setFlipSided(false);
  setCullFace(CullFaceBack);
  enable(gl.CULL_FACE);
  setBlending(NoBlending);
  function enable(id) {
    if (enabledCapabilities[id] !== true) {
      gl.enable(id);
      enabledCapabilities[id] = true;
    }
  }
  function disable(id) {
    if (enabledCapabilities[id] !== false) {
      gl.disable(id);
      enabledCapabilities[id] = false;
    }
  }
  function bindFramebuffer(target, framebuffer) {
    if (currentBoundFramebuffers[target] !== framebuffer) {
      gl.bindFramebuffer(target, framebuffer);
      currentBoundFramebuffers[target] = framebuffer;
      if (target === gl.DRAW_FRAMEBUFFER) {
        currentBoundFramebuffers[gl.FRAMEBUFFER] = framebuffer;
      }
      if (target === gl.FRAMEBUFFER) {
        currentBoundFramebuffers[gl.DRAW_FRAMEBUFFER] = framebuffer;
      }
      return true;
    }
    return false;
  }
  function drawBuffers(renderTarget, framebuffer) {
    let drawBuffers2 = defaultDrawbuffers;
    let needsUpdate = false;
    if (renderTarget) {
      drawBuffers2 = currentDrawbuffers.get(framebuffer);
      if (drawBuffers2 === void 0) {
        drawBuffers2 = [];
        currentDrawbuffers.set(framebuffer, drawBuffers2);
      }
      const textures = renderTarget.textures;
      if (drawBuffers2.length !== textures.length || drawBuffers2[0] !== gl.COLOR_ATTACHMENT0) {
        for (let i = 0, il = textures.length; i < il; i++) {
          drawBuffers2[i] = gl.COLOR_ATTACHMENT0 + i;
        }
        drawBuffers2.length = textures.length;
        needsUpdate = true;
      }
    } else {
      if (drawBuffers2[0] !== gl.BACK) {
        drawBuffers2[0] = gl.BACK;
        needsUpdate = true;
      }
    }
    if (needsUpdate) {
      gl.drawBuffers(drawBuffers2);
    }
  }
  function useProgram(program) {
    if (currentProgram !== program) {
      gl.useProgram(program);
      currentProgram = program;
      return true;
    }
    return false;
  }
  const equationToGL = {
    [AddEquation]: gl.FUNC_ADD,
    [SubtractEquation]: gl.FUNC_SUBTRACT,
    [ReverseSubtractEquation]: gl.FUNC_REVERSE_SUBTRACT
  };
  equationToGL[MinEquation] = gl.MIN;
  equationToGL[MaxEquation] = gl.MAX;
  const factorToGL = {
    [ZeroFactor]: gl.ZERO,
    [OneFactor]: gl.ONE,
    [SrcColorFactor]: gl.SRC_COLOR,
    [SrcAlphaFactor]: gl.SRC_ALPHA,
    [SrcAlphaSaturateFactor]: gl.SRC_ALPHA_SATURATE,
    [DstColorFactor]: gl.DST_COLOR,
    [DstAlphaFactor]: gl.DST_ALPHA,
    [OneMinusSrcColorFactor]: gl.ONE_MINUS_SRC_COLOR,
    [OneMinusSrcAlphaFactor]: gl.ONE_MINUS_SRC_ALPHA,
    [OneMinusDstColorFactor]: gl.ONE_MINUS_DST_COLOR,
    [OneMinusDstAlphaFactor]: gl.ONE_MINUS_DST_ALPHA,
    [ConstantColorFactor]: gl.CONSTANT_COLOR,
    [OneMinusConstantColorFactor]: gl.ONE_MINUS_CONSTANT_COLOR,
    [ConstantAlphaFactor]: gl.CONSTANT_ALPHA,
    [OneMinusConstantAlphaFactor]: gl.ONE_MINUS_CONSTANT_ALPHA
  };
  function setBlending(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, blendColor, blendAlpha, premultipliedAlpha) {
    if (blending === NoBlending) {
      if (currentBlendingEnabled === true) {
        disable(gl.BLEND);
        currentBlendingEnabled = false;
      }
      return;
    }
    if (currentBlendingEnabled === false) {
      enable(gl.BLEND);
      currentBlendingEnabled = true;
    }
    if (blending !== CustomBlending) {
      if (blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha) {
        if (currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation) {
          gl.blendEquation(gl.FUNC_ADD);
          currentBlendEquation = AddEquation;
          currentBlendEquationAlpha = AddEquation;
        }
        if (premultipliedAlpha) {
          switch (blending) {
            case NormalBlending:
              gl.blendFuncSeparate(gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
              break;
            case AdditiveBlending:
              gl.blendFunc(gl.ONE, gl.ONE);
              break;
            case SubtractiveBlending:
              gl.blendFuncSeparate(gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ZERO, gl.ONE);
              break;
            case MultiplyBlending:
              gl.blendFuncSeparate(gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", blending);
              break;
          }
        } else {
          switch (blending) {
            case NormalBlending:
              gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
              break;
            case AdditiveBlending:
              gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
              break;
            case SubtractiveBlending:
              gl.blendFuncSeparate(gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ZERO, gl.ONE);
              break;
            case MultiplyBlending:
              gl.blendFunc(gl.ZERO, gl.SRC_COLOR);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", blending);
              break;
          }
        }
        currentBlendSrc = null;
        currentBlendDst = null;
        currentBlendSrcAlpha = null;
        currentBlendDstAlpha = null;
        currentBlendColor.set(0, 0, 0);
        currentBlendAlpha = 0;
        currentBlending = blending;
        currentPremultipledAlpha = premultipliedAlpha;
      }
      return;
    }
    blendEquationAlpha = blendEquationAlpha || blendEquation;
    blendSrcAlpha = blendSrcAlpha || blendSrc;
    blendDstAlpha = blendDstAlpha || blendDst;
    if (blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha) {
      gl.blendEquationSeparate(equationToGL[blendEquation], equationToGL[blendEquationAlpha]);
      currentBlendEquation = blendEquation;
      currentBlendEquationAlpha = blendEquationAlpha;
    }
    if (blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha) {
      gl.blendFuncSeparate(factorToGL[blendSrc], factorToGL[blendDst], factorToGL[blendSrcAlpha], factorToGL[blendDstAlpha]);
      currentBlendSrc = blendSrc;
      currentBlendDst = blendDst;
      currentBlendSrcAlpha = blendSrcAlpha;
      currentBlendDstAlpha = blendDstAlpha;
    }
    if (blendColor.equals(currentBlendColor) === false || blendAlpha !== currentBlendAlpha) {
      gl.blendColor(blendColor.r, blendColor.g, blendColor.b, blendAlpha);
      currentBlendColor.copy(blendColor);
      currentBlendAlpha = blendAlpha;
    }
    currentBlending = blending;
    currentPremultipledAlpha = false;
  }
  function setMaterial(material, frontFaceCW) {
    material.side === DoubleSide ? disable(gl.CULL_FACE) : enable(gl.CULL_FACE);
    let flipSided = material.side === BackSide;
    if (frontFaceCW) flipSided = !flipSided;
    setFlipSided(flipSided);
    material.blending === NormalBlending && material.transparent === false ? setBlending(NoBlending) : setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.blendColor, material.blendAlpha, material.premultipliedAlpha);
    depthBuffer.setFunc(material.depthFunc);
    depthBuffer.setTest(material.depthTest);
    depthBuffer.setMask(material.depthWrite);
    colorBuffer.setMask(material.colorWrite);
    const stencilWrite = material.stencilWrite;
    stencilBuffer.setTest(stencilWrite);
    if (stencilWrite) {
      stencilBuffer.setMask(material.stencilWriteMask);
      stencilBuffer.setFunc(material.stencilFunc, material.stencilRef, material.stencilFuncMask);
      stencilBuffer.setOp(material.stencilFail, material.stencilZFail, material.stencilZPass);
    }
    setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
    material.alphaToCoverage === true ? enable(gl.SAMPLE_ALPHA_TO_COVERAGE) : disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
  }
  function setFlipSided(flipSided) {
    if (currentFlipSided !== flipSided) {
      if (flipSided) {
        gl.frontFace(gl.CW);
      } else {
        gl.frontFace(gl.CCW);
      }
      currentFlipSided = flipSided;
    }
  }
  function setCullFace(cullFace) {
    if (cullFace !== CullFaceNone) {
      enable(gl.CULL_FACE);
      if (cullFace !== currentCullFace) {
        if (cullFace === CullFaceBack) {
          gl.cullFace(gl.BACK);
        } else if (cullFace === CullFaceFront) {
          gl.cullFace(gl.FRONT);
        } else {
          gl.cullFace(gl.FRONT_AND_BACK);
        }
      }
    } else {
      disable(gl.CULL_FACE);
    }
    currentCullFace = cullFace;
  }
  function setLineWidth(width) {
    if (width !== currentLineWidth) {
      if (lineWidthAvailable) gl.lineWidth(width);
      currentLineWidth = width;
    }
  }
  function setPolygonOffset(polygonOffset, factor, units) {
    if (polygonOffset) {
      enable(gl.POLYGON_OFFSET_FILL);
      if (currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units) {
        gl.polygonOffset(factor, units);
        currentPolygonOffsetFactor = factor;
        currentPolygonOffsetUnits = units;
      }
    } else {
      disable(gl.POLYGON_OFFSET_FILL);
    }
  }
  function setScissorTest(scissorTest) {
    if (scissorTest) {
      enable(gl.SCISSOR_TEST);
    } else {
      disable(gl.SCISSOR_TEST);
    }
  }
  function activeTexture(webglSlot) {
    if (webglSlot === void 0) webglSlot = gl.TEXTURE0 + maxTextures - 1;
    if (currentTextureSlot !== webglSlot) {
      gl.activeTexture(webglSlot);
      currentTextureSlot = webglSlot;
    }
  }
  function bindTexture(webglType, webglTexture, webglSlot) {
    if (webglSlot === void 0) {
      if (currentTextureSlot === null) {
        webglSlot = gl.TEXTURE0 + maxTextures - 1;
      } else {
        webglSlot = currentTextureSlot;
      }
    }
    let boundTexture = currentBoundTextures[webglSlot];
    if (boundTexture === void 0) {
      boundTexture = { type: void 0, texture: void 0 };
      currentBoundTextures[webglSlot] = boundTexture;
    }
    if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {
      if (currentTextureSlot !== webglSlot) {
        gl.activeTexture(webglSlot);
        currentTextureSlot = webglSlot;
      }
      gl.bindTexture(webglType, webglTexture || emptyTextures[webglType]);
      boundTexture.type = webglType;
      boundTexture.texture = webglTexture;
    }
  }
  function unbindTexture() {
    const boundTexture = currentBoundTextures[currentTextureSlot];
    if (boundTexture !== void 0 && boundTexture.type !== void 0) {
      gl.bindTexture(boundTexture.type, null);
      boundTexture.type = void 0;
      boundTexture.texture = void 0;
    }
  }
  function compressedTexImage2D() {
    try {
      gl.compressedTexImage2D.apply(gl, arguments);
    } catch (error2) {
      console.error("THREE.WebGLState:", error2);
    }
  }
  function compressedTexImage3D() {
    try {
      gl.compressedTexImage3D.apply(gl, arguments);
    } catch (error2) {
      console.error("THREE.WebGLState:", error2);
    }
  }
  function texSubImage2D() {
    try {
      gl.texSubImage2D.apply(gl, arguments);
    } catch (error2) {
      console.error("THREE.WebGLState:", error2);
    }
  }
  function texSubImage3D() {
    try {
      gl.texSubImage3D.apply(gl, arguments);
    } catch (error2) {
      console.error("THREE.WebGLState:", error2);
    }
  }
  function compressedTexSubImage2D() {
    try {
      gl.compressedTexSubImage2D.apply(gl, arguments);
    } catch (error2) {
      console.error("THREE.WebGLState:", error2);
    }
  }
  function compressedTexSubImage3D() {
    try {
      gl.compressedTexSubImage3D.apply(gl, arguments);
    } catch (error2) {
      console.error("THREE.WebGLState:", error2);
    }
  }
  function texStorage2D() {
    try {
      gl.texStorage2D.apply(gl, arguments);
    } catch (error2) {
      console.error("THREE.WebGLState:", error2);
    }
  }
  function texStorage3D() {
    try {
      gl.texStorage3D.apply(gl, arguments);
    } catch (error2) {
      console.error("THREE.WebGLState:", error2);
    }
  }
  function texImage2D() {
    try {
      gl.texImage2D.apply(gl, arguments);
    } catch (error2) {
      console.error("THREE.WebGLState:", error2);
    }
  }
  function texImage3D() {
    try {
      gl.texImage3D.apply(gl, arguments);
    } catch (error2) {
      console.error("THREE.WebGLState:", error2);
    }
  }
  function scissor(scissor2) {
    if (currentScissor.equals(scissor2) === false) {
      gl.scissor(scissor2.x, scissor2.y, scissor2.z, scissor2.w);
      currentScissor.copy(scissor2);
    }
  }
  function viewport(viewport2) {
    if (currentViewport.equals(viewport2) === false) {
      gl.viewport(viewport2.x, viewport2.y, viewport2.z, viewport2.w);
      currentViewport.copy(viewport2);
    }
  }
  function updateUBOMapping(uniformsGroup, program) {
    let mapping = uboProgramMap.get(program);
    if (mapping === void 0) {
      mapping = /* @__PURE__ */ new WeakMap();
      uboProgramMap.set(program, mapping);
    }
    let blockIndex = mapping.get(uniformsGroup);
    if (blockIndex === void 0) {
      blockIndex = gl.getUniformBlockIndex(program, uniformsGroup.name);
      mapping.set(uniformsGroup, blockIndex);
    }
  }
  function uniformBlockBinding(uniformsGroup, program) {
    const mapping = uboProgramMap.get(program);
    const blockIndex = mapping.get(uniformsGroup);
    if (uboBindings.get(program) !== blockIndex) {
      gl.uniformBlockBinding(program, blockIndex, uniformsGroup.__bindingPointIndex);
      uboBindings.set(program, blockIndex);
    }
  }
  function reset() {
    gl.disable(gl.BLEND);
    gl.disable(gl.CULL_FACE);
    gl.disable(gl.DEPTH_TEST);
    gl.disable(gl.POLYGON_OFFSET_FILL);
    gl.disable(gl.SCISSOR_TEST);
    gl.disable(gl.STENCIL_TEST);
    gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
    gl.blendEquation(gl.FUNC_ADD);
    gl.blendFunc(gl.ONE, gl.ZERO);
    gl.blendFuncSeparate(gl.ONE, gl.ZERO, gl.ONE, gl.ZERO);
    gl.blendColor(0, 0, 0, 0);
    gl.colorMask(true, true, true, true);
    gl.clearColor(0, 0, 0, 0);
    gl.depthMask(true);
    gl.depthFunc(gl.LESS);
    depthBuffer.setReversed(false);
    gl.clearDepth(1);
    gl.stencilMask(4294967295);
    gl.stencilFunc(gl.ALWAYS, 0, 4294967295);
    gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
    gl.clearStencil(0);
    gl.cullFace(gl.BACK);
    gl.frontFace(gl.CCW);
    gl.polygonOffset(0, 0);
    gl.activeTexture(gl.TEXTURE0);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);
    gl.bindFramebuffer(gl.READ_FRAMEBUFFER, null);
    gl.useProgram(null);
    gl.lineWidth(1);
    gl.scissor(0, 0, gl.canvas.width, gl.canvas.height);
    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
    enabledCapabilities = {};
    currentTextureSlot = null;
    currentBoundTextures = {};
    currentBoundFramebuffers = {};
    currentDrawbuffers = /* @__PURE__ */ new WeakMap();
    defaultDrawbuffers = [];
    currentProgram = null;
    currentBlendingEnabled = false;
    currentBlending = null;
    currentBlendEquation = null;
    currentBlendSrc = null;
    currentBlendDst = null;
    currentBlendEquationAlpha = null;
    currentBlendSrcAlpha = null;
    currentBlendDstAlpha = null;
    currentBlendColor = new Color$1(0, 0, 0);
    currentBlendAlpha = 0;
    currentPremultipledAlpha = false;
    currentFlipSided = null;
    currentCullFace = null;
    currentLineWidth = null;
    currentPolygonOffsetFactor = null;
    currentPolygonOffsetUnits = null;
    currentScissor.set(0, 0, gl.canvas.width, gl.canvas.height);
    currentViewport.set(0, 0, gl.canvas.width, gl.canvas.height);
    colorBuffer.reset();
    depthBuffer.reset();
    stencilBuffer.reset();
  }
  return {
    buffers: {
      color: colorBuffer,
      depth: depthBuffer,
      stencil: stencilBuffer
    },
    enable,
    disable,
    bindFramebuffer,
    drawBuffers,
    useProgram,
    setBlending,
    setMaterial,
    setFlipSided,
    setCullFace,
    setLineWidth,
    setPolygonOffset,
    setScissorTest,
    activeTexture,
    bindTexture,
    unbindTexture,
    compressedTexImage2D,
    compressedTexImage3D,
    texImage2D,
    texImage3D,
    updateUBOMapping,
    uniformBlockBinding,
    texStorage2D,
    texStorage3D,
    texSubImage2D,
    texSubImage3D,
    compressedTexSubImage2D,
    compressedTexSubImage3D,
    scissor,
    viewport,
    reset
  };
}
function WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info) {
  const multisampledRTTExt = extensions.has("WEBGL_multisampled_render_to_texture") ? extensions.get("WEBGL_multisampled_render_to_texture") : null;
  const supportsInvalidateFramebuffer = typeof navigator === "undefined" ? false : /OculusBrowser/g.test(navigator.userAgent);
  const _imageDimensions = new Vector2$1();
  const _videoTextures = /* @__PURE__ */ new WeakMap();
  let _canvas2;
  const _sources = /* @__PURE__ */ new WeakMap();
  let useOffscreenCanvas = false;
  try {
    useOffscreenCanvas = typeof OffscreenCanvas !== "undefined" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch (err) {
  }
  function createCanvas(width, height) {
    return useOffscreenCanvas ? (
      // eslint-disable-next-line compat/compat
      new OffscreenCanvas(width, height)
    ) : createElementNS("canvas");
  }
  function resizeImage(image, needsNewCanvas, maxSize) {
    let scale = 1;
    const dimensions = getDimensions(image);
    if (dimensions.width > maxSize || dimensions.height > maxSize) {
      scale = maxSize / Math.max(dimensions.width, dimensions.height);
    }
    if (scale < 1) {
      if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap || typeof VideoFrame !== "undefined" && image instanceof VideoFrame) {
        const width = Math.floor(scale * dimensions.width);
        const height = Math.floor(scale * dimensions.height);
        if (_canvas2 === void 0) _canvas2 = createCanvas(width, height);
        const canvas = needsNewCanvas ? createCanvas(width, height) : _canvas2;
        canvas.width = width;
        canvas.height = height;
        const context2 = canvas.getContext("2d");
        context2.drawImage(image, 0, 0, width, height);
        console.warn("THREE.WebGLRenderer: Texture has been resized from (" + dimensions.width + "x" + dimensions.height + ") to (" + width + "x" + height + ").");
        return canvas;
      } else {
        if ("data" in image) {
          console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + dimensions.width + "x" + dimensions.height + ").");
        }
        return image;
      }
    }
    return image;
  }
  function textureNeedsGenerateMipmaps(texture) {
    return texture.generateMipmaps;
  }
  function generateMipmap(target) {
    _gl.generateMipmap(target);
  }
  function getTargetType(texture) {
    if (texture.isWebGLCubeRenderTarget) return _gl.TEXTURE_CUBE_MAP;
    if (texture.isWebGL3DRenderTarget) return _gl.TEXTURE_3D;
    if (texture.isWebGLArrayRenderTarget || texture.isCompressedArrayTexture) return _gl.TEXTURE_2D_ARRAY;
    return _gl.TEXTURE_2D;
  }
  function getInternalFormat(internalFormatName, glFormat, glType, colorSpace, forceLinearTransfer = false) {
    if (internalFormatName !== null) {
      if (_gl[internalFormatName] !== void 0) return _gl[internalFormatName];
      console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + internalFormatName + "'");
    }
    let internalFormat = glFormat;
    if (glFormat === _gl.RED) {
      if (glType === _gl.FLOAT) internalFormat = _gl.R32F;
      if (glType === _gl.HALF_FLOAT) internalFormat = _gl.R16F;
      if (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.R8;
    }
    if (glFormat === _gl.RED_INTEGER) {
      if (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.R8UI;
      if (glType === _gl.UNSIGNED_SHORT) internalFormat = _gl.R16UI;
      if (glType === _gl.UNSIGNED_INT) internalFormat = _gl.R32UI;
      if (glType === _gl.BYTE) internalFormat = _gl.R8I;
      if (glType === _gl.SHORT) internalFormat = _gl.R16I;
      if (glType === _gl.INT) internalFormat = _gl.R32I;
    }
    if (glFormat === _gl.RG) {
      if (glType === _gl.FLOAT) internalFormat = _gl.RG32F;
      if (glType === _gl.HALF_FLOAT) internalFormat = _gl.RG16F;
      if (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.RG8;
    }
    if (glFormat === _gl.RG_INTEGER) {
      if (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.RG8UI;
      if (glType === _gl.UNSIGNED_SHORT) internalFormat = _gl.RG16UI;
      if (glType === _gl.UNSIGNED_INT) internalFormat = _gl.RG32UI;
      if (glType === _gl.BYTE) internalFormat = _gl.RG8I;
      if (glType === _gl.SHORT) internalFormat = _gl.RG16I;
      if (glType === _gl.INT) internalFormat = _gl.RG32I;
    }
    if (glFormat === _gl.RGB_INTEGER) {
      if (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.RGB8UI;
      if (glType === _gl.UNSIGNED_SHORT) internalFormat = _gl.RGB16UI;
      if (glType === _gl.UNSIGNED_INT) internalFormat = _gl.RGB32UI;
      if (glType === _gl.BYTE) internalFormat = _gl.RGB8I;
      if (glType === _gl.SHORT) internalFormat = _gl.RGB16I;
      if (glType === _gl.INT) internalFormat = _gl.RGB32I;
    }
    if (glFormat === _gl.RGBA_INTEGER) {
      if (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.RGBA8UI;
      if (glType === _gl.UNSIGNED_SHORT) internalFormat = _gl.RGBA16UI;
      if (glType === _gl.UNSIGNED_INT) internalFormat = _gl.RGBA32UI;
      if (glType === _gl.BYTE) internalFormat = _gl.RGBA8I;
      if (glType === _gl.SHORT) internalFormat = _gl.RGBA16I;
      if (glType === _gl.INT) internalFormat = _gl.RGBA32I;
    }
    if (glFormat === _gl.RGB) {
      if (glType === _gl.UNSIGNED_INT_5_9_9_9_REV) internalFormat = _gl.RGB9_E5;
    }
    if (glFormat === _gl.RGBA) {
      const transfer = forceLinearTransfer ? LinearTransfer$1 : ColorManagement$1.getTransfer(colorSpace);
      if (glType === _gl.FLOAT) internalFormat = _gl.RGBA32F;
      if (glType === _gl.HALF_FLOAT) internalFormat = _gl.RGBA16F;
      if (glType === _gl.UNSIGNED_BYTE) internalFormat = transfer === SRGBTransfer$1 ? _gl.SRGB8_ALPHA8 : _gl.RGBA8;
      if (glType === _gl.UNSIGNED_SHORT_4_4_4_4) internalFormat = _gl.RGBA4;
      if (glType === _gl.UNSIGNED_SHORT_5_5_5_1) internalFormat = _gl.RGB5_A1;
    }
    if (internalFormat === _gl.R16F || internalFormat === _gl.R32F || internalFormat === _gl.RG16F || internalFormat === _gl.RG32F || internalFormat === _gl.RGBA16F || internalFormat === _gl.RGBA32F) {
      extensions.get("EXT_color_buffer_float");
    }
    return internalFormat;
  }
  function getInternalDepthFormat(useStencil, depthType) {
    let glInternalFormat;
    if (useStencil) {
      if (depthType === null || depthType === UnsignedIntType || depthType === UnsignedInt248Type) {
        glInternalFormat = _gl.DEPTH24_STENCIL8;
      } else if (depthType === FloatType$1) {
        glInternalFormat = _gl.DEPTH32F_STENCIL8;
      } else if (depthType === UnsignedShortType) {
        glInternalFormat = _gl.DEPTH24_STENCIL8;
        console.warn("DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.");
      }
    } else {
      if (depthType === null || depthType === UnsignedIntType || depthType === UnsignedInt248Type) {
        glInternalFormat = _gl.DEPTH_COMPONENT24;
      } else if (depthType === FloatType$1) {
        glInternalFormat = _gl.DEPTH_COMPONENT32F;
      } else if (depthType === UnsignedShortType) {
        glInternalFormat = _gl.DEPTH_COMPONENT16;
      }
    }
    return glInternalFormat;
  }
  function getMipLevels(texture, image) {
    if (textureNeedsGenerateMipmaps(texture) === true || texture.isFramebufferTexture && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter) {
      return Math.log2(Math.max(image.width, image.height)) + 1;
    } else if (texture.mipmaps !== void 0 && texture.mipmaps.length > 0) {
      return texture.mipmaps.length;
    } else if (texture.isCompressedTexture && Array.isArray(texture.image)) {
      return image.mipmaps.length;
    } else {
      return 1;
    }
  }
  function onTextureDispose(event) {
    const texture = event.target;
    texture.removeEventListener("dispose", onTextureDispose);
    deallocateTexture(texture);
    if (texture.isVideoTexture) {
      _videoTextures.delete(texture);
    }
  }
  function onRenderTargetDispose(event) {
    const renderTarget = event.target;
    renderTarget.removeEventListener("dispose", onRenderTargetDispose);
    deallocateRenderTarget(renderTarget);
  }
  function deallocateTexture(texture) {
    const textureProperties = properties.get(texture);
    if (textureProperties.__webglInit === void 0) return;
    const source = texture.source;
    const webglTextures = _sources.get(source);
    if (webglTextures) {
      const webglTexture = webglTextures[textureProperties.__cacheKey];
      webglTexture.usedTimes--;
      if (webglTexture.usedTimes === 0) {
        deleteTexture(texture);
      }
      if (Object.keys(webglTextures).length === 0) {
        _sources.delete(source);
      }
    }
    properties.remove(texture);
  }
  function deleteTexture(texture) {
    const textureProperties = properties.get(texture);
    _gl.deleteTexture(textureProperties.__webglTexture);
    const source = texture.source;
    const webglTextures = _sources.get(source);
    delete webglTextures[textureProperties.__cacheKey];
    info.memory.textures--;
  }
  function deallocateRenderTarget(renderTarget) {
    const renderTargetProperties = properties.get(renderTarget);
    if (renderTarget.depthTexture) {
      renderTarget.depthTexture.dispose();
      properties.remove(renderTarget.depthTexture);
    }
    if (renderTarget.isWebGLCubeRenderTarget) {
      for (let i = 0; i < 6; i++) {
        if (Array.isArray(renderTargetProperties.__webglFramebuffer[i])) {
          for (let level = 0; level < renderTargetProperties.__webglFramebuffer[i].length; level++) _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i][level]);
        } else {
          _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i]);
        }
        if (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i]);
      }
    } else {
      if (Array.isArray(renderTargetProperties.__webglFramebuffer)) {
        for (let level = 0; level < renderTargetProperties.__webglFramebuffer.length; level++) _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[level]);
      } else {
        _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);
      }
      if (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);
      if (renderTargetProperties.__webglMultisampledFramebuffer) _gl.deleteFramebuffer(renderTargetProperties.__webglMultisampledFramebuffer);
      if (renderTargetProperties.__webglColorRenderbuffer) {
        for (let i = 0; i < renderTargetProperties.__webglColorRenderbuffer.length; i++) {
          if (renderTargetProperties.__webglColorRenderbuffer[i]) _gl.deleteRenderbuffer(renderTargetProperties.__webglColorRenderbuffer[i]);
        }
      }
      if (renderTargetProperties.__webglDepthRenderbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthRenderbuffer);
    }
    const textures = renderTarget.textures;
    for (let i = 0, il = textures.length; i < il; i++) {
      const attachmentProperties = properties.get(textures[i]);
      if (attachmentProperties.__webglTexture) {
        _gl.deleteTexture(attachmentProperties.__webglTexture);
        info.memory.textures--;
      }
      properties.remove(textures[i]);
    }
    properties.remove(renderTarget);
  }
  let textureUnits = 0;
  function resetTextureUnits() {
    textureUnits = 0;
  }
  function allocateTextureUnit() {
    const textureUnit = textureUnits;
    if (textureUnit >= capabilities.maxTextures) {
      console.warn("THREE.WebGLTextures: Trying to use " + textureUnit + " texture units while this GPU supports only " + capabilities.maxTextures);
    }
    textureUnits += 1;
    return textureUnit;
  }
  function getTextureCacheKey(texture) {
    const array = [];
    array.push(texture.wrapS);
    array.push(texture.wrapT);
    array.push(texture.wrapR || 0);
    array.push(texture.magFilter);
    array.push(texture.minFilter);
    array.push(texture.anisotropy);
    array.push(texture.internalFormat);
    array.push(texture.format);
    array.push(texture.type);
    array.push(texture.generateMipmaps);
    array.push(texture.premultiplyAlpha);
    array.push(texture.flipY);
    array.push(texture.unpackAlignment);
    array.push(texture.colorSpace);
    return array.join();
  }
  function setTexture2D(texture, slot) {
    const textureProperties = properties.get(texture);
    if (texture.isVideoTexture) updateVideoTexture(texture);
    if (texture.isRenderTargetTexture === false && texture.version > 0 && textureProperties.__version !== texture.version) {
      const image = texture.image;
      if (image === null) {
        console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
      } else if (image.complete === false) {
        console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
      } else {
        uploadTexture(textureProperties, texture, slot);
        return;
      }
    }
    state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
  }
  function setTexture2DArray(texture, slot) {
    const textureProperties = properties.get(texture);
    if (texture.version > 0 && textureProperties.__version !== texture.version) {
      uploadTexture(textureProperties, texture, slot);
      return;
    }
    state.bindTexture(_gl.TEXTURE_2D_ARRAY, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
  }
  function setTexture3D(texture, slot) {
    const textureProperties = properties.get(texture);
    if (texture.version > 0 && textureProperties.__version !== texture.version) {
      uploadTexture(textureProperties, texture, slot);
      return;
    }
    state.bindTexture(_gl.TEXTURE_3D, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
  }
  function setTextureCube(texture, slot) {
    const textureProperties = properties.get(texture);
    if (texture.version > 0 && textureProperties.__version !== texture.version) {
      uploadCubeTexture(textureProperties, texture, slot);
      return;
    }
    state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
  }
  const wrappingToGL = {
    [RepeatWrapping]: _gl.REPEAT,
    [ClampToEdgeWrapping]: _gl.CLAMP_TO_EDGE,
    [MirroredRepeatWrapping]: _gl.MIRRORED_REPEAT
  };
  const filterToGL = {
    [NearestFilter]: _gl.NEAREST,
    [NearestMipmapNearestFilter]: _gl.NEAREST_MIPMAP_NEAREST,
    [NearestMipmapLinearFilter]: _gl.NEAREST_MIPMAP_LINEAR,
    [LinearFilter]: _gl.LINEAR,
    [LinearMipmapNearestFilter]: _gl.LINEAR_MIPMAP_NEAREST,
    [LinearMipmapLinearFilter]: _gl.LINEAR_MIPMAP_LINEAR
  };
  const compareToGL = {
    [NeverCompare]: _gl.NEVER,
    [AlwaysCompare]: _gl.ALWAYS,
    [LessCompare]: _gl.LESS,
    [LessEqualCompare]: _gl.LEQUAL,
    [EqualCompare]: _gl.EQUAL,
    [GreaterEqualCompare]: _gl.GEQUAL,
    [GreaterCompare]: _gl.GREATER,
    [NotEqualCompare]: _gl.NOTEQUAL
  };
  function setTextureParameters(textureType, texture) {
    if (texture.type === FloatType$1 && extensions.has("OES_texture_float_linear") === false && (texture.magFilter === LinearFilter || texture.magFilter === LinearMipmapNearestFilter || texture.magFilter === NearestMipmapLinearFilter || texture.magFilter === LinearMipmapLinearFilter || texture.minFilter === LinearFilter || texture.minFilter === LinearMipmapNearestFilter || texture.minFilter === NearestMipmapLinearFilter || texture.minFilter === LinearMipmapLinearFilter)) {
      console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device.");
    }
    _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, wrappingToGL[texture.wrapS]);
    _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, wrappingToGL[texture.wrapT]);
    if (textureType === _gl.TEXTURE_3D || textureType === _gl.TEXTURE_2D_ARRAY) {
      _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_R, wrappingToGL[texture.wrapR]);
    }
    _gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, filterToGL[texture.magFilter]);
    _gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, filterToGL[texture.minFilter]);
    if (texture.compareFunction) {
      _gl.texParameteri(textureType, _gl.TEXTURE_COMPARE_MODE, _gl.COMPARE_REF_TO_TEXTURE);
      _gl.texParameteri(textureType, _gl.TEXTURE_COMPARE_FUNC, compareToGL[texture.compareFunction]);
    }
    if (extensions.has("EXT_texture_filter_anisotropic") === true) {
      if (texture.magFilter === NearestFilter) return;
      if (texture.minFilter !== NearestMipmapLinearFilter && texture.minFilter !== LinearMipmapLinearFilter) return;
      if (texture.type === FloatType$1 && extensions.has("OES_texture_float_linear") === false) return;
      if (texture.anisotropy > 1 || properties.get(texture).__currentAnisotropy) {
        const extension = extensions.get("EXT_texture_filter_anisotropic");
        _gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, capabilities.getMaxAnisotropy()));
        properties.get(texture).__currentAnisotropy = texture.anisotropy;
      }
    }
  }
  function initTexture(textureProperties, texture) {
    let forceUpload = false;
    if (textureProperties.__webglInit === void 0) {
      textureProperties.__webglInit = true;
      texture.addEventListener("dispose", onTextureDispose);
    }
    const source = texture.source;
    let webglTextures = _sources.get(source);
    if (webglTextures === void 0) {
      webglTextures = {};
      _sources.set(source, webglTextures);
    }
    const textureCacheKey = getTextureCacheKey(texture);
    if (textureCacheKey !== textureProperties.__cacheKey) {
      if (webglTextures[textureCacheKey] === void 0) {
        webglTextures[textureCacheKey] = {
          texture: _gl.createTexture(),
          usedTimes: 0
        };
        info.memory.textures++;
        forceUpload = true;
      }
      webglTextures[textureCacheKey].usedTimes++;
      const webglTexture = webglTextures[textureProperties.__cacheKey];
      if (webglTexture !== void 0) {
        webglTextures[textureProperties.__cacheKey].usedTimes--;
        if (webglTexture.usedTimes === 0) {
          deleteTexture(texture);
        }
      }
      textureProperties.__cacheKey = textureCacheKey;
      textureProperties.__webglTexture = webglTextures[textureCacheKey].texture;
    }
    return forceUpload;
  }
  function uploadTexture(textureProperties, texture, slot) {
    let textureType = _gl.TEXTURE_2D;
    if (texture.isDataArrayTexture || texture.isCompressedArrayTexture) textureType = _gl.TEXTURE_2D_ARRAY;
    if (texture.isData3DTexture) textureType = _gl.TEXTURE_3D;
    const forceUpload = initTexture(textureProperties, texture);
    const source = texture.source;
    state.bindTexture(textureType, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
    const sourceProperties = properties.get(source);
    if (source.version !== sourceProperties.__version || forceUpload === true) {
      state.activeTexture(_gl.TEXTURE0 + slot);
      const workingPrimaries = ColorManagement$1.getPrimaries(ColorManagement$1.workingColorSpace);
      const texturePrimaries = texture.colorSpace === NoColorSpace$1 ? null : ColorManagement$1.getPrimaries(texture.colorSpace);
      const unpackConversion = texture.colorSpace === NoColorSpace$1 || workingPrimaries === texturePrimaries ? _gl.NONE : _gl.BROWSER_DEFAULT_WEBGL;
      _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);
      _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha);
      _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, texture.unpackAlignment);
      _gl.pixelStorei(_gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, unpackConversion);
      let image = resizeImage(texture.image, false, capabilities.maxTextureSize);
      image = verifyColorSpace(texture, image);
      const glFormat = utils.convert(texture.format, texture.colorSpace);
      const glType = utils.convert(texture.type);
      let glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.colorSpace, texture.isVideoTexture);
      setTextureParameters(textureType, texture);
      let mipmap;
      const mipmaps = texture.mipmaps;
      const useTexStorage = texture.isVideoTexture !== true;
      const allocateMemory = sourceProperties.__version === void 0 || forceUpload === true;
      const dataReady = source.dataReady;
      const levels = getMipLevels(texture, image);
      if (texture.isDepthTexture) {
        glInternalFormat = getInternalDepthFormat(texture.format === DepthStencilFormat, texture.type);
        if (allocateMemory) {
          if (useTexStorage) {
            state.texStorage2D(_gl.TEXTURE_2D, 1, glInternalFormat, image.width, image.height);
          } else {
            state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null);
          }
        }
      } else if (texture.isDataTexture) {
        if (mipmaps.length > 0) {
          if (useTexStorage && allocateMemory) {
            state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height);
          }
          for (let i = 0, il = mipmaps.length; i < il; i++) {
            mipmap = mipmaps[i];
            if (useTexStorage) {
              if (dataReady) {
                state.texSubImage2D(_gl.TEXTURE_2D, i, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data);
              }
            } else {
              state.texImage2D(_gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
            }
          }
          texture.generateMipmaps = false;
        } else {
          if (useTexStorage) {
            if (allocateMemory) {
              state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, image.width, image.height);
            }
            if (dataReady) {
              state.texSubImage2D(_gl.TEXTURE_2D, 0, 0, 0, image.width, image.height, glFormat, glType, image.data);
            }
          } else {
            state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data);
          }
        }
      } else if (texture.isCompressedTexture) {
        if (texture.isCompressedArrayTexture) {
          if (useTexStorage && allocateMemory) {
            state.texStorage3D(_gl.TEXTURE_2D_ARRAY, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height, image.depth);
          }
          for (let i = 0, il = mipmaps.length; i < il; i++) {
            mipmap = mipmaps[i];
            if (texture.format !== RGBAFormat) {
              if (glFormat !== null) {
                if (useTexStorage) {
                  if (dataReady) {
                    if (texture.layerUpdates.size > 0) {
                      const layerByteLength = getByteLength(mipmap.width, mipmap.height, texture.format, texture.type);
                      for (const layerIndex of texture.layerUpdates) {
                        const layerData = mipmap.data.subarray(
                          layerIndex * layerByteLength / mipmap.data.BYTES_PER_ELEMENT,
                          (layerIndex + 1) * layerByteLength / mipmap.data.BYTES_PER_ELEMENT
                        );
                        state.compressedTexSubImage3D(_gl.TEXTURE_2D_ARRAY, i, 0, 0, layerIndex, mipmap.width, mipmap.height, 1, glFormat, layerData);
                      }
                      texture.clearLayerUpdates();
                    } else {
                      state.compressedTexSubImage3D(_gl.TEXTURE_2D_ARRAY, i, 0, 0, 0, mipmap.width, mipmap.height, image.depth, glFormat, mipmap.data);
                    }
                  }
                } else {
                  state.compressedTexImage3D(_gl.TEXTURE_2D_ARRAY, i, glInternalFormat, mipmap.width, mipmap.height, image.depth, 0, mipmap.data, 0, 0);
                }
              } else {
                console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
              }
            } else {
              if (useTexStorage) {
                if (dataReady) {
                  state.texSubImage3D(_gl.TEXTURE_2D_ARRAY, i, 0, 0, 0, mipmap.width, mipmap.height, image.depth, glFormat, glType, mipmap.data);
                }
              } else {
                state.texImage3D(_gl.TEXTURE_2D_ARRAY, i, glInternalFormat, mipmap.width, mipmap.height, image.depth, 0, glFormat, glType, mipmap.data);
              }
            }
          }
        } else {
          if (useTexStorage && allocateMemory) {
            state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height);
          }
          for (let i = 0, il = mipmaps.length; i < il; i++) {
            mipmap = mipmaps[i];
            if (texture.format !== RGBAFormat) {
              if (glFormat !== null) {
                if (useTexStorage) {
                  if (dataReady) {
                    state.compressedTexSubImage2D(_gl.TEXTURE_2D, i, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data);
                  }
                } else {
                  state.compressedTexImage2D(_gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
                }
              } else {
                console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
              }
            } else {
              if (useTexStorage) {
                if (dataReady) {
                  state.texSubImage2D(_gl.TEXTURE_2D, i, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data);
                }
              } else {
                state.texImage2D(_gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
              }
            }
          }
        }
      } else if (texture.isDataArrayTexture) {
        if (useTexStorage) {
          if (allocateMemory) {
            state.texStorage3D(_gl.TEXTURE_2D_ARRAY, levels, glInternalFormat, image.width, image.height, image.depth);
          }
          if (dataReady) {
            if (texture.layerUpdates.size > 0) {
              const layerByteLength = getByteLength(image.width, image.height, texture.format, texture.type);
              for (const layerIndex of texture.layerUpdates) {
                const layerData = image.data.subarray(
                  layerIndex * layerByteLength / image.data.BYTES_PER_ELEMENT,
                  (layerIndex + 1) * layerByteLength / image.data.BYTES_PER_ELEMENT
                );
                state.texSubImage3D(_gl.TEXTURE_2D_ARRAY, 0, 0, 0, layerIndex, image.width, image.height, 1, glFormat, glType, layerData);
              }
              texture.clearLayerUpdates();
            } else {
              state.texSubImage3D(_gl.TEXTURE_2D_ARRAY, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data);
            }
          }
        } else {
          state.texImage3D(_gl.TEXTURE_2D_ARRAY, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
        }
      } else if (texture.isData3DTexture) {
        if (useTexStorage) {
          if (allocateMemory) {
            state.texStorage3D(_gl.TEXTURE_3D, levels, glInternalFormat, image.width, image.height, image.depth);
          }
          if (dataReady) {
            state.texSubImage3D(_gl.TEXTURE_3D, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data);
          }
        } else {
          state.texImage3D(_gl.TEXTURE_3D, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
        }
      } else if (texture.isFramebufferTexture) {
        if (allocateMemory) {
          if (useTexStorage) {
            state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, image.width, image.height);
          } else {
            let width = image.width, height = image.height;
            for (let i = 0; i < levels; i++) {
              state.texImage2D(_gl.TEXTURE_2D, i, glInternalFormat, width, height, 0, glFormat, glType, null);
              width >>= 1;
              height >>= 1;
            }
          }
        }
      } else {
        if (mipmaps.length > 0) {
          if (useTexStorage && allocateMemory) {
            const dimensions = getDimensions(mipmaps[0]);
            state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, dimensions.width, dimensions.height);
          }
          for (let i = 0, il = mipmaps.length; i < il; i++) {
            mipmap = mipmaps[i];
            if (useTexStorage) {
              if (dataReady) {
                state.texSubImage2D(_gl.TEXTURE_2D, i, 0, 0, glFormat, glType, mipmap);
              }
            } else {
              state.texImage2D(_gl.TEXTURE_2D, i, glInternalFormat, glFormat, glType, mipmap);
            }
          }
          texture.generateMipmaps = false;
        } else {
          if (useTexStorage) {
            if (allocateMemory) {
              const dimensions = getDimensions(image);
              state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, dimensions.width, dimensions.height);
            }
            if (dataReady) {
              state.texSubImage2D(_gl.TEXTURE_2D, 0, 0, 0, glFormat, glType, image);
            }
          } else {
            state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, glFormat, glType, image);
          }
        }
      }
      if (textureNeedsGenerateMipmaps(texture)) {
        generateMipmap(textureType);
      }
      sourceProperties.__version = source.version;
      if (texture.onUpdate) texture.onUpdate(texture);
    }
    textureProperties.__version = texture.version;
  }
  function uploadCubeTexture(textureProperties, texture, slot) {
    if (texture.image.length !== 6) return;
    const forceUpload = initTexture(textureProperties, texture);
    const source = texture.source;
    state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
    const sourceProperties = properties.get(source);
    if (source.version !== sourceProperties.__version || forceUpload === true) {
      state.activeTexture(_gl.TEXTURE0 + slot);
      const workingPrimaries = ColorManagement$1.getPrimaries(ColorManagement$1.workingColorSpace);
      const texturePrimaries = texture.colorSpace === NoColorSpace$1 ? null : ColorManagement$1.getPrimaries(texture.colorSpace);
      const unpackConversion = texture.colorSpace === NoColorSpace$1 || workingPrimaries === texturePrimaries ? _gl.NONE : _gl.BROWSER_DEFAULT_WEBGL;
      _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);
      _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha);
      _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, texture.unpackAlignment);
      _gl.pixelStorei(_gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, unpackConversion);
      const isCompressed = texture.isCompressedTexture || texture.image[0].isCompressedTexture;
      const isDataTexture = texture.image[0] && texture.image[0].isDataTexture;
      const cubeImage = [];
      for (let i = 0; i < 6; i++) {
        if (!isCompressed && !isDataTexture) {
          cubeImage[i] = resizeImage(texture.image[i], true, capabilities.maxCubemapSize);
        } else {
          cubeImage[i] = isDataTexture ? texture.image[i].image : texture.image[i];
        }
        cubeImage[i] = verifyColorSpace(texture, cubeImage[i]);
      }
      const image = cubeImage[0], glFormat = utils.convert(texture.format, texture.colorSpace), glType = utils.convert(texture.type), glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.colorSpace);
      const useTexStorage = texture.isVideoTexture !== true;
      const allocateMemory = sourceProperties.__version === void 0 || forceUpload === true;
      const dataReady = source.dataReady;
      let levels = getMipLevels(texture, image);
      setTextureParameters(_gl.TEXTURE_CUBE_MAP, texture);
      let mipmaps;
      if (isCompressed) {
        if (useTexStorage && allocateMemory) {
          state.texStorage2D(_gl.TEXTURE_CUBE_MAP, levels, glInternalFormat, image.width, image.height);
        }
        for (let i = 0; i < 6; i++) {
          mipmaps = cubeImage[i].mipmaps;
          for (let j = 0; j < mipmaps.length; j++) {
            const mipmap = mipmaps[j];
            if (texture.format !== RGBAFormat) {
              if (glFormat !== null) {
                if (useTexStorage) {
                  if (dataReady) {
                    state.compressedTexSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data);
                  }
                } else {
                  state.compressedTexImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
                }
              } else {
                console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()");
              }
            } else {
              if (useTexStorage) {
                if (dataReady) {
                  state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data);
                }
              } else {
                state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
              }
            }
          }
        }
      } else {
        mipmaps = texture.mipmaps;
        if (useTexStorage && allocateMemory) {
          if (mipmaps.length > 0) levels++;
          const dimensions = getDimensions(cubeImage[0]);
          state.texStorage2D(_gl.TEXTURE_CUBE_MAP, levels, glInternalFormat, dimensions.width, dimensions.height);
        }
        for (let i = 0; i < 6; i++) {
          if (isDataTexture) {
            if (useTexStorage) {
              if (dataReady) {
                state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, 0, 0, cubeImage[i].width, cubeImage[i].height, glFormat, glType, cubeImage[i].data);
              }
            } else {
              state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glInternalFormat, cubeImage[i].width, cubeImage[i].height, 0, glFormat, glType, cubeImage[i].data);
            }
            for (let j = 0; j < mipmaps.length; j++) {
              const mipmap = mipmaps[j];
              const mipmapImage = mipmap.image[i].image;
              if (useTexStorage) {
                if (dataReady) {
                  state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, 0, 0, mipmapImage.width, mipmapImage.height, glFormat, glType, mipmapImage.data);
                }
              } else {
                state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data);
              }
            }
          } else {
            if (useTexStorage) {
              if (dataReady) {
                state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, 0, 0, glFormat, glType, cubeImage[i]);
              }
            } else {
              state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glInternalFormat, glFormat, glType, cubeImage[i]);
            }
            for (let j = 0; j < mipmaps.length; j++) {
              const mipmap = mipmaps[j];
              if (useTexStorage) {
                if (dataReady) {
                  state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, 0, 0, glFormat, glType, mipmap.image[i]);
                }
              } else {
                state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, glInternalFormat, glFormat, glType, mipmap.image[i]);
              }
            }
          }
        }
      }
      if (textureNeedsGenerateMipmaps(texture)) {
        generateMipmap(_gl.TEXTURE_CUBE_MAP);
      }
      sourceProperties.__version = source.version;
      if (texture.onUpdate) texture.onUpdate(texture);
    }
    textureProperties.__version = texture.version;
  }
  function setupFrameBufferTexture(framebuffer, renderTarget, texture, attachment, textureTarget, level) {
    const glFormat = utils.convert(texture.format, texture.colorSpace);
    const glType = utils.convert(texture.type);
    const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.colorSpace);
    const renderTargetProperties = properties.get(renderTarget);
    const textureProperties = properties.get(texture);
    textureProperties.__renderTarget = renderTarget;
    if (!renderTargetProperties.__hasExternalTextures) {
      const width = Math.max(1, renderTarget.width >> level);
      const height = Math.max(1, renderTarget.height >> level);
      if (textureTarget === _gl.TEXTURE_3D || textureTarget === _gl.TEXTURE_2D_ARRAY) {
        state.texImage3D(textureTarget, level, glInternalFormat, width, height, renderTarget.depth, 0, glFormat, glType, null);
      } else {
        state.texImage2D(textureTarget, level, glInternalFormat, width, height, 0, glFormat, glType, null);
      }
    }
    state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
    if (useMultisampledRTT(renderTarget)) {
      multisampledRTTExt.framebufferTexture2DMultisampleEXT(_gl.FRAMEBUFFER, attachment, textureTarget, textureProperties.__webglTexture, 0, getRenderTargetSamples(renderTarget));
    } else if (textureTarget === _gl.TEXTURE_2D || textureTarget >= _gl.TEXTURE_CUBE_MAP_POSITIVE_X && textureTarget <= _gl.TEXTURE_CUBE_MAP_NEGATIVE_Z) {
      _gl.framebufferTexture2D(_gl.FRAMEBUFFER, attachment, textureTarget, textureProperties.__webglTexture, level);
    }
    state.bindFramebuffer(_gl.FRAMEBUFFER, null);
  }
  function setupRenderBufferStorage(renderbuffer, renderTarget, isMultisample) {
    _gl.bindRenderbuffer(_gl.RENDERBUFFER, renderbuffer);
    if (renderTarget.depthBuffer) {
      const depthTexture = renderTarget.depthTexture;
      const depthType = depthTexture && depthTexture.isDepthTexture ? depthTexture.type : null;
      const glInternalFormat = getInternalDepthFormat(renderTarget.stencilBuffer, depthType);
      const glAttachmentType = renderTarget.stencilBuffer ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT;
      const samples = getRenderTargetSamples(renderTarget);
      const isUseMultisampledRTT = useMultisampledRTT(renderTarget);
      if (isUseMultisampledRTT) {
        multisampledRTTExt.renderbufferStorageMultisampleEXT(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
      } else if (isMultisample) {
        _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
      } else {
        _gl.renderbufferStorage(_gl.RENDERBUFFER, glInternalFormat, renderTarget.width, renderTarget.height);
      }
      _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, glAttachmentType, _gl.RENDERBUFFER, renderbuffer);
    } else {
      const textures = renderTarget.textures;
      for (let i = 0; i < textures.length; i++) {
        const texture = textures[i];
        const glFormat = utils.convert(texture.format, texture.colorSpace);
        const glType = utils.convert(texture.type);
        const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.colorSpace);
        const samples = getRenderTargetSamples(renderTarget);
        if (isMultisample && useMultisampledRTT(renderTarget) === false) {
          _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
        } else if (useMultisampledRTT(renderTarget)) {
          multisampledRTTExt.renderbufferStorageMultisampleEXT(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
        } else {
          _gl.renderbufferStorage(_gl.RENDERBUFFER, glInternalFormat, renderTarget.width, renderTarget.height);
        }
      }
    }
    _gl.bindRenderbuffer(_gl.RENDERBUFFER, null);
  }
  function setupDepthTexture(framebuffer, renderTarget) {
    const isCube = renderTarget && renderTarget.isWebGLCubeRenderTarget;
    if (isCube) throw new Error("Depth Texture with cube render targets is not supported");
    state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
    if (!(renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture)) {
      throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
    }
    const textureProperties = properties.get(renderTarget.depthTexture);
    textureProperties.__renderTarget = renderTarget;
    if (!textureProperties.__webglTexture || renderTarget.depthTexture.image.width !== renderTarget.width || renderTarget.depthTexture.image.height !== renderTarget.height) {
      renderTarget.depthTexture.image.width = renderTarget.width;
      renderTarget.depthTexture.image.height = renderTarget.height;
      renderTarget.depthTexture.needsUpdate = true;
    }
    setTexture2D(renderTarget.depthTexture, 0);
    const webglDepthTexture = textureProperties.__webglTexture;
    const samples = getRenderTargetSamples(renderTarget);
    if (renderTarget.depthTexture.format === DepthFormat) {
      if (useMultisampledRTT(renderTarget)) {
        multisampledRTTExt.framebufferTexture2DMultisampleEXT(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0, samples);
      } else {
        _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0);
      }
    } else if (renderTarget.depthTexture.format === DepthStencilFormat) {
      if (useMultisampledRTT(renderTarget)) {
        multisampledRTTExt.framebufferTexture2DMultisampleEXT(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0, samples);
      } else {
        _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0);
      }
    } else {
      throw new Error("Unknown depthTexture format");
    }
  }
  function setupDepthRenderbuffer(renderTarget) {
    const renderTargetProperties = properties.get(renderTarget);
    const isCube = renderTarget.isWebGLCubeRenderTarget === true;
    if (renderTargetProperties.__boundDepthTexture !== renderTarget.depthTexture) {
      const depthTexture = renderTarget.depthTexture;
      if (renderTargetProperties.__depthDisposeCallback) {
        renderTargetProperties.__depthDisposeCallback();
      }
      if (depthTexture) {
        const disposeEvent = () => {
          delete renderTargetProperties.__boundDepthTexture;
          delete renderTargetProperties.__depthDisposeCallback;
          depthTexture.removeEventListener("dispose", disposeEvent);
        };
        depthTexture.addEventListener("dispose", disposeEvent);
        renderTargetProperties.__depthDisposeCallback = disposeEvent;
      }
      renderTargetProperties.__boundDepthTexture = depthTexture;
    }
    if (renderTarget.depthTexture && !renderTargetProperties.__autoAllocateDepthBuffer) {
      if (isCube) throw new Error("target.depthTexture not supported in Cube render targets");
      setupDepthTexture(renderTargetProperties.__webglFramebuffer, renderTarget);
    } else {
      if (isCube) {
        renderTargetProperties.__webglDepthbuffer = [];
        for (let i = 0; i < 6; i++) {
          state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[i]);
          if (renderTargetProperties.__webglDepthbuffer[i] === void 0) {
            renderTargetProperties.__webglDepthbuffer[i] = _gl.createRenderbuffer();
            setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i], renderTarget, false);
          } else {
            const glAttachmentType = renderTarget.stencilBuffer ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT;
            const renderbuffer = renderTargetProperties.__webglDepthbuffer[i];
            _gl.bindRenderbuffer(_gl.RENDERBUFFER, renderbuffer);
            _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, glAttachmentType, _gl.RENDERBUFFER, renderbuffer);
          }
        }
      } else {
        state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
        if (renderTargetProperties.__webglDepthbuffer === void 0) {
          renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
          setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, renderTarget, false);
        } else {
          const glAttachmentType = renderTarget.stencilBuffer ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT;
          const renderbuffer = renderTargetProperties.__webglDepthbuffer;
          _gl.bindRenderbuffer(_gl.RENDERBUFFER, renderbuffer);
          _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, glAttachmentType, _gl.RENDERBUFFER, renderbuffer);
        }
      }
    }
    state.bindFramebuffer(_gl.FRAMEBUFFER, null);
  }
  function rebindTextures(renderTarget, colorTexture, depthTexture) {
    const renderTargetProperties = properties.get(renderTarget);
    if (colorTexture !== void 0) {
      setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, renderTarget.texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D, 0);
    }
    if (depthTexture !== void 0) {
      setupDepthRenderbuffer(renderTarget);
    }
  }
  function setupRenderTarget(renderTarget) {
    const texture = renderTarget.texture;
    const renderTargetProperties = properties.get(renderTarget);
    const textureProperties = properties.get(texture);
    renderTarget.addEventListener("dispose", onRenderTargetDispose);
    const textures = renderTarget.textures;
    const isCube = renderTarget.isWebGLCubeRenderTarget === true;
    const isMultipleRenderTargets = textures.length > 1;
    if (!isMultipleRenderTargets) {
      if (textureProperties.__webglTexture === void 0) {
        textureProperties.__webglTexture = _gl.createTexture();
      }
      textureProperties.__version = texture.version;
      info.memory.textures++;
    }
    if (isCube) {
      renderTargetProperties.__webglFramebuffer = [];
      for (let i = 0; i < 6; i++) {
        if (texture.mipmaps && texture.mipmaps.length > 0) {
          renderTargetProperties.__webglFramebuffer[i] = [];
          for (let level = 0; level < texture.mipmaps.length; level++) {
            renderTargetProperties.__webglFramebuffer[i][level] = _gl.createFramebuffer();
          }
        } else {
          renderTargetProperties.__webglFramebuffer[i] = _gl.createFramebuffer();
        }
      }
    } else {
      if (texture.mipmaps && texture.mipmaps.length > 0) {
        renderTargetProperties.__webglFramebuffer = [];
        for (let level = 0; level < texture.mipmaps.length; level++) {
          renderTargetProperties.__webglFramebuffer[level] = _gl.createFramebuffer();
        }
      } else {
        renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();
      }
      if (isMultipleRenderTargets) {
        for (let i = 0, il = textures.length; i < il; i++) {
          const attachmentProperties = properties.get(textures[i]);
          if (attachmentProperties.__webglTexture === void 0) {
            attachmentProperties.__webglTexture = _gl.createTexture();
            info.memory.textures++;
          }
        }
      }
      if (renderTarget.samples > 0 && useMultisampledRTT(renderTarget) === false) {
        renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();
        renderTargetProperties.__webglColorRenderbuffer = [];
        state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
        for (let i = 0; i < textures.length; i++) {
          const texture2 = textures[i];
          renderTargetProperties.__webglColorRenderbuffer[i] = _gl.createRenderbuffer();
          _gl.bindRenderbuffer(_gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[i]);
          const glFormat = utils.convert(texture2.format, texture2.colorSpace);
          const glType = utils.convert(texture2.type);
          const glInternalFormat = getInternalFormat(texture2.internalFormat, glFormat, glType, texture2.colorSpace, renderTarget.isXRRenderTarget === true);
          const samples = getRenderTargetSamples(renderTarget);
          _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
          _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[i]);
        }
        _gl.bindRenderbuffer(_gl.RENDERBUFFER, null);
        if (renderTarget.depthBuffer) {
          renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();
          setupRenderBufferStorage(renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true);
        }
        state.bindFramebuffer(_gl.FRAMEBUFFER, null);
      }
    }
    if (isCube) {
      state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture);
      setTextureParameters(_gl.TEXTURE_CUBE_MAP, texture);
      for (let i = 0; i < 6; i++) {
        if (texture.mipmaps && texture.mipmaps.length > 0) {
          for (let level = 0; level < texture.mipmaps.length; level++) {
            setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i][level], renderTarget, texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, level);
          }
        } else {
          setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i], renderTarget, texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0);
        }
      }
      if (textureNeedsGenerateMipmaps(texture)) {
        generateMipmap(_gl.TEXTURE_CUBE_MAP);
      }
      state.unbindTexture();
    } else if (isMultipleRenderTargets) {
      for (let i = 0, il = textures.length; i < il; i++) {
        const attachment = textures[i];
        const attachmentProperties = properties.get(attachment);
        state.bindTexture(_gl.TEXTURE_2D, attachmentProperties.__webglTexture);
        setTextureParameters(_gl.TEXTURE_2D, attachment);
        setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, attachment, _gl.COLOR_ATTACHMENT0 + i, _gl.TEXTURE_2D, 0);
        if (textureNeedsGenerateMipmaps(attachment)) {
          generateMipmap(_gl.TEXTURE_2D);
        }
      }
      state.unbindTexture();
    } else {
      let glTextureType = _gl.TEXTURE_2D;
      if (renderTarget.isWebGL3DRenderTarget || renderTarget.isWebGLArrayRenderTarget) {
        glTextureType = renderTarget.isWebGL3DRenderTarget ? _gl.TEXTURE_3D : _gl.TEXTURE_2D_ARRAY;
      }
      state.bindTexture(glTextureType, textureProperties.__webglTexture);
      setTextureParameters(glTextureType, texture);
      if (texture.mipmaps && texture.mipmaps.length > 0) {
        for (let level = 0; level < texture.mipmaps.length; level++) {
          setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[level], renderTarget, texture, _gl.COLOR_ATTACHMENT0, glTextureType, level);
        }
      } else {
        setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, texture, _gl.COLOR_ATTACHMENT0, glTextureType, 0);
      }
      if (textureNeedsGenerateMipmaps(texture)) {
        generateMipmap(glTextureType);
      }
      state.unbindTexture();
    }
    if (renderTarget.depthBuffer) {
      setupDepthRenderbuffer(renderTarget);
    }
  }
  function updateRenderTargetMipmap(renderTarget) {
    const textures = renderTarget.textures;
    for (let i = 0, il = textures.length; i < il; i++) {
      const texture = textures[i];
      if (textureNeedsGenerateMipmaps(texture)) {
        const targetType = getTargetType(renderTarget);
        const webglTexture = properties.get(texture).__webglTexture;
        state.bindTexture(targetType, webglTexture);
        generateMipmap(targetType);
        state.unbindTexture();
      }
    }
  }
  const invalidationArrayRead = [];
  const invalidationArrayDraw = [];
  function updateMultisampleRenderTarget(renderTarget) {
    if (renderTarget.samples > 0) {
      if (useMultisampledRTT(renderTarget) === false) {
        const textures = renderTarget.textures;
        const width = renderTarget.width;
        const height = renderTarget.height;
        let mask = _gl.COLOR_BUFFER_BIT;
        const depthStyle = renderTarget.stencilBuffer ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT;
        const renderTargetProperties = properties.get(renderTarget);
        const isMultipleRenderTargets = textures.length > 1;
        if (isMultipleRenderTargets) {
          for (let i = 0; i < textures.length; i++) {
            state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
            _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.RENDERBUFFER, null);
            state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
            _gl.framebufferTexture2D(_gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.TEXTURE_2D, null, 0);
          }
        }
        state.bindFramebuffer(_gl.READ_FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
        state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
        for (let i = 0; i < textures.length; i++) {
          if (renderTarget.resolveDepthBuffer) {
            if (renderTarget.depthBuffer) mask |= _gl.DEPTH_BUFFER_BIT;
            if (renderTarget.stencilBuffer && renderTarget.resolveStencilBuffer) mask |= _gl.STENCIL_BUFFER_BIT;
          }
          if (isMultipleRenderTargets) {
            _gl.framebufferRenderbuffer(_gl.READ_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[i]);
            const webglTexture = properties.get(textures[i]).__webglTexture;
            _gl.framebufferTexture2D(_gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D, webglTexture, 0);
          }
          _gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, mask, _gl.NEAREST);
          if (supportsInvalidateFramebuffer === true) {
            invalidationArrayRead.length = 0;
            invalidationArrayDraw.length = 0;
            invalidationArrayRead.push(_gl.COLOR_ATTACHMENT0 + i);
            if (renderTarget.depthBuffer && renderTarget.resolveDepthBuffer === false) {
              invalidationArrayRead.push(depthStyle);
              invalidationArrayDraw.push(depthStyle);
              _gl.invalidateFramebuffer(_gl.DRAW_FRAMEBUFFER, invalidationArrayDraw);
            }
            _gl.invalidateFramebuffer(_gl.READ_FRAMEBUFFER, invalidationArrayRead);
          }
        }
        state.bindFramebuffer(_gl.READ_FRAMEBUFFER, null);
        state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, null);
        if (isMultipleRenderTargets) {
          for (let i = 0; i < textures.length; i++) {
            state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
            _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[i]);
            const webglTexture = properties.get(textures[i]).__webglTexture;
            state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
            _gl.framebufferTexture2D(_gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.TEXTURE_2D, webglTexture, 0);
          }
        }
        state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
      } else {
        if (renderTarget.depthBuffer && renderTarget.resolveDepthBuffer === false && supportsInvalidateFramebuffer) {
          const depthStyle = renderTarget.stencilBuffer ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT;
          _gl.invalidateFramebuffer(_gl.DRAW_FRAMEBUFFER, [depthStyle]);
        }
      }
    }
  }
  function getRenderTargetSamples(renderTarget) {
    return Math.min(capabilities.maxSamples, renderTarget.samples);
  }
  function useMultisampledRTT(renderTarget) {
    const renderTargetProperties = properties.get(renderTarget);
    return renderTarget.samples > 0 && extensions.has("WEBGL_multisampled_render_to_texture") === true && renderTargetProperties.__useRenderToTexture !== false;
  }
  function updateVideoTexture(texture) {
    const frame = info.render.frame;
    if (_videoTextures.get(texture) !== frame) {
      _videoTextures.set(texture, frame);
      texture.update();
    }
  }
  function verifyColorSpace(texture, image) {
    const colorSpace = texture.colorSpace;
    const format = texture.format;
    const type = texture.type;
    if (texture.isCompressedTexture === true || texture.isVideoTexture === true) return image;
    if (colorSpace !== LinearSRGBColorSpace$1 && colorSpace !== NoColorSpace$1) {
      if (ColorManagement$1.getTransfer(colorSpace) === SRGBTransfer$1) {
        if (format !== RGBAFormat || type !== UnsignedByteType) {
          console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.");
        }
      } else {
        console.error("THREE.WebGLTextures: Unsupported texture color space:", colorSpace);
      }
    }
    return image;
  }
  function getDimensions(image) {
    if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement) {
      _imageDimensions.width = image.naturalWidth || image.width;
      _imageDimensions.height = image.naturalHeight || image.height;
    } else if (typeof VideoFrame !== "undefined" && image instanceof VideoFrame) {
      _imageDimensions.width = image.displayWidth;
      _imageDimensions.height = image.displayHeight;
    } else {
      _imageDimensions.width = image.width;
      _imageDimensions.height = image.height;
    }
    return _imageDimensions;
  }
  this.allocateTextureUnit = allocateTextureUnit;
  this.resetTextureUnits = resetTextureUnits;
  this.setTexture2D = setTexture2D;
  this.setTexture2DArray = setTexture2DArray;
  this.setTexture3D = setTexture3D;
  this.setTextureCube = setTextureCube;
  this.rebindTextures = rebindTextures;
  this.setupRenderTarget = setupRenderTarget;
  this.updateRenderTargetMipmap = updateRenderTargetMipmap;
  this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;
  this.setupDepthRenderbuffer = setupDepthRenderbuffer;
  this.setupFrameBufferTexture = setupFrameBufferTexture;
  this.useMultisampledRTT = useMultisampledRTT;
}
function WebGLUtils(gl, extensions) {
  function convert2(p, colorSpace = NoColorSpace$1) {
    let extension;
    const transfer = ColorManagement$1.getTransfer(colorSpace);
    if (p === UnsignedByteType) return gl.UNSIGNED_BYTE;
    if (p === UnsignedShort4444Type) return gl.UNSIGNED_SHORT_4_4_4_4;
    if (p === UnsignedShort5551Type) return gl.UNSIGNED_SHORT_5_5_5_1;
    if (p === UnsignedInt5999Type) return gl.UNSIGNED_INT_5_9_9_9_REV;
    if (p === ByteType) return gl.BYTE;
    if (p === ShortType) return gl.SHORT;
    if (p === UnsignedShortType) return gl.UNSIGNED_SHORT;
    if (p === IntType) return gl.INT;
    if (p === UnsignedIntType) return gl.UNSIGNED_INT;
    if (p === FloatType$1) return gl.FLOAT;
    if (p === HalfFloatType) return gl.HALF_FLOAT;
    if (p === AlphaFormat) return gl.ALPHA;
    if (p === RGBFormat) return gl.RGB;
    if (p === RGBAFormat) return gl.RGBA;
    if (p === LuminanceFormat) return gl.LUMINANCE;
    if (p === LuminanceAlphaFormat) return gl.LUMINANCE_ALPHA;
    if (p === DepthFormat) return gl.DEPTH_COMPONENT;
    if (p === DepthStencilFormat) return gl.DEPTH_STENCIL;
    if (p === RedFormat) return gl.RED;
    if (p === RedIntegerFormat) return gl.RED_INTEGER;
    if (p === RGFormat) return gl.RG;
    if (p === RGIntegerFormat) return gl.RG_INTEGER;
    if (p === RGBAIntegerFormat) return gl.RGBA_INTEGER;
    if (p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format || p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format) {
      if (transfer === SRGBTransfer$1) {
        extension = extensions.get("WEBGL_compressed_texture_s3tc_srgb");
        if (extension !== null) {
          if (p === RGB_S3TC_DXT1_Format) return extension.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          if (p === RGBA_S3TC_DXT1_Format) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          if (p === RGBA_S3TC_DXT3_Format) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
          if (p === RGBA_S3TC_DXT5_Format) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        } else {
          return null;
        }
      } else {
        extension = extensions.get("WEBGL_compressed_texture_s3tc");
        if (extension !== null) {
          if (p === RGB_S3TC_DXT1_Format) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
          if (p === RGBA_S3TC_DXT1_Format) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
          if (p === RGBA_S3TC_DXT3_Format) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
          if (p === RGBA_S3TC_DXT5_Format) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
        } else {
          return null;
        }
      }
    }
    if (p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format || p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format) {
      extension = extensions.get("WEBGL_compressed_texture_pvrtc");
      if (extension !== null) {
        if (p === RGB_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (p === RGB_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (p === RGBA_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (p === RGBA_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else {
        return null;
      }
    }
    if (p === RGB_ETC1_Format || p === RGB_ETC2_Format || p === RGBA_ETC2_EAC_Format) {
      extension = extensions.get("WEBGL_compressed_texture_etc");
      if (extension !== null) {
        if (p === RGB_ETC1_Format || p === RGB_ETC2_Format) return transfer === SRGBTransfer$1 ? extension.COMPRESSED_SRGB8_ETC2 : extension.COMPRESSED_RGB8_ETC2;
        if (p === RGBA_ETC2_EAC_Format) return transfer === SRGBTransfer$1 ? extension.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : extension.COMPRESSED_RGBA8_ETC2_EAC;
      } else {
        return null;
      }
    }
    if (p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format || p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format || p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format || p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format || p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format) {
      extension = extensions.get("WEBGL_compressed_texture_astc");
      if (extension !== null) {
        if (p === RGBA_ASTC_4x4_Format) return transfer === SRGBTransfer$1 ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : extension.COMPRESSED_RGBA_ASTC_4x4_KHR;
        if (p === RGBA_ASTC_5x4_Format) return transfer === SRGBTransfer$1 ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : extension.COMPRESSED_RGBA_ASTC_5x4_KHR;
        if (p === RGBA_ASTC_5x5_Format) return transfer === SRGBTransfer$1 ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : extension.COMPRESSED_RGBA_ASTC_5x5_KHR;
        if (p === RGBA_ASTC_6x5_Format) return transfer === SRGBTransfer$1 ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : extension.COMPRESSED_RGBA_ASTC_6x5_KHR;
        if (p === RGBA_ASTC_6x6_Format) return transfer === SRGBTransfer$1 ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : extension.COMPRESSED_RGBA_ASTC_6x6_KHR;
        if (p === RGBA_ASTC_8x5_Format) return transfer === SRGBTransfer$1 ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : extension.COMPRESSED_RGBA_ASTC_8x5_KHR;
        if (p === RGBA_ASTC_8x6_Format) return transfer === SRGBTransfer$1 ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : extension.COMPRESSED_RGBA_ASTC_8x6_KHR;
        if (p === RGBA_ASTC_8x8_Format) return transfer === SRGBTransfer$1 ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : extension.COMPRESSED_RGBA_ASTC_8x8_KHR;
        if (p === RGBA_ASTC_10x5_Format) return transfer === SRGBTransfer$1 ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : extension.COMPRESSED_RGBA_ASTC_10x5_KHR;
        if (p === RGBA_ASTC_10x6_Format) return transfer === SRGBTransfer$1 ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : extension.COMPRESSED_RGBA_ASTC_10x6_KHR;
        if (p === RGBA_ASTC_10x8_Format) return transfer === SRGBTransfer$1 ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : extension.COMPRESSED_RGBA_ASTC_10x8_KHR;
        if (p === RGBA_ASTC_10x10_Format) return transfer === SRGBTransfer$1 ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : extension.COMPRESSED_RGBA_ASTC_10x10_KHR;
        if (p === RGBA_ASTC_12x10_Format) return transfer === SRGBTransfer$1 ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : extension.COMPRESSED_RGBA_ASTC_12x10_KHR;
        if (p === RGBA_ASTC_12x12_Format) return transfer === SRGBTransfer$1 ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : extension.COMPRESSED_RGBA_ASTC_12x12_KHR;
      } else {
        return null;
      }
    }
    if (p === RGBA_BPTC_Format || p === RGB_BPTC_SIGNED_Format || p === RGB_BPTC_UNSIGNED_Format) {
      extension = extensions.get("EXT_texture_compression_bptc");
      if (extension !== null) {
        if (p === RGBA_BPTC_Format) return transfer === SRGBTransfer$1 ? extension.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : extension.COMPRESSED_RGBA_BPTC_UNORM_EXT;
        if (p === RGB_BPTC_SIGNED_Format) return extension.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
        if (p === RGB_BPTC_UNSIGNED_Format) return extension.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
      } else {
        return null;
      }
    }
    if (p === RED_RGTC1_Format || p === SIGNED_RED_RGTC1_Format || p === RED_GREEN_RGTC2_Format || p === SIGNED_RED_GREEN_RGTC2_Format) {
      extension = extensions.get("EXT_texture_compression_rgtc");
      if (extension !== null) {
        if (p === RGBA_BPTC_Format) return extension.COMPRESSED_RED_RGTC1_EXT;
        if (p === SIGNED_RED_RGTC1_Format) return extension.COMPRESSED_SIGNED_RED_RGTC1_EXT;
        if (p === RED_GREEN_RGTC2_Format) return extension.COMPRESSED_RED_GREEN_RGTC2_EXT;
        if (p === SIGNED_RED_GREEN_RGTC2_Format) return extension.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
      } else {
        return null;
      }
    }
    if (p === UnsignedInt248Type) return gl.UNSIGNED_INT_24_8;
    return gl[p] !== void 0 ? gl[p] : null;
  }
  return { convert: convert2 };
}
const _moveEvent = { type: "move" };
class WebXRController {
  constructor() {
    this._targetRay = null;
    this._grip = null;
    this._hand = null;
  }
  getHandSpace() {
    if (this._hand === null) {
      this._hand = new Group$1();
      this._hand.matrixAutoUpdate = false;
      this._hand.visible = false;
      this._hand.joints = {};
      this._hand.inputState = { pinching: false };
    }
    return this._hand;
  }
  getTargetRaySpace() {
    if (this._targetRay === null) {
      this._targetRay = new Group$1();
      this._targetRay.matrixAutoUpdate = false;
      this._targetRay.visible = false;
      this._targetRay.hasLinearVelocity = false;
      this._targetRay.linearVelocity = new Vector3$1();
      this._targetRay.hasAngularVelocity = false;
      this._targetRay.angularVelocity = new Vector3$1();
    }
    return this._targetRay;
  }
  getGripSpace() {
    if (this._grip === null) {
      this._grip = new Group$1();
      this._grip.matrixAutoUpdate = false;
      this._grip.visible = false;
      this._grip.hasLinearVelocity = false;
      this._grip.linearVelocity = new Vector3$1();
      this._grip.hasAngularVelocity = false;
      this._grip.angularVelocity = new Vector3$1();
    }
    return this._grip;
  }
  dispatchEvent(event) {
    if (this._targetRay !== null) {
      this._targetRay.dispatchEvent(event);
    }
    if (this._grip !== null) {
      this._grip.dispatchEvent(event);
    }
    if (this._hand !== null) {
      this._hand.dispatchEvent(event);
    }
    return this;
  }
  connect(inputSource) {
    if (inputSource && inputSource.hand) {
      const hand = this._hand;
      if (hand) {
        for (const inputjoint of inputSource.hand.values()) {
          this._getHandJoint(hand, inputjoint);
        }
      }
    }
    this.dispatchEvent({ type: "connected", data: inputSource });
    return this;
  }
  disconnect(inputSource) {
    this.dispatchEvent({ type: "disconnected", data: inputSource });
    if (this._targetRay !== null) {
      this._targetRay.visible = false;
    }
    if (this._grip !== null) {
      this._grip.visible = false;
    }
    if (this._hand !== null) {
      this._hand.visible = false;
    }
    return this;
  }
  update(inputSource, frame, referenceSpace) {
    let inputPose = null;
    let gripPose = null;
    let handPose = null;
    const targetRay = this._targetRay;
    const grip = this._grip;
    const hand = this._hand;
    if (inputSource && frame.session.visibilityState !== "visible-blurred") {
      if (hand && inputSource.hand) {
        handPose = true;
        for (const inputjoint of inputSource.hand.values()) {
          const jointPose = frame.getJointPose(inputjoint, referenceSpace);
          const joint = this._getHandJoint(hand, inputjoint);
          if (jointPose !== null) {
            joint.matrix.fromArray(jointPose.transform.matrix);
            joint.matrix.decompose(joint.position, joint.rotation, joint.scale);
            joint.matrixWorldNeedsUpdate = true;
            joint.jointRadius = jointPose.radius;
          }
          joint.visible = jointPose !== null;
        }
        const indexTip = hand.joints["index-finger-tip"];
        const thumbTip = hand.joints["thumb-tip"];
        const distance2 = indexTip.position.distanceTo(thumbTip.position);
        const distanceToPinch = 0.02;
        const threshold = 5e-3;
        if (hand.inputState.pinching && distance2 > distanceToPinch + threshold) {
          hand.inputState.pinching = false;
          this.dispatchEvent({
            type: "pinchend",
            handedness: inputSource.handedness,
            target: this
          });
        } else if (!hand.inputState.pinching && distance2 <= distanceToPinch - threshold) {
          hand.inputState.pinching = true;
          this.dispatchEvent({
            type: "pinchstart",
            handedness: inputSource.handedness,
            target: this
          });
        }
      } else {
        if (grip !== null && inputSource.gripSpace) {
          gripPose = frame.getPose(inputSource.gripSpace, referenceSpace);
          if (gripPose !== null) {
            grip.matrix.fromArray(gripPose.transform.matrix);
            grip.matrix.decompose(grip.position, grip.rotation, grip.scale);
            grip.matrixWorldNeedsUpdate = true;
            if (gripPose.linearVelocity) {
              grip.hasLinearVelocity = true;
              grip.linearVelocity.copy(gripPose.linearVelocity);
            } else {
              grip.hasLinearVelocity = false;
            }
            if (gripPose.angularVelocity) {
              grip.hasAngularVelocity = true;
              grip.angularVelocity.copy(gripPose.angularVelocity);
            } else {
              grip.hasAngularVelocity = false;
            }
          }
        }
      }
      if (targetRay !== null) {
        inputPose = frame.getPose(inputSource.targetRaySpace, referenceSpace);
        if (inputPose === null && gripPose !== null) {
          inputPose = gripPose;
        }
        if (inputPose !== null) {
          targetRay.matrix.fromArray(inputPose.transform.matrix);
          targetRay.matrix.decompose(targetRay.position, targetRay.rotation, targetRay.scale);
          targetRay.matrixWorldNeedsUpdate = true;
          if (inputPose.linearVelocity) {
            targetRay.hasLinearVelocity = true;
            targetRay.linearVelocity.copy(inputPose.linearVelocity);
          } else {
            targetRay.hasLinearVelocity = false;
          }
          if (inputPose.angularVelocity) {
            targetRay.hasAngularVelocity = true;
            targetRay.angularVelocity.copy(inputPose.angularVelocity);
          } else {
            targetRay.hasAngularVelocity = false;
          }
          this.dispatchEvent(_moveEvent);
        }
      }
    }
    if (targetRay !== null) {
      targetRay.visible = inputPose !== null;
    }
    if (grip !== null) {
      grip.visible = gripPose !== null;
    }
    if (hand !== null) {
      hand.visible = handPose !== null;
    }
    return this;
  }
  // private method
  _getHandJoint(hand, inputjoint) {
    if (hand.joints[inputjoint.jointName] === void 0) {
      const joint = new Group$1();
      joint.matrixAutoUpdate = false;
      joint.visible = false;
      hand.joints[inputjoint.jointName] = joint;
      hand.add(joint);
    }
    return hand.joints[inputjoint.jointName];
  }
}
const _occlusion_vertex = `
void main() {

	gl_Position = vec4( position, 1.0 );

}`;
const _occlusion_fragment = `
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;
class WebXRDepthSensing {
  constructor() {
    this.texture = null;
    this.mesh = null;
    this.depthNear = 0;
    this.depthFar = 0;
  }
  init(renderer, depthData, renderState) {
    if (this.texture === null) {
      const texture = new Texture();
      const texProps = renderer.properties.get(texture);
      texProps.__webglTexture = depthData.texture;
      if (depthData.depthNear !== renderState.depthNear || depthData.depthFar !== renderState.depthFar) {
        this.depthNear = depthData.depthNear;
        this.depthFar = depthData.depthFar;
      }
      this.texture = texture;
    }
  }
  getMesh(cameraXR) {
    if (this.texture !== null) {
      if (this.mesh === null) {
        const viewport = cameraXR.cameras[0].viewport;
        const material = new ShaderMaterial({
          vertexShader: _occlusion_vertex,
          fragmentShader: _occlusion_fragment,
          uniforms: {
            depthColor: { value: this.texture },
            depthWidth: { value: viewport.z },
            depthHeight: { value: viewport.w }
          }
        });
        this.mesh = new Mesh(new PlaneGeometry(20, 20), material);
      }
    }
    return this.mesh;
  }
  reset() {
    this.texture = null;
    this.mesh = null;
  }
  getDepthTexture() {
    return this.texture;
  }
}
class WebXRManager extends EventDispatcher$1 {
  constructor(renderer, gl) {
    super();
    const scope = this;
    let session = null;
    let framebufferScaleFactor = 1;
    let referenceSpace = null;
    let referenceSpaceType = "local-floor";
    let foveation = 1;
    let customReferenceSpace = null;
    let pose = null;
    let glBinding = null;
    let glProjLayer = null;
    let glBaseLayer = null;
    let xrFrame = null;
    const depthSensing = new WebXRDepthSensing();
    const attributes = gl.getContextAttributes();
    let initialRenderTarget = null;
    let newRenderTarget = null;
    const controllers = [];
    const controllerInputSources = [];
    const currentSize = new Vector2$1();
    let currentPixelRatio = null;
    const cameraL = new PerspectiveCamera();
    cameraL.viewport = new Vector4$1();
    const cameraR = new PerspectiveCamera();
    cameraR.viewport = new Vector4$1();
    const cameras = [cameraL, cameraR];
    const cameraXR = new ArrayCamera();
    let _currentDepthNear = null;
    let _currentDepthFar = null;
    this.cameraAutoUpdate = true;
    this.enabled = false;
    this.isPresenting = false;
    this.getController = function(index) {
      let controller = controllers[index];
      if (controller === void 0) {
        controller = new WebXRController();
        controllers[index] = controller;
      }
      return controller.getTargetRaySpace();
    };
    this.getControllerGrip = function(index) {
      let controller = controllers[index];
      if (controller === void 0) {
        controller = new WebXRController();
        controllers[index] = controller;
      }
      return controller.getGripSpace();
    };
    this.getHand = function(index) {
      let controller = controllers[index];
      if (controller === void 0) {
        controller = new WebXRController();
        controllers[index] = controller;
      }
      return controller.getHandSpace();
    };
    function onSessionEvent(event) {
      const controllerIndex = controllerInputSources.indexOf(event.inputSource);
      if (controllerIndex === -1) {
        return;
      }
      const controller = controllers[controllerIndex];
      if (controller !== void 0) {
        controller.update(event.inputSource, event.frame, customReferenceSpace || referenceSpace);
        controller.dispatchEvent({ type: event.type, data: event.inputSource });
      }
    }
    function onSessionEnd() {
      session.removeEventListener("select", onSessionEvent);
      session.removeEventListener("selectstart", onSessionEvent);
      session.removeEventListener("selectend", onSessionEvent);
      session.removeEventListener("squeeze", onSessionEvent);
      session.removeEventListener("squeezestart", onSessionEvent);
      session.removeEventListener("squeezeend", onSessionEvent);
      session.removeEventListener("end", onSessionEnd);
      session.removeEventListener("inputsourceschange", onInputSourcesChange);
      for (let i = 0; i < controllers.length; i++) {
        const inputSource = controllerInputSources[i];
        if (inputSource === null) continue;
        controllerInputSources[i] = null;
        controllers[i].disconnect(inputSource);
      }
      _currentDepthNear = null;
      _currentDepthFar = null;
      depthSensing.reset();
      renderer.setRenderTarget(initialRenderTarget);
      glBaseLayer = null;
      glProjLayer = null;
      glBinding = null;
      session = null;
      newRenderTarget = null;
      animation.stop();
      scope.isPresenting = false;
      renderer.setPixelRatio(currentPixelRatio);
      renderer.setSize(currentSize.width, currentSize.height, false);
      scope.dispatchEvent({ type: "sessionend" });
    }
    this.setFramebufferScaleFactor = function(value) {
      framebufferScaleFactor = value;
      if (scope.isPresenting === true) {
        console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
      }
    };
    this.setReferenceSpaceType = function(value) {
      referenceSpaceType = value;
      if (scope.isPresenting === true) {
        console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
      }
    };
    this.getReferenceSpace = function() {
      return customReferenceSpace || referenceSpace;
    };
    this.setReferenceSpace = function(space) {
      customReferenceSpace = space;
    };
    this.getBaseLayer = function() {
      return glProjLayer !== null ? glProjLayer : glBaseLayer;
    };
    this.getBinding = function() {
      return glBinding;
    };
    this.getFrame = function() {
      return xrFrame;
    };
    this.getSession = function() {
      return session;
    };
    this.setSession = async function(value) {
      session = value;
      if (session !== null) {
        initialRenderTarget = renderer.getRenderTarget();
        session.addEventListener("select", onSessionEvent);
        session.addEventListener("selectstart", onSessionEvent);
        session.addEventListener("selectend", onSessionEvent);
        session.addEventListener("squeeze", onSessionEvent);
        session.addEventListener("squeezestart", onSessionEvent);
        session.addEventListener("squeezeend", onSessionEvent);
        session.addEventListener("end", onSessionEnd);
        session.addEventListener("inputsourceschange", onInputSourcesChange);
        if (attributes.xrCompatible !== true) {
          await gl.makeXRCompatible();
        }
        currentPixelRatio = renderer.getPixelRatio();
        renderer.getSize(currentSize);
        const useLayers = session.enabledFeatures !== void 0 && session.enabledFeatures.includes("layers");
        if (!useLayers) {
          const layerInit = {
            antialias: attributes.antialias,
            alpha: true,
            depth: attributes.depth,
            stencil: attributes.stencil,
            framebufferScaleFactor
          };
          glBaseLayer = new XRWebGLLayer(session, gl, layerInit);
          session.updateRenderState({ baseLayer: glBaseLayer });
          renderer.setPixelRatio(1);
          renderer.setSize(glBaseLayer.framebufferWidth, glBaseLayer.framebufferHeight, false);
          newRenderTarget = new WebGLRenderTarget(
            glBaseLayer.framebufferWidth,
            glBaseLayer.framebufferHeight,
            {
              format: RGBAFormat,
              type: UnsignedByteType,
              colorSpace: renderer.outputColorSpace,
              stencilBuffer: attributes.stencil
            }
          );
        } else {
          let depthFormat = null;
          let depthType = null;
          let glDepthFormat = null;
          if (attributes.depth) {
            glDepthFormat = attributes.stencil ? gl.DEPTH24_STENCIL8 : gl.DEPTH_COMPONENT24;
            depthFormat = attributes.stencil ? DepthStencilFormat : DepthFormat;
            depthType = attributes.stencil ? UnsignedInt248Type : UnsignedIntType;
          }
          const projectionlayerInit = {
            colorFormat: gl.RGBA8,
            depthFormat: glDepthFormat,
            scaleFactor: framebufferScaleFactor
          };
          glBinding = new XRWebGLBinding(session, gl);
          glProjLayer = glBinding.createProjectionLayer(projectionlayerInit);
          session.updateRenderState({ layers: [glProjLayer] });
          renderer.setPixelRatio(1);
          renderer.setSize(glProjLayer.textureWidth, glProjLayer.textureHeight, false);
          newRenderTarget = new WebGLRenderTarget(
            glProjLayer.textureWidth,
            glProjLayer.textureHeight,
            {
              format: RGBAFormat,
              type: UnsignedByteType,
              depthTexture: new DepthTexture(glProjLayer.textureWidth, glProjLayer.textureHeight, depthType, void 0, void 0, void 0, void 0, void 0, void 0, depthFormat),
              stencilBuffer: attributes.stencil,
              colorSpace: renderer.outputColorSpace,
              samples: attributes.antialias ? 4 : 0,
              resolveDepthBuffer: glProjLayer.ignoreDepthValues === false
            }
          );
        }
        newRenderTarget.isXRRenderTarget = true;
        this.setFoveation(foveation);
        customReferenceSpace = null;
        referenceSpace = await session.requestReferenceSpace(referenceSpaceType);
        animation.setContext(session);
        animation.start();
        scope.isPresenting = true;
        scope.dispatchEvent({ type: "sessionstart" });
      }
    };
    this.getEnvironmentBlendMode = function() {
      if (session !== null) {
        return session.environmentBlendMode;
      }
    };
    this.getDepthTexture = function() {
      return depthSensing.getDepthTexture();
    };
    function onInputSourcesChange(event) {
      for (let i = 0; i < event.removed.length; i++) {
        const inputSource = event.removed[i];
        const index = controllerInputSources.indexOf(inputSource);
        if (index >= 0) {
          controllerInputSources[index] = null;
          controllers[index].disconnect(inputSource);
        }
      }
      for (let i = 0; i < event.added.length; i++) {
        const inputSource = event.added[i];
        let controllerIndex = controllerInputSources.indexOf(inputSource);
        if (controllerIndex === -1) {
          for (let i2 = 0; i2 < controllers.length; i2++) {
            if (i2 >= controllerInputSources.length) {
              controllerInputSources.push(inputSource);
              controllerIndex = i2;
              break;
            } else if (controllerInputSources[i2] === null) {
              controllerInputSources[i2] = inputSource;
              controllerIndex = i2;
              break;
            }
          }
          if (controllerIndex === -1) break;
        }
        const controller = controllers[controllerIndex];
        if (controller) {
          controller.connect(inputSource);
        }
      }
    }
    const cameraLPos = new Vector3$1();
    const cameraRPos = new Vector3$1();
    function setProjectionFromUnion(camera, cameraL2, cameraR2) {
      cameraLPos.setFromMatrixPosition(cameraL2.matrixWorld);
      cameraRPos.setFromMatrixPosition(cameraR2.matrixWorld);
      const ipd = cameraLPos.distanceTo(cameraRPos);
      const projL = cameraL2.projectionMatrix.elements;
      const projR = cameraR2.projectionMatrix.elements;
      const near = projL[14] / (projL[10] - 1);
      const far = projL[14] / (projL[10] + 1);
      const topFov = (projL[9] + 1) / projL[5];
      const bottomFov = (projL[9] - 1) / projL[5];
      const leftFov = (projL[8] - 1) / projL[0];
      const rightFov = (projR[8] + 1) / projR[0];
      const left = near * leftFov;
      const right = near * rightFov;
      const zOffset = ipd / (-leftFov + rightFov);
      const xOffset = zOffset * -leftFov;
      cameraL2.matrixWorld.decompose(camera.position, camera.quaternion, camera.scale);
      camera.translateX(xOffset);
      camera.translateZ(zOffset);
      camera.matrixWorld.compose(camera.position, camera.quaternion, camera.scale);
      camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
      if (projL[10] === -1) {
        camera.projectionMatrix.copy(cameraL2.projectionMatrix);
        camera.projectionMatrixInverse.copy(cameraL2.projectionMatrixInverse);
      } else {
        const near2 = near + zOffset;
        const far2 = far + zOffset;
        const left2 = left - xOffset;
        const right2 = right + (ipd - xOffset);
        const top2 = topFov * far / far2 * near2;
        const bottom2 = bottomFov * far / far2 * near2;
        camera.projectionMatrix.makePerspective(left2, right2, top2, bottom2, near2, far2);
        camera.projectionMatrixInverse.copy(camera.projectionMatrix).invert();
      }
    }
    function updateCamera(camera, parent) {
      if (parent === null) {
        camera.matrixWorld.copy(camera.matrix);
      } else {
        camera.matrixWorld.multiplyMatrices(parent.matrixWorld, camera.matrix);
      }
      camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
    }
    this.updateCamera = function(camera) {
      if (session === null) return;
      let depthNear = camera.near;
      let depthFar = camera.far;
      if (depthSensing.texture !== null) {
        if (depthSensing.depthNear > 0) depthNear = depthSensing.depthNear;
        if (depthSensing.depthFar > 0) depthFar = depthSensing.depthFar;
      }
      cameraXR.near = cameraR.near = cameraL.near = depthNear;
      cameraXR.far = cameraR.far = cameraL.far = depthFar;
      if (_currentDepthNear !== cameraXR.near || _currentDepthFar !== cameraXR.far) {
        session.updateRenderState({
          depthNear: cameraXR.near,
          depthFar: cameraXR.far
        });
        _currentDepthNear = cameraXR.near;
        _currentDepthFar = cameraXR.far;
      }
      cameraL.layers.mask = camera.layers.mask | 2;
      cameraR.layers.mask = camera.layers.mask | 4;
      cameraXR.layers.mask = cameraL.layers.mask | cameraR.layers.mask;
      const parent = camera.parent;
      const cameras2 = cameraXR.cameras;
      updateCamera(cameraXR, parent);
      for (let i = 0; i < cameras2.length; i++) {
        updateCamera(cameras2[i], parent);
      }
      if (cameras2.length === 2) {
        setProjectionFromUnion(cameraXR, cameraL, cameraR);
      } else {
        cameraXR.projectionMatrix.copy(cameraL.projectionMatrix);
      }
      updateUserCamera(camera, cameraXR, parent);
    };
    function updateUserCamera(camera, cameraXR2, parent) {
      if (parent === null) {
        camera.matrix.copy(cameraXR2.matrixWorld);
      } else {
        camera.matrix.copy(parent.matrixWorld);
        camera.matrix.invert();
        camera.matrix.multiply(cameraXR2.matrixWorld);
      }
      camera.matrix.decompose(camera.position, camera.quaternion, camera.scale);
      camera.updateMatrixWorld(true);
      camera.projectionMatrix.copy(cameraXR2.projectionMatrix);
      camera.projectionMatrixInverse.copy(cameraXR2.projectionMatrixInverse);
      if (camera.isPerspectiveCamera) {
        camera.fov = RAD2DEG$1 * 2 * Math.atan(1 / camera.projectionMatrix.elements[5]);
        camera.zoom = 1;
      }
    }
    this.getCamera = function() {
      return cameraXR;
    };
    this.getFoveation = function() {
      if (glProjLayer === null && glBaseLayer === null) {
        return void 0;
      }
      return foveation;
    };
    this.setFoveation = function(value) {
      foveation = value;
      if (glProjLayer !== null) {
        glProjLayer.fixedFoveation = value;
      }
      if (glBaseLayer !== null && glBaseLayer.fixedFoveation !== void 0) {
        glBaseLayer.fixedFoveation = value;
      }
    };
    this.hasDepthSensing = function() {
      return depthSensing.texture !== null;
    };
    this.getDepthSensingMesh = function() {
      return depthSensing.getMesh(cameraXR);
    };
    let onAnimationFrameCallback = null;
    function onAnimationFrame(time, frame) {
      pose = frame.getViewerPose(customReferenceSpace || referenceSpace);
      xrFrame = frame;
      if (pose !== null) {
        const views = pose.views;
        if (glBaseLayer !== null) {
          renderer.setRenderTargetFramebuffer(newRenderTarget, glBaseLayer.framebuffer);
          renderer.setRenderTarget(newRenderTarget);
        }
        let cameraXRNeedsUpdate = false;
        if (views.length !== cameraXR.cameras.length) {
          cameraXR.cameras.length = 0;
          cameraXRNeedsUpdate = true;
        }
        for (let i = 0; i < views.length; i++) {
          const view = views[i];
          let viewport = null;
          if (glBaseLayer !== null) {
            viewport = glBaseLayer.getViewport(view);
          } else {
            const glSubImage = glBinding.getViewSubImage(glProjLayer, view);
            viewport = glSubImage.viewport;
            if (i === 0) {
              renderer.setRenderTargetTextures(
                newRenderTarget,
                glSubImage.colorTexture,
                glProjLayer.ignoreDepthValues ? void 0 : glSubImage.depthStencilTexture
              );
              renderer.setRenderTarget(newRenderTarget);
            }
          }
          let camera = cameras[i];
          if (camera === void 0) {
            camera = new PerspectiveCamera();
            camera.layers.enable(i);
            camera.viewport = new Vector4$1();
            cameras[i] = camera;
          }
          camera.matrix.fromArray(view.transform.matrix);
          camera.matrix.decompose(camera.position, camera.quaternion, camera.scale);
          camera.projectionMatrix.fromArray(view.projectionMatrix);
          camera.projectionMatrixInverse.copy(camera.projectionMatrix).invert();
          camera.viewport.set(viewport.x, viewport.y, viewport.width, viewport.height);
          if (i === 0) {
            cameraXR.matrix.copy(camera.matrix);
            cameraXR.matrix.decompose(cameraXR.position, cameraXR.quaternion, cameraXR.scale);
          }
          if (cameraXRNeedsUpdate === true) {
            cameraXR.cameras.push(camera);
          }
        }
        const enabledFeatures = session.enabledFeatures;
        if (enabledFeatures && enabledFeatures.includes("depth-sensing")) {
          const depthData = glBinding.getDepthInformation(views[0]);
          if (depthData && depthData.isValid && depthData.texture) {
            depthSensing.init(renderer, depthData, session.renderState);
          }
        }
      }
      for (let i = 0; i < controllers.length; i++) {
        const inputSource = controllerInputSources[i];
        const controller = controllers[i];
        if (inputSource !== null && controller !== void 0) {
          controller.update(inputSource, frame, customReferenceSpace || referenceSpace);
        }
      }
      if (onAnimationFrameCallback) onAnimationFrameCallback(time, frame);
      if (frame.detectedPlanes) {
        scope.dispatchEvent({ type: "planesdetected", data: frame });
      }
      xrFrame = null;
    }
    const animation = new WebGLAnimation();
    animation.setAnimationLoop(onAnimationFrame);
    this.setAnimationLoop = function(callback) {
      onAnimationFrameCallback = callback;
    };
    this.dispose = function() {
    };
  }
}
const _e1 = /* @__PURE__ */ new Euler();
const _m1$2 = /* @__PURE__ */ new Matrix4$1();
function WebGLMaterials(renderer, properties) {
  function refreshTransformUniform(map, uniform2) {
    if (map.matrixAutoUpdate === true) {
      map.updateMatrix();
    }
    uniform2.value.copy(map.matrix);
  }
  function refreshFogUniforms(uniforms, fog) {
    fog.color.getRGB(uniforms.fogColor.value, getUnlitUniformColorSpace(renderer));
    if (fog.isFog) {
      uniforms.fogNear.value = fog.near;
      uniforms.fogFar.value = fog.far;
    } else if (fog.isFogExp2) {
      uniforms.fogDensity.value = fog.density;
    }
  }
  function refreshMaterialUniforms(uniforms, material, pixelRatio, height, transmissionRenderTarget) {
    if (material.isMeshBasicMaterial) {
      refreshUniformsCommon(uniforms, material);
    } else if (material.isMeshLambertMaterial) {
      refreshUniformsCommon(uniforms, material);
    } else if (material.isMeshToonMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsToon(uniforms, material);
    } else if (material.isMeshPhongMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsPhong(uniforms, material);
    } else if (material.isMeshStandardMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsStandard(uniforms, material);
      if (material.isMeshPhysicalMaterial) {
        refreshUniformsPhysical(uniforms, material, transmissionRenderTarget);
      }
    } else if (material.isMeshMatcapMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsMatcap(uniforms, material);
    } else if (material.isMeshDepthMaterial) {
      refreshUniformsCommon(uniforms, material);
    } else if (material.isMeshDistanceMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsDistance(uniforms, material);
    } else if (material.isMeshNormalMaterial) {
      refreshUniformsCommon(uniforms, material);
    } else if (material.isLineBasicMaterial) {
      refreshUniformsLine(uniforms, material);
      if (material.isLineDashedMaterial) {
        refreshUniformsDash(uniforms, material);
      }
    } else if (material.isPointsMaterial) {
      refreshUniformsPoints(uniforms, material, pixelRatio, height);
    } else if (material.isSpriteMaterial) {
      refreshUniformsSprites(uniforms, material);
    } else if (material.isShadowMaterial) {
      uniforms.color.value.copy(material.color);
      uniforms.opacity.value = material.opacity;
    } else if (material.isShaderMaterial) {
      material.uniformsNeedUpdate = false;
    }
  }
  function refreshUniformsCommon(uniforms, material) {
    uniforms.opacity.value = material.opacity;
    if (material.color) {
      uniforms.diffuse.value.copy(material.color);
    }
    if (material.emissive) {
      uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);
    }
    if (material.map) {
      uniforms.map.value = material.map;
      refreshTransformUniform(material.map, uniforms.mapTransform);
    }
    if (material.alphaMap) {
      uniforms.alphaMap.value = material.alphaMap;
      refreshTransformUniform(material.alphaMap, uniforms.alphaMapTransform);
    }
    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      refreshTransformUniform(material.bumpMap, uniforms.bumpMapTransform);
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === BackSide) {
        uniforms.bumpScale.value *= -1;
      }
    }
    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      refreshTransformUniform(material.normalMap, uniforms.normalMapTransform);
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === BackSide) {
        uniforms.normalScale.value.negate();
      }
    }
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      refreshTransformUniform(material.displacementMap, uniforms.displacementMapTransform);
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
    if (material.emissiveMap) {
      uniforms.emissiveMap.value = material.emissiveMap;
      refreshTransformUniform(material.emissiveMap, uniforms.emissiveMapTransform);
    }
    if (material.specularMap) {
      uniforms.specularMap.value = material.specularMap;
      refreshTransformUniform(material.specularMap, uniforms.specularMapTransform);
    }
    if (material.alphaTest > 0) {
      uniforms.alphaTest.value = material.alphaTest;
    }
    const materialProperties = properties.get(material);
    const envMap = materialProperties.envMap;
    const envMapRotation = materialProperties.envMapRotation;
    if (envMap) {
      uniforms.envMap.value = envMap;
      _e1.copy(envMapRotation);
      _e1.x *= -1;
      _e1.y *= -1;
      _e1.z *= -1;
      if (envMap.isCubeTexture && envMap.isRenderTargetTexture === false) {
        _e1.y *= -1;
        _e1.z *= -1;
      }
      uniforms.envMapRotation.value.setFromMatrix4(_m1$2.makeRotationFromEuler(_e1));
      uniforms.flipEnvMap.value = envMap.isCubeTexture && envMap.isRenderTargetTexture === false ? -1 : 1;
      uniforms.reflectivity.value = material.reflectivity;
      uniforms.ior.value = material.ior;
      uniforms.refractionRatio.value = material.refractionRatio;
    }
    if (material.lightMap) {
      uniforms.lightMap.value = material.lightMap;
      uniforms.lightMapIntensity.value = material.lightMapIntensity;
      refreshTransformUniform(material.lightMap, uniforms.lightMapTransform);
    }
    if (material.aoMap) {
      uniforms.aoMap.value = material.aoMap;
      uniforms.aoMapIntensity.value = material.aoMapIntensity;
      refreshTransformUniform(material.aoMap, uniforms.aoMapTransform);
    }
  }
  function refreshUniformsLine(uniforms, material) {
    uniforms.diffuse.value.copy(material.color);
    uniforms.opacity.value = material.opacity;
    if (material.map) {
      uniforms.map.value = material.map;
      refreshTransformUniform(material.map, uniforms.mapTransform);
    }
  }
  function refreshUniformsDash(uniforms, material) {
    uniforms.dashSize.value = material.dashSize;
    uniforms.totalSize.value = material.dashSize + material.gapSize;
    uniforms.scale.value = material.scale;
  }
  function refreshUniformsPoints(uniforms, material, pixelRatio, height) {
    uniforms.diffuse.value.copy(material.color);
    uniforms.opacity.value = material.opacity;
    uniforms.size.value = material.size * pixelRatio;
    uniforms.scale.value = height * 0.5;
    if (material.map) {
      uniforms.map.value = material.map;
      refreshTransformUniform(material.map, uniforms.uvTransform);
    }
    if (material.alphaMap) {
      uniforms.alphaMap.value = material.alphaMap;
      refreshTransformUniform(material.alphaMap, uniforms.alphaMapTransform);
    }
    if (material.alphaTest > 0) {
      uniforms.alphaTest.value = material.alphaTest;
    }
  }
  function refreshUniformsSprites(uniforms, material) {
    uniforms.diffuse.value.copy(material.color);
    uniforms.opacity.value = material.opacity;
    uniforms.rotation.value = material.rotation;
    if (material.map) {
      uniforms.map.value = material.map;
      refreshTransformUniform(material.map, uniforms.mapTransform);
    }
    if (material.alphaMap) {
      uniforms.alphaMap.value = material.alphaMap;
      refreshTransformUniform(material.alphaMap, uniforms.alphaMapTransform);
    }
    if (material.alphaTest > 0) {
      uniforms.alphaTest.value = material.alphaTest;
    }
  }
  function refreshUniformsPhong(uniforms, material) {
    uniforms.specular.value.copy(material.specular);
    uniforms.shininess.value = Math.max(material.shininess, 1e-4);
  }
  function refreshUniformsToon(uniforms, material) {
    if (material.gradientMap) {
      uniforms.gradientMap.value = material.gradientMap;
    }
  }
  function refreshUniformsStandard(uniforms, material) {
    uniforms.metalness.value = material.metalness;
    if (material.metalnessMap) {
      uniforms.metalnessMap.value = material.metalnessMap;
      refreshTransformUniform(material.metalnessMap, uniforms.metalnessMapTransform);
    }
    uniforms.roughness.value = material.roughness;
    if (material.roughnessMap) {
      uniforms.roughnessMap.value = material.roughnessMap;
      refreshTransformUniform(material.roughnessMap, uniforms.roughnessMapTransform);
    }
    if (material.envMap) {
      uniforms.envMapIntensity.value = material.envMapIntensity;
    }
  }
  function refreshUniformsPhysical(uniforms, material, transmissionRenderTarget) {
    uniforms.ior.value = material.ior;
    if (material.sheen > 0) {
      uniforms.sheenColor.value.copy(material.sheenColor).multiplyScalar(material.sheen);
      uniforms.sheenRoughness.value = material.sheenRoughness;
      if (material.sheenColorMap) {
        uniforms.sheenColorMap.value = material.sheenColorMap;
        refreshTransformUniform(material.sheenColorMap, uniforms.sheenColorMapTransform);
      }
      if (material.sheenRoughnessMap) {
        uniforms.sheenRoughnessMap.value = material.sheenRoughnessMap;
        refreshTransformUniform(material.sheenRoughnessMap, uniforms.sheenRoughnessMapTransform);
      }
    }
    if (material.clearcoat > 0) {
      uniforms.clearcoat.value = material.clearcoat;
      uniforms.clearcoatRoughness.value = material.clearcoatRoughness;
      if (material.clearcoatMap) {
        uniforms.clearcoatMap.value = material.clearcoatMap;
        refreshTransformUniform(material.clearcoatMap, uniforms.clearcoatMapTransform);
      }
      if (material.clearcoatRoughnessMap) {
        uniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap;
        refreshTransformUniform(material.clearcoatRoughnessMap, uniforms.clearcoatRoughnessMapTransform);
      }
      if (material.clearcoatNormalMap) {
        uniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;
        refreshTransformUniform(material.clearcoatNormalMap, uniforms.clearcoatNormalMapTransform);
        uniforms.clearcoatNormalScale.value.copy(material.clearcoatNormalScale);
        if (material.side === BackSide) {
          uniforms.clearcoatNormalScale.value.negate();
        }
      }
    }
    if (material.dispersion > 0) {
      uniforms.dispersion.value = material.dispersion;
    }
    if (material.iridescence > 0) {
      uniforms.iridescence.value = material.iridescence;
      uniforms.iridescenceIOR.value = material.iridescenceIOR;
      uniforms.iridescenceThicknessMinimum.value = material.iridescenceThicknessRange[0];
      uniforms.iridescenceThicknessMaximum.value = material.iridescenceThicknessRange[1];
      if (material.iridescenceMap) {
        uniforms.iridescenceMap.value = material.iridescenceMap;
        refreshTransformUniform(material.iridescenceMap, uniforms.iridescenceMapTransform);
      }
      if (material.iridescenceThicknessMap) {
        uniforms.iridescenceThicknessMap.value = material.iridescenceThicknessMap;
        refreshTransformUniform(material.iridescenceThicknessMap, uniforms.iridescenceThicknessMapTransform);
      }
    }
    if (material.transmission > 0) {
      uniforms.transmission.value = material.transmission;
      uniforms.transmissionSamplerMap.value = transmissionRenderTarget.texture;
      uniforms.transmissionSamplerSize.value.set(transmissionRenderTarget.width, transmissionRenderTarget.height);
      if (material.transmissionMap) {
        uniforms.transmissionMap.value = material.transmissionMap;
        refreshTransformUniform(material.transmissionMap, uniforms.transmissionMapTransform);
      }
      uniforms.thickness.value = material.thickness;
      if (material.thicknessMap) {
        uniforms.thicknessMap.value = material.thicknessMap;
        refreshTransformUniform(material.thicknessMap, uniforms.thicknessMapTransform);
      }
      uniforms.attenuationDistance.value = material.attenuationDistance;
      uniforms.attenuationColor.value.copy(material.attenuationColor);
    }
    if (material.anisotropy > 0) {
      uniforms.anisotropyVector.value.set(material.anisotropy * Math.cos(material.anisotropyRotation), material.anisotropy * Math.sin(material.anisotropyRotation));
      if (material.anisotropyMap) {
        uniforms.anisotropyMap.value = material.anisotropyMap;
        refreshTransformUniform(material.anisotropyMap, uniforms.anisotropyMapTransform);
      }
    }
    uniforms.specularIntensity.value = material.specularIntensity;
    uniforms.specularColor.value.copy(material.specularColor);
    if (material.specularColorMap) {
      uniforms.specularColorMap.value = material.specularColorMap;
      refreshTransformUniform(material.specularColorMap, uniforms.specularColorMapTransform);
    }
    if (material.specularIntensityMap) {
      uniforms.specularIntensityMap.value = material.specularIntensityMap;
      refreshTransformUniform(material.specularIntensityMap, uniforms.specularIntensityMapTransform);
    }
  }
  function refreshUniformsMatcap(uniforms, material) {
    if (material.matcap) {
      uniforms.matcap.value = material.matcap;
    }
  }
  function refreshUniformsDistance(uniforms, material) {
    const light = properties.get(material).light;
    uniforms.referencePosition.value.setFromMatrixPosition(light.matrixWorld);
    uniforms.nearDistance.value = light.shadow.camera.near;
    uniforms.farDistance.value = light.shadow.camera.far;
  }
  return {
    refreshFogUniforms,
    refreshMaterialUniforms
  };
}
function WebGLUniformsGroups(gl, info, capabilities, state) {
  let buffers = {};
  let updateList = {};
  let allocatedBindingPoints = [];
  const maxBindingPoints = gl.getParameter(gl.MAX_UNIFORM_BUFFER_BINDINGS);
  function bind(uniformsGroup, program) {
    const webglProgram = program.program;
    state.uniformBlockBinding(uniformsGroup, webglProgram);
  }
  function update(uniformsGroup, program) {
    let buffer = buffers[uniformsGroup.id];
    if (buffer === void 0) {
      prepareUniformsGroup(uniformsGroup);
      buffer = createBuffer(uniformsGroup);
      buffers[uniformsGroup.id] = buffer;
      uniformsGroup.addEventListener("dispose", onUniformsGroupsDispose);
    }
    const webglProgram = program.program;
    state.updateUBOMapping(uniformsGroup, webglProgram);
    const frame = info.render.frame;
    if (updateList[uniformsGroup.id] !== frame) {
      updateBufferData(uniformsGroup);
      updateList[uniformsGroup.id] = frame;
    }
  }
  function createBuffer(uniformsGroup) {
    const bindingPointIndex = allocateBindingPointIndex();
    uniformsGroup.__bindingPointIndex = bindingPointIndex;
    const buffer = gl.createBuffer();
    const size = uniformsGroup.__size;
    const usage = uniformsGroup.usage;
    gl.bindBuffer(gl.UNIFORM_BUFFER, buffer);
    gl.bufferData(gl.UNIFORM_BUFFER, size, usage);
    gl.bindBuffer(gl.UNIFORM_BUFFER, null);
    gl.bindBufferBase(gl.UNIFORM_BUFFER, bindingPointIndex, buffer);
    return buffer;
  }
  function allocateBindingPointIndex() {
    for (let i = 0; i < maxBindingPoints; i++) {
      if (allocatedBindingPoints.indexOf(i) === -1) {
        allocatedBindingPoints.push(i);
        return i;
      }
    }
    console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached.");
    return 0;
  }
  function updateBufferData(uniformsGroup) {
    const buffer = buffers[uniformsGroup.id];
    const uniforms = uniformsGroup.uniforms;
    const cache2 = uniformsGroup.__cache;
    gl.bindBuffer(gl.UNIFORM_BUFFER, buffer);
    for (let i = 0, il = uniforms.length; i < il; i++) {
      const uniformArray = Array.isArray(uniforms[i]) ? uniforms[i] : [uniforms[i]];
      for (let j = 0, jl = uniformArray.length; j < jl; j++) {
        const uniform2 = uniformArray[j];
        if (hasUniformChanged(uniform2, i, j, cache2) === true) {
          const offset = uniform2.__offset;
          const values = Array.isArray(uniform2.value) ? uniform2.value : [uniform2.value];
          let arrayOffset = 0;
          for (let k = 0; k < values.length; k++) {
            const value = values[k];
            const info2 = getUniformSize(value);
            if (typeof value === "number" || typeof value === "boolean") {
              uniform2.__data[0] = value;
              gl.bufferSubData(gl.UNIFORM_BUFFER, offset + arrayOffset, uniform2.__data);
            } else if (value.isMatrix3) {
              uniform2.__data[0] = value.elements[0];
              uniform2.__data[1] = value.elements[1];
              uniform2.__data[2] = value.elements[2];
              uniform2.__data[3] = 0;
              uniform2.__data[4] = value.elements[3];
              uniform2.__data[5] = value.elements[4];
              uniform2.__data[6] = value.elements[5];
              uniform2.__data[7] = 0;
              uniform2.__data[8] = value.elements[6];
              uniform2.__data[9] = value.elements[7];
              uniform2.__data[10] = value.elements[8];
              uniform2.__data[11] = 0;
            } else {
              value.toArray(uniform2.__data, arrayOffset);
              arrayOffset += info2.storage / Float32Array.BYTES_PER_ELEMENT;
            }
          }
          gl.bufferSubData(gl.UNIFORM_BUFFER, offset, uniform2.__data);
        }
      }
    }
    gl.bindBuffer(gl.UNIFORM_BUFFER, null);
  }
  function hasUniformChanged(uniform2, index, indexArray, cache2) {
    const value = uniform2.value;
    const indexString = index + "_" + indexArray;
    if (cache2[indexString] === void 0) {
      if (typeof value === "number" || typeof value === "boolean") {
        cache2[indexString] = value;
      } else {
        cache2[indexString] = value.clone();
      }
      return true;
    } else {
      const cachedObject = cache2[indexString];
      if (typeof value === "number" || typeof value === "boolean") {
        if (cachedObject !== value) {
          cache2[indexString] = value;
          return true;
        }
      } else {
        if (cachedObject.equals(value) === false) {
          cachedObject.copy(value);
          return true;
        }
      }
    }
    return false;
  }
  function prepareUniformsGroup(uniformsGroup) {
    const uniforms = uniformsGroup.uniforms;
    let offset = 0;
    const chunkSize = 16;
    for (let i = 0, l = uniforms.length; i < l; i++) {
      const uniformArray = Array.isArray(uniforms[i]) ? uniforms[i] : [uniforms[i]];
      for (let j = 0, jl = uniformArray.length; j < jl; j++) {
        const uniform2 = uniformArray[j];
        const values = Array.isArray(uniform2.value) ? uniform2.value : [uniform2.value];
        for (let k = 0, kl = values.length; k < kl; k++) {
          const value = values[k];
          const info2 = getUniformSize(value);
          const chunkOffset2 = offset % chunkSize;
          const chunkPadding = chunkOffset2 % info2.boundary;
          const chunkStart = chunkOffset2 + chunkPadding;
          offset += chunkPadding;
          if (chunkStart !== 0 && chunkSize - chunkStart < info2.storage) {
            offset += chunkSize - chunkStart;
          }
          uniform2.__data = new Float32Array(info2.storage / Float32Array.BYTES_PER_ELEMENT);
          uniform2.__offset = offset;
          offset += info2.storage;
        }
      }
    }
    const chunkOffset = offset % chunkSize;
    if (chunkOffset > 0) offset += chunkSize - chunkOffset;
    uniformsGroup.__size = offset;
    uniformsGroup.__cache = {};
    return this;
  }
  function getUniformSize(value) {
    const info2 = {
      boundary: 0,
      // bytes
      storage: 0
      // bytes
    };
    if (typeof value === "number" || typeof value === "boolean") {
      info2.boundary = 4;
      info2.storage = 4;
    } else if (value.isVector2) {
      info2.boundary = 8;
      info2.storage = 8;
    } else if (value.isVector3 || value.isColor) {
      info2.boundary = 16;
      info2.storage = 12;
    } else if (value.isVector4) {
      info2.boundary = 16;
      info2.storage = 16;
    } else if (value.isMatrix3) {
      info2.boundary = 48;
      info2.storage = 48;
    } else if (value.isMatrix4) {
      info2.boundary = 64;
      info2.storage = 64;
    } else if (value.isTexture) {
      console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.");
    } else {
      console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", value);
    }
    return info2;
  }
  function onUniformsGroupsDispose(event) {
    const uniformsGroup = event.target;
    uniformsGroup.removeEventListener("dispose", onUniformsGroupsDispose);
    const index = allocatedBindingPoints.indexOf(uniformsGroup.__bindingPointIndex);
    allocatedBindingPoints.splice(index, 1);
    gl.deleteBuffer(buffers[uniformsGroup.id]);
    delete buffers[uniformsGroup.id];
    delete updateList[uniformsGroup.id];
  }
  function dispose() {
    for (const id in buffers) {
      gl.deleteBuffer(buffers[id]);
    }
    allocatedBindingPoints = [];
    buffers = {};
    updateList = {};
  }
  return {
    bind,
    update,
    dispose
  };
}
class WebGLRenderer {
  constructor(parameters = {}) {
    const {
      canvas = createCanvasElement(),
      context: context2 = null,
      depth = true,
      stencil = false,
      alpha = false,
      antialias = false,
      premultipliedAlpha = true,
      preserveDrawingBuffer = false,
      powerPreference = "default",
      failIfMajorPerformanceCaveat = false,
      reverseDepthBuffer = false
    } = parameters;
    this.isWebGLRenderer = true;
    let _alpha;
    if (context2 !== null) {
      if (typeof WebGLRenderingContext !== "undefined" && context2 instanceof WebGLRenderingContext) {
        throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163.");
      }
      _alpha = context2.getContextAttributes().alpha;
    } else {
      _alpha = alpha;
    }
    const uintClearColor = new Uint32Array(4);
    const intClearColor = new Int32Array(4);
    let currentRenderList = null;
    let currentRenderState = null;
    const renderListStack = [];
    const renderStateStack = [];
    this.domElement = canvas;
    this.debug = {
      /**
       * Enables error checking and reporting when shader programs are being compiled
       * @type {boolean}
       */
      checkShaderErrors: true,
      /**
       * Callback for custom error reporting.
       * @type {?Function}
       */
      onShaderError: null
    };
    this.autoClear = true;
    this.autoClearColor = true;
    this.autoClearDepth = true;
    this.autoClearStencil = true;
    this.sortObjects = true;
    this.clippingPlanes = [];
    this.localClippingEnabled = false;
    this._outputColorSpace = SRGBColorSpace$1;
    this.toneMapping = NoToneMapping$1;
    this.toneMappingExposure = 1;
    const _this = this;
    let _isContextLost = false;
    let _currentActiveCubeFace = 0;
    let _currentActiveMipmapLevel = 0;
    let _currentRenderTarget = null;
    let _currentMaterialId = -1;
    let _currentCamera = null;
    const _currentViewport = new Vector4$1();
    const _currentScissor = new Vector4$1();
    let _currentScissorTest = null;
    const _currentClearColor = new Color$1(0);
    let _currentClearAlpha = 0;
    let _width = canvas.width;
    let _height = canvas.height;
    let _pixelRatio = 1;
    let _opaqueSort = null;
    let _transparentSort = null;
    const _viewport = new Vector4$1(0, 0, _width, _height);
    const _scissor = new Vector4$1(0, 0, _width, _height);
    let _scissorTest = false;
    const _frustum2 = new Frustum();
    let _clippingEnabled = false;
    let _localClippingEnabled = false;
    this.transmissionResolutionScale = 1;
    const _currentProjectionMatrix = new Matrix4$1();
    const _projScreenMatrix2 = new Matrix4$1();
    const _vector32 = new Vector3$1();
    const _vector4 = new Vector4$1();
    const _emptyScene = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: true };
    let _renderBackground = false;
    function getTargetPixelRatio() {
      return _currentRenderTarget === null ? _pixelRatio : 1;
    }
    let _gl = context2;
    function getContext(contextName, contextAttributes) {
      return canvas.getContext(contextName, contextAttributes);
    }
    try {
      const contextAttributes = {
        alpha: true,
        depth,
        stencil,
        antialias,
        premultipliedAlpha,
        preserveDrawingBuffer,
        powerPreference,
        failIfMajorPerformanceCaveat
      };
      if ("setAttribute" in canvas) canvas.setAttribute("data-engine", `three.js r${REVISION}`);
      canvas.addEventListener("webglcontextlost", onContextLost, false);
      canvas.addEventListener("webglcontextrestored", onContextRestore, false);
      canvas.addEventListener("webglcontextcreationerror", onContextCreationError, false);
      if (_gl === null) {
        const contextName = "webgl2";
        _gl = getContext(contextName, contextAttributes);
        if (_gl === null) {
          if (getContext(contextName)) {
            throw new Error("Error creating WebGL context with your selected attributes.");
          } else {
            throw new Error("Error creating WebGL context.");
          }
        }
      }
    } catch (error2) {
      console.error("THREE.WebGLRenderer: " + error2.message);
      throw error2;
    }
    let extensions, capabilities, state, info;
    let properties, textures, cubemaps, cubeuvmaps, attributes, geometries, objects;
    let programCache, materials, renderLists, renderStates, clipping, shadowMap;
    let background, morphtargets, bufferRenderer, indexedBufferRenderer;
    let utils, bindingStates, uniformsGroups;
    function initGLContext() {
      extensions = new WebGLExtensions(_gl);
      extensions.init();
      utils = new WebGLUtils(_gl, extensions);
      capabilities = new WebGLCapabilities(_gl, extensions, parameters, utils);
      state = new WebGLState(_gl, extensions);
      if (capabilities.reverseDepthBuffer && reverseDepthBuffer) {
        state.buffers.depth.setReversed(true);
      }
      info = new WebGLInfo(_gl);
      properties = new WebGLProperties();
      textures = new WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info);
      cubemaps = new WebGLCubeMaps(_this);
      cubeuvmaps = new WebGLCubeUVMaps(_this);
      attributes = new WebGLAttributes(_gl);
      bindingStates = new WebGLBindingStates(_gl, attributes);
      geometries = new WebGLGeometries(_gl, attributes, info, bindingStates);
      objects = new WebGLObjects(_gl, geometries, attributes, info);
      morphtargets = new WebGLMorphtargets(_gl, capabilities, textures);
      clipping = new WebGLClipping(properties);
      programCache = new WebGLPrograms(_this, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping);
      materials = new WebGLMaterials(_this, properties);
      renderLists = new WebGLRenderLists();
      renderStates = new WebGLRenderStates(extensions);
      background = new WebGLBackground(_this, cubemaps, cubeuvmaps, state, objects, _alpha, premultipliedAlpha);
      shadowMap = new WebGLShadowMap(_this, objects, capabilities);
      uniformsGroups = new WebGLUniformsGroups(_gl, info, capabilities, state);
      bufferRenderer = new WebGLBufferRenderer(_gl, extensions, info);
      indexedBufferRenderer = new WebGLIndexedBufferRenderer(_gl, extensions, info);
      info.programs = programCache.programs;
      _this.capabilities = capabilities;
      _this.extensions = extensions;
      _this.properties = properties;
      _this.renderLists = renderLists;
      _this.shadowMap = shadowMap;
      _this.state = state;
      _this.info = info;
    }
    initGLContext();
    const xr = new WebXRManager(_this, _gl);
    this.xr = xr;
    this.getContext = function() {
      return _gl;
    };
    this.getContextAttributes = function() {
      return _gl.getContextAttributes();
    };
    this.forceContextLoss = function() {
      const extension = extensions.get("WEBGL_lose_context");
      if (extension) extension.loseContext();
    };
    this.forceContextRestore = function() {
      const extension = extensions.get("WEBGL_lose_context");
      if (extension) extension.restoreContext();
    };
    this.getPixelRatio = function() {
      return _pixelRatio;
    };
    this.setPixelRatio = function(value) {
      if (value === void 0) return;
      _pixelRatio = value;
      this.setSize(_width, _height, false);
    };
    this.getSize = function(target) {
      return target.set(_width, _height);
    };
    this.setSize = function(width, height, updateStyle = true) {
      if (xr.isPresenting) {
        console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
        return;
      }
      _width = width;
      _height = height;
      canvas.width = Math.floor(width * _pixelRatio);
      canvas.height = Math.floor(height * _pixelRatio);
      if (updateStyle === true) {
        canvas.style.width = width + "px";
        canvas.style.height = height + "px";
      }
      this.setViewport(0, 0, width, height);
    };
    this.getDrawingBufferSize = function(target) {
      return target.set(_width * _pixelRatio, _height * _pixelRatio).floor();
    };
    this.setDrawingBufferSize = function(width, height, pixelRatio) {
      _width = width;
      _height = height;
      _pixelRatio = pixelRatio;
      canvas.width = Math.floor(width * pixelRatio);
      canvas.height = Math.floor(height * pixelRatio);
      this.setViewport(0, 0, width, height);
    };
    this.getCurrentViewport = function(target) {
      return target.copy(_currentViewport);
    };
    this.getViewport = function(target) {
      return target.copy(_viewport);
    };
    this.setViewport = function(x, y, width, height) {
      if (x.isVector4) {
        _viewport.set(x.x, x.y, x.z, x.w);
      } else {
        _viewport.set(x, y, width, height);
      }
      state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).round());
    };
    this.getScissor = function(target) {
      return target.copy(_scissor);
    };
    this.setScissor = function(x, y, width, height) {
      if (x.isVector4) {
        _scissor.set(x.x, x.y, x.z, x.w);
      } else {
        _scissor.set(x, y, width, height);
      }
      state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).round());
    };
    this.getScissorTest = function() {
      return _scissorTest;
    };
    this.setScissorTest = function(boolean) {
      state.setScissorTest(_scissorTest = boolean);
    };
    this.setOpaqueSort = function(method) {
      _opaqueSort = method;
    };
    this.setTransparentSort = function(method) {
      _transparentSort = method;
    };
    this.getClearColor = function(target) {
      return target.copy(background.getClearColor());
    };
    this.setClearColor = function() {
      background.setClearColor.apply(background, arguments);
    };
    this.getClearAlpha = function() {
      return background.getClearAlpha();
    };
    this.setClearAlpha = function() {
      background.setClearAlpha.apply(background, arguments);
    };
    this.clear = function(color2 = true, depth2 = true, stencil2 = true) {
      let bits = 0;
      if (color2) {
        let isIntegerFormat = false;
        if (_currentRenderTarget !== null) {
          const targetFormat = _currentRenderTarget.texture.format;
          isIntegerFormat = targetFormat === RGBAIntegerFormat || targetFormat === RGIntegerFormat || targetFormat === RedIntegerFormat;
        }
        if (isIntegerFormat) {
          const targetType = _currentRenderTarget.texture.type;
          const isUnsignedType = targetType === UnsignedByteType || targetType === UnsignedIntType || targetType === UnsignedShortType || targetType === UnsignedInt248Type || targetType === UnsignedShort4444Type || targetType === UnsignedShort5551Type;
          const clearColor = background.getClearColor();
          const a = background.getClearAlpha();
          const r = clearColor.r;
          const g = clearColor.g;
          const b = clearColor.b;
          if (isUnsignedType) {
            uintClearColor[0] = r;
            uintClearColor[1] = g;
            uintClearColor[2] = b;
            uintClearColor[3] = a;
            _gl.clearBufferuiv(_gl.COLOR, 0, uintClearColor);
          } else {
            intClearColor[0] = r;
            intClearColor[1] = g;
            intClearColor[2] = b;
            intClearColor[3] = a;
            _gl.clearBufferiv(_gl.COLOR, 0, intClearColor);
          }
        } else {
          bits |= _gl.COLOR_BUFFER_BIT;
        }
      }
      if (depth2) {
        bits |= _gl.DEPTH_BUFFER_BIT;
      }
      if (stencil2) {
        bits |= _gl.STENCIL_BUFFER_BIT;
        this.state.buffers.stencil.setMask(4294967295);
      }
      _gl.clear(bits);
    };
    this.clearColor = function() {
      this.clear(true, false, false);
    };
    this.clearDepth = function() {
      this.clear(false, true, false);
    };
    this.clearStencil = function() {
      this.clear(false, false, true);
    };
    this.dispose = function() {
      canvas.removeEventListener("webglcontextlost", onContextLost, false);
      canvas.removeEventListener("webglcontextrestored", onContextRestore, false);
      canvas.removeEventListener("webglcontextcreationerror", onContextCreationError, false);
      background.dispose();
      renderLists.dispose();
      renderStates.dispose();
      properties.dispose();
      cubemaps.dispose();
      cubeuvmaps.dispose();
      objects.dispose();
      bindingStates.dispose();
      uniformsGroups.dispose();
      programCache.dispose();
      xr.dispose();
      xr.removeEventListener("sessionstart", onXRSessionStart);
      xr.removeEventListener("sessionend", onXRSessionEnd);
      animation.stop();
    };
    function onContextLost(event) {
      event.preventDefault();
      console.log("THREE.WebGLRenderer: Context Lost.");
      _isContextLost = true;
    }
    function onContextRestore() {
      console.log("THREE.WebGLRenderer: Context Restored.");
      _isContextLost = false;
      const infoAutoReset = info.autoReset;
      const shadowMapEnabled = shadowMap.enabled;
      const shadowMapAutoUpdate = shadowMap.autoUpdate;
      const shadowMapNeedsUpdate = shadowMap.needsUpdate;
      const shadowMapType = shadowMap.type;
      initGLContext();
      info.autoReset = infoAutoReset;
      shadowMap.enabled = shadowMapEnabled;
      shadowMap.autoUpdate = shadowMapAutoUpdate;
      shadowMap.needsUpdate = shadowMapNeedsUpdate;
      shadowMap.type = shadowMapType;
    }
    function onContextCreationError(event) {
      console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", event.statusMessage);
    }
    function onMaterialDispose(event) {
      const material = event.target;
      material.removeEventListener("dispose", onMaterialDispose);
      deallocateMaterial(material);
    }
    function deallocateMaterial(material) {
      releaseMaterialProgramReferences(material);
      properties.remove(material);
    }
    function releaseMaterialProgramReferences(material) {
      const programs = properties.get(material).programs;
      if (programs !== void 0) {
        programs.forEach(function(program) {
          programCache.releaseProgram(program);
        });
        if (material.isShaderMaterial) {
          programCache.releaseShaderCache(material);
        }
      }
    }
    this.renderBufferDirect = function(camera, scene, geometry, material, object, group) {
      if (scene === null) scene = _emptyScene;
      const frontFaceCW = object.isMesh && object.matrixWorld.determinant() < 0;
      const program = setProgram(camera, scene, geometry, material, object);
      state.setMaterial(material, frontFaceCW);
      let index = geometry.index;
      let rangeFactor = 1;
      if (material.wireframe === true) {
        index = geometries.getWireframeAttribute(geometry);
        if (index === void 0) return;
        rangeFactor = 2;
      }
      const drawRange = geometry.drawRange;
      const position = geometry.attributes.position;
      let drawStart = drawRange.start * rangeFactor;
      let drawEnd = (drawRange.start + drawRange.count) * rangeFactor;
      if (group !== null) {
        drawStart = Math.max(drawStart, group.start * rangeFactor);
        drawEnd = Math.min(drawEnd, (group.start + group.count) * rangeFactor);
      }
      if (index !== null) {
        drawStart = Math.max(drawStart, 0);
        drawEnd = Math.min(drawEnd, index.count);
      } else if (position !== void 0 && position !== null) {
        drawStart = Math.max(drawStart, 0);
        drawEnd = Math.min(drawEnd, position.count);
      }
      const drawCount = drawEnd - drawStart;
      if (drawCount < 0 || drawCount === Infinity) return;
      bindingStates.setup(object, material, program, geometry, index);
      let attribute;
      let renderer = bufferRenderer;
      if (index !== null) {
        attribute = attributes.get(index);
        renderer = indexedBufferRenderer;
        renderer.setIndex(attribute);
      }
      if (object.isMesh) {
        if (material.wireframe === true) {
          state.setLineWidth(material.wireframeLinewidth * getTargetPixelRatio());
          renderer.setMode(_gl.LINES);
        } else {
          renderer.setMode(_gl.TRIANGLES);
        }
      } else if (object.isLine) {
        let lineWidth = material.linewidth;
        if (lineWidth === void 0) lineWidth = 1;
        state.setLineWidth(lineWidth * getTargetPixelRatio());
        if (object.isLineSegments) {
          renderer.setMode(_gl.LINES);
        } else if (object.isLineLoop) {
          renderer.setMode(_gl.LINE_LOOP);
        } else {
          renderer.setMode(_gl.LINE_STRIP);
        }
      } else if (object.isPoints) {
        renderer.setMode(_gl.POINTS);
      } else if (object.isSprite) {
        renderer.setMode(_gl.TRIANGLES);
      }
      if (object.isBatchedMesh) {
        if (object._multiDrawInstances !== null) {
          renderer.renderMultiDrawInstances(object._multiDrawStarts, object._multiDrawCounts, object._multiDrawCount, object._multiDrawInstances);
        } else {
          if (!extensions.get("WEBGL_multi_draw")) {
            const starts = object._multiDrawStarts;
            const counts = object._multiDrawCounts;
            const drawCount2 = object._multiDrawCount;
            const bytesPerElement = index ? attributes.get(index).bytesPerElement : 1;
            const uniforms = properties.get(material).currentProgram.getUniforms();
            for (let i = 0; i < drawCount2; i++) {
              uniforms.setValue(_gl, "_gl_DrawID", i);
              renderer.render(starts[i] / bytesPerElement, counts[i]);
            }
          } else {
            renderer.renderMultiDraw(object._multiDrawStarts, object._multiDrawCounts, object._multiDrawCount);
          }
        }
      } else if (object.isInstancedMesh) {
        renderer.renderInstances(drawStart, drawCount, object.count);
      } else if (geometry.isInstancedBufferGeometry) {
        const maxInstanceCount = geometry._maxInstanceCount !== void 0 ? geometry._maxInstanceCount : Infinity;
        const instanceCount = Math.min(geometry.instanceCount, maxInstanceCount);
        renderer.renderInstances(drawStart, drawCount, instanceCount);
      } else {
        renderer.render(drawStart, drawCount);
      }
    };
    function prepareMaterial(material, scene, object) {
      if (material.transparent === true && material.side === DoubleSide && material.forceSinglePass === false) {
        material.side = BackSide;
        material.needsUpdate = true;
        getProgram(material, scene, object);
        material.side = FrontSide;
        material.needsUpdate = true;
        getProgram(material, scene, object);
        material.side = DoubleSide;
      } else {
        getProgram(material, scene, object);
      }
    }
    this.compile = function(scene, camera, targetScene = null) {
      if (targetScene === null) targetScene = scene;
      currentRenderState = renderStates.get(targetScene);
      currentRenderState.init(camera);
      renderStateStack.push(currentRenderState);
      targetScene.traverseVisible(function(object) {
        if (object.isLight && object.layers.test(camera.layers)) {
          currentRenderState.pushLight(object);
          if (object.castShadow) {
            currentRenderState.pushShadow(object);
          }
        }
      });
      if (scene !== targetScene) {
        scene.traverseVisible(function(object) {
          if (object.isLight && object.layers.test(camera.layers)) {
            currentRenderState.pushLight(object);
            if (object.castShadow) {
              currentRenderState.pushShadow(object);
            }
          }
        });
      }
      currentRenderState.setupLights();
      const materials2 = /* @__PURE__ */ new Set();
      scene.traverse(function(object) {
        if (!(object.isMesh || object.isPoints || object.isLine || object.isSprite)) {
          return;
        }
        const material = object.material;
        if (material) {
          if (Array.isArray(material)) {
            for (let i = 0; i < material.length; i++) {
              const material2 = material[i];
              prepareMaterial(material2, targetScene, object);
              materials2.add(material2);
            }
          } else {
            prepareMaterial(material, targetScene, object);
            materials2.add(material);
          }
        }
      });
      renderStateStack.pop();
      currentRenderState = null;
      return materials2;
    };
    this.compileAsync = function(scene, camera, targetScene = null) {
      const materials2 = this.compile(scene, camera, targetScene);
      return new Promise((resolve) => {
        function checkMaterialsReady() {
          materials2.forEach(function(material) {
            const materialProperties = properties.get(material);
            const program = materialProperties.currentProgram;
            if (program.isReady()) {
              materials2.delete(material);
            }
          });
          if (materials2.size === 0) {
            resolve(scene);
            return;
          }
          setTimeout(checkMaterialsReady, 10);
        }
        if (extensions.get("KHR_parallel_shader_compile") !== null) {
          checkMaterialsReady();
        } else {
          setTimeout(checkMaterialsReady, 10);
        }
      });
    };
    let onAnimationFrameCallback = null;
    function onAnimationFrame(time) {
      if (onAnimationFrameCallback) onAnimationFrameCallback(time);
    }
    function onXRSessionStart() {
      animation.stop();
    }
    function onXRSessionEnd() {
      animation.start();
    }
    const animation = new WebGLAnimation();
    animation.setAnimationLoop(onAnimationFrame);
    if (typeof self !== "undefined") animation.setContext(self);
    this.setAnimationLoop = function(callback) {
      onAnimationFrameCallback = callback;
      xr.setAnimationLoop(callback);
      callback === null ? animation.stop() : animation.start();
    };
    xr.addEventListener("sessionstart", onXRSessionStart);
    xr.addEventListener("sessionend", onXRSessionEnd);
    this.render = function(scene, camera) {
      if (camera !== void 0 && camera.isCamera !== true) {
        console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
        return;
      }
      if (_isContextLost === true) return;
      if (scene.matrixWorldAutoUpdate === true) scene.updateMatrixWorld();
      if (camera.parent === null && camera.matrixWorldAutoUpdate === true) camera.updateMatrixWorld();
      if (xr.enabled === true && xr.isPresenting === true) {
        if (xr.cameraAutoUpdate === true) xr.updateCamera(camera);
        camera = xr.getCamera();
      }
      if (scene.isScene === true) scene.onBeforeRender(_this, scene, camera, _currentRenderTarget);
      currentRenderState = renderStates.get(scene, renderStateStack.length);
      currentRenderState.init(camera);
      renderStateStack.push(currentRenderState);
      _projScreenMatrix2.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
      _frustum2.setFromProjectionMatrix(_projScreenMatrix2);
      _localClippingEnabled = this.localClippingEnabled;
      _clippingEnabled = clipping.init(this.clippingPlanes, _localClippingEnabled);
      currentRenderList = renderLists.get(scene, renderListStack.length);
      currentRenderList.init();
      renderListStack.push(currentRenderList);
      if (xr.enabled === true && xr.isPresenting === true) {
        const depthSensingMesh = _this.xr.getDepthSensingMesh();
        if (depthSensingMesh !== null) {
          projectObject(depthSensingMesh, camera, -Infinity, _this.sortObjects);
        }
      }
      projectObject(scene, camera, 0, _this.sortObjects);
      currentRenderList.finish();
      if (_this.sortObjects === true) {
        currentRenderList.sort(_opaqueSort, _transparentSort);
      }
      _renderBackground = xr.enabled === false || xr.isPresenting === false || xr.hasDepthSensing() === false;
      if (_renderBackground) {
        background.addToRenderList(currentRenderList, scene);
      }
      this.info.render.frame++;
      if (_clippingEnabled === true) clipping.beginShadows();
      const shadowsArray = currentRenderState.state.shadowsArray;
      shadowMap.render(shadowsArray, scene, camera);
      if (_clippingEnabled === true) clipping.endShadows();
      if (this.info.autoReset === true) this.info.reset();
      const opaqueObjects = currentRenderList.opaque;
      const transmissiveObjects = currentRenderList.transmissive;
      currentRenderState.setupLights();
      if (camera.isArrayCamera) {
        const cameras = camera.cameras;
        if (transmissiveObjects.length > 0) {
          for (let i = 0, l = cameras.length; i < l; i++) {
            const camera2 = cameras[i];
            renderTransmissionPass(opaqueObjects, transmissiveObjects, scene, camera2);
          }
        }
        if (_renderBackground) background.render(scene);
        for (let i = 0, l = cameras.length; i < l; i++) {
          const camera2 = cameras[i];
          renderScene(currentRenderList, scene, camera2, camera2.viewport);
        }
      } else {
        if (transmissiveObjects.length > 0) renderTransmissionPass(opaqueObjects, transmissiveObjects, scene, camera);
        if (_renderBackground) background.render(scene);
        renderScene(currentRenderList, scene, camera);
      }
      if (_currentRenderTarget !== null && _currentActiveMipmapLevel === 0) {
        textures.updateMultisampleRenderTarget(_currentRenderTarget);
        textures.updateRenderTargetMipmap(_currentRenderTarget);
      }
      if (scene.isScene === true) scene.onAfterRender(_this, scene, camera);
      bindingStates.resetDefaultState();
      _currentMaterialId = -1;
      _currentCamera = null;
      renderStateStack.pop();
      if (renderStateStack.length > 0) {
        currentRenderState = renderStateStack[renderStateStack.length - 1];
        if (_clippingEnabled === true) clipping.setGlobalState(_this.clippingPlanes, currentRenderState.state.camera);
      } else {
        currentRenderState = null;
      }
      renderListStack.pop();
      if (renderListStack.length > 0) {
        currentRenderList = renderListStack[renderListStack.length - 1];
      } else {
        currentRenderList = null;
      }
    };
    function projectObject(object, camera, groupOrder, sortObjects) {
      if (object.visible === false) return;
      const visible = object.layers.test(camera.layers);
      if (visible) {
        if (object.isGroup) {
          groupOrder = object.renderOrder;
        } else if (object.isLOD) {
          if (object.autoUpdate === true) object.update(camera);
        } else if (object.isLight) {
          currentRenderState.pushLight(object);
          if (object.castShadow) {
            currentRenderState.pushShadow(object);
          }
        } else if (object.isSprite) {
          if (!object.frustumCulled || _frustum2.intersectsSprite(object)) {
            if (sortObjects) {
              _vector4.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix2);
            }
            const geometry = objects.update(object);
            const material = object.material;
            if (material.visible) {
              currentRenderList.push(object, geometry, material, groupOrder, _vector4.z, null);
            }
          }
        } else if (object.isMesh || object.isLine || object.isPoints) {
          if (!object.frustumCulled || _frustum2.intersectsObject(object)) {
            const geometry = objects.update(object);
            const material = object.material;
            if (sortObjects) {
              if (object.boundingSphere !== void 0) {
                if (object.boundingSphere === null) object.computeBoundingSphere();
                _vector4.copy(object.boundingSphere.center);
              } else {
                if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
                _vector4.copy(geometry.boundingSphere.center);
              }
              _vector4.applyMatrix4(object.matrixWorld).applyMatrix4(_projScreenMatrix2);
            }
            if (Array.isArray(material)) {
              const groups = geometry.groups;
              for (let i = 0, l = groups.length; i < l; i++) {
                const group = groups[i];
                const groupMaterial = material[group.materialIndex];
                if (groupMaterial && groupMaterial.visible) {
                  currentRenderList.push(object, geometry, groupMaterial, groupOrder, _vector4.z, group);
                }
              }
            } else if (material.visible) {
              currentRenderList.push(object, geometry, material, groupOrder, _vector4.z, null);
            }
          }
        }
      }
      const children = object.children;
      for (let i = 0, l = children.length; i < l; i++) {
        projectObject(children[i], camera, groupOrder, sortObjects);
      }
    }
    function renderScene(currentRenderList2, scene, camera, viewport) {
      const opaqueObjects = currentRenderList2.opaque;
      const transmissiveObjects = currentRenderList2.transmissive;
      const transparentObjects = currentRenderList2.transparent;
      currentRenderState.setupLightsView(camera);
      if (_clippingEnabled === true) clipping.setGlobalState(_this.clippingPlanes, camera);
      if (viewport) state.viewport(_currentViewport.copy(viewport));
      if (opaqueObjects.length > 0) renderObjects(opaqueObjects, scene, camera);
      if (transmissiveObjects.length > 0) renderObjects(transmissiveObjects, scene, camera);
      if (transparentObjects.length > 0) renderObjects(transparentObjects, scene, camera);
      state.buffers.depth.setTest(true);
      state.buffers.depth.setMask(true);
      state.buffers.color.setMask(true);
      state.setPolygonOffset(false);
    }
    function renderTransmissionPass(opaqueObjects, transmissiveObjects, scene, camera) {
      const overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;
      if (overrideMaterial !== null) {
        return;
      }
      if (currentRenderState.state.transmissionRenderTarget[camera.id] === void 0) {
        currentRenderState.state.transmissionRenderTarget[camera.id] = new WebGLRenderTarget(1, 1, {
          generateMipmaps: true,
          type: extensions.has("EXT_color_buffer_half_float") || extensions.has("EXT_color_buffer_float") ? HalfFloatType : UnsignedByteType,
          minFilter: LinearMipmapLinearFilter,
          samples: 4,
          stencilBuffer: stencil,
          resolveDepthBuffer: false,
          resolveStencilBuffer: false,
          colorSpace: ColorManagement$1.workingColorSpace
        });
      }
      const transmissionRenderTarget = currentRenderState.state.transmissionRenderTarget[camera.id];
      const activeViewport = camera.viewport || _currentViewport;
      transmissionRenderTarget.setSize(activeViewport.z * _this.transmissionResolutionScale, activeViewport.w * _this.transmissionResolutionScale);
      const currentRenderTarget = _this.getRenderTarget();
      _this.setRenderTarget(transmissionRenderTarget);
      _this.getClearColor(_currentClearColor);
      _currentClearAlpha = _this.getClearAlpha();
      if (_currentClearAlpha < 1) _this.setClearColor(16777215, 0.5);
      _this.clear();
      if (_renderBackground) background.render(scene);
      const currentToneMapping = _this.toneMapping;
      _this.toneMapping = NoToneMapping$1;
      const currentCameraViewport = camera.viewport;
      if (camera.viewport !== void 0) camera.viewport = void 0;
      currentRenderState.setupLightsView(camera);
      if (_clippingEnabled === true) clipping.setGlobalState(_this.clippingPlanes, camera);
      renderObjects(opaqueObjects, scene, camera);
      textures.updateMultisampleRenderTarget(transmissionRenderTarget);
      textures.updateRenderTargetMipmap(transmissionRenderTarget);
      if (extensions.has("WEBGL_multisampled_render_to_texture") === false) {
        let renderTargetNeedsUpdate = false;
        for (let i = 0, l = transmissiveObjects.length; i < l; i++) {
          const renderItem = transmissiveObjects[i];
          const object = renderItem.object;
          const geometry = renderItem.geometry;
          const material = renderItem.material;
          const group = renderItem.group;
          if (material.side === DoubleSide && object.layers.test(camera.layers)) {
            const currentSide = material.side;
            material.side = BackSide;
            material.needsUpdate = true;
            renderObject(object, scene, camera, geometry, material, group);
            material.side = currentSide;
            material.needsUpdate = true;
            renderTargetNeedsUpdate = true;
          }
        }
        if (renderTargetNeedsUpdate === true) {
          textures.updateMultisampleRenderTarget(transmissionRenderTarget);
          textures.updateRenderTargetMipmap(transmissionRenderTarget);
        }
      }
      _this.setRenderTarget(currentRenderTarget);
      _this.setClearColor(_currentClearColor, _currentClearAlpha);
      if (currentCameraViewport !== void 0) camera.viewport = currentCameraViewport;
      _this.toneMapping = currentToneMapping;
    }
    function renderObjects(renderList, scene, camera) {
      const overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;
      for (let i = 0, l = renderList.length; i < l; i++) {
        const renderItem = renderList[i];
        const object = renderItem.object;
        const geometry = renderItem.geometry;
        const material = overrideMaterial === null ? renderItem.material : overrideMaterial;
        const group = renderItem.group;
        if (object.layers.test(camera.layers)) {
          renderObject(object, scene, camera, geometry, material, group);
        }
      }
    }
    function renderObject(object, scene, camera, geometry, material, group) {
      object.onBeforeRender(_this, scene, camera, geometry, material, group);
      object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
      object.normalMatrix.getNormalMatrix(object.modelViewMatrix);
      material.onBeforeRender(_this, scene, camera, geometry, object, group);
      if (material.transparent === true && material.side === DoubleSide && material.forceSinglePass === false) {
        material.side = BackSide;
        material.needsUpdate = true;
        _this.renderBufferDirect(camera, scene, geometry, material, object, group);
        material.side = FrontSide;
        material.needsUpdate = true;
        _this.renderBufferDirect(camera, scene, geometry, material, object, group);
        material.side = DoubleSide;
      } else {
        _this.renderBufferDirect(camera, scene, geometry, material, object, group);
      }
      object.onAfterRender(_this, scene, camera, geometry, material, group);
    }
    function getProgram(material, scene, object) {
      if (scene.isScene !== true) scene = _emptyScene;
      const materialProperties = properties.get(material);
      const lights = currentRenderState.state.lights;
      const shadowsArray = currentRenderState.state.shadowsArray;
      const lightsStateVersion = lights.state.version;
      const parameters2 = programCache.getParameters(material, lights.state, shadowsArray, scene, object);
      const programCacheKey = programCache.getProgramCacheKey(parameters2);
      let programs = materialProperties.programs;
      materialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null;
      materialProperties.fog = scene.fog;
      materialProperties.envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || materialProperties.environment);
      materialProperties.envMapRotation = materialProperties.environment !== null && material.envMap === null ? scene.environmentRotation : material.envMapRotation;
      if (programs === void 0) {
        material.addEventListener("dispose", onMaterialDispose);
        programs = /* @__PURE__ */ new Map();
        materialProperties.programs = programs;
      }
      let program = programs.get(programCacheKey);
      if (program !== void 0) {
        if (materialProperties.currentProgram === program && materialProperties.lightsStateVersion === lightsStateVersion) {
          updateCommonMaterialProperties(material, parameters2);
          return program;
        }
      } else {
        parameters2.uniforms = programCache.getUniforms(material);
        material.onBeforeCompile(parameters2, _this);
        program = programCache.acquireProgram(parameters2, programCacheKey);
        programs.set(programCacheKey, program);
        materialProperties.uniforms = parameters2.uniforms;
      }
      const uniforms = materialProperties.uniforms;
      if (!material.isShaderMaterial && !material.isRawShaderMaterial || material.clipping === true) {
        uniforms.clippingPlanes = clipping.uniform;
      }
      updateCommonMaterialProperties(material, parameters2);
      materialProperties.needsLights = materialNeedsLights(material);
      materialProperties.lightsStateVersion = lightsStateVersion;
      if (materialProperties.needsLights) {
        uniforms.ambientLightColor.value = lights.state.ambient;
        uniforms.lightProbe.value = lights.state.probe;
        uniforms.directionalLights.value = lights.state.directional;
        uniforms.directionalLightShadows.value = lights.state.directionalShadow;
        uniforms.spotLights.value = lights.state.spot;
        uniforms.spotLightShadows.value = lights.state.spotShadow;
        uniforms.rectAreaLights.value = lights.state.rectArea;
        uniforms.ltc_1.value = lights.state.rectAreaLTC1;
        uniforms.ltc_2.value = lights.state.rectAreaLTC2;
        uniforms.pointLights.value = lights.state.point;
        uniforms.pointLightShadows.value = lights.state.pointShadow;
        uniforms.hemisphereLights.value = lights.state.hemi;
        uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
        uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
        uniforms.spotShadowMap.value = lights.state.spotShadowMap;
        uniforms.spotLightMatrix.value = lights.state.spotLightMatrix;
        uniforms.spotLightMap.value = lights.state.spotLightMap;
        uniforms.pointShadowMap.value = lights.state.pointShadowMap;
        uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;
      }
      materialProperties.currentProgram = program;
      materialProperties.uniformsList = null;
      return program;
    }
    function getUniformList(materialProperties) {
      if (materialProperties.uniformsList === null) {
        const progUniforms = materialProperties.currentProgram.getUniforms();
        materialProperties.uniformsList = WebGLUniforms.seqWithValue(progUniforms.seq, materialProperties.uniforms);
      }
      return materialProperties.uniformsList;
    }
    function updateCommonMaterialProperties(material, parameters2) {
      const materialProperties = properties.get(material);
      materialProperties.outputColorSpace = parameters2.outputColorSpace;
      materialProperties.batching = parameters2.batching;
      materialProperties.batchingColor = parameters2.batchingColor;
      materialProperties.instancing = parameters2.instancing;
      materialProperties.instancingColor = parameters2.instancingColor;
      materialProperties.instancingMorph = parameters2.instancingMorph;
      materialProperties.skinning = parameters2.skinning;
      materialProperties.morphTargets = parameters2.morphTargets;
      materialProperties.morphNormals = parameters2.morphNormals;
      materialProperties.morphColors = parameters2.morphColors;
      materialProperties.morphTargetsCount = parameters2.morphTargetsCount;
      materialProperties.numClippingPlanes = parameters2.numClippingPlanes;
      materialProperties.numIntersection = parameters2.numClipIntersection;
      materialProperties.vertexAlphas = parameters2.vertexAlphas;
      materialProperties.vertexTangents = parameters2.vertexTangents;
      materialProperties.toneMapping = parameters2.toneMapping;
    }
    function setProgram(camera, scene, geometry, material, object) {
      if (scene.isScene !== true) scene = _emptyScene;
      textures.resetTextureUnits();
      const fog = scene.fog;
      const environment = material.isMeshStandardMaterial ? scene.environment : null;
      const colorSpace = _currentRenderTarget === null ? _this.outputColorSpace : _currentRenderTarget.isXRRenderTarget === true ? _currentRenderTarget.texture.colorSpace : LinearSRGBColorSpace$1;
      const envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || environment);
      const vertexAlphas = material.vertexColors === true && !!geometry.attributes.color && geometry.attributes.color.itemSize === 4;
      const vertexTangents = !!geometry.attributes.tangent && (!!material.normalMap || material.anisotropy > 0);
      const morphTargets = !!geometry.morphAttributes.position;
      const morphNormals = !!geometry.morphAttributes.normal;
      const morphColors = !!geometry.morphAttributes.color;
      let toneMapping2 = NoToneMapping$1;
      if (material.toneMapped) {
        if (_currentRenderTarget === null || _currentRenderTarget.isXRRenderTarget === true) {
          toneMapping2 = _this.toneMapping;
        }
      }
      const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
      const morphTargetsCount = morphAttribute !== void 0 ? morphAttribute.length : 0;
      const materialProperties = properties.get(material);
      const lights = currentRenderState.state.lights;
      if (_clippingEnabled === true) {
        if (_localClippingEnabled === true || camera !== _currentCamera) {
          const useCache = camera === _currentCamera && material.id === _currentMaterialId;
          clipping.setState(material, camera, useCache);
        }
      }
      let needsProgramChange = false;
      if (material.version === materialProperties.__version) {
        if (materialProperties.needsLights && materialProperties.lightsStateVersion !== lights.state.version) {
          needsProgramChange = true;
        } else if (materialProperties.outputColorSpace !== colorSpace) {
          needsProgramChange = true;
        } else if (object.isBatchedMesh && materialProperties.batching === false) {
          needsProgramChange = true;
        } else if (!object.isBatchedMesh && materialProperties.batching === true) {
          needsProgramChange = true;
        } else if (object.isBatchedMesh && materialProperties.batchingColor === true && object.colorTexture === null) {
          needsProgramChange = true;
        } else if (object.isBatchedMesh && materialProperties.batchingColor === false && object.colorTexture !== null) {
          needsProgramChange = true;
        } else if (object.isInstancedMesh && materialProperties.instancing === false) {
          needsProgramChange = true;
        } else if (!object.isInstancedMesh && materialProperties.instancing === true) {
          needsProgramChange = true;
        } else if (object.isSkinnedMesh && materialProperties.skinning === false) {
          needsProgramChange = true;
        } else if (!object.isSkinnedMesh && materialProperties.skinning === true) {
          needsProgramChange = true;
        } else if (object.isInstancedMesh && materialProperties.instancingColor === true && object.instanceColor === null) {
          needsProgramChange = true;
        } else if (object.isInstancedMesh && materialProperties.instancingColor === false && object.instanceColor !== null) {
          needsProgramChange = true;
        } else if (object.isInstancedMesh && materialProperties.instancingMorph === true && object.morphTexture === null) {
          needsProgramChange = true;
        } else if (object.isInstancedMesh && materialProperties.instancingMorph === false && object.morphTexture !== null) {
          needsProgramChange = true;
        } else if (materialProperties.envMap !== envMap) {
          needsProgramChange = true;
        } else if (material.fog === true && materialProperties.fog !== fog) {
          needsProgramChange = true;
        } else if (materialProperties.numClippingPlanes !== void 0 && (materialProperties.numClippingPlanes !== clipping.numPlanes || materialProperties.numIntersection !== clipping.numIntersection)) {
          needsProgramChange = true;
        } else if (materialProperties.vertexAlphas !== vertexAlphas) {
          needsProgramChange = true;
        } else if (materialProperties.vertexTangents !== vertexTangents) {
          needsProgramChange = true;
        } else if (materialProperties.morphTargets !== morphTargets) {
          needsProgramChange = true;
        } else if (materialProperties.morphNormals !== morphNormals) {
          needsProgramChange = true;
        } else if (materialProperties.morphColors !== morphColors) {
          needsProgramChange = true;
        } else if (materialProperties.toneMapping !== toneMapping2) {
          needsProgramChange = true;
        } else if (materialProperties.morphTargetsCount !== morphTargetsCount) {
          needsProgramChange = true;
        }
      } else {
        needsProgramChange = true;
        materialProperties.__version = material.version;
      }
      let program = materialProperties.currentProgram;
      if (needsProgramChange === true) {
        program = getProgram(material, scene, object);
      }
      let refreshProgram = false;
      let refreshMaterial = false;
      let refreshLights = false;
      const p_uniforms = program.getUniforms(), m_uniforms = materialProperties.uniforms;
      if (state.useProgram(program.program)) {
        refreshProgram = true;
        refreshMaterial = true;
        refreshLights = true;
      }
      if (material.id !== _currentMaterialId) {
        _currentMaterialId = material.id;
        refreshMaterial = true;
      }
      if (refreshProgram || _currentCamera !== camera) {
        const reverseDepthBuffer2 = state.buffers.depth.getReversed();
        if (reverseDepthBuffer2) {
          _currentProjectionMatrix.copy(camera.projectionMatrix);
          toNormalizedProjectionMatrix(_currentProjectionMatrix);
          toReversedProjectionMatrix(_currentProjectionMatrix);
          p_uniforms.setValue(_gl, "projectionMatrix", _currentProjectionMatrix);
        } else {
          p_uniforms.setValue(_gl, "projectionMatrix", camera.projectionMatrix);
        }
        p_uniforms.setValue(_gl, "viewMatrix", camera.matrixWorldInverse);
        const uCamPos = p_uniforms.map.cameraPosition;
        if (uCamPos !== void 0) {
          uCamPos.setValue(_gl, _vector32.setFromMatrixPosition(camera.matrixWorld));
        }
        if (capabilities.logarithmicDepthBuffer) {
          p_uniforms.setValue(
            _gl,
            "logDepthBufFC",
            2 / (Math.log(camera.far + 1) / Math.LN2)
          );
        }
        if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial) {
          p_uniforms.setValue(_gl, "isOrthographic", camera.isOrthographicCamera === true);
        }
        if (_currentCamera !== camera) {
          _currentCamera = camera;
          refreshMaterial = true;
          refreshLights = true;
        }
      }
      if (object.isSkinnedMesh) {
        p_uniforms.setOptional(_gl, object, "bindMatrix");
        p_uniforms.setOptional(_gl, object, "bindMatrixInverse");
        const skeleton = object.skeleton;
        if (skeleton) {
          if (skeleton.boneTexture === null) skeleton.computeBoneTexture();
          p_uniforms.setValue(_gl, "boneTexture", skeleton.boneTexture, textures);
        }
      }
      if (object.isBatchedMesh) {
        p_uniforms.setOptional(_gl, object, "batchingTexture");
        p_uniforms.setValue(_gl, "batchingTexture", object._matricesTexture, textures);
        p_uniforms.setOptional(_gl, object, "batchingIdTexture");
        p_uniforms.setValue(_gl, "batchingIdTexture", object._indirectTexture, textures);
        p_uniforms.setOptional(_gl, object, "batchingColorTexture");
        if (object._colorsTexture !== null) {
          p_uniforms.setValue(_gl, "batchingColorTexture", object._colorsTexture, textures);
        }
      }
      const morphAttributes = geometry.morphAttributes;
      if (morphAttributes.position !== void 0 || morphAttributes.normal !== void 0 || morphAttributes.color !== void 0) {
        morphtargets.update(object, geometry, program);
      }
      if (refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow) {
        materialProperties.receiveShadow = object.receiveShadow;
        p_uniforms.setValue(_gl, "receiveShadow", object.receiveShadow);
      }
      if (material.isMeshGouraudMaterial && material.envMap !== null) {
        m_uniforms.envMap.value = envMap;
        m_uniforms.flipEnvMap.value = envMap.isCubeTexture && envMap.isRenderTargetTexture === false ? -1 : 1;
      }
      if (material.isMeshStandardMaterial && material.envMap === null && scene.environment !== null) {
        m_uniforms.envMapIntensity.value = scene.environmentIntensity;
      }
      if (refreshMaterial) {
        p_uniforms.setValue(_gl, "toneMappingExposure", _this.toneMappingExposure);
        if (materialProperties.needsLights) {
          markUniformsLightsNeedsUpdate(m_uniforms, refreshLights);
        }
        if (fog && material.fog === true) {
          materials.refreshFogUniforms(m_uniforms, fog);
        }
        materials.refreshMaterialUniforms(m_uniforms, material, _pixelRatio, _height, currentRenderState.state.transmissionRenderTarget[camera.id]);
        WebGLUniforms.upload(_gl, getUniformList(materialProperties), m_uniforms, textures);
      }
      if (material.isShaderMaterial && material.uniformsNeedUpdate === true) {
        WebGLUniforms.upload(_gl, getUniformList(materialProperties), m_uniforms, textures);
        material.uniformsNeedUpdate = false;
      }
      if (material.isSpriteMaterial) {
        p_uniforms.setValue(_gl, "center", object.center);
      }
      p_uniforms.setValue(_gl, "modelViewMatrix", object.modelViewMatrix);
      p_uniforms.setValue(_gl, "normalMatrix", object.normalMatrix);
      p_uniforms.setValue(_gl, "modelMatrix", object.matrixWorld);
      if (material.isShaderMaterial || material.isRawShaderMaterial) {
        const groups = material.uniformsGroups;
        for (let i = 0, l = groups.length; i < l; i++) {
          const group = groups[i];
          uniformsGroups.update(group, program);
          uniformsGroups.bind(group, program);
        }
      }
      return program;
    }
    function markUniformsLightsNeedsUpdate(uniforms, value) {
      uniforms.ambientLightColor.needsUpdate = value;
      uniforms.lightProbe.needsUpdate = value;
      uniforms.directionalLights.needsUpdate = value;
      uniforms.directionalLightShadows.needsUpdate = value;
      uniforms.pointLights.needsUpdate = value;
      uniforms.pointLightShadows.needsUpdate = value;
      uniforms.spotLights.needsUpdate = value;
      uniforms.spotLightShadows.needsUpdate = value;
      uniforms.rectAreaLights.needsUpdate = value;
      uniforms.hemisphereLights.needsUpdate = value;
    }
    function materialNeedsLights(material) {
      return material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial || material.isShadowMaterial || material.isShaderMaterial && material.lights === true;
    }
    this.getActiveCubeFace = function() {
      return _currentActiveCubeFace;
    };
    this.getActiveMipmapLevel = function() {
      return _currentActiveMipmapLevel;
    };
    this.getRenderTarget = function() {
      return _currentRenderTarget;
    };
    this.setRenderTargetTextures = function(renderTarget, colorTexture, depthTexture) {
      properties.get(renderTarget.texture).__webglTexture = colorTexture;
      properties.get(renderTarget.depthTexture).__webglTexture = depthTexture;
      const renderTargetProperties = properties.get(renderTarget);
      renderTargetProperties.__hasExternalTextures = true;
      renderTargetProperties.__autoAllocateDepthBuffer = depthTexture === void 0;
      if (!renderTargetProperties.__autoAllocateDepthBuffer) {
        if (extensions.has("WEBGL_multisampled_render_to_texture") === true) {
          console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided");
          renderTargetProperties.__useRenderToTexture = false;
        }
      }
    };
    this.setRenderTargetFramebuffer = function(renderTarget, defaultFramebuffer) {
      const renderTargetProperties = properties.get(renderTarget);
      renderTargetProperties.__webglFramebuffer = defaultFramebuffer;
      renderTargetProperties.__useDefaultFramebuffer = defaultFramebuffer === void 0;
    };
    const _scratchFrameBuffer = _gl.createFramebuffer();
    this.setRenderTarget = function(renderTarget, activeCubeFace = 0, activeMipmapLevel = 0) {
      _currentRenderTarget = renderTarget;
      _currentActiveCubeFace = activeCubeFace;
      _currentActiveMipmapLevel = activeMipmapLevel;
      let useDefaultFramebuffer = true;
      let framebuffer = null;
      let isCube = false;
      let isRenderTarget3D = false;
      if (renderTarget) {
        const renderTargetProperties = properties.get(renderTarget);
        if (renderTargetProperties.__useDefaultFramebuffer !== void 0) {
          state.bindFramebuffer(_gl.FRAMEBUFFER, null);
          useDefaultFramebuffer = false;
        } else if (renderTargetProperties.__webglFramebuffer === void 0) {
          textures.setupRenderTarget(renderTarget);
        } else if (renderTargetProperties.__hasExternalTextures) {
          textures.rebindTextures(renderTarget, properties.get(renderTarget.texture).__webglTexture, properties.get(renderTarget.depthTexture).__webglTexture);
        } else if (renderTarget.depthBuffer) {
          const depthTexture = renderTarget.depthTexture;
          if (renderTargetProperties.__boundDepthTexture !== depthTexture) {
            if (depthTexture !== null && properties.has(depthTexture) && (renderTarget.width !== depthTexture.image.width || renderTarget.height !== depthTexture.image.height)) {
              throw new Error("WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size.");
            }
            textures.setupDepthRenderbuffer(renderTarget);
          }
        }
        const texture = renderTarget.texture;
        if (texture.isData3DTexture || texture.isDataArrayTexture || texture.isCompressedArrayTexture) {
          isRenderTarget3D = true;
        }
        const __webglFramebuffer = properties.get(renderTarget).__webglFramebuffer;
        if (renderTarget.isWebGLCubeRenderTarget) {
          if (Array.isArray(__webglFramebuffer[activeCubeFace])) {
            framebuffer = __webglFramebuffer[activeCubeFace][activeMipmapLevel];
          } else {
            framebuffer = __webglFramebuffer[activeCubeFace];
          }
          isCube = true;
        } else if (renderTarget.samples > 0 && textures.useMultisampledRTT(renderTarget) === false) {
          framebuffer = properties.get(renderTarget).__webglMultisampledFramebuffer;
        } else {
          if (Array.isArray(__webglFramebuffer)) {
            framebuffer = __webglFramebuffer[activeMipmapLevel];
          } else {
            framebuffer = __webglFramebuffer;
          }
        }
        _currentViewport.copy(renderTarget.viewport);
        _currentScissor.copy(renderTarget.scissor);
        _currentScissorTest = renderTarget.scissorTest;
      } else {
        _currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor();
        _currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor();
        _currentScissorTest = _scissorTest;
      }
      if (activeMipmapLevel !== 0) {
        framebuffer = _scratchFrameBuffer;
      }
      const framebufferBound = state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
      if (framebufferBound && useDefaultFramebuffer) {
        state.drawBuffers(renderTarget, framebuffer);
      }
      state.viewport(_currentViewport);
      state.scissor(_currentScissor);
      state.setScissorTest(_currentScissorTest);
      if (isCube) {
        const textureProperties = properties.get(renderTarget.texture);
        _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + activeCubeFace, textureProperties.__webglTexture, activeMipmapLevel);
      } else if (isRenderTarget3D) {
        const textureProperties = properties.get(renderTarget.texture);
        const layer = activeCubeFace;
        _gl.framebufferTextureLayer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, textureProperties.__webglTexture, activeMipmapLevel, layer);
      } else if (renderTarget !== null && activeMipmapLevel !== 0) {
        const textureProperties = properties.get(renderTarget.texture);
        _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D, textureProperties.__webglTexture, activeMipmapLevel);
      }
      _currentMaterialId = -1;
    };
    this.readRenderTargetPixels = function(renderTarget, x, y, width, height, buffer, activeCubeFaceIndex) {
      if (!(renderTarget && renderTarget.isWebGLRenderTarget)) {
        console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
        return;
      }
      let framebuffer = properties.get(renderTarget).__webglFramebuffer;
      if (renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== void 0) {
        framebuffer = framebuffer[activeCubeFaceIndex];
      }
      if (framebuffer) {
        state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
        try {
          const texture = renderTarget.texture;
          const textureFormat = texture.format;
          const textureType = texture.type;
          if (!capabilities.textureFormatReadable(textureFormat)) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
            return;
          }
          if (!capabilities.textureTypeReadable(textureType)) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
            return;
          }
          if (x >= 0 && x <= renderTarget.width - width && (y >= 0 && y <= renderTarget.height - height)) {
            _gl.readPixels(x, y, width, height, utils.convert(textureFormat), utils.convert(textureType), buffer);
          }
        } finally {
          const framebuffer2 = _currentRenderTarget !== null ? properties.get(_currentRenderTarget).__webglFramebuffer : null;
          state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer2);
        }
      }
    };
    this.readRenderTargetPixelsAsync = async function(renderTarget, x, y, width, height, buffer, activeCubeFaceIndex) {
      if (!(renderTarget && renderTarget.isWebGLRenderTarget)) {
        throw new Error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
      }
      let framebuffer = properties.get(renderTarget).__webglFramebuffer;
      if (renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== void 0) {
        framebuffer = framebuffer[activeCubeFaceIndex];
      }
      if (framebuffer) {
        const texture = renderTarget.texture;
        const textureFormat = texture.format;
        const textureType = texture.type;
        if (!capabilities.textureFormatReadable(textureFormat)) {
          throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.");
        }
        if (!capabilities.textureTypeReadable(textureType)) {
          throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.");
        }
        if (x >= 0 && x <= renderTarget.width - width && (y >= 0 && y <= renderTarget.height - height)) {
          state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
          const glBuffer = _gl.createBuffer();
          _gl.bindBuffer(_gl.PIXEL_PACK_BUFFER, glBuffer);
          _gl.bufferData(_gl.PIXEL_PACK_BUFFER, buffer.byteLength, _gl.STREAM_READ);
          _gl.readPixels(x, y, width, height, utils.convert(textureFormat), utils.convert(textureType), 0);
          const currFramebuffer = _currentRenderTarget !== null ? properties.get(_currentRenderTarget).__webglFramebuffer : null;
          state.bindFramebuffer(_gl.FRAMEBUFFER, currFramebuffer);
          const sync = _gl.fenceSync(_gl.SYNC_GPU_COMMANDS_COMPLETE, 0);
          _gl.flush();
          await probeAsync(_gl, sync, 4);
          _gl.bindBuffer(_gl.PIXEL_PACK_BUFFER, glBuffer);
          _gl.getBufferSubData(_gl.PIXEL_PACK_BUFFER, 0, buffer);
          _gl.deleteBuffer(glBuffer);
          _gl.deleteSync(sync);
          return buffer;
        } else {
          throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range.");
        }
      }
    };
    this.copyFramebufferToTexture = function(texture, position = null, level = 0) {
      if (texture.isTexture !== true) {
        warnOnce("WebGLRenderer: copyFramebufferToTexture function signature has changed.");
        position = arguments[0] || null;
        texture = arguments[1];
      }
      const levelScale = Math.pow(2, -level);
      const width = Math.floor(texture.image.width * levelScale);
      const height = Math.floor(texture.image.height * levelScale);
      const x = position !== null ? position.x : 0;
      const y = position !== null ? position.y : 0;
      textures.setTexture2D(texture, 0);
      _gl.copyTexSubImage2D(_gl.TEXTURE_2D, level, 0, 0, x, y, width, height);
      state.unbindTexture();
    };
    const _srcFramebuffer = _gl.createFramebuffer();
    const _dstFramebuffer = _gl.createFramebuffer();
    this.copyTextureToTexture = function(srcTexture, dstTexture, srcRegion = null, dstPosition = null, srcLevel = 0, dstLevel = null) {
      if (srcTexture.isTexture !== true) {
        warnOnce("WebGLRenderer: copyTextureToTexture function signature has changed.");
        dstPosition = arguments[0] || null;
        srcTexture = arguments[1];
        dstTexture = arguments[2];
        dstLevel = arguments[3] || 0;
        srcRegion = null;
      }
      if (dstLevel === null) {
        if (srcLevel !== 0) {
          warnOnce("WebGLRenderer: copyTextureToTexture function signature has changed to support src and dst mipmap levels.");
          dstLevel = srcLevel;
          srcLevel = 0;
        } else {
          dstLevel = 0;
        }
      }
      let width, height, depth2, minX, minY, minZ;
      let dstX, dstY, dstZ;
      const image = srcTexture.isCompressedTexture ? srcTexture.mipmaps[dstLevel] : srcTexture.image;
      if (srcRegion !== null) {
        width = srcRegion.max.x - srcRegion.min.x;
        height = srcRegion.max.y - srcRegion.min.y;
        depth2 = srcRegion.isBox3 ? srcRegion.max.z - srcRegion.min.z : 1;
        minX = srcRegion.min.x;
        minY = srcRegion.min.y;
        minZ = srcRegion.isBox3 ? srcRegion.min.z : 0;
      } else {
        const levelScale = Math.pow(2, -srcLevel);
        width = Math.floor(image.width * levelScale);
        height = Math.floor(image.height * levelScale);
        if (srcTexture.isDataArrayTexture) {
          depth2 = image.depth;
        } else if (srcTexture.isData3DTexture) {
          depth2 = Math.floor(image.depth * levelScale);
        } else {
          depth2 = 1;
        }
        minX = 0;
        minY = 0;
        minZ = 0;
      }
      if (dstPosition !== null) {
        dstX = dstPosition.x;
        dstY = dstPosition.y;
        dstZ = dstPosition.z;
      } else {
        dstX = 0;
        dstY = 0;
        dstZ = 0;
      }
      const glFormat = utils.convert(dstTexture.format);
      const glType = utils.convert(dstTexture.type);
      let glTarget;
      if (dstTexture.isData3DTexture) {
        textures.setTexture3D(dstTexture, 0);
        glTarget = _gl.TEXTURE_3D;
      } else if (dstTexture.isDataArrayTexture || dstTexture.isCompressedArrayTexture) {
        textures.setTexture2DArray(dstTexture, 0);
        glTarget = _gl.TEXTURE_2D_ARRAY;
      } else {
        textures.setTexture2D(dstTexture, 0);
        glTarget = _gl.TEXTURE_2D;
      }
      _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY);
      _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha);
      _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment);
      const currentUnpackRowLen = _gl.getParameter(_gl.UNPACK_ROW_LENGTH);
      const currentUnpackImageHeight = _gl.getParameter(_gl.UNPACK_IMAGE_HEIGHT);
      const currentUnpackSkipPixels = _gl.getParameter(_gl.UNPACK_SKIP_PIXELS);
      const currentUnpackSkipRows = _gl.getParameter(_gl.UNPACK_SKIP_ROWS);
      const currentUnpackSkipImages = _gl.getParameter(_gl.UNPACK_SKIP_IMAGES);
      _gl.pixelStorei(_gl.UNPACK_ROW_LENGTH, image.width);
      _gl.pixelStorei(_gl.UNPACK_IMAGE_HEIGHT, image.height);
      _gl.pixelStorei(_gl.UNPACK_SKIP_PIXELS, minX);
      _gl.pixelStorei(_gl.UNPACK_SKIP_ROWS, minY);
      _gl.pixelStorei(_gl.UNPACK_SKIP_IMAGES, minZ);
      const isSrc3D = srcTexture.isDataArrayTexture || srcTexture.isData3DTexture;
      const isDst3D = dstTexture.isDataArrayTexture || dstTexture.isData3DTexture;
      if (srcTexture.isDepthTexture) {
        const srcTextureProperties = properties.get(srcTexture);
        const dstTextureProperties = properties.get(dstTexture);
        const srcRenderTargetProperties = properties.get(srcTextureProperties.__renderTarget);
        const dstRenderTargetProperties = properties.get(dstTextureProperties.__renderTarget);
        state.bindFramebuffer(_gl.READ_FRAMEBUFFER, srcRenderTargetProperties.__webglFramebuffer);
        state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, dstRenderTargetProperties.__webglFramebuffer);
        for (let i = 0; i < depth2; i++) {
          if (isSrc3D) {
            _gl.framebufferTextureLayer(_gl.READ_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, properties.get(srcTexture).__webglTexture, srcLevel, minZ + i);
            _gl.framebufferTextureLayer(_gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, properties.get(dstTexture).__webglTexture, dstLevel, dstZ + i);
          }
          _gl.blitFramebuffer(minX, minY, width, height, dstX, dstY, width, height, _gl.DEPTH_BUFFER_BIT, _gl.NEAREST);
        }
        state.bindFramebuffer(_gl.READ_FRAMEBUFFER, null);
        state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, null);
      } else if (srcLevel !== 0 || srcTexture.isRenderTargetTexture || properties.has(srcTexture)) {
        const srcTextureProperties = properties.get(srcTexture);
        const dstTextureProperties = properties.get(dstTexture);
        state.bindFramebuffer(_gl.READ_FRAMEBUFFER, _srcFramebuffer);
        state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, _dstFramebuffer);
        for (let i = 0; i < depth2; i++) {
          if (isSrc3D) {
            _gl.framebufferTextureLayer(_gl.READ_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, srcTextureProperties.__webglTexture, srcLevel, minZ + i);
          } else {
            _gl.framebufferTexture2D(_gl.READ_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D, srcTextureProperties.__webglTexture, srcLevel);
          }
          if (isDst3D) {
            _gl.framebufferTextureLayer(_gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, dstTextureProperties.__webglTexture, dstLevel, dstZ + i);
          } else {
            _gl.framebufferTexture2D(_gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D, dstTextureProperties.__webglTexture, dstLevel);
          }
          if (srcLevel !== 0) {
            _gl.blitFramebuffer(minX, minY, width, height, dstX, dstY, width, height, _gl.COLOR_BUFFER_BIT, _gl.NEAREST);
          } else if (isDst3D) {
            _gl.copyTexSubImage3D(glTarget, dstLevel, dstX, dstY, dstZ + i, minX, minY, width, height);
          } else {
            _gl.copyTexSubImage2D(glTarget, dstLevel, dstX, dstY, minX, minY, width, height);
          }
        }
        state.bindFramebuffer(_gl.READ_FRAMEBUFFER, null);
        state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, null);
      } else {
        if (isDst3D) {
          if (srcTexture.isDataTexture || srcTexture.isData3DTexture) {
            _gl.texSubImage3D(glTarget, dstLevel, dstX, dstY, dstZ, width, height, depth2, glFormat, glType, image.data);
          } else if (dstTexture.isCompressedArrayTexture) {
            _gl.compressedTexSubImage3D(glTarget, dstLevel, dstX, dstY, dstZ, width, height, depth2, glFormat, image.data);
          } else {
            _gl.texSubImage3D(glTarget, dstLevel, dstX, dstY, dstZ, width, height, depth2, glFormat, glType, image);
          }
        } else {
          if (srcTexture.isDataTexture) {
            _gl.texSubImage2D(_gl.TEXTURE_2D, dstLevel, dstX, dstY, width, height, glFormat, glType, image.data);
          } else if (srcTexture.isCompressedTexture) {
            _gl.compressedTexSubImage2D(_gl.TEXTURE_2D, dstLevel, dstX, dstY, image.width, image.height, glFormat, image.data);
          } else {
            _gl.texSubImage2D(_gl.TEXTURE_2D, dstLevel, dstX, dstY, width, height, glFormat, glType, image);
          }
        }
      }
      _gl.pixelStorei(_gl.UNPACK_ROW_LENGTH, currentUnpackRowLen);
      _gl.pixelStorei(_gl.UNPACK_IMAGE_HEIGHT, currentUnpackImageHeight);
      _gl.pixelStorei(_gl.UNPACK_SKIP_PIXELS, currentUnpackSkipPixels);
      _gl.pixelStorei(_gl.UNPACK_SKIP_ROWS, currentUnpackSkipRows);
      _gl.pixelStorei(_gl.UNPACK_SKIP_IMAGES, currentUnpackSkipImages);
      if (dstLevel === 0 && dstTexture.generateMipmaps) {
        _gl.generateMipmap(glTarget);
      }
      state.unbindTexture();
    };
    this.copyTextureToTexture3D = function(srcTexture, dstTexture, srcRegion = null, dstPosition = null, level = 0) {
      if (srcTexture.isTexture !== true) {
        warnOnce("WebGLRenderer: copyTextureToTexture3D function signature has changed.");
        srcRegion = arguments[0] || null;
        dstPosition = arguments[1] || null;
        srcTexture = arguments[2];
        dstTexture = arguments[3];
        level = arguments[4] || 0;
      }
      warnOnce('WebGLRenderer: copyTextureToTexture3D function has been deprecated. Use "copyTextureToTexture" instead.');
      return this.copyTextureToTexture(srcTexture, dstTexture, srcRegion, dstPosition, level);
    };
    this.initRenderTarget = function(target) {
      if (properties.get(target).__webglFramebuffer === void 0) {
        textures.setupRenderTarget(target);
      }
    };
    this.initTexture = function(texture) {
      if (texture.isCubeTexture) {
        textures.setTextureCube(texture, 0);
      } else if (texture.isData3DTexture) {
        textures.setTexture3D(texture, 0);
      } else if (texture.isDataArrayTexture || texture.isCompressedArrayTexture) {
        textures.setTexture2DArray(texture, 0);
      } else {
        textures.setTexture2D(texture, 0);
      }
      state.unbindTexture();
    };
    this.resetState = function() {
      _currentActiveCubeFace = 0;
      _currentActiveMipmapLevel = 0;
      _currentRenderTarget = null;
      state.reset();
      bindingStates.reset();
    };
    if (typeof __THREE_DEVTOOLS__ !== "undefined") {
      __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
    }
  }
  get coordinateSystem() {
    return WebGLCoordinateSystem$1;
  }
  get outputColorSpace() {
    return this._outputColorSpace;
  }
  set outputColorSpace(colorSpace) {
    this._outputColorSpace = colorSpace;
    const gl = this.getContext();
    gl.drawingBufferColorspace = ColorManagement$1._getDrawingBufferColorSpace(colorSpace);
    gl.unpackColorSpace = ColorManagement$1._getUnpackColorSpace();
  }
}
const THREE = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ACESFilmicToneMapping,
  AddEquation,
  AddOperation,
  AdditiveAnimationBlendMode,
  AdditiveBlending,
  AgXToneMapping,
  AlphaFormat,
  AlwaysCompare,
  AlwaysDepth,
  AlwaysStencilFunc,
  AmbientLight,
  AnimationAction,
  AnimationClip,
  AnimationLoader,
  AnimationMixer,
  AnimationObjectGroup,
  AnimationUtils,
  ArcCurve,
  ArrayCamera,
  ArrowHelper,
  AttachedBindMode,
  Audio,
  AudioAnalyser,
  AudioContext,
  AudioListener,
  AudioLoader,
  AxesHelper,
  BackSide,
  BasicDepthPacking,
  BasicShadowMap,
  BatchedMesh,
  Bone,
  BooleanKeyframeTrack,
  Box2,
  Box3,
  Box3Helper,
  BoxGeometry,
  BoxHelper,
  BufferAttribute: BufferAttribute$1,
  BufferGeometry,
  BufferGeometryLoader,
  ByteType,
  Cache,
  Camera,
  CameraHelper,
  CanvasTexture,
  CapsuleGeometry,
  CatmullRomCurve3,
  CineonToneMapping,
  CircleGeometry,
  ClampToEdgeWrapping,
  Clock,
  Color: Color$1,
  ColorKeyframeTrack,
  ColorManagement: ColorManagement$1,
  CompressedArrayTexture,
  CompressedCubeTexture,
  CompressedTexture,
  CompressedTextureLoader,
  ConeGeometry,
  ConstantAlphaFactor,
  ConstantColorFactor,
  Controls,
  CubeCamera,
  CubeReflectionMapping,
  CubeRefractionMapping,
  CubeTexture,
  CubeTextureLoader,
  CubeUVReflectionMapping,
  CubicBezierCurve,
  CubicBezierCurve3,
  CubicInterpolant,
  CullFaceBack,
  CullFaceFront,
  CullFaceFrontBack,
  CullFaceNone,
  Curve,
  CurvePath,
  CustomBlending,
  CustomToneMapping,
  CylinderGeometry,
  Cylindrical,
  Data3DTexture,
  DataArrayTexture,
  DataTexture,
  DataTextureLoader,
  DataUtils,
  DecrementStencilOp,
  DecrementWrapStencilOp,
  DefaultLoadingManager,
  DepthFormat,
  DepthStencilFormat,
  DepthTexture,
  DetachedBindMode,
  DirectionalLight,
  DirectionalLightHelper,
  DiscreteInterpolant,
  DodecahedronGeometry,
  DoubleSide,
  DstAlphaFactor,
  DstColorFactor,
  DynamicCopyUsage,
  DynamicDrawUsage,
  DynamicReadUsage,
  EdgesGeometry,
  EllipseCurve,
  EqualCompare,
  EqualDepth,
  EqualStencilFunc,
  EquirectangularReflectionMapping,
  EquirectangularRefractionMapping,
  Euler,
  EventDispatcher: EventDispatcher$1,
  ExtrudeGeometry,
  FileLoader,
  Float16BufferAttribute,
  Float32BufferAttribute,
  FloatType: FloatType$1,
  Fog,
  FogExp2,
  FramebufferTexture,
  FrontSide,
  Frustum,
  GLBufferAttribute,
  GLSL1,
  GLSL3,
  GreaterCompare,
  GreaterDepth,
  GreaterEqualCompare,
  GreaterEqualDepth,
  GreaterEqualStencilFunc,
  GreaterStencilFunc,
  GridHelper,
  Group: Group$1,
  HalfFloatType,
  HemisphereLight,
  HemisphereLightHelper,
  IcosahedronGeometry,
  ImageBitmapLoader,
  ImageLoader,
  ImageUtils,
  IncrementStencilOp,
  IncrementWrapStencilOp,
  InstancedBufferAttribute,
  InstancedBufferGeometry,
  InstancedInterleavedBuffer,
  InstancedMesh,
  Int16BufferAttribute,
  Int32BufferAttribute,
  Int8BufferAttribute,
  IntType,
  InterleavedBuffer: InterleavedBuffer$1,
  InterleavedBufferAttribute: InterleavedBufferAttribute$1,
  Interpolant,
  InterpolateDiscrete,
  InterpolateLinear,
  InterpolateSmooth,
  InvertStencilOp,
  KeepStencilOp,
  KeyframeTrack,
  LOD,
  LatheGeometry,
  Layers,
  LessCompare,
  LessDepth,
  LessEqualCompare,
  LessEqualDepth,
  LessEqualStencilFunc,
  LessStencilFunc,
  Light,
  LightProbe,
  Line,
  Line3,
  LineBasicMaterial,
  LineCurve,
  LineCurve3,
  LineDashedMaterial,
  LineLoop,
  LineSegments,
  LinearFilter,
  LinearInterpolant,
  LinearMipMapLinearFilter,
  LinearMipMapNearestFilter,
  LinearMipmapLinearFilter,
  LinearMipmapNearestFilter,
  LinearSRGBColorSpace: LinearSRGBColorSpace$1,
  LinearToneMapping,
  LinearTransfer: LinearTransfer$1,
  Loader,
  LoaderUtils,
  LoadingManager,
  LoopOnce,
  LoopPingPong,
  LoopRepeat,
  LuminanceAlphaFormat,
  LuminanceFormat,
  MOUSE,
  Material,
  MaterialLoader,
  MathUtils: MathUtils$1,
  Matrix2,
  Matrix3: Matrix3$1,
  Matrix4: Matrix4$1,
  MaxEquation,
  Mesh,
  MeshBasicMaterial,
  MeshDepthMaterial,
  MeshDistanceMaterial,
  MeshLambertMaterial,
  MeshMatcapMaterial,
  MeshNormalMaterial,
  MeshPhongMaterial,
  MeshPhysicalMaterial,
  MeshStandardMaterial,
  MeshToonMaterial,
  MinEquation,
  MirroredRepeatWrapping,
  MixOperation,
  MultiplyBlending,
  MultiplyOperation,
  NearestFilter,
  NearestMipMapLinearFilter,
  NearestMipMapNearestFilter,
  NearestMipmapLinearFilter,
  NearestMipmapNearestFilter,
  NeutralToneMapping,
  NeverCompare,
  NeverDepth,
  NeverStencilFunc,
  NoBlending,
  NoColorSpace: NoColorSpace$1,
  NoToneMapping: NoToneMapping$1,
  NormalAnimationBlendMode,
  NormalBlending,
  NotEqualCompare,
  NotEqualDepth,
  NotEqualStencilFunc,
  NumberKeyframeTrack,
  Object3D,
  ObjectLoader,
  ObjectSpaceNormalMap,
  OctahedronGeometry,
  OneFactor,
  OneMinusConstantAlphaFactor,
  OneMinusConstantColorFactor,
  OneMinusDstAlphaFactor,
  OneMinusDstColorFactor,
  OneMinusSrcAlphaFactor,
  OneMinusSrcColorFactor,
  OrthographicCamera,
  PCFShadowMap,
  PCFSoftShadowMap,
  PMREMGenerator,
  Path,
  PerspectiveCamera,
  Plane,
  PlaneGeometry,
  PlaneHelper,
  PointLight,
  PointLightHelper,
  Points,
  PointsMaterial,
  PolarGridHelper,
  PolyhedronGeometry,
  PositionalAudio,
  PropertyBinding,
  PropertyMixer,
  QuadraticBezierCurve,
  QuadraticBezierCurve3,
  Quaternion: Quaternion$1,
  QuaternionKeyframeTrack,
  QuaternionLinearInterpolant,
  RED_GREEN_RGTC2_Format,
  RED_RGTC1_Format,
  REVISION,
  RGBADepthPacking,
  RGBAFormat,
  RGBAIntegerFormat,
  RGBA_ASTC_10x10_Format,
  RGBA_ASTC_10x5_Format,
  RGBA_ASTC_10x6_Format,
  RGBA_ASTC_10x8_Format,
  RGBA_ASTC_12x10_Format,
  RGBA_ASTC_12x12_Format,
  RGBA_ASTC_4x4_Format,
  RGBA_ASTC_5x4_Format,
  RGBA_ASTC_5x5_Format,
  RGBA_ASTC_6x5_Format,
  RGBA_ASTC_6x6_Format,
  RGBA_ASTC_8x5_Format,
  RGBA_ASTC_8x6_Format,
  RGBA_ASTC_8x8_Format,
  RGBA_BPTC_Format,
  RGBA_ETC2_EAC_Format,
  RGBA_PVRTC_2BPPV1_Format,
  RGBA_PVRTC_4BPPV1_Format,
  RGBA_S3TC_DXT1_Format,
  RGBA_S3TC_DXT3_Format,
  RGBA_S3TC_DXT5_Format,
  RGBDepthPacking,
  RGBFormat,
  RGBIntegerFormat,
  RGB_BPTC_SIGNED_Format,
  RGB_BPTC_UNSIGNED_Format,
  RGB_ETC1_Format,
  RGB_ETC2_Format,
  RGB_PVRTC_2BPPV1_Format,
  RGB_PVRTC_4BPPV1_Format,
  RGB_S3TC_DXT1_Format,
  RGDepthPacking,
  RGFormat,
  RGIntegerFormat,
  RawShaderMaterial,
  Ray,
  Raycaster,
  RectAreaLight,
  RedFormat,
  RedIntegerFormat,
  ReinhardToneMapping,
  RenderTarget,
  RenderTarget3D,
  RenderTargetArray,
  RepeatWrapping,
  ReplaceStencilOp,
  ReverseSubtractEquation,
  RingGeometry,
  SIGNED_RED_GREEN_RGTC2_Format,
  SIGNED_RED_RGTC1_Format,
  SRGBColorSpace: SRGBColorSpace$1,
  SRGBTransfer: SRGBTransfer$1,
  Scene,
  ShaderChunk,
  ShaderLib,
  ShaderMaterial,
  ShadowMaterial,
  Shape: Shape$1,
  ShapeGeometry,
  ShapePath,
  ShapeUtils,
  ShortType,
  Skeleton,
  SkeletonHelper,
  SkinnedMesh,
  Source,
  Sphere,
  SphereGeometry,
  Spherical,
  SphericalHarmonics3,
  SplineCurve,
  SpotLight,
  SpotLightHelper,
  Sprite,
  SpriteMaterial,
  SrcAlphaFactor,
  SrcAlphaSaturateFactor,
  SrcColorFactor,
  StaticCopyUsage,
  StaticDrawUsage: StaticDrawUsage$1,
  StaticReadUsage,
  StereoCamera,
  StreamCopyUsage,
  StreamDrawUsage,
  StreamReadUsage,
  StringKeyframeTrack,
  SubtractEquation,
  SubtractiveBlending,
  TOUCH,
  TangentSpaceNormalMap,
  TetrahedronGeometry,
  Texture,
  TextureLoader,
  TextureUtils,
  TorusGeometry,
  TorusKnotGeometry,
  Triangle,
  TriangleFanDrawMode,
  TriangleStripDrawMode,
  TrianglesDrawMode,
  TubeGeometry,
  UVMapping,
  Uint16BufferAttribute,
  Uint32BufferAttribute,
  Uint8BufferAttribute,
  Uint8ClampedBufferAttribute,
  Uniform,
  UniformsGroup,
  UniformsLib,
  UniformsUtils,
  UnsignedByteType,
  UnsignedInt248Type,
  UnsignedInt5999Type,
  UnsignedIntType,
  UnsignedShort4444Type,
  UnsignedShort5551Type,
  UnsignedShortType,
  VSMShadowMap,
  Vector2: Vector2$1,
  Vector3: Vector3$1,
  Vector4: Vector4$1,
  VectorKeyframeTrack,
  VideoTexture,
  WebGL3DRenderTarget,
  WebGLArrayRenderTarget,
  WebGLCoordinateSystem: WebGLCoordinateSystem$1,
  WebGLCubeRenderTarget,
  WebGLRenderTarget,
  WebGLRenderer,
  WebGLUtils,
  WebGPUCoordinateSystem: WebGPUCoordinateSystem$1,
  WireframeGeometry,
  WrapAroundEnding,
  ZeroCurvatureEnding,
  ZeroFactor,
  ZeroSlopeEnding,
  ZeroStencilOp,
  createCanvasElement
}, Symbol.toStringTag, { value: "Module" }));
var Easing = Object.freeze({
  Linear: Object.freeze({
    None: function(amount) {
      return amount;
    },
    In: function(amount) {
      return amount;
    },
    Out: function(amount) {
      return amount;
    },
    InOut: function(amount) {
      return amount;
    }
  }),
  Quadratic: Object.freeze({
    In: function(amount) {
      return amount * amount;
    },
    Out: function(amount) {
      return amount * (2 - amount);
    },
    InOut: function(amount) {
      if ((amount *= 2) < 1) {
        return 0.5 * amount * amount;
      }
      return -0.5 * (--amount * (amount - 2) - 1);
    }
  }),
  Cubic: Object.freeze({
    In: function(amount) {
      return amount * amount * amount;
    },
    Out: function(amount) {
      return --amount * amount * amount + 1;
    },
    InOut: function(amount) {
      if ((amount *= 2) < 1) {
        return 0.5 * amount * amount * amount;
      }
      return 0.5 * ((amount -= 2) * amount * amount + 2);
    }
  }),
  Quartic: Object.freeze({
    In: function(amount) {
      return amount * amount * amount * amount;
    },
    Out: function(amount) {
      return 1 - --amount * amount * amount * amount;
    },
    InOut: function(amount) {
      if ((amount *= 2) < 1) {
        return 0.5 * amount * amount * amount * amount;
      }
      return -0.5 * ((amount -= 2) * amount * amount * amount - 2);
    }
  }),
  Quintic: Object.freeze({
    In: function(amount) {
      return amount * amount * amount * amount * amount;
    },
    Out: function(amount) {
      return --amount * amount * amount * amount * amount + 1;
    },
    InOut: function(amount) {
      if ((amount *= 2) < 1) {
        return 0.5 * amount * amount * amount * amount * amount;
      }
      return 0.5 * ((amount -= 2) * amount * amount * amount * amount + 2);
    }
  }),
  Sinusoidal: Object.freeze({
    In: function(amount) {
      return 1 - Math.sin((1 - amount) * Math.PI / 2);
    },
    Out: function(amount) {
      return Math.sin(amount * Math.PI / 2);
    },
    InOut: function(amount) {
      return 0.5 * (1 - Math.sin(Math.PI * (0.5 - amount)));
    }
  }),
  Exponential: Object.freeze({
    In: function(amount) {
      return amount === 0 ? 0 : Math.pow(1024, amount - 1);
    },
    Out: function(amount) {
      return amount === 1 ? 1 : 1 - Math.pow(2, -10 * amount);
    },
    InOut: function(amount) {
      if (amount === 0) {
        return 0;
      }
      if (amount === 1) {
        return 1;
      }
      if ((amount *= 2) < 1) {
        return 0.5 * Math.pow(1024, amount - 1);
      }
      return 0.5 * (-Math.pow(2, -10 * (amount - 1)) + 2);
    }
  }),
  Circular: Object.freeze({
    In: function(amount) {
      return 1 - Math.sqrt(1 - amount * amount);
    },
    Out: function(amount) {
      return Math.sqrt(1 - --amount * amount);
    },
    InOut: function(amount) {
      if ((amount *= 2) < 1) {
        return -0.5 * (Math.sqrt(1 - amount * amount) - 1);
      }
      return 0.5 * (Math.sqrt(1 - (amount -= 2) * amount) + 1);
    }
  }),
  Elastic: Object.freeze({
    In: function(amount) {
      if (amount === 0) {
        return 0;
      }
      if (amount === 1) {
        return 1;
      }
      return -Math.pow(2, 10 * (amount - 1)) * Math.sin((amount - 1.1) * 5 * Math.PI);
    },
    Out: function(amount) {
      if (amount === 0) {
        return 0;
      }
      if (amount === 1) {
        return 1;
      }
      return Math.pow(2, -10 * amount) * Math.sin((amount - 0.1) * 5 * Math.PI) + 1;
    },
    InOut: function(amount) {
      if (amount === 0) {
        return 0;
      }
      if (amount === 1) {
        return 1;
      }
      amount *= 2;
      if (amount < 1) {
        return -0.5 * Math.pow(2, 10 * (amount - 1)) * Math.sin((amount - 1.1) * 5 * Math.PI);
      }
      return 0.5 * Math.pow(2, -10 * (amount - 1)) * Math.sin((amount - 1.1) * 5 * Math.PI) + 1;
    }
  }),
  Back: Object.freeze({
    In: function(amount) {
      var s = 1.70158;
      return amount === 1 ? 1 : amount * amount * ((s + 1) * amount - s);
    },
    Out: function(amount) {
      var s = 1.70158;
      return amount === 0 ? 0 : --amount * amount * ((s + 1) * amount + s) + 1;
    },
    InOut: function(amount) {
      var s = 1.70158 * 1.525;
      if ((amount *= 2) < 1) {
        return 0.5 * (amount * amount * ((s + 1) * amount - s));
      }
      return 0.5 * ((amount -= 2) * amount * ((s + 1) * amount + s) + 2);
    }
  }),
  Bounce: Object.freeze({
    In: function(amount) {
      return 1 - Easing.Bounce.Out(1 - amount);
    },
    Out: function(amount) {
      if (amount < 1 / 2.75) {
        return 7.5625 * amount * amount;
      } else if (amount < 2 / 2.75) {
        return 7.5625 * (amount -= 1.5 / 2.75) * amount + 0.75;
      } else if (amount < 2.5 / 2.75) {
        return 7.5625 * (amount -= 2.25 / 2.75) * amount + 0.9375;
      } else {
        return 7.5625 * (amount -= 2.625 / 2.75) * amount + 0.984375;
      }
    },
    InOut: function(amount) {
      if (amount < 0.5) {
        return Easing.Bounce.In(amount * 2) * 0.5;
      }
      return Easing.Bounce.Out(amount * 2 - 1) * 0.5 + 0.5;
    }
  }),
  generatePow: function(power) {
    if (power === void 0) {
      power = 4;
    }
    power = power < Number.EPSILON ? Number.EPSILON : power;
    power = power > 1e4 ? 1e4 : power;
    return {
      In: function(amount) {
        return Math.pow(amount, power);
      },
      Out: function(amount) {
        return 1 - Math.pow(1 - amount, power);
      },
      InOut: function(amount) {
        if (amount < 0.5) {
          return Math.pow(amount * 2, power) / 2;
        }
        return (1 - Math.pow(2 - amount * 2, power)) / 2 + 0.5;
      }
    };
  }
});
var now = function() {
  return performance.now();
};
var Group2 = (
  /** @class */
  function() {
    function Group3() {
      var tweens = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        tweens[_i] = arguments[_i];
      }
      this._tweens = {};
      this._tweensAddedDuringUpdate = {};
      this.add.apply(this, tweens);
    }
    Group3.prototype.getAll = function() {
      var _this = this;
      return Object.keys(this._tweens).map(function(tweenId) {
        return _this._tweens[tweenId];
      });
    };
    Group3.prototype.removeAll = function() {
      this._tweens = {};
    };
    Group3.prototype.add = function() {
      var _a;
      var tweens = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        tweens[_i] = arguments[_i];
      }
      for (var _b = 0, tweens_1 = tweens; _b < tweens_1.length; _b++) {
        var tween = tweens_1[_b];
        (_a = tween._group) === null || _a === void 0 ? void 0 : _a.remove(tween);
        tween._group = this;
        this._tweens[tween.getId()] = tween;
        this._tweensAddedDuringUpdate[tween.getId()] = tween;
      }
    };
    Group3.prototype.remove = function() {
      var tweens = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        tweens[_i] = arguments[_i];
      }
      for (var _a = 0, tweens_2 = tweens; _a < tweens_2.length; _a++) {
        var tween = tweens_2[_a];
        tween._group = void 0;
        delete this._tweens[tween.getId()];
        delete this._tweensAddedDuringUpdate[tween.getId()];
      }
    };
    Group3.prototype.allStopped = function() {
      return this.getAll().every(function(tween) {
        return !tween.isPlaying();
      });
    };
    Group3.prototype.update = function(time, preserve) {
      if (time === void 0) {
        time = now();
      }
      if (preserve === void 0) {
        preserve = true;
      }
      var tweenIds = Object.keys(this._tweens);
      if (tweenIds.length === 0)
        return;
      while (tweenIds.length > 0) {
        this._tweensAddedDuringUpdate = {};
        for (var i = 0; i < tweenIds.length; i++) {
          var tween = this._tweens[tweenIds[i]];
          var autoStart = !preserve;
          if (tween && tween.update(time, autoStart) === false && !preserve)
            this.remove(tween);
        }
        tweenIds = Object.keys(this._tweensAddedDuringUpdate);
      }
    };
    return Group3;
  }()
);
var Interpolation = {
  Linear: function(v, k) {
    var m = v.length - 1;
    var f = m * k;
    var i = Math.floor(f);
    var fn = Interpolation.Utils.Linear;
    if (k < 0) {
      return fn(v[0], v[1], f);
    }
    if (k > 1) {
      return fn(v[m], v[m - 1], m - f);
    }
    return fn(v[i], v[i + 1 > m ? m : i + 1], f - i);
  },
  Utils: {
    Linear: function(p0, p1, t) {
      return (p1 - p0) * t + p0;
    }
  }
};
var Sequence = (
  /** @class */
  function() {
    function Sequence2() {
    }
    Sequence2.nextId = function() {
      return Sequence2._nextId++;
    };
    Sequence2._nextId = 0;
    return Sequence2;
  }()
);
var mainGroup = new Group2();
var Tween$1 = (
  /** @class */
  function() {
    function Tween2(object, group) {
      this._isPaused = false;
      this._pauseStart = 0;
      this._valuesStart = {};
      this._valuesEnd = {};
      this._valuesStartRepeat = {};
      this._duration = 1e3;
      this._isDynamic = false;
      this._initialRepeat = 0;
      this._repeat = 0;
      this._yoyo = false;
      this._isPlaying = false;
      this._reversed = false;
      this._delayTime = 0;
      this._startTime = 0;
      this._easingFunction = Easing.Linear.None;
      this._interpolationFunction = Interpolation.Linear;
      this._chainedTweens = [];
      this._onStartCallbackFired = false;
      this._onEveryStartCallbackFired = false;
      this._id = Sequence.nextId();
      this._isChainStopped = false;
      this._propertiesAreSetUp = false;
      this._goToEnd = false;
      this._object = object;
      if (typeof group === "object") {
        this._group = group;
        group.add(this);
      } else if (group === true) {
        this._group = mainGroup;
        mainGroup.add(this);
      }
    }
    Tween2.prototype.getId = function() {
      return this._id;
    };
    Tween2.prototype.isPlaying = function() {
      return this._isPlaying;
    };
    Tween2.prototype.isPaused = function() {
      return this._isPaused;
    };
    Tween2.prototype.getDuration = function() {
      return this._duration;
    };
    Tween2.prototype.to = function(target, duration) {
      if (duration === void 0) {
        duration = 1e3;
      }
      if (this._isPlaying)
        throw new Error("Can not call Tween.to() while Tween is already started or paused. Stop the Tween first.");
      this._valuesEnd = target;
      this._propertiesAreSetUp = false;
      this._duration = duration < 0 ? 0 : duration;
      return this;
    };
    Tween2.prototype.duration = function(duration) {
      if (duration === void 0) {
        duration = 1e3;
      }
      this._duration = duration < 0 ? 0 : duration;
      return this;
    };
    Tween2.prototype.dynamic = function(dynamic) {
      if (dynamic === void 0) {
        dynamic = false;
      }
      this._isDynamic = dynamic;
      return this;
    };
    Tween2.prototype.start = function(time, overrideStartingValues) {
      if (time === void 0) {
        time = now();
      }
      if (overrideStartingValues === void 0) {
        overrideStartingValues = false;
      }
      if (this._isPlaying) {
        return this;
      }
      this._repeat = this._initialRepeat;
      if (this._reversed) {
        this._reversed = false;
        for (var property2 in this._valuesStartRepeat) {
          this._swapEndStartRepeatValues(property2);
          this._valuesStart[property2] = this._valuesStartRepeat[property2];
        }
      }
      this._isPlaying = true;
      this._isPaused = false;
      this._onStartCallbackFired = false;
      this._onEveryStartCallbackFired = false;
      this._isChainStopped = false;
      this._startTime = time;
      this._startTime += this._delayTime;
      if (!this._propertiesAreSetUp || overrideStartingValues) {
        this._propertiesAreSetUp = true;
        if (!this._isDynamic) {
          var tmp2 = {};
          for (var prop in this._valuesEnd)
            tmp2[prop] = this._valuesEnd[prop];
          this._valuesEnd = tmp2;
        }
        this._setupProperties(this._object, this._valuesStart, this._valuesEnd, this._valuesStartRepeat, overrideStartingValues);
      }
      return this;
    };
    Tween2.prototype.startFromCurrentValues = function(time) {
      return this.start(time, true);
    };
    Tween2.prototype._setupProperties = function(_object, _valuesStart, _valuesEnd, _valuesStartRepeat, overrideStartingValues) {
      for (var property2 in _valuesEnd) {
        var startValue = _object[property2];
        var startValueIsArray = Array.isArray(startValue);
        var propType = startValueIsArray ? "array" : typeof startValue;
        var isInterpolationList = !startValueIsArray && Array.isArray(_valuesEnd[property2]);
        if (propType === "undefined" || propType === "function") {
          continue;
        }
        if (isInterpolationList) {
          var endValues = _valuesEnd[property2];
          if (endValues.length === 0) {
            continue;
          }
          var temp2 = [startValue];
          for (var i = 0, l = endValues.length; i < l; i += 1) {
            var value = this._handleRelativeValue(startValue, endValues[i]);
            if (isNaN(value)) {
              isInterpolationList = false;
              console.warn("Found invalid interpolation list. Skipping.");
              break;
            }
            temp2.push(value);
          }
          if (isInterpolationList) {
            _valuesEnd[property2] = temp2;
          }
        }
        if ((propType === "object" || startValueIsArray) && startValue && !isInterpolationList) {
          _valuesStart[property2] = startValueIsArray ? [] : {};
          var nestedObject = startValue;
          for (var prop in nestedObject) {
            _valuesStart[property2][prop] = nestedObject[prop];
          }
          _valuesStartRepeat[property2] = startValueIsArray ? [] : {};
          var endValues = _valuesEnd[property2];
          if (!this._isDynamic) {
            var tmp2 = {};
            for (var prop in endValues)
              tmp2[prop] = endValues[prop];
            _valuesEnd[property2] = endValues = tmp2;
          }
          this._setupProperties(nestedObject, _valuesStart[property2], endValues, _valuesStartRepeat[property2], overrideStartingValues);
        } else {
          if (typeof _valuesStart[property2] === "undefined" || overrideStartingValues) {
            _valuesStart[property2] = startValue;
          }
          if (!startValueIsArray) {
            _valuesStart[property2] *= 1;
          }
          if (isInterpolationList) {
            _valuesStartRepeat[property2] = _valuesEnd[property2].slice().reverse();
          } else {
            _valuesStartRepeat[property2] = _valuesStart[property2] || 0;
          }
        }
      }
    };
    Tween2.prototype.stop = function() {
      if (!this._isChainStopped) {
        this._isChainStopped = true;
        this.stopChainedTweens();
      }
      if (!this._isPlaying) {
        return this;
      }
      this._isPlaying = false;
      this._isPaused = false;
      if (this._onStopCallback) {
        this._onStopCallback(this._object);
      }
      return this;
    };
    Tween2.prototype.end = function() {
      this._goToEnd = true;
      this.update(this._startTime + this._duration);
      return this;
    };
    Tween2.prototype.pause = function(time) {
      if (time === void 0) {
        time = now();
      }
      if (this._isPaused || !this._isPlaying) {
        return this;
      }
      this._isPaused = true;
      this._pauseStart = time;
      return this;
    };
    Tween2.prototype.resume = function(time) {
      if (time === void 0) {
        time = now();
      }
      if (!this._isPaused || !this._isPlaying) {
        return this;
      }
      this._isPaused = false;
      this._startTime += time - this._pauseStart;
      this._pauseStart = 0;
      return this;
    };
    Tween2.prototype.stopChainedTweens = function() {
      for (var i = 0, numChainedTweens = this._chainedTweens.length; i < numChainedTweens; i++) {
        this._chainedTweens[i].stop();
      }
      return this;
    };
    Tween2.prototype.group = function(group) {
      if (!group) {
        console.warn("tween.group() without args has been removed, use group.add(tween) instead.");
        return this;
      }
      group.add(this);
      return this;
    };
    Tween2.prototype.remove = function() {
      var _a;
      (_a = this._group) === null || _a === void 0 ? void 0 : _a.remove(this);
      return this;
    };
    Tween2.prototype.delay = function(amount) {
      if (amount === void 0) {
        amount = 0;
      }
      this._delayTime = amount;
      return this;
    };
    Tween2.prototype.repeat = function(times) {
      if (times === void 0) {
        times = 0;
      }
      this._initialRepeat = times;
      this._repeat = times;
      return this;
    };
    Tween2.prototype.repeatDelay = function(amount) {
      this._repeatDelayTime = amount;
      return this;
    };
    Tween2.prototype.yoyo = function(yoyo) {
      if (yoyo === void 0) {
        yoyo = false;
      }
      this._yoyo = yoyo;
      return this;
    };
    Tween2.prototype.easing = function(easingFunction) {
      if (easingFunction === void 0) {
        easingFunction = Easing.Linear.None;
      }
      this._easingFunction = easingFunction;
      return this;
    };
    Tween2.prototype.interpolation = function(interpolationFunction) {
      if (interpolationFunction === void 0) {
        interpolationFunction = Interpolation.Linear;
      }
      this._interpolationFunction = interpolationFunction;
      return this;
    };
    Tween2.prototype.chain = function() {
      var tweens = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        tweens[_i] = arguments[_i];
      }
      this._chainedTweens = tweens;
      return this;
    };
    Tween2.prototype.onStart = function(callback) {
      this._onStartCallback = callback;
      return this;
    };
    Tween2.prototype.onEveryStart = function(callback) {
      this._onEveryStartCallback = callback;
      return this;
    };
    Tween2.prototype.onUpdate = function(callback) {
      this._onUpdateCallback = callback;
      return this;
    };
    Tween2.prototype.onRepeat = function(callback) {
      this._onRepeatCallback = callback;
      return this;
    };
    Tween2.prototype.onComplete = function(callback) {
      this._onCompleteCallback = callback;
      return this;
    };
    Tween2.prototype.onStop = function(callback) {
      this._onStopCallback = callback;
      return this;
    };
    Tween2.prototype.update = function(time, autoStart) {
      var _this = this;
      var _a;
      if (time === void 0) {
        time = now();
      }
      if (autoStart === void 0) {
        autoStart = Tween2.autoStartOnUpdate;
      }
      if (this._isPaused)
        return true;
      var property2;
      if (!this._goToEnd && !this._isPlaying) {
        if (autoStart)
          this.start(time, true);
        else
          return false;
      }
      this._goToEnd = false;
      if (time < this._startTime) {
        return true;
      }
      if (this._onStartCallbackFired === false) {
        if (this._onStartCallback) {
          this._onStartCallback(this._object);
        }
        this._onStartCallbackFired = true;
      }
      if (this._onEveryStartCallbackFired === false) {
        if (this._onEveryStartCallback) {
          this._onEveryStartCallback(this._object);
        }
        this._onEveryStartCallbackFired = true;
      }
      var elapsedTime = time - this._startTime;
      var durationAndDelay = this._duration + ((_a = this._repeatDelayTime) !== null && _a !== void 0 ? _a : this._delayTime);
      var totalTime = this._duration + this._repeat * durationAndDelay;
      var calculateElapsedPortion = function() {
        if (_this._duration === 0)
          return 1;
        if (elapsedTime > totalTime) {
          return 1;
        }
        var timesRepeated = Math.trunc(elapsedTime / durationAndDelay);
        var timeIntoCurrentRepeat = elapsedTime - timesRepeated * durationAndDelay;
        var portion = Math.min(timeIntoCurrentRepeat / _this._duration, 1);
        if (portion === 0 && elapsedTime === _this._duration) {
          return 1;
        }
        return portion;
      };
      var elapsed = calculateElapsedPortion();
      var value = this._easingFunction(elapsed);
      this._updateProperties(this._object, this._valuesStart, this._valuesEnd, value);
      if (this._onUpdateCallback) {
        this._onUpdateCallback(this._object, elapsed);
      }
      if (this._duration === 0 || elapsedTime >= this._duration) {
        if (this._repeat > 0) {
          var completeCount = Math.min(Math.trunc((elapsedTime - this._duration) / durationAndDelay) + 1, this._repeat);
          if (isFinite(this._repeat)) {
            this._repeat -= completeCount;
          }
          for (property2 in this._valuesStartRepeat) {
            if (!this._yoyo && typeof this._valuesEnd[property2] === "string") {
              this._valuesStartRepeat[property2] = // eslint-disable-next-line
              // @ts-ignore FIXME?
              this._valuesStartRepeat[property2] + parseFloat(this._valuesEnd[property2]);
            }
            if (this._yoyo) {
              this._swapEndStartRepeatValues(property2);
            }
            this._valuesStart[property2] = this._valuesStartRepeat[property2];
          }
          if (this._yoyo) {
            this._reversed = !this._reversed;
          }
          this._startTime += durationAndDelay * completeCount;
          if (this._onRepeatCallback) {
            this._onRepeatCallback(this._object);
          }
          this._onEveryStartCallbackFired = false;
          return true;
        } else {
          if (this._onCompleteCallback) {
            this._onCompleteCallback(this._object);
          }
          for (var i = 0, numChainedTweens = this._chainedTweens.length; i < numChainedTweens; i++) {
            this._chainedTweens[i].start(this._startTime + this._duration, false);
          }
          this._isPlaying = false;
          return false;
        }
      }
      return true;
    };
    Tween2.prototype._updateProperties = function(_object, _valuesStart, _valuesEnd, value) {
      for (var property2 in _valuesEnd) {
        if (_valuesStart[property2] === void 0) {
          continue;
        }
        var start = _valuesStart[property2] || 0;
        var end = _valuesEnd[property2];
        var startIsArray = Array.isArray(_object[property2]);
        var endIsArray = Array.isArray(end);
        var isInterpolationList = !startIsArray && endIsArray;
        if (isInterpolationList) {
          _object[property2] = this._interpolationFunction(end, value);
        } else if (typeof end === "object" && end) {
          this._updateProperties(_object[property2], start, end, value);
        } else {
          end = this._handleRelativeValue(start, end);
          if (typeof end === "number") {
            _object[property2] = start + (end - start) * value;
          }
        }
      }
    };
    Tween2.prototype._handleRelativeValue = function(start, end) {
      if (typeof end !== "string") {
        return end;
      }
      if (end.charAt(0) === "+" || end.charAt(0) === "-") {
        return start + parseFloat(end);
      }
      return parseFloat(end);
    };
    Tween2.prototype._swapEndStartRepeatValues = function(property2) {
      var tmp2 = this._valuesStartRepeat[property2];
      var endValue = this._valuesEnd[property2];
      if (typeof endValue === "string") {
        this._valuesStartRepeat[property2] = this._valuesStartRepeat[property2] + parseFloat(endValue);
      } else {
        this._valuesStartRepeat[property2] = this._valuesEnd[property2];
      }
      this._valuesEnd[property2] = tmp2;
    };
    Tween2.autoStartOnUpdate = false;
    return Tween2;
  }()
);
Sequence.nextId;
var TWEEN = mainGroup;
TWEEN.getAll.bind(TWEEN);
TWEEN.removeAll.bind(TWEEN);
TWEEN.add.bind(TWEEN);
TWEEN.remove.bind(TWEEN);
TWEEN.update.bind(TWEEN);
const _changeEvent = { type: "change" };
const _startEvent = { type: "start" };
const _endEvent = { type: "end" };
const _ray = new Ray();
const _plane = new Plane();
const _TILT_LIMIT = Math.cos(70 * MathUtils$1.DEG2RAD);
const _v = new Vector3$1();
const _twoPI = 2 * Math.PI;
const _STATE = {
  NONE: -1,
  ROTATE: 0,
  DOLLY: 1,
  PAN: 2,
  TOUCH_ROTATE: 3,
  TOUCH_PAN: 4,
  TOUCH_DOLLY_PAN: 5,
  TOUCH_DOLLY_ROTATE: 6
};
const _EPS = 1e-6;
class OrbitControls extends Controls {
  constructor(object, domElement = null) {
    super(object, domElement);
    this.state = _STATE.NONE;
    this.enabled = true;
    this.target = new Vector3$1();
    this.cursor = new Vector3$1();
    this.minDistance = 0;
    this.maxDistance = Infinity;
    this.minZoom = 0;
    this.maxZoom = Infinity;
    this.minTargetRadius = 0;
    this.maxTargetRadius = Infinity;
    this.minPolarAngle = 0;
    this.maxPolarAngle = Math.PI;
    this.minAzimuthAngle = -Infinity;
    this.maxAzimuthAngle = Infinity;
    this.enableDamping = false;
    this.dampingFactor = 0.05;
    this.enableZoom = true;
    this.zoomSpeed = 1;
    this.enableRotate = true;
    this.rotateSpeed = 1;
    this.keyRotateSpeed = 1;
    this.enablePan = true;
    this.panSpeed = 1;
    this.screenSpacePanning = true;
    this.keyPanSpeed = 7;
    this.zoomToCursor = false;
    this.autoRotate = false;
    this.autoRotateSpeed = 2;
    this.keys = { LEFT: "ArrowLeft", UP: "ArrowUp", RIGHT: "ArrowRight", BOTTOM: "ArrowDown" };
    this.mouseButtons = { LEFT: MOUSE.ROTATE, MIDDLE: MOUSE.DOLLY, RIGHT: MOUSE.PAN };
    this.touches = { ONE: TOUCH.ROTATE, TWO: TOUCH.DOLLY_PAN };
    this.target0 = this.target.clone();
    this.position0 = this.object.position.clone();
    this.zoom0 = this.object.zoom;
    this._domElementKeyEvents = null;
    this._lastPosition = new Vector3$1();
    this._lastQuaternion = new Quaternion$1();
    this._lastTargetPosition = new Vector3$1();
    this._quat = new Quaternion$1().setFromUnitVectors(object.up, new Vector3$1(0, 1, 0));
    this._quatInverse = this._quat.clone().invert();
    this._spherical = new Spherical();
    this._sphericalDelta = new Spherical();
    this._scale = 1;
    this._panOffset = new Vector3$1();
    this._rotateStart = new Vector2$1();
    this._rotateEnd = new Vector2$1();
    this._rotateDelta = new Vector2$1();
    this._panStart = new Vector2$1();
    this._panEnd = new Vector2$1();
    this._panDelta = new Vector2$1();
    this._dollyStart = new Vector2$1();
    this._dollyEnd = new Vector2$1();
    this._dollyDelta = new Vector2$1();
    this._dollyDirection = new Vector3$1();
    this._mouse = new Vector2$1();
    this._performCursorZoom = false;
    this._pointers = [];
    this._pointerPositions = {};
    this._controlActive = false;
    this._onPointerMove = onPointerMove.bind(this);
    this._onPointerDown = onPointerDown.bind(this);
    this._onPointerUp = onPointerUp.bind(this);
    this._onContextMenu = onContextMenu.bind(this);
    this._onMouseWheel = onMouseWheel.bind(this);
    this._onKeyDown = onKeyDown.bind(this);
    this._onTouchStart = onTouchStart.bind(this);
    this._onTouchMove = onTouchMove.bind(this);
    this._onMouseDown = onMouseDown.bind(this);
    this._onMouseMove = onMouseMove.bind(this);
    this._interceptControlDown = interceptControlDown.bind(this);
    this._interceptControlUp = interceptControlUp.bind(this);
    if (this.domElement !== null) {
      this.connect();
    }
    this.update();
  }
  connect() {
    this.domElement.addEventListener("pointerdown", this._onPointerDown);
    this.domElement.addEventListener("pointercancel", this._onPointerUp);
    this.domElement.addEventListener("contextmenu", this._onContextMenu);
    this.domElement.addEventListener("wheel", this._onMouseWheel, { passive: false });
    const document2 = this.domElement.getRootNode();
    document2.addEventListener("keydown", this._interceptControlDown, { passive: true, capture: true });
    this.domElement.style.touchAction = "none";
  }
  disconnect() {
    this.domElement.removeEventListener("pointerdown", this._onPointerDown);
    this.domElement.removeEventListener("pointermove", this._onPointerMove);
    this.domElement.removeEventListener("pointerup", this._onPointerUp);
    this.domElement.removeEventListener("pointercancel", this._onPointerUp);
    this.domElement.removeEventListener("wheel", this._onMouseWheel);
    this.domElement.removeEventListener("contextmenu", this._onContextMenu);
    this.stopListenToKeyEvents();
    const document2 = this.domElement.getRootNode();
    document2.removeEventListener("keydown", this._interceptControlDown, { capture: true });
    this.domElement.style.touchAction = "auto";
  }
  dispose() {
    this.disconnect();
  }
  getPolarAngle() {
    return this._spherical.phi;
  }
  getAzimuthalAngle() {
    return this._spherical.theta;
  }
  getDistance() {
    return this.object.position.distanceTo(this.target);
  }
  listenToKeyEvents(domElement) {
    domElement.addEventListener("keydown", this._onKeyDown);
    this._domElementKeyEvents = domElement;
  }
  stopListenToKeyEvents() {
    if (this._domElementKeyEvents !== null) {
      this._domElementKeyEvents.removeEventListener("keydown", this._onKeyDown);
      this._domElementKeyEvents = null;
    }
  }
  saveState() {
    this.target0.copy(this.target);
    this.position0.copy(this.object.position);
    this.zoom0 = this.object.zoom;
  }
  reset() {
    this.target.copy(this.target0);
    this.object.position.copy(this.position0);
    this.object.zoom = this.zoom0;
    this.object.updateProjectionMatrix();
    this.dispatchEvent(_changeEvent);
    this.update();
    this.state = _STATE.NONE;
  }
  update(deltaTime = null) {
    const position = this.object.position;
    _v.copy(position).sub(this.target);
    _v.applyQuaternion(this._quat);
    this._spherical.setFromVector3(_v);
    if (this.autoRotate && this.state === _STATE.NONE) {
      this._rotateLeft(this._getAutoRotationAngle(deltaTime));
    }
    if (this.enableDamping) {
      this._spherical.theta += this._sphericalDelta.theta * this.dampingFactor;
      this._spherical.phi += this._sphericalDelta.phi * this.dampingFactor;
    } else {
      this._spherical.theta += this._sphericalDelta.theta;
      this._spherical.phi += this._sphericalDelta.phi;
    }
    let min2 = this.minAzimuthAngle;
    let max2 = this.maxAzimuthAngle;
    if (isFinite(min2) && isFinite(max2)) {
      if (min2 < -Math.PI) min2 += _twoPI;
      else if (min2 > Math.PI) min2 -= _twoPI;
      if (max2 < -Math.PI) max2 += _twoPI;
      else if (max2 > Math.PI) max2 -= _twoPI;
      if (min2 <= max2) {
        this._spherical.theta = Math.max(min2, Math.min(max2, this._spherical.theta));
      } else {
        this._spherical.theta = this._spherical.theta > (min2 + max2) / 2 ? Math.max(min2, this._spherical.theta) : Math.min(max2, this._spherical.theta);
      }
    }
    this._spherical.phi = Math.max(this.minPolarAngle, Math.min(this.maxPolarAngle, this._spherical.phi));
    this._spherical.makeSafe();
    if (this.enableDamping === true) {
      this.target.addScaledVector(this._panOffset, this.dampingFactor);
    } else {
      this.target.add(this._panOffset);
    }
    this.target.sub(this.cursor);
    this.target.clampLength(this.minTargetRadius, this.maxTargetRadius);
    this.target.add(this.cursor);
    let zoomChanged = false;
    if (this.zoomToCursor && this._performCursorZoom || this.object.isOrthographicCamera) {
      this._spherical.radius = this._clampDistance(this._spherical.radius);
    } else {
      const prevRadius = this._spherical.radius;
      this._spherical.radius = this._clampDistance(this._spherical.radius * this._scale);
      zoomChanged = prevRadius != this._spherical.radius;
    }
    _v.setFromSpherical(this._spherical);
    _v.applyQuaternion(this._quatInverse);
    position.copy(this.target).add(_v);
    this.object.lookAt(this.target);
    if (this.enableDamping === true) {
      this._sphericalDelta.theta *= 1 - this.dampingFactor;
      this._sphericalDelta.phi *= 1 - this.dampingFactor;
      this._panOffset.multiplyScalar(1 - this.dampingFactor);
    } else {
      this._sphericalDelta.set(0, 0, 0);
      this._panOffset.set(0, 0, 0);
    }
    if (this.zoomToCursor && this._performCursorZoom) {
      let newRadius = null;
      if (this.object.isPerspectiveCamera) {
        const prevRadius = _v.length();
        newRadius = this._clampDistance(prevRadius * this._scale);
        const radiusDelta = prevRadius - newRadius;
        this.object.position.addScaledVector(this._dollyDirection, radiusDelta);
        this.object.updateMatrixWorld();
        zoomChanged = !!radiusDelta;
      } else if (this.object.isOrthographicCamera) {
        const mouseBefore = new Vector3$1(this._mouse.x, this._mouse.y, 0);
        mouseBefore.unproject(this.object);
        const prevZoom = this.object.zoom;
        this.object.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.object.zoom / this._scale));
        this.object.updateProjectionMatrix();
        zoomChanged = prevZoom !== this.object.zoom;
        const mouseAfter = new Vector3$1(this._mouse.x, this._mouse.y, 0);
        mouseAfter.unproject(this.object);
        this.object.position.sub(mouseAfter).add(mouseBefore);
        this.object.updateMatrixWorld();
        newRadius = _v.length();
      } else {
        console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled.");
        this.zoomToCursor = false;
      }
      if (newRadius !== null) {
        if (this.screenSpacePanning) {
          this.target.set(0, 0, -1).transformDirection(this.object.matrix).multiplyScalar(newRadius).add(this.object.position);
        } else {
          _ray.origin.copy(this.object.position);
          _ray.direction.set(0, 0, -1).transformDirection(this.object.matrix);
          if (Math.abs(this.object.up.dot(_ray.direction)) < _TILT_LIMIT) {
            this.object.lookAt(this.target);
          } else {
            _plane.setFromNormalAndCoplanarPoint(this.object.up, this.target);
            _ray.intersectPlane(_plane, this.target);
          }
        }
      }
    } else if (this.object.isOrthographicCamera) {
      const prevZoom = this.object.zoom;
      this.object.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.object.zoom / this._scale));
      if (prevZoom !== this.object.zoom) {
        this.object.updateProjectionMatrix();
        zoomChanged = true;
      }
    }
    this._scale = 1;
    this._performCursorZoom = false;
    if (zoomChanged || this._lastPosition.distanceToSquared(this.object.position) > _EPS || 8 * (1 - this._lastQuaternion.dot(this.object.quaternion)) > _EPS || this._lastTargetPosition.distanceToSquared(this.target) > _EPS) {
      this.dispatchEvent(_changeEvent);
      this._lastPosition.copy(this.object.position);
      this._lastQuaternion.copy(this.object.quaternion);
      this._lastTargetPosition.copy(this.target);
      return true;
    }
    return false;
  }
  _getAutoRotationAngle(deltaTime) {
    if (deltaTime !== null) {
      return _twoPI / 60 * this.autoRotateSpeed * deltaTime;
    } else {
      return _twoPI / 60 / 60 * this.autoRotateSpeed;
    }
  }
  _getZoomScale(delta) {
    const normalizedDelta = Math.abs(delta * 0.01);
    return Math.pow(0.95, this.zoomSpeed * normalizedDelta);
  }
  _rotateLeft(angle) {
    this._sphericalDelta.theta -= angle;
  }
  _rotateUp(angle) {
    this._sphericalDelta.phi -= angle;
  }
  _panLeft(distance2, objectMatrix) {
    _v.setFromMatrixColumn(objectMatrix, 0);
    _v.multiplyScalar(-distance2);
    this._panOffset.add(_v);
  }
  _panUp(distance2, objectMatrix) {
    if (this.screenSpacePanning === true) {
      _v.setFromMatrixColumn(objectMatrix, 1);
    } else {
      _v.setFromMatrixColumn(objectMatrix, 0);
      _v.crossVectors(this.object.up, _v);
    }
    _v.multiplyScalar(distance2);
    this._panOffset.add(_v);
  }
  // deltaX and deltaY are in pixels; right and down are positive
  _pan(deltaX, deltaY) {
    const element2 = this.domElement;
    if (this.object.isPerspectiveCamera) {
      const position = this.object.position;
      _v.copy(position).sub(this.target);
      let targetDistance = _v.length();
      targetDistance *= Math.tan(this.object.fov / 2 * Math.PI / 180);
      this._panLeft(2 * deltaX * targetDistance / element2.clientHeight, this.object.matrix);
      this._panUp(2 * deltaY * targetDistance / element2.clientHeight, this.object.matrix);
    } else if (this.object.isOrthographicCamera) {
      this._panLeft(deltaX * (this.object.right - this.object.left) / this.object.zoom / element2.clientWidth, this.object.matrix);
      this._panUp(deltaY * (this.object.top - this.object.bottom) / this.object.zoom / element2.clientHeight, this.object.matrix);
    } else {
      console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.");
      this.enablePan = false;
    }
  }
  _dollyOut(dollyScale) {
    if (this.object.isPerspectiveCamera || this.object.isOrthographicCamera) {
      this._scale /= dollyScale;
    } else {
      console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.");
      this.enableZoom = false;
    }
  }
  _dollyIn(dollyScale) {
    if (this.object.isPerspectiveCamera || this.object.isOrthographicCamera) {
      this._scale *= dollyScale;
    } else {
      console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.");
      this.enableZoom = false;
    }
  }
  _updateZoomParameters(x, y) {
    if (!this.zoomToCursor) {
      return;
    }
    this._performCursorZoom = true;
    const rect = this.domElement.getBoundingClientRect();
    const dx = x - rect.left;
    const dy = y - rect.top;
    const w = rect.width;
    const h = rect.height;
    this._mouse.x = dx / w * 2 - 1;
    this._mouse.y = -(dy / h) * 2 + 1;
    this._dollyDirection.set(this._mouse.x, this._mouse.y, 1).unproject(this.object).sub(this.object.position).normalize();
  }
  _clampDistance(dist) {
    return Math.max(this.minDistance, Math.min(this.maxDistance, dist));
  }
  //
  // event callbacks - update the object state
  //
  _handleMouseDownRotate(event) {
    this._rotateStart.set(event.clientX, event.clientY);
  }
  _handleMouseDownDolly(event) {
    this._updateZoomParameters(event.clientX, event.clientX);
    this._dollyStart.set(event.clientX, event.clientY);
  }
  _handleMouseDownPan(event) {
    this._panStart.set(event.clientX, event.clientY);
  }
  _handleMouseMoveRotate(event) {
    this._rotateEnd.set(event.clientX, event.clientY);
    this._rotateDelta.subVectors(this._rotateEnd, this._rotateStart).multiplyScalar(this.rotateSpeed);
    const element2 = this.domElement;
    this._rotateLeft(_twoPI * this._rotateDelta.x / element2.clientHeight);
    this._rotateUp(_twoPI * this._rotateDelta.y / element2.clientHeight);
    this._rotateStart.copy(this._rotateEnd);
    this.update();
  }
  _handleMouseMoveDolly(event) {
    this._dollyEnd.set(event.clientX, event.clientY);
    this._dollyDelta.subVectors(this._dollyEnd, this._dollyStart);
    if (this._dollyDelta.y > 0) {
      this._dollyOut(this._getZoomScale(this._dollyDelta.y));
    } else if (this._dollyDelta.y < 0) {
      this._dollyIn(this._getZoomScale(this._dollyDelta.y));
    }
    this._dollyStart.copy(this._dollyEnd);
    this.update();
  }
  _handleMouseMovePan(event) {
    this._panEnd.set(event.clientX, event.clientY);
    this._panDelta.subVectors(this._panEnd, this._panStart).multiplyScalar(this.panSpeed);
    this._pan(this._panDelta.x, this._panDelta.y);
    this._panStart.copy(this._panEnd);
    this.update();
  }
  _handleMouseWheel(event) {
    this._updateZoomParameters(event.clientX, event.clientY);
    if (event.deltaY < 0) {
      this._dollyIn(this._getZoomScale(event.deltaY));
    } else if (event.deltaY > 0) {
      this._dollyOut(this._getZoomScale(event.deltaY));
    }
    this.update();
  }
  _handleKeyDown(event) {
    let needsUpdate = false;
    switch (event.code) {
      case this.keys.UP:
        if (event.ctrlKey || event.metaKey || event.shiftKey) {
          if (this.enableRotate) {
            this._rotateUp(_twoPI * this.keyRotateSpeed / this.domElement.clientHeight);
          }
        } else {
          if (this.enablePan) {
            this._pan(0, this.keyPanSpeed);
          }
        }
        needsUpdate = true;
        break;
      case this.keys.BOTTOM:
        if (event.ctrlKey || event.metaKey || event.shiftKey) {
          if (this.enableRotate) {
            this._rotateUp(-_twoPI * this.keyRotateSpeed / this.domElement.clientHeight);
          }
        } else {
          if (this.enablePan) {
            this._pan(0, -this.keyPanSpeed);
          }
        }
        needsUpdate = true;
        break;
      case this.keys.LEFT:
        if (event.ctrlKey || event.metaKey || event.shiftKey) {
          if (this.enableRotate) {
            this._rotateLeft(_twoPI * this.keyRotateSpeed / this.domElement.clientHeight);
          }
        } else {
          if (this.enablePan) {
            this._pan(this.keyPanSpeed, 0);
          }
        }
        needsUpdate = true;
        break;
      case this.keys.RIGHT:
        if (event.ctrlKey || event.metaKey || event.shiftKey) {
          if (this.enableRotate) {
            this._rotateLeft(-_twoPI * this.keyRotateSpeed / this.domElement.clientHeight);
          }
        } else {
          if (this.enablePan) {
            this._pan(-this.keyPanSpeed, 0);
          }
        }
        needsUpdate = true;
        break;
    }
    if (needsUpdate) {
      event.preventDefault();
      this.update();
    }
  }
  _handleTouchStartRotate(event) {
    if (this._pointers.length === 1) {
      this._rotateStart.set(event.pageX, event.pageY);
    } else {
      const position = this._getSecondPointerPosition(event);
      const x = 0.5 * (event.pageX + position.x);
      const y = 0.5 * (event.pageY + position.y);
      this._rotateStart.set(x, y);
    }
  }
  _handleTouchStartPan(event) {
    if (this._pointers.length === 1) {
      this._panStart.set(event.pageX, event.pageY);
    } else {
      const position = this._getSecondPointerPosition(event);
      const x = 0.5 * (event.pageX + position.x);
      const y = 0.5 * (event.pageY + position.y);
      this._panStart.set(x, y);
    }
  }
  _handleTouchStartDolly(event) {
    const position = this._getSecondPointerPosition(event);
    const dx = event.pageX - position.x;
    const dy = event.pageY - position.y;
    const distance2 = Math.sqrt(dx * dx + dy * dy);
    this._dollyStart.set(0, distance2);
  }
  _handleTouchStartDollyPan(event) {
    if (this.enableZoom) this._handleTouchStartDolly(event);
    if (this.enablePan) this._handleTouchStartPan(event);
  }
  _handleTouchStartDollyRotate(event) {
    if (this.enableZoom) this._handleTouchStartDolly(event);
    if (this.enableRotate) this._handleTouchStartRotate(event);
  }
  _handleTouchMoveRotate(event) {
    if (this._pointers.length == 1) {
      this._rotateEnd.set(event.pageX, event.pageY);
    } else {
      const position = this._getSecondPointerPosition(event);
      const x = 0.5 * (event.pageX + position.x);
      const y = 0.5 * (event.pageY + position.y);
      this._rotateEnd.set(x, y);
    }
    this._rotateDelta.subVectors(this._rotateEnd, this._rotateStart).multiplyScalar(this.rotateSpeed);
    const element2 = this.domElement;
    this._rotateLeft(_twoPI * this._rotateDelta.x / element2.clientHeight);
    this._rotateUp(_twoPI * this._rotateDelta.y / element2.clientHeight);
    this._rotateStart.copy(this._rotateEnd);
  }
  _handleTouchMovePan(event) {
    if (this._pointers.length === 1) {
      this._panEnd.set(event.pageX, event.pageY);
    } else {
      const position = this._getSecondPointerPosition(event);
      const x = 0.5 * (event.pageX + position.x);
      const y = 0.5 * (event.pageY + position.y);
      this._panEnd.set(x, y);
    }
    this._panDelta.subVectors(this._panEnd, this._panStart).multiplyScalar(this.panSpeed);
    this._pan(this._panDelta.x, this._panDelta.y);
    this._panStart.copy(this._panEnd);
  }
  _handleTouchMoveDolly(event) {
    const position = this._getSecondPointerPosition(event);
    const dx = event.pageX - position.x;
    const dy = event.pageY - position.y;
    const distance2 = Math.sqrt(dx * dx + dy * dy);
    this._dollyEnd.set(0, distance2);
    this._dollyDelta.set(0, Math.pow(this._dollyEnd.y / this._dollyStart.y, this.zoomSpeed));
    this._dollyOut(this._dollyDelta.y);
    this._dollyStart.copy(this._dollyEnd);
    const centerX = (event.pageX + position.x) * 0.5;
    const centerY = (event.pageY + position.y) * 0.5;
    this._updateZoomParameters(centerX, centerY);
  }
  _handleTouchMoveDollyPan(event) {
    if (this.enableZoom) this._handleTouchMoveDolly(event);
    if (this.enablePan) this._handleTouchMovePan(event);
  }
  _handleTouchMoveDollyRotate(event) {
    if (this.enableZoom) this._handleTouchMoveDolly(event);
    if (this.enableRotate) this._handleTouchMoveRotate(event);
  }
  // pointers
  _addPointer(event) {
    this._pointers.push(event.pointerId);
  }
  _removePointer(event) {
    delete this._pointerPositions[event.pointerId];
    for (let i = 0; i < this._pointers.length; i++) {
      if (this._pointers[i] == event.pointerId) {
        this._pointers.splice(i, 1);
        return;
      }
    }
  }
  _isTrackingPointer(event) {
    for (let i = 0; i < this._pointers.length; i++) {
      if (this._pointers[i] == event.pointerId) return true;
    }
    return false;
  }
  _trackPointer(event) {
    let position = this._pointerPositions[event.pointerId];
    if (position === void 0) {
      position = new Vector2$1();
      this._pointerPositions[event.pointerId] = position;
    }
    position.set(event.pageX, event.pageY);
  }
  _getSecondPointerPosition(event) {
    const pointerId = event.pointerId === this._pointers[0] ? this._pointers[1] : this._pointers[0];
    return this._pointerPositions[pointerId];
  }
  //
  _customWheelEvent(event) {
    const mode = event.deltaMode;
    const newEvent = {
      clientX: event.clientX,
      clientY: event.clientY,
      deltaY: event.deltaY
    };
    switch (mode) {
      case 1:
        newEvent.deltaY *= 16;
        break;
      case 2:
        newEvent.deltaY *= 100;
        break;
    }
    if (event.ctrlKey && !this._controlActive) {
      newEvent.deltaY *= 10;
    }
    return newEvent;
  }
}
function onPointerDown(event) {
  if (this.enabled === false) return;
  if (this._pointers.length === 0) {
    this.domElement.setPointerCapture(event.pointerId);
    this.domElement.addEventListener("pointermove", this._onPointerMove);
    this.domElement.addEventListener("pointerup", this._onPointerUp);
  }
  if (this._isTrackingPointer(event)) return;
  this._addPointer(event);
  if (event.pointerType === "touch") {
    this._onTouchStart(event);
  } else {
    this._onMouseDown(event);
  }
}
function onPointerMove(event) {
  if (this.enabled === false) return;
  if (event.pointerType === "touch") {
    this._onTouchMove(event);
  } else {
    this._onMouseMove(event);
  }
}
function onPointerUp(event) {
  this._removePointer(event);
  switch (this._pointers.length) {
    case 0:
      this.domElement.releasePointerCapture(event.pointerId);
      this.domElement.removeEventListener("pointermove", this._onPointerMove);
      this.domElement.removeEventListener("pointerup", this._onPointerUp);
      this.dispatchEvent(_endEvent);
      this.state = _STATE.NONE;
      break;
    case 1:
      const pointerId = this._pointers[0];
      const position = this._pointerPositions[pointerId];
      this._onTouchStart({ pointerId, pageX: position.x, pageY: position.y });
      break;
  }
}
function onMouseDown(event) {
  let mouseAction;
  switch (event.button) {
    case 0:
      mouseAction = this.mouseButtons.LEFT;
      break;
    case 1:
      mouseAction = this.mouseButtons.MIDDLE;
      break;
    case 2:
      mouseAction = this.mouseButtons.RIGHT;
      break;
    default:
      mouseAction = -1;
  }
  switch (mouseAction) {
    case MOUSE.DOLLY:
      if (this.enableZoom === false) return;
      this._handleMouseDownDolly(event);
      this.state = _STATE.DOLLY;
      break;
    case MOUSE.ROTATE:
      if (event.ctrlKey || event.metaKey || event.shiftKey) {
        if (this.enablePan === false) return;
        this._handleMouseDownPan(event);
        this.state = _STATE.PAN;
      } else {
        if (this.enableRotate === false) return;
        this._handleMouseDownRotate(event);
        this.state = _STATE.ROTATE;
      }
      break;
    case MOUSE.PAN:
      if (event.ctrlKey || event.metaKey || event.shiftKey) {
        if (this.enableRotate === false) return;
        this._handleMouseDownRotate(event);
        this.state = _STATE.ROTATE;
      } else {
        if (this.enablePan === false) return;
        this._handleMouseDownPan(event);
        this.state = _STATE.PAN;
      }
      break;
    default:
      this.state = _STATE.NONE;
  }
  if (this.state !== _STATE.NONE) {
    this.dispatchEvent(_startEvent);
  }
}
function onMouseMove(event) {
  switch (this.state) {
    case _STATE.ROTATE:
      if (this.enableRotate === false) return;
      this._handleMouseMoveRotate(event);
      break;
    case _STATE.DOLLY:
      if (this.enableZoom === false) return;
      this._handleMouseMoveDolly(event);
      break;
    case _STATE.PAN:
      if (this.enablePan === false) return;
      this._handleMouseMovePan(event);
      break;
  }
}
function onMouseWheel(event) {
  if (this.enabled === false || this.enableZoom === false || this.state !== _STATE.NONE) return;
  event.preventDefault();
  this.dispatchEvent(_startEvent);
  this._handleMouseWheel(this._customWheelEvent(event));
  this.dispatchEvent(_endEvent);
}
function onKeyDown(event) {
  if (this.enabled === false) return;
  this._handleKeyDown(event);
}
function onTouchStart(event) {
  this._trackPointer(event);
  switch (this._pointers.length) {
    case 1:
      switch (this.touches.ONE) {
        case TOUCH.ROTATE:
          if (this.enableRotate === false) return;
          this._handleTouchStartRotate(event);
          this.state = _STATE.TOUCH_ROTATE;
          break;
        case TOUCH.PAN:
          if (this.enablePan === false) return;
          this._handleTouchStartPan(event);
          this.state = _STATE.TOUCH_PAN;
          break;
        default:
          this.state = _STATE.NONE;
      }
      break;
    case 2:
      switch (this.touches.TWO) {
        case TOUCH.DOLLY_PAN:
          if (this.enableZoom === false && this.enablePan === false) return;
          this._handleTouchStartDollyPan(event);
          this.state = _STATE.TOUCH_DOLLY_PAN;
          break;
        case TOUCH.DOLLY_ROTATE:
          if (this.enableZoom === false && this.enableRotate === false) return;
          this._handleTouchStartDollyRotate(event);
          this.state = _STATE.TOUCH_DOLLY_ROTATE;
          break;
        default:
          this.state = _STATE.NONE;
      }
      break;
    default:
      this.state = _STATE.NONE;
  }
  if (this.state !== _STATE.NONE) {
    this.dispatchEvent(_startEvent);
  }
}
function onTouchMove(event) {
  this._trackPointer(event);
  switch (this.state) {
    case _STATE.TOUCH_ROTATE:
      if (this.enableRotate === false) return;
      this._handleTouchMoveRotate(event);
      this.update();
      break;
    case _STATE.TOUCH_PAN:
      if (this.enablePan === false) return;
      this._handleTouchMovePan(event);
      this.update();
      break;
    case _STATE.TOUCH_DOLLY_PAN:
      if (this.enableZoom === false && this.enablePan === false) return;
      this._handleTouchMoveDollyPan(event);
      this.update();
      break;
    case _STATE.TOUCH_DOLLY_ROTATE:
      if (this.enableZoom === false && this.enableRotate === false) return;
      this._handleTouchMoveDollyRotate(event);
      this.update();
      break;
    default:
      this.state = _STATE.NONE;
  }
}
function onContextMenu(event) {
  if (this.enabled === false) return;
  event.preventDefault();
}
function interceptControlDown(event) {
  if (event.key === "Control") {
    this._controlActive = true;
    const document2 = this.domElement.getRootNode();
    document2.addEventListener("keyup", this._interceptControlUp, { passive: true, capture: true });
  }
}
function interceptControlUp(event) {
  if (event.key === "Control") {
    this._controlActive = false;
    const document2 = this.domElement.getRootNode();
    document2.removeEventListener("keyup", this._interceptControlUp, { passive: true, capture: true });
  }
}
class MapControls extends OrbitControls {
  constructor(object, domElement) {
    super(object, domElement);
    this.screenSpacePanning = false;
    this.mouseButtons = { LEFT: MOUSE.PAN, MIDDLE: MOUSE.DOLLY, RIGHT: MOUSE.ROTATE };
    this.touches = { ONE: TOUCH.PAN, TWO: TOUCH.DOLLY_ROTATE };
  }
}
const NodeShaderStage = {
  VERTEX: "vertex"
};
const NodeUpdateType = {
  NONE: "none",
  FRAME: "frame",
  RENDER: "render",
  OBJECT: "object"
};
const vectorComponents = ["x", "y", "z", "w"];
const _lut = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
let _seed = 1234567;
const DEG2RAD = Math.PI / 180;
const RAD2DEG = 180 / Math.PI;
function generateUUID() {
  const d0 = Math.random() * 4294967295 | 0;
  const d1 = Math.random() * 4294967295 | 0;
  const d2 = Math.random() * 4294967295 | 0;
  const d3 = Math.random() * 4294967295 | 0;
  const uuid = _lut[d0 & 255] + _lut[d0 >> 8 & 255] + _lut[d0 >> 16 & 255] + _lut[d0 >> 24 & 255] + "-" + _lut[d1 & 255] + _lut[d1 >> 8 & 255] + "-" + _lut[d1 >> 16 & 15 | 64] + _lut[d1 >> 24 & 255] + "-" + _lut[d2 & 63 | 128] + _lut[d2 >> 8 & 255] + "-" + _lut[d2 >> 16 & 255] + _lut[d2 >> 24 & 255] + _lut[d3 & 255] + _lut[d3 >> 8 & 255] + _lut[d3 >> 16 & 255] + _lut[d3 >> 24 & 255];
  return uuid.toLowerCase();
}
function clamp$1(value, min2, max2) {
  return Math.max(min2, Math.min(max2, value));
}
function euclideanModulo(n, m) {
  return (n % m + m) % m;
}
function mapLinear(x, a1, a2, b1, b2) {
  return b1 + (x - a1) * (b2 - b1) / (a2 - a1);
}
function inverseLerp(x, y, value) {
  if (x !== y) {
    return (value - x) / (y - x);
  } else {
    return 0;
  }
}
function lerp(x, y, t) {
  return (1 - t) * x + t * y;
}
function damp(x, y, lambda, dt) {
  return lerp(x, y, 1 - Math.exp(-lambda * dt));
}
function pingpong(x, length2 = 1) {
  return length2 - Math.abs(euclideanModulo(x, length2 * 2) - length2);
}
function smoothstep$1(x, min2, max2) {
  if (x <= min2) return 0;
  if (x >= max2) return 1;
  x = (x - min2) / (max2 - min2);
  return x * x * (3 - 2 * x);
}
function smootherstep(x, min2, max2) {
  if (x <= min2) return 0;
  if (x >= max2) return 1;
  x = (x - min2) / (max2 - min2);
  return x * x * x * (x * (x * 6 - 15) + 10);
}
function randInt(low, high) {
  return low + Math.floor(Math.random() * (high - low + 1));
}
function randFloat(low, high) {
  return low + Math.random() * (high - low);
}
function randFloatSpread(range) {
  return range * (0.5 - Math.random());
}
function seededRandom(s) {
  if (s !== void 0) _seed = s;
  let t = _seed += 1831565813;
  t = Math.imul(t ^ t >>> 15, t | 1);
  t ^= t + Math.imul(t ^ t >>> 7, t | 61);
  return ((t ^ t >>> 14) >>> 0) / 4294967296;
}
function degToRad(degrees2) {
  return degrees2 * DEG2RAD;
}
function radToDeg(radians2) {
  return radians2 * RAD2DEG;
}
function isPowerOfTwo(value) {
  return (value & value - 1) === 0 && value !== 0;
}
function ceilPowerOfTwo(value) {
  return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));
}
function floorPowerOfTwo(value) {
  return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));
}
function setQuaternionFromProperEuler(q, a, b, c, order) {
  const cos2 = Math.cos;
  const sin2 = Math.sin;
  const c2 = cos2(b / 2);
  const s2 = sin2(b / 2);
  const c13 = cos2((a + c) / 2);
  const s13 = sin2((a + c) / 2);
  const c1_3 = cos2((a - c) / 2);
  const s1_3 = sin2((a - c) / 2);
  const c3_1 = cos2((c - a) / 2);
  const s3_1 = sin2((c - a) / 2);
  switch (order) {
    case "XYX":
      q.set(c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13);
      break;
    case "YZY":
      q.set(s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13);
      break;
    case "ZXZ":
      q.set(s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13);
      break;
    case "XZX":
      q.set(c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13);
      break;
    case "YXY":
      q.set(s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13);
      break;
    case "ZYZ":
      q.set(s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13);
      break;
    default:
      console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + order);
  }
}
function denormalize(value, array) {
  switch (array.constructor) {
    case Float32Array:
      return value;
    case Uint32Array:
      return value / 4294967295;
    case Uint16Array:
      return value / 65535;
    case Uint8Array:
      return value / 255;
    case Int32Array:
      return Math.max(value / 2147483647, -1);
    case Int16Array:
      return Math.max(value / 32767, -1);
    case Int8Array:
      return Math.max(value / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
}
function normalize$1(value, array) {
  switch (array.constructor) {
    case Float32Array:
      return value;
    case Uint32Array:
      return Math.round(value * 4294967295);
    case Uint16Array:
      return Math.round(value * 65535);
    case Uint8Array:
      return Math.round(value * 255);
    case Int32Array:
      return Math.round(value * 2147483647);
    case Int16Array:
      return Math.round(value * 32767);
    case Int8Array:
      return Math.round(value * 127);
    default:
      throw new Error("Invalid component type.");
  }
}
const MathUtils = {
  DEG2RAD,
  RAD2DEG,
  generateUUID,
  clamp: clamp$1,
  euclideanModulo,
  mapLinear,
  inverseLerp,
  lerp,
  damp,
  pingpong,
  smoothstep: smoothstep$1,
  smootherstep,
  randInt,
  randFloat,
  randFloatSpread,
  seededRandom,
  degToRad,
  radToDeg,
  isPowerOfTwo,
  ceilPowerOfTwo,
  floorPowerOfTwo,
  setQuaternionFromProperEuler,
  normalize: normalize$1,
  denormalize
};
const NoToneMapping = 0;
const FloatType = 1015;
const NoColorSpace = "";
const SRGBColorSpace = "srgb";
const LinearSRGBColorSpace = "srgb-linear";
const LinearTransfer = "linear";
const SRGBTransfer = "srgb";
const StaticDrawUsage = 35044;
const WebGLCoordinateSystem = 2e3;
const WebGPUCoordinateSystem = 2001;
class Matrix32 {
  constructor(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
    Matrix32.prototype.isMatrix3 = true;
    this.elements = [
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ];
    if (n11 !== void 0) {
      this.set(n11, n12, n13, n21, n22, n23, n31, n32, n33);
    }
  }
  set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
    const te = this.elements;
    te[0] = n11;
    te[1] = n21;
    te[2] = n31;
    te[3] = n12;
    te[4] = n22;
    te[5] = n32;
    te[6] = n13;
    te[7] = n23;
    te[8] = n33;
    return this;
  }
  identity() {
    this.set(
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    );
    return this;
  }
  copy(m) {
    const te = this.elements;
    const me = m.elements;
    te[0] = me[0];
    te[1] = me[1];
    te[2] = me[2];
    te[3] = me[3];
    te[4] = me[4];
    te[5] = me[5];
    te[6] = me[6];
    te[7] = me[7];
    te[8] = me[8];
    return this;
  }
  extractBasis(xAxis, yAxis, zAxis) {
    xAxis.setFromMatrix3Column(this, 0);
    yAxis.setFromMatrix3Column(this, 1);
    zAxis.setFromMatrix3Column(this, 2);
    return this;
  }
  setFromMatrix4(m) {
    const me = m.elements;
    this.set(
      me[0],
      me[4],
      me[8],
      me[1],
      me[5],
      me[9],
      me[2],
      me[6],
      me[10]
    );
    return this;
  }
  multiply(m) {
    return this.multiplyMatrices(this, m);
  }
  premultiply(m) {
    return this.multiplyMatrices(m, this);
  }
  multiplyMatrices(a, b) {
    const ae = a.elements;
    const be = b.elements;
    const te = this.elements;
    const a11 = ae[0], a12 = ae[3], a13 = ae[6];
    const a21 = ae[1], a22 = ae[4], a23 = ae[7];
    const a31 = ae[2], a32 = ae[5], a33 = ae[8];
    const b11 = be[0], b12 = be[3], b13 = be[6];
    const b21 = be[1], b22 = be[4], b23 = be[7];
    const b31 = be[2], b32 = be[5], b33 = be[8];
    te[0] = a11 * b11 + a12 * b21 + a13 * b31;
    te[3] = a11 * b12 + a12 * b22 + a13 * b32;
    te[6] = a11 * b13 + a12 * b23 + a13 * b33;
    te[1] = a21 * b11 + a22 * b21 + a23 * b31;
    te[4] = a21 * b12 + a22 * b22 + a23 * b32;
    te[7] = a21 * b13 + a22 * b23 + a23 * b33;
    te[2] = a31 * b11 + a32 * b21 + a33 * b31;
    te[5] = a31 * b12 + a32 * b22 + a33 * b32;
    te[8] = a31 * b13 + a32 * b23 + a33 * b33;
    return this;
  }
  multiplyScalar(s) {
    const te = this.elements;
    te[0] *= s;
    te[3] *= s;
    te[6] *= s;
    te[1] *= s;
    te[4] *= s;
    te[7] *= s;
    te[2] *= s;
    te[5] *= s;
    te[8] *= s;
    return this;
  }
  determinant() {
    const te = this.elements;
    const a = te[0], b = te[1], c = te[2], d = te[3], e = te[4], f = te[5], g = te[6], h = te[7], i = te[8];
    return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;
  }
  invert() {
    const te = this.elements, n11 = te[0], n21 = te[1], n31 = te[2], n12 = te[3], n22 = te[4], n32 = te[5], n13 = te[6], n23 = te[7], n33 = te[8], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13, det = n11 * t11 + n21 * t12 + n31 * t13;
    if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const detInv = 1 / det;
    te[0] = t11 * detInv;
    te[1] = (n31 * n23 - n33 * n21) * detInv;
    te[2] = (n32 * n21 - n31 * n22) * detInv;
    te[3] = t12 * detInv;
    te[4] = (n33 * n11 - n31 * n13) * detInv;
    te[5] = (n31 * n12 - n32 * n11) * detInv;
    te[6] = t13 * detInv;
    te[7] = (n21 * n13 - n23 * n11) * detInv;
    te[8] = (n22 * n11 - n21 * n12) * detInv;
    return this;
  }
  transpose() {
    let tmp2;
    const m = this.elements;
    tmp2 = m[1];
    m[1] = m[3];
    m[3] = tmp2;
    tmp2 = m[2];
    m[2] = m[6];
    m[6] = tmp2;
    tmp2 = m[5];
    m[5] = m[7];
    m[7] = tmp2;
    return this;
  }
  getNormalMatrix(matrix4) {
    return this.setFromMatrix4(matrix4).invert().transpose();
  }
  transposeIntoArray(r) {
    const m = this.elements;
    r[0] = m[0];
    r[1] = m[3];
    r[2] = m[6];
    r[3] = m[1];
    r[4] = m[4];
    r[5] = m[7];
    r[6] = m[2];
    r[7] = m[5];
    r[8] = m[8];
    return this;
  }
  setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {
    const c = Math.cos(rotation);
    const s = Math.sin(rotation);
    this.set(
      sx * c,
      sx * s,
      -sx * (c * cx + s * cy) + cx + tx,
      -sy * s,
      sy * c,
      -sy * (-s * cx + c * cy) + cy + ty,
      0,
      0,
      1
    );
    return this;
  }
  //
  scale(sx, sy) {
    this.premultiply(_m3.makeScale(sx, sy));
    return this;
  }
  rotate(theta) {
    this.premultiply(_m3.makeRotation(-theta));
    return this;
  }
  translate(tx, ty) {
    this.premultiply(_m3.makeTranslation(tx, ty));
    return this;
  }
  // for 2D Transforms
  makeTranslation(x, y) {
    if (x.isVector2) {
      this.set(
        1,
        0,
        x.x,
        0,
        1,
        x.y,
        0,
        0,
        1
      );
    } else {
      this.set(
        1,
        0,
        x,
        0,
        1,
        y,
        0,
        0,
        1
      );
    }
    return this;
  }
  makeRotation(theta) {
    const c = Math.cos(theta);
    const s = Math.sin(theta);
    this.set(
      c,
      -s,
      0,
      s,
      c,
      0,
      0,
      0,
      1
    );
    return this;
  }
  makeScale(x, y) {
    this.set(
      x,
      0,
      0,
      0,
      y,
      0,
      0,
      0,
      1
    );
    return this;
  }
  //
  equals(matrix) {
    const te = this.elements;
    const me = matrix.elements;
    for (let i = 0; i < 9; i++) {
      if (te[i] !== me[i]) return false;
    }
    return true;
  }
  fromArray(array, offset = 0) {
    for (let i = 0; i < 9; i++) {
      this.elements[i] = array[i + offset];
    }
    return this;
  }
  toArray(array = [], offset = 0) {
    const te = this.elements;
    array[offset] = te[0];
    array[offset + 1] = te[1];
    array[offset + 2] = te[2];
    array[offset + 3] = te[3];
    array[offset + 4] = te[4];
    array[offset + 5] = te[5];
    array[offset + 6] = te[6];
    array[offset + 7] = te[7];
    array[offset + 8] = te[8];
    return array;
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
const _m3 = /* @__PURE__ */ new Matrix32();
const LINEAR_REC709_TO_XYZ = /* @__PURE__ */ new Matrix32().set(
  0.4123908,
  0.3575843,
  0.1804808,
  0.212639,
  0.7151687,
  0.0721923,
  0.0193308,
  0.1191948,
  0.9505322
);
const XYZ_TO_LINEAR_REC709 = /* @__PURE__ */ new Matrix32().set(
  3.2409699,
  -1.5373832,
  -0.4986108,
  -0.9692436,
  1.8759675,
  0.0415551,
  0.0556301,
  -0.203977,
  1.0569715
);
function createColorManagement() {
  const ColorManagement2 = {
    enabled: true,
    workingColorSpace: LinearSRGBColorSpace,
    /**
     * Implementations of supported color spaces.
     *
     * Required:
     *	- primaries: chromaticity coordinates [ rx ry gx gy bx by ]
     *	- whitePoint: reference white [ x y ]
     *	- transfer: transfer function (pre-defined)
     *	- toXYZ: Matrix3 RGB to XYZ transform
     *	- fromXYZ: Matrix3 XYZ to RGB transform
     *	- luminanceCoefficients: RGB luminance coefficients
     *
     * Optional:
     *  - outputColorSpaceConfig: { drawingBufferColorSpace: ColorSpace }
     *  - workingColorSpaceConfig: { unpackColorSpace: ColorSpace }
     *
     * Reference:
     * - https://www.russellcottrell.com/photo/matrixCalculator.htm
     */
    spaces: {},
    convert: function(color2, sourceColorSpace, targetColorSpace) {
      if (this.enabled === false || sourceColorSpace === targetColorSpace || !sourceColorSpace || !targetColorSpace) {
        return color2;
      }
      if (this.spaces[sourceColorSpace].transfer === SRGBTransfer) {
        color2.r = SRGBToLinear(color2.r);
        color2.g = SRGBToLinear(color2.g);
        color2.b = SRGBToLinear(color2.b);
      }
      if (this.spaces[sourceColorSpace].primaries !== this.spaces[targetColorSpace].primaries) {
        color2.applyMatrix3(this.spaces[sourceColorSpace].toXYZ);
        color2.applyMatrix3(this.spaces[targetColorSpace].fromXYZ);
      }
      if (this.spaces[targetColorSpace].transfer === SRGBTransfer) {
        color2.r = LinearToSRGB(color2.r);
        color2.g = LinearToSRGB(color2.g);
        color2.b = LinearToSRGB(color2.b);
      }
      return color2;
    },
    fromWorkingColorSpace: function(color2, targetColorSpace) {
      return this.convert(color2, this.workingColorSpace, targetColorSpace);
    },
    toWorkingColorSpace: function(color2, sourceColorSpace) {
      return this.convert(color2, sourceColorSpace, this.workingColorSpace);
    },
    getPrimaries: function(colorSpace) {
      return this.spaces[colorSpace].primaries;
    },
    getTransfer: function(colorSpace) {
      if (colorSpace === NoColorSpace) return LinearTransfer;
      return this.spaces[colorSpace].transfer;
    },
    getLuminanceCoefficients: function(target, colorSpace = this.workingColorSpace) {
      return target.fromArray(this.spaces[colorSpace].luminanceCoefficients);
    },
    define: function(colorSpaces) {
      Object.assign(this.spaces, colorSpaces);
    },
    // Internal APIs
    _getMatrix: function(targetMatrix, sourceColorSpace, targetColorSpace) {
      return targetMatrix.copy(this.spaces[sourceColorSpace].toXYZ).multiply(this.spaces[targetColorSpace].fromXYZ);
    },
    _getDrawingBufferColorSpace: function(colorSpace) {
      return this.spaces[colorSpace].outputColorSpaceConfig.drawingBufferColorSpace;
    },
    _getUnpackColorSpace: function(colorSpace = this.workingColorSpace) {
      return this.spaces[colorSpace].workingColorSpaceConfig.unpackColorSpace;
    }
  };
  const REC709_PRIMARIES = [0.64, 0.33, 0.3, 0.6, 0.15, 0.06];
  const REC709_LUMINANCE_COEFFICIENTS = [0.2126, 0.7152, 0.0722];
  const D65 = [0.3127, 0.329];
  ColorManagement2.define({
    [LinearSRGBColorSpace]: {
      primaries: REC709_PRIMARIES,
      whitePoint: D65,
      transfer: LinearTransfer,
      toXYZ: LINEAR_REC709_TO_XYZ,
      fromXYZ: XYZ_TO_LINEAR_REC709,
      luminanceCoefficients: REC709_LUMINANCE_COEFFICIENTS,
      workingColorSpaceConfig: { unpackColorSpace: SRGBColorSpace },
      outputColorSpaceConfig: { drawingBufferColorSpace: SRGBColorSpace }
    },
    [SRGBColorSpace]: {
      primaries: REC709_PRIMARIES,
      whitePoint: D65,
      transfer: SRGBTransfer,
      toXYZ: LINEAR_REC709_TO_XYZ,
      fromXYZ: XYZ_TO_LINEAR_REC709,
      luminanceCoefficients: REC709_LUMINANCE_COEFFICIENTS,
      outputColorSpaceConfig: { drawingBufferColorSpace: SRGBColorSpace }
    }
  });
  return ColorManagement2;
}
const ColorManagement = /* @__PURE__ */ createColorManagement();
function SRGBToLinear(c) {
  return c < 0.04045 ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);
}
function LinearToSRGB(c) {
  return c < 31308e-7 ? c * 12.92 : 1.055 * Math.pow(c, 0.41666) - 0.055;
}
const _colorKeywords = {
  "aliceblue": 15792383,
  "antiquewhite": 16444375,
  "aqua": 65535,
  "aquamarine": 8388564,
  "azure": 15794175,
  "beige": 16119260,
  "bisque": 16770244,
  "black": 0,
  "blanchedalmond": 16772045,
  "blue": 255,
  "blueviolet": 9055202,
  "brown": 10824234,
  "burlywood": 14596231,
  "cadetblue": 6266528,
  "chartreuse": 8388352,
  "chocolate": 13789470,
  "coral": 16744272,
  "cornflowerblue": 6591981,
  "cornsilk": 16775388,
  "crimson": 14423100,
  "cyan": 65535,
  "darkblue": 139,
  "darkcyan": 35723,
  "darkgoldenrod": 12092939,
  "darkgray": 11119017,
  "darkgreen": 25600,
  "darkgrey": 11119017,
  "darkkhaki": 12433259,
  "darkmagenta": 9109643,
  "darkolivegreen": 5597999,
  "darkorange": 16747520,
  "darkorchid": 10040012,
  "darkred": 9109504,
  "darksalmon": 15308410,
  "darkseagreen": 9419919,
  "darkslateblue": 4734347,
  "darkslategray": 3100495,
  "darkslategrey": 3100495,
  "darkturquoise": 52945,
  "darkviolet": 9699539,
  "deeppink": 16716947,
  "deepskyblue": 49151,
  "dimgray": 6908265,
  "dimgrey": 6908265,
  "dodgerblue": 2003199,
  "firebrick": 11674146,
  "floralwhite": 16775920,
  "forestgreen": 2263842,
  "fuchsia": 16711935,
  "gainsboro": 14474460,
  "ghostwhite": 16316671,
  "gold": 16766720,
  "goldenrod": 14329120,
  "gray": 8421504,
  "green": 32768,
  "greenyellow": 11403055,
  "grey": 8421504,
  "honeydew": 15794160,
  "hotpink": 16738740,
  "indianred": 13458524,
  "indigo": 4915330,
  "ivory": 16777200,
  "khaki": 15787660,
  "lavender": 15132410,
  "lavenderblush": 16773365,
  "lawngreen": 8190976,
  "lemonchiffon": 16775885,
  "lightblue": 11393254,
  "lightcoral": 15761536,
  "lightcyan": 14745599,
  "lightgoldenrodyellow": 16448210,
  "lightgray": 13882323,
  "lightgreen": 9498256,
  "lightgrey": 13882323,
  "lightpink": 16758465,
  "lightsalmon": 16752762,
  "lightseagreen": 2142890,
  "lightskyblue": 8900346,
  "lightslategray": 7833753,
  "lightslategrey": 7833753,
  "lightsteelblue": 11584734,
  "lightyellow": 16777184,
  "lime": 65280,
  "limegreen": 3329330,
  "linen": 16445670,
  "magenta": 16711935,
  "maroon": 8388608,
  "mediumaquamarine": 6737322,
  "mediumblue": 205,
  "mediumorchid": 12211667,
  "mediumpurple": 9662683,
  "mediumseagreen": 3978097,
  "mediumslateblue": 8087790,
  "mediumspringgreen": 64154,
  "mediumturquoise": 4772300,
  "mediumvioletred": 13047173,
  "midnightblue": 1644912,
  "mintcream": 16121850,
  "mistyrose": 16770273,
  "moccasin": 16770229,
  "navajowhite": 16768685,
  "navy": 128,
  "oldlace": 16643558,
  "olive": 8421376,
  "olivedrab": 7048739,
  "orange": 16753920,
  "orangered": 16729344,
  "orchid": 14315734,
  "palegoldenrod": 15657130,
  "palegreen": 10025880,
  "paleturquoise": 11529966,
  "palevioletred": 14381203,
  "papayawhip": 16773077,
  "peachpuff": 16767673,
  "peru": 13468991,
  "pink": 16761035,
  "plum": 14524637,
  "powderblue": 11591910,
  "purple": 8388736,
  "rebeccapurple": 6697881,
  "red": 16711680,
  "rosybrown": 12357519,
  "royalblue": 4286945,
  "saddlebrown": 9127187,
  "salmon": 16416882,
  "sandybrown": 16032864,
  "seagreen": 3050327,
  "seashell": 16774638,
  "sienna": 10506797,
  "silver": 12632256,
  "skyblue": 8900331,
  "slateblue": 6970061,
  "slategray": 7372944,
  "slategrey": 7372944,
  "snow": 16775930,
  "springgreen": 65407,
  "steelblue": 4620980,
  "tan": 13808780,
  "teal": 32896,
  "thistle": 14204888,
  "tomato": 16737095,
  "turquoise": 4251856,
  "violet": 15631086,
  "wheat": 16113331,
  "white": 16777215,
  "whitesmoke": 16119285,
  "yellow": 16776960,
  "yellowgreen": 10145074
};
const _hslA = { h: 0, s: 0, l: 0 };
const _hslB = { h: 0, s: 0, l: 0 };
function hue2rgb(p, q, t) {
  if (t < 0) t += 1;
  if (t > 1) t -= 1;
  if (t < 1 / 6) return p + (q - p) * 6 * t;
  if (t < 1 / 2) return q;
  if (t < 2 / 3) return p + (q - p) * 6 * (2 / 3 - t);
  return p;
}
class Color2 {
  constructor(r, g, b) {
    this.isColor = true;
    this.r = 1;
    this.g = 1;
    this.b = 1;
    return this.set(r, g, b);
  }
  set(r, g, b) {
    if (g === void 0 && b === void 0) {
      const value = r;
      if (value && value.isColor) {
        this.copy(value);
      } else if (typeof value === "number") {
        this.setHex(value);
      } else if (typeof value === "string") {
        this.setStyle(value);
      }
    } else {
      this.setRGB(r, g, b);
    }
    return this;
  }
  setScalar(scalar) {
    this.r = scalar;
    this.g = scalar;
    this.b = scalar;
    return this;
  }
  setHex(hex, colorSpace = SRGBColorSpace) {
    hex = Math.floor(hex);
    this.r = (hex >> 16 & 255) / 255;
    this.g = (hex >> 8 & 255) / 255;
    this.b = (hex & 255) / 255;
    ColorManagement.toWorkingColorSpace(this, colorSpace);
    return this;
  }
  setRGB(r, g, b, colorSpace = ColorManagement.workingColorSpace) {
    this.r = r;
    this.g = g;
    this.b = b;
    ColorManagement.toWorkingColorSpace(this, colorSpace);
    return this;
  }
  setHSL(h, s, l, colorSpace = ColorManagement.workingColorSpace) {
    h = euclideanModulo(h, 1);
    s = clamp$1(s, 0, 1);
    l = clamp$1(l, 0, 1);
    if (s === 0) {
      this.r = this.g = this.b = l;
    } else {
      const p = l <= 0.5 ? l * (1 + s) : l + s - l * s;
      const q = 2 * l - p;
      this.r = hue2rgb(q, p, h + 1 / 3);
      this.g = hue2rgb(q, p, h);
      this.b = hue2rgb(q, p, h - 1 / 3);
    }
    ColorManagement.toWorkingColorSpace(this, colorSpace);
    return this;
  }
  setStyle(style, colorSpace = SRGBColorSpace) {
    function handleAlpha(string) {
      if (string === void 0) return;
      if (parseFloat(string) < 1) {
        console.warn("THREE.Color: Alpha component of " + style + " will be ignored.");
      }
    }
    let m;
    if (m = /^(\w+)\(([^\)]*)\)/.exec(style)) {
      let color2;
      const name = m[1];
      const components = m[2];
      switch (name) {
        case "rgb":
        case "rgba":
          if (color2 = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
            handleAlpha(color2[4]);
            return this.setRGB(
              Math.min(255, parseInt(color2[1], 10)) / 255,
              Math.min(255, parseInt(color2[2], 10)) / 255,
              Math.min(255, parseInt(color2[3], 10)) / 255,
              colorSpace
            );
          }
          if (color2 = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
            handleAlpha(color2[4]);
            return this.setRGB(
              Math.min(100, parseInt(color2[1], 10)) / 100,
              Math.min(100, parseInt(color2[2], 10)) / 100,
              Math.min(100, parseInt(color2[3], 10)) / 100,
              colorSpace
            );
          }
          break;
        case "hsl":
        case "hsla":
          if (color2 = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
            handleAlpha(color2[4]);
            return this.setHSL(
              parseFloat(color2[1]) / 360,
              parseFloat(color2[2]) / 100,
              parseFloat(color2[3]) / 100,
              colorSpace
            );
          }
          break;
        default:
          console.warn("THREE.Color: Unknown color model " + style);
      }
    } else if (m = /^\#([A-Fa-f\d]+)$/.exec(style)) {
      const hex = m[1];
      const size = hex.length;
      if (size === 3) {
        return this.setRGB(
          parseInt(hex.charAt(0), 16) / 15,
          parseInt(hex.charAt(1), 16) / 15,
          parseInt(hex.charAt(2), 16) / 15,
          colorSpace
        );
      } else if (size === 6) {
        return this.setHex(parseInt(hex, 16), colorSpace);
      } else {
        console.warn("THREE.Color: Invalid hex color " + style);
      }
    } else if (style && style.length > 0) {
      return this.setColorName(style, colorSpace);
    }
    return this;
  }
  setColorName(style, colorSpace = SRGBColorSpace) {
    const hex = _colorKeywords[style.toLowerCase()];
    if (hex !== void 0) {
      this.setHex(hex, colorSpace);
    } else {
      console.warn("THREE.Color: Unknown color " + style);
    }
    return this;
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(color2) {
    this.r = color2.r;
    this.g = color2.g;
    this.b = color2.b;
    return this;
  }
  copySRGBToLinear(color2) {
    this.r = SRGBToLinear(color2.r);
    this.g = SRGBToLinear(color2.g);
    this.b = SRGBToLinear(color2.b);
    return this;
  }
  copyLinearToSRGB(color2) {
    this.r = LinearToSRGB(color2.r);
    this.g = LinearToSRGB(color2.g);
    this.b = LinearToSRGB(color2.b);
    return this;
  }
  convertSRGBToLinear() {
    this.copySRGBToLinear(this);
    return this;
  }
  convertLinearToSRGB() {
    this.copyLinearToSRGB(this);
    return this;
  }
  getHex(colorSpace = SRGBColorSpace) {
    ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);
    return Math.round(clamp$1(_color.r * 255, 0, 255)) * 65536 + Math.round(clamp$1(_color.g * 255, 0, 255)) * 256 + Math.round(clamp$1(_color.b * 255, 0, 255));
  }
  getHexString(colorSpace = SRGBColorSpace) {
    return ("000000" + this.getHex(colorSpace).toString(16)).slice(-6);
  }
  getHSL(target, colorSpace = ColorManagement.workingColorSpace) {
    ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);
    const r = _color.r, g = _color.g, b = _color.b;
    const max2 = Math.max(r, g, b);
    const min2 = Math.min(r, g, b);
    let hue, saturation;
    const lightness = (min2 + max2) / 2;
    if (min2 === max2) {
      hue = 0;
      saturation = 0;
    } else {
      const delta = max2 - min2;
      saturation = lightness <= 0.5 ? delta / (max2 + min2) : delta / (2 - max2 - min2);
      switch (max2) {
        case r:
          hue = (g - b) / delta + (g < b ? 6 : 0);
          break;
        case g:
          hue = (b - r) / delta + 2;
          break;
        case b:
          hue = (r - g) / delta + 4;
          break;
      }
      hue /= 6;
    }
    target.h = hue;
    target.s = saturation;
    target.l = lightness;
    return target;
  }
  getRGB(target, colorSpace = ColorManagement.workingColorSpace) {
    ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);
    target.r = _color.r;
    target.g = _color.g;
    target.b = _color.b;
    return target;
  }
  getStyle(colorSpace = SRGBColorSpace) {
    ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);
    const r = _color.r, g = _color.g, b = _color.b;
    if (colorSpace !== SRGBColorSpace) {
      return `color(${colorSpace} ${r.toFixed(3)} ${g.toFixed(3)} ${b.toFixed(3)})`;
    }
    return `rgb(${Math.round(r * 255)},${Math.round(g * 255)},${Math.round(b * 255)})`;
  }
  offsetHSL(h, s, l) {
    this.getHSL(_hslA);
    return this.setHSL(_hslA.h + h, _hslA.s + s, _hslA.l + l);
  }
  add(color2) {
    this.r += color2.r;
    this.g += color2.g;
    this.b += color2.b;
    return this;
  }
  addColors(color1, color2) {
    this.r = color1.r + color2.r;
    this.g = color1.g + color2.g;
    this.b = color1.b + color2.b;
    return this;
  }
  addScalar(s) {
    this.r += s;
    this.g += s;
    this.b += s;
    return this;
  }
  sub(color2) {
    this.r = Math.max(0, this.r - color2.r);
    this.g = Math.max(0, this.g - color2.g);
    this.b = Math.max(0, this.b - color2.b);
    return this;
  }
  multiply(color2) {
    this.r *= color2.r;
    this.g *= color2.g;
    this.b *= color2.b;
    return this;
  }
  multiplyScalar(s) {
    this.r *= s;
    this.g *= s;
    this.b *= s;
    return this;
  }
  lerp(color2, alpha) {
    this.r += (color2.r - this.r) * alpha;
    this.g += (color2.g - this.g) * alpha;
    this.b += (color2.b - this.b) * alpha;
    return this;
  }
  lerpColors(color1, color2, alpha) {
    this.r = color1.r + (color2.r - color1.r) * alpha;
    this.g = color1.g + (color2.g - color1.g) * alpha;
    this.b = color1.b + (color2.b - color1.b) * alpha;
    return this;
  }
  lerpHSL(color2, alpha) {
    this.getHSL(_hslA);
    color2.getHSL(_hslB);
    const h = lerp(_hslA.h, _hslB.h, alpha);
    const s = lerp(_hslA.s, _hslB.s, alpha);
    const l = lerp(_hslA.l, _hslB.l, alpha);
    this.setHSL(h, s, l);
    return this;
  }
  setFromVector3(v) {
    this.r = v.x;
    this.g = v.y;
    this.b = v.z;
    return this;
  }
  applyMatrix3(m) {
    const r = this.r, g = this.g, b = this.b;
    const e = m.elements;
    this.r = e[0] * r + e[3] * g + e[6] * b;
    this.g = e[1] * r + e[4] * g + e[7] * b;
    this.b = e[2] * r + e[5] * g + e[8] * b;
    return this;
  }
  equals(c) {
    return c.r === this.r && c.g === this.g && c.b === this.b;
  }
  fromArray(array, offset = 0) {
    this.r = array[offset];
    this.g = array[offset + 1];
    this.b = array[offset + 2];
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this.r;
    array[offset + 1] = this.g;
    array[offset + 2] = this.b;
    return array;
  }
  fromBufferAttribute(attribute, index) {
    this.r = attribute.getX(index);
    this.g = attribute.getY(index);
    this.b = attribute.getZ(index);
    return this;
  }
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    yield this.r;
    yield this.g;
    yield this.b;
  }
}
const _color = /* @__PURE__ */ new Color2();
Color2.NAMES = _colorKeywords;
class Quaternion2 {
  constructor(x = 0, y = 0, z = 0, w = 1) {
    this.isQuaternion = true;
    this._x = x;
    this._y = y;
    this._z = z;
    this._w = w;
  }
  static slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {
    let x0 = src0[srcOffset0 + 0], y0 = src0[srcOffset0 + 1], z0 = src0[srcOffset0 + 2], w0 = src0[srcOffset0 + 3];
    const x1 = src1[srcOffset1 + 0], y1 = src1[srcOffset1 + 1], z1 = src1[srcOffset1 + 2], w1 = src1[srcOffset1 + 3];
    if (t === 0) {
      dst[dstOffset + 0] = x0;
      dst[dstOffset + 1] = y0;
      dst[dstOffset + 2] = z0;
      dst[dstOffset + 3] = w0;
      return;
    }
    if (t === 1) {
      dst[dstOffset + 0] = x1;
      dst[dstOffset + 1] = y1;
      dst[dstOffset + 2] = z1;
      dst[dstOffset + 3] = w1;
      return;
    }
    if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
      let s = 1 - t;
      const cos2 = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1, dir = cos2 >= 0 ? 1 : -1, sqrSin = 1 - cos2 * cos2;
      if (sqrSin > Number.EPSILON) {
        const sin2 = Math.sqrt(sqrSin), len = Math.atan2(sin2, cos2 * dir);
        s = Math.sin(s * len) / sin2;
        t = Math.sin(t * len) / sin2;
      }
      const tDir = t * dir;
      x0 = x0 * s + x1 * tDir;
      y0 = y0 * s + y1 * tDir;
      z0 = z0 * s + z1 * tDir;
      w0 = w0 * s + w1 * tDir;
      if (s === 1 - t) {
        const f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
        x0 *= f;
        y0 *= f;
        z0 *= f;
        w0 *= f;
      }
    }
    dst[dstOffset] = x0;
    dst[dstOffset + 1] = y0;
    dst[dstOffset + 2] = z0;
    dst[dstOffset + 3] = w0;
  }
  static multiplyQuaternionsFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1) {
    const x0 = src0[srcOffset0];
    const y0 = src0[srcOffset0 + 1];
    const z0 = src0[srcOffset0 + 2];
    const w0 = src0[srcOffset0 + 3];
    const x1 = src1[srcOffset1];
    const y1 = src1[srcOffset1 + 1];
    const z1 = src1[srcOffset1 + 2];
    const w1 = src1[srcOffset1 + 3];
    dst[dstOffset] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
    dst[dstOffset + 1] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
    dst[dstOffset + 2] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
    dst[dstOffset + 3] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;
    return dst;
  }
  get x() {
    return this._x;
  }
  set x(value) {
    this._x = value;
    this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(value) {
    this._y = value;
    this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(value) {
    this._z = value;
    this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(value) {
    this._w = value;
    this._onChangeCallback();
  }
  set(x, y, z, w) {
    this._x = x;
    this._y = y;
    this._z = z;
    this._w = w;
    this._onChangeCallback();
    return this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(quaternion) {
    this._x = quaternion.x;
    this._y = quaternion.y;
    this._z = quaternion.z;
    this._w = quaternion.w;
    this._onChangeCallback();
    return this;
  }
  setFromEuler(euler, update = true) {
    const x = euler._x, y = euler._y, z = euler._z, order = euler._order;
    const cos2 = Math.cos;
    const sin2 = Math.sin;
    const c1 = cos2(x / 2);
    const c2 = cos2(y / 2);
    const c3 = cos2(z / 2);
    const s1 = sin2(x / 2);
    const s2 = sin2(y / 2);
    const s3 = sin2(z / 2);
    switch (order) {
      case "XYZ":
        this._x = s1 * c2 * c3 + c1 * s2 * s3;
        this._y = c1 * s2 * c3 - s1 * c2 * s3;
        this._z = c1 * c2 * s3 + s1 * s2 * c3;
        this._w = c1 * c2 * c3 - s1 * s2 * s3;
        break;
      case "YXZ":
        this._x = s1 * c2 * c3 + c1 * s2 * s3;
        this._y = c1 * s2 * c3 - s1 * c2 * s3;
        this._z = c1 * c2 * s3 - s1 * s2 * c3;
        this._w = c1 * c2 * c3 + s1 * s2 * s3;
        break;
      case "ZXY":
        this._x = s1 * c2 * c3 - c1 * s2 * s3;
        this._y = c1 * s2 * c3 + s1 * c2 * s3;
        this._z = c1 * c2 * s3 + s1 * s2 * c3;
        this._w = c1 * c2 * c3 - s1 * s2 * s3;
        break;
      case "ZYX":
        this._x = s1 * c2 * c3 - c1 * s2 * s3;
        this._y = c1 * s2 * c3 + s1 * c2 * s3;
        this._z = c1 * c2 * s3 - s1 * s2 * c3;
        this._w = c1 * c2 * c3 + s1 * s2 * s3;
        break;
      case "YZX":
        this._x = s1 * c2 * c3 + c1 * s2 * s3;
        this._y = c1 * s2 * c3 + s1 * c2 * s3;
        this._z = c1 * c2 * s3 - s1 * s2 * c3;
        this._w = c1 * c2 * c3 - s1 * s2 * s3;
        break;
      case "XZY":
        this._x = s1 * c2 * c3 - c1 * s2 * s3;
        this._y = c1 * s2 * c3 - s1 * c2 * s3;
        this._z = c1 * c2 * s3 + s1 * s2 * c3;
        this._w = c1 * c2 * c3 + s1 * s2 * s3;
        break;
      default:
        console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + order);
    }
    if (update === true) this._onChangeCallback();
    return this;
  }
  setFromAxisAngle(axis, angle) {
    const halfAngle = angle / 2, s = Math.sin(halfAngle);
    this._x = axis.x * s;
    this._y = axis.y * s;
    this._z = axis.z * s;
    this._w = Math.cos(halfAngle);
    this._onChangeCallback();
    return this;
  }
  setFromRotationMatrix(m) {
    const te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10], trace = m11 + m22 + m33;
    if (trace > 0) {
      const s = 0.5 / Math.sqrt(trace + 1);
      this._w = 0.25 / s;
      this._x = (m32 - m23) * s;
      this._y = (m13 - m31) * s;
      this._z = (m21 - m12) * s;
    } else if (m11 > m22 && m11 > m33) {
      const s = 2 * Math.sqrt(1 + m11 - m22 - m33);
      this._w = (m32 - m23) / s;
      this._x = 0.25 * s;
      this._y = (m12 + m21) / s;
      this._z = (m13 + m31) / s;
    } else if (m22 > m33) {
      const s = 2 * Math.sqrt(1 + m22 - m11 - m33);
      this._w = (m13 - m31) / s;
      this._x = (m12 + m21) / s;
      this._y = 0.25 * s;
      this._z = (m23 + m32) / s;
    } else {
      const s = 2 * Math.sqrt(1 + m33 - m11 - m22);
      this._w = (m21 - m12) / s;
      this._x = (m13 + m31) / s;
      this._y = (m23 + m32) / s;
      this._z = 0.25 * s;
    }
    this._onChangeCallback();
    return this;
  }
  setFromUnitVectors(vFrom, vTo) {
    let r = vFrom.dot(vTo) + 1;
    if (r < Number.EPSILON) {
      r = 0;
      if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
        this._x = -vFrom.y;
        this._y = vFrom.x;
        this._z = 0;
        this._w = r;
      } else {
        this._x = 0;
        this._y = -vFrom.z;
        this._z = vFrom.y;
        this._w = r;
      }
    } else {
      this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
      this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
      this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
      this._w = r;
    }
    return this.normalize();
  }
  angleTo(q) {
    return 2 * Math.acos(Math.abs(clamp$1(this.dot(q), -1, 1)));
  }
  rotateTowards(q, step2) {
    const angle = this.angleTo(q);
    if (angle === 0) return this;
    const t = Math.min(1, step2 / angle);
    this.slerp(q, t);
    return this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    this._x *= -1;
    this._y *= -1;
    this._z *= -1;
    this._onChangeCallback();
    return this;
  }
  dot(v) {
    return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
  }
  lengthSq() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  }
  length() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  }
  normalize() {
    let l = this.length();
    if (l === 0) {
      this._x = 0;
      this._y = 0;
      this._z = 0;
      this._w = 1;
    } else {
      l = 1 / l;
      this._x = this._x * l;
      this._y = this._y * l;
      this._z = this._z * l;
      this._w = this._w * l;
    }
    this._onChangeCallback();
    return this;
  }
  multiply(q) {
    return this.multiplyQuaternions(this, q);
  }
  premultiply(q) {
    return this.multiplyQuaternions(q, this);
  }
  multiplyQuaternions(a, b) {
    const qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
    const qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;
    this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
    this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
    this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
    this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
    this._onChangeCallback();
    return this;
  }
  slerp(qb, t) {
    if (t === 0) return this;
    if (t === 1) return this.copy(qb);
    const x = this._x, y = this._y, z = this._z, w = this._w;
    let cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;
    if (cosHalfTheta < 0) {
      this._w = -qb._w;
      this._x = -qb._x;
      this._y = -qb._y;
      this._z = -qb._z;
      cosHalfTheta = -cosHalfTheta;
    } else {
      this.copy(qb);
    }
    if (cosHalfTheta >= 1) {
      this._w = w;
      this._x = x;
      this._y = y;
      this._z = z;
      return this;
    }
    const sqrSinHalfTheta = 1 - cosHalfTheta * cosHalfTheta;
    if (sqrSinHalfTheta <= Number.EPSILON) {
      const s = 1 - t;
      this._w = s * w + t * this._w;
      this._x = s * x + t * this._x;
      this._y = s * y + t * this._y;
      this._z = s * z + t * this._z;
      this.normalize();
      return this;
    }
    const sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
    const halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
    const ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta, ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
    this._w = w * ratioA + this._w * ratioB;
    this._x = x * ratioA + this._x * ratioB;
    this._y = y * ratioA + this._y * ratioB;
    this._z = z * ratioA + this._z * ratioB;
    this._onChangeCallback();
    return this;
  }
  slerpQuaternions(qa, qb, t) {
    return this.copy(qa).slerp(qb, t);
  }
  random() {
    const theta1 = 2 * Math.PI * Math.random();
    const theta2 = 2 * Math.PI * Math.random();
    const x0 = Math.random();
    const r1 = Math.sqrt(1 - x0);
    const r2 = Math.sqrt(x0);
    return this.set(
      r1 * Math.sin(theta1),
      r1 * Math.cos(theta1),
      r2 * Math.sin(theta2),
      r2 * Math.cos(theta2)
    );
  }
  equals(quaternion) {
    return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;
  }
  fromArray(array, offset = 0) {
    this._x = array[offset];
    this._y = array[offset + 1];
    this._z = array[offset + 2];
    this._w = array[offset + 3];
    this._onChangeCallback();
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this._x;
    array[offset + 1] = this._y;
    array[offset + 2] = this._z;
    array[offset + 3] = this._w;
    return array;
  }
  fromBufferAttribute(attribute, index) {
    this._x = attribute.getX(index);
    this._y = attribute.getY(index);
    this._z = attribute.getZ(index);
    this._w = attribute.getW(index);
    this._onChangeCallback();
    return this;
  }
  toJSON() {
    return this.toArray();
  }
  _onChange(callback) {
    this._onChangeCallback = callback;
    return this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x;
    yield this._y;
    yield this._z;
    yield this._w;
  }
}
class Vector32 {
  constructor(x = 0, y = 0, z = 0) {
    Vector32.prototype.isVector3 = true;
    this.x = x;
    this.y = y;
    this.z = z;
  }
  set(x, y, z) {
    if (z === void 0) z = this.z;
    this.x = x;
    this.y = y;
    this.z = z;
    return this;
  }
  setScalar(scalar) {
    this.x = scalar;
    this.y = scalar;
    this.z = scalar;
    return this;
  }
  setX(x) {
    this.x = x;
    return this;
  }
  setY(y) {
    this.y = y;
    return this;
  }
  setZ(z) {
    this.z = z;
    return this;
  }
  setComponent(index, value) {
    switch (index) {
      case 0:
        this.x = value;
        break;
      case 1:
        this.y = value;
        break;
      case 2:
        this.z = value;
        break;
      default:
        throw new Error("index is out of range: " + index);
    }
    return this;
  }
  getComponent(index) {
    switch (index) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + index);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(v) {
    this.x = v.x;
    this.y = v.y;
    this.z = v.z;
    return this;
  }
  add(v) {
    this.x += v.x;
    this.y += v.y;
    this.z += v.z;
    return this;
  }
  addScalar(s) {
    this.x += s;
    this.y += s;
    this.z += s;
    return this;
  }
  addVectors(a, b) {
    this.x = a.x + b.x;
    this.y = a.y + b.y;
    this.z = a.z + b.z;
    return this;
  }
  addScaledVector(v, s) {
    this.x += v.x * s;
    this.y += v.y * s;
    this.z += v.z * s;
    return this;
  }
  sub(v) {
    this.x -= v.x;
    this.y -= v.y;
    this.z -= v.z;
    return this;
  }
  subScalar(s) {
    this.x -= s;
    this.y -= s;
    this.z -= s;
    return this;
  }
  subVectors(a, b) {
    this.x = a.x - b.x;
    this.y = a.y - b.y;
    this.z = a.z - b.z;
    return this;
  }
  multiply(v) {
    this.x *= v.x;
    this.y *= v.y;
    this.z *= v.z;
    return this;
  }
  multiplyScalar(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    this.z *= scalar;
    return this;
  }
  multiplyVectors(a, b) {
    this.x = a.x * b.x;
    this.y = a.y * b.y;
    this.z = a.z * b.z;
    return this;
  }
  applyEuler(euler) {
    return this.applyQuaternion(_quaternion.setFromEuler(euler));
  }
  applyAxisAngle(axis, angle) {
    return this.applyQuaternion(_quaternion.setFromAxisAngle(axis, angle));
  }
  applyMatrix3(m) {
    const x = this.x, y = this.y, z = this.z;
    const e = m.elements;
    this.x = e[0] * x + e[3] * y + e[6] * z;
    this.y = e[1] * x + e[4] * y + e[7] * z;
    this.z = e[2] * x + e[5] * y + e[8] * z;
    return this;
  }
  applyNormalMatrix(m) {
    return this.applyMatrix3(m).normalize();
  }
  applyMatrix4(m) {
    const x = this.x, y = this.y, z = this.z;
    const e = m.elements;
    const w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);
    this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w;
    this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w;
    this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w;
    return this;
  }
  applyQuaternion(q) {
    const vx = this.x, vy = this.y, vz = this.z;
    const qx = q.x, qy = q.y, qz = q.z, qw = q.w;
    const tx = 2 * (qy * vz - qz * vy);
    const ty = 2 * (qz * vx - qx * vz);
    const tz = 2 * (qx * vy - qy * vx);
    this.x = vx + qw * tx + qy * tz - qz * ty;
    this.y = vy + qw * ty + qz * tx - qx * tz;
    this.z = vz + qw * tz + qx * ty - qy * tx;
    return this;
  }
  project(camera) {
    return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);
  }
  unproject(camera) {
    return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);
  }
  transformDirection(m) {
    const x = this.x, y = this.y, z = this.z;
    const e = m.elements;
    this.x = e[0] * x + e[4] * y + e[8] * z;
    this.y = e[1] * x + e[5] * y + e[9] * z;
    this.z = e[2] * x + e[6] * y + e[10] * z;
    return this.normalize();
  }
  divide(v) {
    this.x /= v.x;
    this.y /= v.y;
    this.z /= v.z;
    return this;
  }
  divideScalar(scalar) {
    return this.multiplyScalar(1 / scalar);
  }
  min(v) {
    this.x = Math.min(this.x, v.x);
    this.y = Math.min(this.y, v.y);
    this.z = Math.min(this.z, v.z);
    return this;
  }
  max(v) {
    this.x = Math.max(this.x, v.x);
    this.y = Math.max(this.y, v.y);
    this.z = Math.max(this.z, v.z);
    return this;
  }
  clamp(min2, max2) {
    this.x = clamp$1(this.x, min2.x, max2.x);
    this.y = clamp$1(this.y, min2.y, max2.y);
    this.z = clamp$1(this.z, min2.z, max2.z);
    return this;
  }
  clampScalar(minVal, maxVal) {
    this.x = clamp$1(this.x, minVal, maxVal);
    this.y = clamp$1(this.y, minVal, maxVal);
    this.z = clamp$1(this.z, minVal, maxVal);
    return this;
  }
  clampLength(min2, max2) {
    const length2 = this.length();
    return this.divideScalar(length2 || 1).multiplyScalar(clamp$1(length2, min2, max2));
  }
  floor() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    this.z = Math.floor(this.z);
    return this;
  }
  ceil() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    this.z = Math.ceil(this.z);
    return this;
  }
  round() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    this.z = Math.round(this.z);
    return this;
  }
  roundToZero() {
    this.x = Math.trunc(this.x);
    this.y = Math.trunc(this.y);
    this.z = Math.trunc(this.z);
    return this;
  }
  negate() {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
    return this;
  }
  dot(v) {
    return this.x * v.x + this.y * v.y + this.z * v.z;
  }
  // TODO lengthSquared?
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(length2) {
    return this.normalize().multiplyScalar(length2);
  }
  lerp(v, alpha) {
    this.x += (v.x - this.x) * alpha;
    this.y += (v.y - this.y) * alpha;
    this.z += (v.z - this.z) * alpha;
    return this;
  }
  lerpVectors(v1, v2, alpha) {
    this.x = v1.x + (v2.x - v1.x) * alpha;
    this.y = v1.y + (v2.y - v1.y) * alpha;
    this.z = v1.z + (v2.z - v1.z) * alpha;
    return this;
  }
  cross(v) {
    return this.crossVectors(this, v);
  }
  crossVectors(a, b) {
    const ax = a.x, ay = a.y, az = a.z;
    const bx = b.x, by = b.y, bz = b.z;
    this.x = ay * bz - az * by;
    this.y = az * bx - ax * bz;
    this.z = ax * by - ay * bx;
    return this;
  }
  projectOnVector(v) {
    const denominator = v.lengthSq();
    if (denominator === 0) return this.set(0, 0, 0);
    const scalar = v.dot(this) / denominator;
    return this.copy(v).multiplyScalar(scalar);
  }
  projectOnPlane(planeNormal) {
    _vector$2.copy(this).projectOnVector(planeNormal);
    return this.sub(_vector$2);
  }
  reflect(normal) {
    return this.sub(_vector$2.copy(normal).multiplyScalar(2 * this.dot(normal)));
  }
  angleTo(v) {
    const denominator = Math.sqrt(this.lengthSq() * v.lengthSq());
    if (denominator === 0) return Math.PI / 2;
    const theta = this.dot(v) / denominator;
    return Math.acos(clamp$1(theta, -1, 1));
  }
  distanceTo(v) {
    return Math.sqrt(this.distanceToSquared(v));
  }
  distanceToSquared(v) {
    const dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;
    return dx * dx + dy * dy + dz * dz;
  }
  manhattanDistanceTo(v) {
    return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);
  }
  setFromSpherical(s) {
    return this.setFromSphericalCoords(s.radius, s.phi, s.theta);
  }
  setFromSphericalCoords(radius, phi, theta) {
    const sinPhiRadius = Math.sin(phi) * radius;
    this.x = sinPhiRadius * Math.sin(theta);
    this.y = Math.cos(phi) * radius;
    this.z = sinPhiRadius * Math.cos(theta);
    return this;
  }
  setFromCylindrical(c) {
    return this.setFromCylindricalCoords(c.radius, c.theta, c.y);
  }
  setFromCylindricalCoords(radius, theta, y) {
    this.x = radius * Math.sin(theta);
    this.y = y;
    this.z = radius * Math.cos(theta);
    return this;
  }
  setFromMatrixPosition(m) {
    const e = m.elements;
    this.x = e[12];
    this.y = e[13];
    this.z = e[14];
    return this;
  }
  setFromMatrixScale(m) {
    const sx = this.setFromMatrixColumn(m, 0).length();
    const sy = this.setFromMatrixColumn(m, 1).length();
    const sz = this.setFromMatrixColumn(m, 2).length();
    this.x = sx;
    this.y = sy;
    this.z = sz;
    return this;
  }
  setFromMatrixColumn(m, index) {
    return this.fromArray(m.elements, index * 4);
  }
  setFromMatrix3Column(m, index) {
    return this.fromArray(m.elements, index * 3);
  }
  setFromEuler(e) {
    this.x = e._x;
    this.y = e._y;
    this.z = e._z;
    return this;
  }
  setFromColor(c) {
    this.x = c.r;
    this.y = c.g;
    this.z = c.b;
    return this;
  }
  equals(v) {
    return v.x === this.x && v.y === this.y && v.z === this.z;
  }
  fromArray(array, offset = 0) {
    this.x = array[offset];
    this.y = array[offset + 1];
    this.z = array[offset + 2];
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this.x;
    array[offset + 1] = this.y;
    array[offset + 2] = this.z;
    return array;
  }
  fromBufferAttribute(attribute, index) {
    this.x = attribute.getX(index);
    this.y = attribute.getY(index);
    this.z = attribute.getZ(index);
    return this;
  }
  random() {
    this.x = Math.random();
    this.y = Math.random();
    this.z = Math.random();
    return this;
  }
  randomDirection() {
    const theta = Math.random() * Math.PI * 2;
    const u = Math.random() * 2 - 1;
    const c = Math.sqrt(1 - u * u);
    this.x = c * Math.cos(theta);
    this.y = u;
    this.z = c * Math.sin(theta);
    return this;
  }
  *[Symbol.iterator]() {
    yield this.x;
    yield this.y;
    yield this.z;
  }
}
const _vector$2 = /* @__PURE__ */ new Vector32();
const _quaternion = /* @__PURE__ */ new Quaternion2();
class Matrix42 {
  constructor(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
    Matrix42.prototype.isMatrix4 = true;
    this.elements = [
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ];
    if (n11 !== void 0) {
      this.set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44);
    }
  }
  set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
    const te = this.elements;
    te[0] = n11;
    te[4] = n12;
    te[8] = n13;
    te[12] = n14;
    te[1] = n21;
    te[5] = n22;
    te[9] = n23;
    te[13] = n24;
    te[2] = n31;
    te[6] = n32;
    te[10] = n33;
    te[14] = n34;
    te[3] = n41;
    te[7] = n42;
    te[11] = n43;
    te[15] = n44;
    return this;
  }
  identity() {
    this.set(
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  clone() {
    return new Matrix42().fromArray(this.elements);
  }
  copy(m) {
    const te = this.elements;
    const me = m.elements;
    te[0] = me[0];
    te[1] = me[1];
    te[2] = me[2];
    te[3] = me[3];
    te[4] = me[4];
    te[5] = me[5];
    te[6] = me[6];
    te[7] = me[7];
    te[8] = me[8];
    te[9] = me[9];
    te[10] = me[10];
    te[11] = me[11];
    te[12] = me[12];
    te[13] = me[13];
    te[14] = me[14];
    te[15] = me[15];
    return this;
  }
  copyPosition(m) {
    const te = this.elements, me = m.elements;
    te[12] = me[12];
    te[13] = me[13];
    te[14] = me[14];
    return this;
  }
  setFromMatrix3(m) {
    const me = m.elements;
    this.set(
      me[0],
      me[3],
      me[6],
      0,
      me[1],
      me[4],
      me[7],
      0,
      me[2],
      me[5],
      me[8],
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  extractBasis(xAxis, yAxis, zAxis) {
    xAxis.setFromMatrixColumn(this, 0);
    yAxis.setFromMatrixColumn(this, 1);
    zAxis.setFromMatrixColumn(this, 2);
    return this;
  }
  makeBasis(xAxis, yAxis, zAxis) {
    this.set(
      xAxis.x,
      yAxis.x,
      zAxis.x,
      0,
      xAxis.y,
      yAxis.y,
      zAxis.y,
      0,
      xAxis.z,
      yAxis.z,
      zAxis.z,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  extractRotation(m) {
    const te = this.elements;
    const me = m.elements;
    const scaleX = 1 / _v1.setFromMatrixColumn(m, 0).length();
    const scaleY = 1 / _v1.setFromMatrixColumn(m, 1).length();
    const scaleZ = 1 / _v1.setFromMatrixColumn(m, 2).length();
    te[0] = me[0] * scaleX;
    te[1] = me[1] * scaleX;
    te[2] = me[2] * scaleX;
    te[3] = 0;
    te[4] = me[4] * scaleY;
    te[5] = me[5] * scaleY;
    te[6] = me[6] * scaleY;
    te[7] = 0;
    te[8] = me[8] * scaleZ;
    te[9] = me[9] * scaleZ;
    te[10] = me[10] * scaleZ;
    te[11] = 0;
    te[12] = 0;
    te[13] = 0;
    te[14] = 0;
    te[15] = 1;
    return this;
  }
  makeRotationFromEuler(euler) {
    const te = this.elements;
    const x = euler.x, y = euler.y, z = euler.z;
    const a = Math.cos(x), b = Math.sin(x);
    const c = Math.cos(y), d = Math.sin(y);
    const e = Math.cos(z), f = Math.sin(z);
    if (euler.order === "XYZ") {
      const ae = a * e, af = a * f, be = b * e, bf = b * f;
      te[0] = c * e;
      te[4] = -c * f;
      te[8] = d;
      te[1] = af + be * d;
      te[5] = ae - bf * d;
      te[9] = -b * c;
      te[2] = bf - ae * d;
      te[6] = be + af * d;
      te[10] = a * c;
    } else if (euler.order === "YXZ") {
      const ce = c * e, cf = c * f, de = d * e, df = d * f;
      te[0] = ce + df * b;
      te[4] = de * b - cf;
      te[8] = a * d;
      te[1] = a * f;
      te[5] = a * e;
      te[9] = -b;
      te[2] = cf * b - de;
      te[6] = df + ce * b;
      te[10] = a * c;
    } else if (euler.order === "ZXY") {
      const ce = c * e, cf = c * f, de = d * e, df = d * f;
      te[0] = ce - df * b;
      te[4] = -a * f;
      te[8] = de + cf * b;
      te[1] = cf + de * b;
      te[5] = a * e;
      te[9] = df - ce * b;
      te[2] = -a * d;
      te[6] = b;
      te[10] = a * c;
    } else if (euler.order === "ZYX") {
      const ae = a * e, af = a * f, be = b * e, bf = b * f;
      te[0] = c * e;
      te[4] = be * d - af;
      te[8] = ae * d + bf;
      te[1] = c * f;
      te[5] = bf * d + ae;
      te[9] = af * d - be;
      te[2] = -d;
      te[6] = b * c;
      te[10] = a * c;
    } else if (euler.order === "YZX") {
      const ac = a * c, ad = a * d, bc = b * c, bd = b * d;
      te[0] = c * e;
      te[4] = bd - ac * f;
      te[8] = bc * f + ad;
      te[1] = f;
      te[5] = a * e;
      te[9] = -b * e;
      te[2] = -d * e;
      te[6] = ad * f + bc;
      te[10] = ac - bd * f;
    } else if (euler.order === "XZY") {
      const ac = a * c, ad = a * d, bc = b * c, bd = b * d;
      te[0] = c * e;
      te[4] = -f;
      te[8] = d * e;
      te[1] = ac * f + bd;
      te[5] = a * e;
      te[9] = ad * f - bc;
      te[2] = bc * f - ad;
      te[6] = b * e;
      te[10] = bd * f + ac;
    }
    te[3] = 0;
    te[7] = 0;
    te[11] = 0;
    te[12] = 0;
    te[13] = 0;
    te[14] = 0;
    te[15] = 1;
    return this;
  }
  makeRotationFromQuaternion(q) {
    return this.compose(_zero, q, _one);
  }
  lookAt(eye, target, up) {
    const te = this.elements;
    _z.subVectors(eye, target);
    if (_z.lengthSq() === 0) {
      _z.z = 1;
    }
    _z.normalize();
    _x.crossVectors(up, _z);
    if (_x.lengthSq() === 0) {
      if (Math.abs(up.z) === 1) {
        _z.x += 1e-4;
      } else {
        _z.z += 1e-4;
      }
      _z.normalize();
      _x.crossVectors(up, _z);
    }
    _x.normalize();
    _y.crossVectors(_z, _x);
    te[0] = _x.x;
    te[4] = _y.x;
    te[8] = _z.x;
    te[1] = _x.y;
    te[5] = _y.y;
    te[9] = _z.y;
    te[2] = _x.z;
    te[6] = _y.z;
    te[10] = _z.z;
    return this;
  }
  multiply(m) {
    return this.multiplyMatrices(this, m);
  }
  premultiply(m) {
    return this.multiplyMatrices(m, this);
  }
  multiplyMatrices(a, b) {
    const ae = a.elements;
    const be = b.elements;
    const te = this.elements;
    const a11 = ae[0], a12 = ae[4], a13 = ae[8], a14 = ae[12];
    const a21 = ae[1], a22 = ae[5], a23 = ae[9], a24 = ae[13];
    const a31 = ae[2], a32 = ae[6], a33 = ae[10], a34 = ae[14];
    const a41 = ae[3], a42 = ae[7], a43 = ae[11], a44 = ae[15];
    const b11 = be[0], b12 = be[4], b13 = be[8], b14 = be[12];
    const b21 = be[1], b22 = be[5], b23 = be[9], b24 = be[13];
    const b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14];
    const b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15];
    te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
    te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
    te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
    te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
    te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
    te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
    te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
    te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
    te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
    te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
    te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
    te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
    te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
    te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
    te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
    te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
    return this;
  }
  multiplyScalar(s) {
    const te = this.elements;
    te[0] *= s;
    te[4] *= s;
    te[8] *= s;
    te[12] *= s;
    te[1] *= s;
    te[5] *= s;
    te[9] *= s;
    te[13] *= s;
    te[2] *= s;
    te[6] *= s;
    te[10] *= s;
    te[14] *= s;
    te[3] *= s;
    te[7] *= s;
    te[11] *= s;
    te[15] *= s;
    return this;
  }
  determinant() {
    const te = this.elements;
    const n11 = te[0], n12 = te[4], n13 = te[8], n14 = te[12];
    const n21 = te[1], n22 = te[5], n23 = te[9], n24 = te[13];
    const n31 = te[2], n32 = te[6], n33 = te[10], n34 = te[14];
    const n41 = te[3], n42 = te[7], n43 = te[11], n44 = te[15];
    return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);
  }
  transpose() {
    const te = this.elements;
    let tmp2;
    tmp2 = te[1];
    te[1] = te[4];
    te[4] = tmp2;
    tmp2 = te[2];
    te[2] = te[8];
    te[8] = tmp2;
    tmp2 = te[6];
    te[6] = te[9];
    te[9] = tmp2;
    tmp2 = te[3];
    te[3] = te[12];
    te[12] = tmp2;
    tmp2 = te[7];
    te[7] = te[13];
    te[13] = tmp2;
    tmp2 = te[11];
    te[11] = te[14];
    te[14] = tmp2;
    return this;
  }
  setPosition(x, y, z) {
    const te = this.elements;
    if (x.isVector3) {
      te[12] = x.x;
      te[13] = x.y;
      te[14] = x.z;
    } else {
      te[12] = x;
      te[13] = y;
      te[14] = z;
    }
    return this;
  }
  invert() {
    const te = this.elements, n11 = te[0], n21 = te[1], n31 = te[2], n41 = te[3], n12 = te[4], n22 = te[5], n32 = te[6], n42 = te[7], n13 = te[8], n23 = te[9], n33 = te[10], n43 = te[11], n14 = te[12], n24 = te[13], n34 = te[14], n44 = te[15], t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44, t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44, t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44, t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
    const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
    if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const detInv = 1 / det;
    te[0] = t11 * detInv;
    te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
    te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
    te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
    te[4] = t12 * detInv;
    te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
    te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
    te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
    te[8] = t13 * detInv;
    te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
    te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
    te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
    te[12] = t14 * detInv;
    te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
    te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
    te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
    return this;
  }
  scale(v) {
    const te = this.elements;
    const x = v.x, y = v.y, z = v.z;
    te[0] *= x;
    te[4] *= y;
    te[8] *= z;
    te[1] *= x;
    te[5] *= y;
    te[9] *= z;
    te[2] *= x;
    te[6] *= y;
    te[10] *= z;
    te[3] *= x;
    te[7] *= y;
    te[11] *= z;
    return this;
  }
  getMaxScaleOnAxis() {
    const te = this.elements;
    const scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
    const scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
    const scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
    return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
  }
  makeTranslation(x, y, z) {
    if (x.isVector3) {
      this.set(
        1,
        0,
        0,
        x.x,
        0,
        1,
        0,
        x.y,
        0,
        0,
        1,
        x.z,
        0,
        0,
        0,
        1
      );
    } else {
      this.set(
        1,
        0,
        0,
        x,
        0,
        1,
        0,
        y,
        0,
        0,
        1,
        z,
        0,
        0,
        0,
        1
      );
    }
    return this;
  }
  makeRotationX(theta) {
    const c = Math.cos(theta), s = Math.sin(theta);
    this.set(
      1,
      0,
      0,
      0,
      0,
      c,
      -s,
      0,
      0,
      s,
      c,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  makeRotationY(theta) {
    const c = Math.cos(theta), s = Math.sin(theta);
    this.set(
      c,
      0,
      s,
      0,
      0,
      1,
      0,
      0,
      -s,
      0,
      c,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  makeRotationZ(theta) {
    const c = Math.cos(theta), s = Math.sin(theta);
    this.set(
      c,
      -s,
      0,
      0,
      s,
      c,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  makeRotationAxis(axis, angle) {
    const c = Math.cos(angle);
    const s = Math.sin(angle);
    const t = 1 - c;
    const x = axis.x, y = axis.y, z = axis.z;
    const tx = t * x, ty = t * y;
    this.set(
      tx * x + c,
      tx * y - s * z,
      tx * z + s * y,
      0,
      tx * y + s * z,
      ty * y + c,
      ty * z - s * x,
      0,
      tx * z - s * y,
      ty * z + s * x,
      t * z * z + c,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  makeScale(x, y, z) {
    this.set(
      x,
      0,
      0,
      0,
      0,
      y,
      0,
      0,
      0,
      0,
      z,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  makeShear(xy, xz, yx, yz, zx, zy) {
    this.set(
      1,
      yx,
      zx,
      0,
      xy,
      1,
      zy,
      0,
      xz,
      yz,
      1,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  compose(position, quaternion, scale) {
    const te = this.elements;
    const x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;
    const x2 = x + x, y2 = y + y, z2 = z + z;
    const xx = x * x2, xy = x * y2, xz = x * z2;
    const yy = y * y2, yz = y * z2, zz = z * z2;
    const wx = w * x2, wy = w * y2, wz = w * z2;
    const sx = scale.x, sy = scale.y, sz = scale.z;
    te[0] = (1 - (yy + zz)) * sx;
    te[1] = (xy + wz) * sx;
    te[2] = (xz - wy) * sx;
    te[3] = 0;
    te[4] = (xy - wz) * sy;
    te[5] = (1 - (xx + zz)) * sy;
    te[6] = (yz + wx) * sy;
    te[7] = 0;
    te[8] = (xz + wy) * sz;
    te[9] = (yz - wx) * sz;
    te[10] = (1 - (xx + yy)) * sz;
    te[11] = 0;
    te[12] = position.x;
    te[13] = position.y;
    te[14] = position.z;
    te[15] = 1;
    return this;
  }
  decompose(position, quaternion, scale) {
    const te = this.elements;
    let sx = _v1.set(te[0], te[1], te[2]).length();
    const sy = _v1.set(te[4], te[5], te[6]).length();
    const sz = _v1.set(te[8], te[9], te[10]).length();
    const det = this.determinant();
    if (det < 0) sx = -sx;
    position.x = te[12];
    position.y = te[13];
    position.z = te[14];
    _m1.copy(this);
    const invSX = 1 / sx;
    const invSY = 1 / sy;
    const invSZ = 1 / sz;
    _m1.elements[0] *= invSX;
    _m1.elements[1] *= invSX;
    _m1.elements[2] *= invSX;
    _m1.elements[4] *= invSY;
    _m1.elements[5] *= invSY;
    _m1.elements[6] *= invSY;
    _m1.elements[8] *= invSZ;
    _m1.elements[9] *= invSZ;
    _m1.elements[10] *= invSZ;
    quaternion.setFromRotationMatrix(_m1);
    scale.x = sx;
    scale.y = sy;
    scale.z = sz;
    return this;
  }
  makePerspective(left, right, top, bottom, near, far, coordinateSystem = WebGLCoordinateSystem) {
    const te = this.elements;
    const x = 2 * near / (right - left);
    const y = 2 * near / (top - bottom);
    const a = (right + left) / (right - left);
    const b = (top + bottom) / (top - bottom);
    let c, d;
    if (coordinateSystem === WebGLCoordinateSystem) {
      c = -(far + near) / (far - near);
      d = -2 * far * near / (far - near);
    } else if (coordinateSystem === WebGPUCoordinateSystem) {
      c = -far / (far - near);
      d = -far * near / (far - near);
    } else {
      throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + coordinateSystem);
    }
    te[0] = x;
    te[4] = 0;
    te[8] = a;
    te[12] = 0;
    te[1] = 0;
    te[5] = y;
    te[9] = b;
    te[13] = 0;
    te[2] = 0;
    te[6] = 0;
    te[10] = c;
    te[14] = d;
    te[3] = 0;
    te[7] = 0;
    te[11] = -1;
    te[15] = 0;
    return this;
  }
  makeOrthographic(left, right, top, bottom, near, far, coordinateSystem = WebGLCoordinateSystem) {
    const te = this.elements;
    const w = 1 / (right - left);
    const h = 1 / (top - bottom);
    const p = 1 / (far - near);
    const x = (right + left) * w;
    const y = (top + bottom) * h;
    let z, zInv;
    if (coordinateSystem === WebGLCoordinateSystem) {
      z = (far + near) * p;
      zInv = -2 * p;
    } else if (coordinateSystem === WebGPUCoordinateSystem) {
      z = near * p;
      zInv = -1 * p;
    } else {
      throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + coordinateSystem);
    }
    te[0] = 2 * w;
    te[4] = 0;
    te[8] = 0;
    te[12] = -x;
    te[1] = 0;
    te[5] = 2 * h;
    te[9] = 0;
    te[13] = -y;
    te[2] = 0;
    te[6] = 0;
    te[10] = zInv;
    te[14] = -z;
    te[3] = 0;
    te[7] = 0;
    te[11] = 0;
    te[15] = 1;
    return this;
  }
  equals(matrix) {
    const te = this.elements;
    const me = matrix.elements;
    for (let i = 0; i < 16; i++) {
      if (te[i] !== me[i]) return false;
    }
    return true;
  }
  fromArray(array, offset = 0) {
    for (let i = 0; i < 16; i++) {
      this.elements[i] = array[i + offset];
    }
    return this;
  }
  toArray(array = [], offset = 0) {
    const te = this.elements;
    array[offset] = te[0];
    array[offset + 1] = te[1];
    array[offset + 2] = te[2];
    array[offset + 3] = te[3];
    array[offset + 4] = te[4];
    array[offset + 5] = te[5];
    array[offset + 6] = te[6];
    array[offset + 7] = te[7];
    array[offset + 8] = te[8];
    array[offset + 9] = te[9];
    array[offset + 10] = te[10];
    array[offset + 11] = te[11];
    array[offset + 12] = te[12];
    array[offset + 13] = te[13];
    array[offset + 14] = te[14];
    array[offset + 15] = te[15];
    return array;
  }
}
const _v1 = /* @__PURE__ */ new Vector32();
const _m1 = /* @__PURE__ */ new Matrix42();
const _zero = /* @__PURE__ */ new Vector32(0, 0, 0);
const _one = /* @__PURE__ */ new Vector32(1, 1, 1);
const _x = /* @__PURE__ */ new Vector32();
const _y = /* @__PURE__ */ new Vector32();
const _z = /* @__PURE__ */ new Vector32();
class Vector22 {
  constructor(x = 0, y = 0) {
    Vector22.prototype.isVector2 = true;
    this.x = x;
    this.y = y;
  }
  get width() {
    return this.x;
  }
  set width(value) {
    this.x = value;
  }
  get height() {
    return this.y;
  }
  set height(value) {
    this.y = value;
  }
  set(x, y) {
    this.x = x;
    this.y = y;
    return this;
  }
  setScalar(scalar) {
    this.x = scalar;
    this.y = scalar;
    return this;
  }
  setX(x) {
    this.x = x;
    return this;
  }
  setY(y) {
    this.y = y;
    return this;
  }
  setComponent(index, value) {
    switch (index) {
      case 0:
        this.x = value;
        break;
      case 1:
        this.y = value;
        break;
      default:
        throw new Error("index is out of range: " + index);
    }
    return this;
  }
  getComponent(index) {
    switch (index) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + index);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(v) {
    this.x = v.x;
    this.y = v.y;
    return this;
  }
  add(v) {
    this.x += v.x;
    this.y += v.y;
    return this;
  }
  addScalar(s) {
    this.x += s;
    this.y += s;
    return this;
  }
  addVectors(a, b) {
    this.x = a.x + b.x;
    this.y = a.y + b.y;
    return this;
  }
  addScaledVector(v, s) {
    this.x += v.x * s;
    this.y += v.y * s;
    return this;
  }
  sub(v) {
    this.x -= v.x;
    this.y -= v.y;
    return this;
  }
  subScalar(s) {
    this.x -= s;
    this.y -= s;
    return this;
  }
  subVectors(a, b) {
    this.x = a.x - b.x;
    this.y = a.y - b.y;
    return this;
  }
  multiply(v) {
    this.x *= v.x;
    this.y *= v.y;
    return this;
  }
  multiplyScalar(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    return this;
  }
  divide(v) {
    this.x /= v.x;
    this.y /= v.y;
    return this;
  }
  divideScalar(scalar) {
    return this.multiplyScalar(1 / scalar);
  }
  applyMatrix3(m) {
    const x = this.x, y = this.y;
    const e = m.elements;
    this.x = e[0] * x + e[3] * y + e[6];
    this.y = e[1] * x + e[4] * y + e[7];
    return this;
  }
  min(v) {
    this.x = Math.min(this.x, v.x);
    this.y = Math.min(this.y, v.y);
    return this;
  }
  max(v) {
    this.x = Math.max(this.x, v.x);
    this.y = Math.max(this.y, v.y);
    return this;
  }
  clamp(min2, max2) {
    this.x = clamp$1(this.x, min2.x, max2.x);
    this.y = clamp$1(this.y, min2.y, max2.y);
    return this;
  }
  clampScalar(minVal, maxVal) {
    this.x = clamp$1(this.x, minVal, maxVal);
    this.y = clamp$1(this.y, minVal, maxVal);
    return this;
  }
  clampLength(min2, max2) {
    const length2 = this.length();
    return this.divideScalar(length2 || 1).multiplyScalar(clamp$1(length2, min2, max2));
  }
  floor() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    return this;
  }
  ceil() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    return this;
  }
  round() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    return this;
  }
  roundToZero() {
    this.x = Math.trunc(this.x);
    this.y = Math.trunc(this.y);
    return this;
  }
  negate() {
    this.x = -this.x;
    this.y = -this.y;
    return this;
  }
  dot(v) {
    return this.x * v.x + this.y * v.y;
  }
  cross(v) {
    return this.x * v.y - this.y * v.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    const angle = Math.atan2(-this.y, -this.x) + Math.PI;
    return angle;
  }
  angleTo(v) {
    const denominator = Math.sqrt(this.lengthSq() * v.lengthSq());
    if (denominator === 0) return Math.PI / 2;
    const theta = this.dot(v) / denominator;
    return Math.acos(clamp$1(theta, -1, 1));
  }
  distanceTo(v) {
    return Math.sqrt(this.distanceToSquared(v));
  }
  distanceToSquared(v) {
    const dx = this.x - v.x, dy = this.y - v.y;
    return dx * dx + dy * dy;
  }
  manhattanDistanceTo(v) {
    return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);
  }
  setLength(length2) {
    return this.normalize().multiplyScalar(length2);
  }
  lerp(v, alpha) {
    this.x += (v.x - this.x) * alpha;
    this.y += (v.y - this.y) * alpha;
    return this;
  }
  lerpVectors(v1, v2, alpha) {
    this.x = v1.x + (v2.x - v1.x) * alpha;
    this.y = v1.y + (v2.y - v1.y) * alpha;
    return this;
  }
  equals(v) {
    return v.x === this.x && v.y === this.y;
  }
  fromArray(array, offset = 0) {
    this.x = array[offset];
    this.y = array[offset + 1];
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this.x;
    array[offset + 1] = this.y;
    return array;
  }
  fromBufferAttribute(attribute, index) {
    this.x = attribute.getX(index);
    this.y = attribute.getY(index);
    return this;
  }
  rotateAround(center, angle) {
    const c = Math.cos(angle), s = Math.sin(angle);
    const x = this.x - center.x;
    const y = this.y - center.y;
    this.x = x * c - y * s + center.x;
    this.y = x * s + y * c + center.y;
    return this;
  }
  random() {
    this.x = Math.random();
    this.y = Math.random();
    return this;
  }
  *[Symbol.iterator]() {
    yield this.x;
    yield this.y;
  }
}
class Vector42 {
  constructor(x = 0, y = 0, z = 0, w = 1) {
    Vector42.prototype.isVector4 = true;
    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;
  }
  get width() {
    return this.z;
  }
  set width(value) {
    this.z = value;
  }
  get height() {
    return this.w;
  }
  set height(value) {
    this.w = value;
  }
  set(x, y, z, w) {
    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;
    return this;
  }
  setScalar(scalar) {
    this.x = scalar;
    this.y = scalar;
    this.z = scalar;
    this.w = scalar;
    return this;
  }
  setX(x) {
    this.x = x;
    return this;
  }
  setY(y) {
    this.y = y;
    return this;
  }
  setZ(z) {
    this.z = z;
    return this;
  }
  setW(w) {
    this.w = w;
    return this;
  }
  setComponent(index, value) {
    switch (index) {
      case 0:
        this.x = value;
        break;
      case 1:
        this.y = value;
        break;
      case 2:
        this.z = value;
        break;
      case 3:
        this.w = value;
        break;
      default:
        throw new Error("index is out of range: " + index);
    }
    return this;
  }
  getComponent(index) {
    switch (index) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + index);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(v) {
    this.x = v.x;
    this.y = v.y;
    this.z = v.z;
    this.w = v.w !== void 0 ? v.w : 1;
    return this;
  }
  add(v) {
    this.x += v.x;
    this.y += v.y;
    this.z += v.z;
    this.w += v.w;
    return this;
  }
  addScalar(s) {
    this.x += s;
    this.y += s;
    this.z += s;
    this.w += s;
    return this;
  }
  addVectors(a, b) {
    this.x = a.x + b.x;
    this.y = a.y + b.y;
    this.z = a.z + b.z;
    this.w = a.w + b.w;
    return this;
  }
  addScaledVector(v, s) {
    this.x += v.x * s;
    this.y += v.y * s;
    this.z += v.z * s;
    this.w += v.w * s;
    return this;
  }
  sub(v) {
    this.x -= v.x;
    this.y -= v.y;
    this.z -= v.z;
    this.w -= v.w;
    return this;
  }
  subScalar(s) {
    this.x -= s;
    this.y -= s;
    this.z -= s;
    this.w -= s;
    return this;
  }
  subVectors(a, b) {
    this.x = a.x - b.x;
    this.y = a.y - b.y;
    this.z = a.z - b.z;
    this.w = a.w - b.w;
    return this;
  }
  multiply(v) {
    this.x *= v.x;
    this.y *= v.y;
    this.z *= v.z;
    this.w *= v.w;
    return this;
  }
  multiplyScalar(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    this.z *= scalar;
    this.w *= scalar;
    return this;
  }
  applyMatrix4(m) {
    const x = this.x, y = this.y, z = this.z, w = this.w;
    const e = m.elements;
    this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;
    this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;
    this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;
    this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;
    return this;
  }
  divide(v) {
    this.x /= v.x;
    this.y /= v.y;
    this.z /= v.z;
    this.w /= v.w;
    return this;
  }
  divideScalar(scalar) {
    return this.multiplyScalar(1 / scalar);
  }
  setAxisAngleFromQuaternion(q) {
    this.w = 2 * Math.acos(q.w);
    const s = Math.sqrt(1 - q.w * q.w);
    if (s < 1e-4) {
      this.x = 1;
      this.y = 0;
      this.z = 0;
    } else {
      this.x = q.x / s;
      this.y = q.y / s;
      this.z = q.z / s;
    }
    return this;
  }
  setAxisAngleFromRotationMatrix(m) {
    let angle, x, y, z;
    const epsilon = 0.01, epsilon2 = 0.1, te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10];
    if (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {
      if (Math.abs(m12 + m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2) {
        this.set(1, 0, 0, 0);
        return this;
      }
      angle = Math.PI;
      const xx = (m11 + 1) / 2;
      const yy = (m22 + 1) / 2;
      const zz = (m33 + 1) / 2;
      const xy = (m12 + m21) / 4;
      const xz = (m13 + m31) / 4;
      const yz = (m23 + m32) / 4;
      if (xx > yy && xx > zz) {
        if (xx < epsilon) {
          x = 0;
          y = 0.707106781;
          z = 0.707106781;
        } else {
          x = Math.sqrt(xx);
          y = xy / x;
          z = xz / x;
        }
      } else if (yy > zz) {
        if (yy < epsilon) {
          x = 0.707106781;
          y = 0;
          z = 0.707106781;
        } else {
          y = Math.sqrt(yy);
          x = xy / y;
          z = yz / y;
        }
      } else {
        if (zz < epsilon) {
          x = 0.707106781;
          y = 0.707106781;
          z = 0;
        } else {
          z = Math.sqrt(zz);
          x = xz / z;
          y = yz / z;
        }
      }
      this.set(x, y, z, angle);
      return this;
    }
    let s = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12));
    if (Math.abs(s) < 1e-3) s = 1;
    this.x = (m32 - m23) / s;
    this.y = (m13 - m31) / s;
    this.z = (m21 - m12) / s;
    this.w = Math.acos((m11 + m22 + m33 - 1) / 2);
    return this;
  }
  setFromMatrixPosition(m) {
    const e = m.elements;
    this.x = e[12];
    this.y = e[13];
    this.z = e[14];
    this.w = e[15];
    return this;
  }
  min(v) {
    this.x = Math.min(this.x, v.x);
    this.y = Math.min(this.y, v.y);
    this.z = Math.min(this.z, v.z);
    this.w = Math.min(this.w, v.w);
    return this;
  }
  max(v) {
    this.x = Math.max(this.x, v.x);
    this.y = Math.max(this.y, v.y);
    this.z = Math.max(this.z, v.z);
    this.w = Math.max(this.w, v.w);
    return this;
  }
  clamp(min2, max2) {
    this.x = clamp$1(this.x, min2.x, max2.x);
    this.y = clamp$1(this.y, min2.y, max2.y);
    this.z = clamp$1(this.z, min2.z, max2.z);
    this.w = clamp$1(this.w, min2.w, max2.w);
    return this;
  }
  clampScalar(minVal, maxVal) {
    this.x = clamp$1(this.x, minVal, maxVal);
    this.y = clamp$1(this.y, minVal, maxVal);
    this.z = clamp$1(this.z, minVal, maxVal);
    this.w = clamp$1(this.w, minVal, maxVal);
    return this;
  }
  clampLength(min2, max2) {
    const length2 = this.length();
    return this.divideScalar(length2 || 1).multiplyScalar(clamp$1(length2, min2, max2));
  }
  floor() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    this.z = Math.floor(this.z);
    this.w = Math.floor(this.w);
    return this;
  }
  ceil() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    this.z = Math.ceil(this.z);
    this.w = Math.ceil(this.w);
    return this;
  }
  round() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    this.z = Math.round(this.z);
    this.w = Math.round(this.w);
    return this;
  }
  roundToZero() {
    this.x = Math.trunc(this.x);
    this.y = Math.trunc(this.y);
    this.z = Math.trunc(this.z);
    this.w = Math.trunc(this.w);
    return this;
  }
  negate() {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
    this.w = -this.w;
    return this;
  }
  dot(v) {
    return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(length2) {
    return this.normalize().multiplyScalar(length2);
  }
  lerp(v, alpha) {
    this.x += (v.x - this.x) * alpha;
    this.y += (v.y - this.y) * alpha;
    this.z += (v.z - this.z) * alpha;
    this.w += (v.w - this.w) * alpha;
    return this;
  }
  lerpVectors(v1, v2, alpha) {
    this.x = v1.x + (v2.x - v1.x) * alpha;
    this.y = v1.y + (v2.y - v1.y) * alpha;
    this.z = v1.z + (v2.z - v1.z) * alpha;
    this.w = v1.w + (v2.w - v1.w) * alpha;
    return this;
  }
  equals(v) {
    return v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w;
  }
  fromArray(array, offset = 0) {
    this.x = array[offset];
    this.y = array[offset + 1];
    this.z = array[offset + 2];
    this.w = array[offset + 3];
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this.x;
    array[offset + 1] = this.y;
    array[offset + 2] = this.z;
    array[offset + 3] = this.w;
    return array;
  }
  fromBufferAttribute(attribute, index) {
    this.x = attribute.getX(index);
    this.y = attribute.getY(index);
    this.z = attribute.getZ(index);
    this.w = attribute.getW(index);
    return this;
  }
  random() {
    this.x = Math.random();
    this.y = Math.random();
    this.z = Math.random();
    this.w = Math.random();
    return this;
  }
  *[Symbol.iterator]() {
    yield this.x;
    yield this.y;
    yield this.z;
    yield this.w;
  }
}
function cyrb53(value, seed = 0) {
  let h1 = 3735928559 ^ seed, h2 = 1103547991 ^ seed;
  if (value instanceof Array) {
    for (let i = 0, val; i < value.length; i++) {
      val = value[i];
      h1 = Math.imul(h1 ^ val, 2654435761);
      h2 = Math.imul(h2 ^ val, 1597334677);
    }
  } else {
    for (let i = 0, ch; i < value.length; i++) {
      ch = value.charCodeAt(i);
      h1 = Math.imul(h1 ^ ch, 2654435761);
      h2 = Math.imul(h2 ^ ch, 1597334677);
    }
  }
  h1 = Math.imul(h1 ^ h1 >>> 16, 2246822507);
  h1 ^= Math.imul(h2 ^ h2 >>> 13, 3266489909);
  h2 = Math.imul(h2 ^ h2 >>> 16, 2246822507);
  h2 ^= Math.imul(h1 ^ h1 >>> 13, 3266489909);
  return 4294967296 * (2097151 & h2) + (h1 >>> 0);
}
const hash = (...params) => cyrb53(params);
function getCacheKey(object, force = false) {
  const values = [];
  if (object.isNode === true) {
    values.push(object.id);
    object = object.getSelf();
  }
  for (const { property: property2, childNode } of getNodeChildren(object)) {
    values.push(values, cyrb53(property2.slice(0, -4)), childNode.getCacheKey(force));
  }
  return cyrb53(values);
}
function* getNodeChildren(node, toJSON2 = false) {
  for (const property2 in node) {
    if (property2.startsWith("_") === true) continue;
    const object = node[property2];
    if (Array.isArray(object) === true) {
      for (let i = 0; i < object.length; i++) {
        const child = object[i];
        if (child && (child.isNode === true || toJSON2 && typeof child.toJSON === "function")) {
          yield { property: property2, index: i, childNode: child };
        }
      }
    } else if (object && object.isNode === true) {
      yield { property: property2, childNode: object };
    } else if (typeof object === "object") {
      for (const subProperty in object) {
        const child = object[subProperty];
        if (child && (child.isNode === true || toJSON2 && typeof child.toJSON === "function")) {
          yield { property: property2, index: subProperty, childNode: child };
        }
      }
    }
  }
}
function getValueType(value) {
  if (value === void 0 || value === null) return null;
  const typeOf = typeof value;
  if (value.isNode === true) {
    return "node";
  } else if (typeOf === "number") {
    return "float";
  } else if (typeOf === "boolean") {
    return "bool";
  } else if (typeOf === "string") {
    return "string";
  } else if (typeOf === "function") {
    return "shader";
  } else if (value.isVector2 === true) {
    return "vec2";
  } else if (value.isVector3 === true) {
    return "vec3";
  } else if (value.isVector4 === true) {
    return "vec4";
  } else if (value.isMatrix3 === true) {
    return "mat3";
  } else if (value.isMatrix4 === true) {
    return "mat4";
  } else if (value.isColor === true) {
    return "color";
  } else if (value instanceof ArrayBuffer) {
    return "ArrayBuffer";
  }
  return null;
}
function getValueFromType(type, ...params) {
  const last4 = type ? type.slice(-4) : void 0;
  if (params.length === 1) {
    if (last4 === "vec2") params = [params[0], params[0]];
    else if (last4 === "vec3") params = [params[0], params[0], params[0]];
    else if (last4 === "vec4") params = [params[0], params[0], params[0], params[0]];
  }
  if (type === "color") {
    return new Color2(...params);
  } else if (last4 === "vec2") {
    return new Vector22(...params);
  } else if (last4 === "vec3") {
    return new Vector32(...params);
  } else if (last4 === "vec4") {
    return new Vector42(...params);
  } else if (last4 === "mat3") {
    return new Matrix32(...params);
  } else if (last4 === "mat4") {
    return new Matrix42(...params);
  } else if (type === "bool") {
    return params[0] || false;
  } else if (type === "float" || type === "int" || type === "uint") {
    return params[0] || 0;
  } else if (type === "string") {
    return params[0] || "";
  } else if (type === "ArrayBuffer") {
    return base64ToArrayBuffer(params[0]);
  }
  return null;
}
function arrayBufferToBase64(arrayBuffer) {
  let chars = "";
  const array = new Uint8Array(arrayBuffer);
  for (let i = 0; i < array.length; i++) {
    chars += String.fromCharCode(array[i]);
  }
  return btoa(chars);
}
function base64ToArrayBuffer(base64) {
  return Uint8Array.from(atob(base64), (c) => c.charCodeAt(0)).buffer;
}
class EventDispatcher2 {
  addEventListener(type, listener) {
    if (this._listeners === void 0) this._listeners = {};
    const listeners = this._listeners;
    if (listeners[type] === void 0) {
      listeners[type] = [];
    }
    if (listeners[type].indexOf(listener) === -1) {
      listeners[type].push(listener);
    }
  }
  hasEventListener(type, listener) {
    if (this._listeners === void 0) return false;
    const listeners = this._listeners;
    return listeners[type] !== void 0 && listeners[type].indexOf(listener) !== -1;
  }
  removeEventListener(type, listener) {
    if (this._listeners === void 0) return;
    const listeners = this._listeners;
    const listenerArray = listeners[type];
    if (listenerArray !== void 0) {
      const index = listenerArray.indexOf(listener);
      if (index !== -1) {
        listenerArray.splice(index, 1);
      }
    }
  }
  dispatchEvent(event) {
    if (this._listeners === void 0) return;
    const listeners = this._listeners;
    const listenerArray = listeners[event.type];
    if (listenerArray !== void 0) {
      event.target = this;
      const array = listenerArray.slice(0);
      for (let i = 0, l = array.length; i < l; i++) {
        array[i].call(this, event);
      }
      event.target = null;
    }
  }
}
let _nodeId = 0;
class Node extends EventDispatcher2 {
  static get type() {
    return "Node";
  }
  /**
   * Constructs a new node.
   *
   * @param {String?} nodeType - The node type.
   */
  constructor(nodeType = null) {
    super();
    this.nodeType = nodeType;
    this.updateType = NodeUpdateType.NONE;
    this.updateBeforeType = NodeUpdateType.NONE;
    this.updateAfterType = NodeUpdateType.NONE;
    this.uuid = MathUtils.generateUUID();
    this.version = 0;
    this.global = false;
    this.isNode = true;
    this._cacheKey = null;
    this._cacheKeyVersion = 0;
    Object.defineProperty(this, "id", { value: _nodeId++ });
  }
  /**
   * Set this property to `true` when the node should be regenerated.
   *
   * @type {Boolean}
   * @default false
   * @param {boolean} value
   */
  set needsUpdate(value) {
    if (value === true) {
      this.version++;
    }
  }
  /**
   * The type of the class. The value is usually the constructor name.
   *
   * @type {String}
  	 * @readonly
   */
  get type() {
    return this.constructor.type;
  }
  /**
   * Convenient method for defining {@link Node#update}.
   *
   * @param {Function} callback - The update method.
   * @param {String} updateType - The update type.
   * @return {Node} A reference to this node.
   */
  onUpdate(callback, updateType) {
    this.updateType = updateType;
    this.update = callback.bind(this.getSelf());
    return this;
  }
  /**
   * Convenient method for defining {@link Node#update}. Similar to {@link Node#onUpdate}, but
   * this method automatically sets the update type to `FRAME`.
   *
   * @param {Function} callback - The update method.
   * @return {Node} A reference to this node.
   */
  onFrameUpdate(callback) {
    return this.onUpdate(callback, NodeUpdateType.FRAME);
  }
  /**
   * Convenient method for defining {@link Node#update}. Similar to {@link Node#onUpdate}, but
   * this method automatically sets the update type to `RENDER`.
   *
   * @param {Function} callback - The update method.
   * @return {Node} A reference to this node.
   */
  onRenderUpdate(callback) {
    return this.onUpdate(callback, NodeUpdateType.RENDER);
  }
  /**
   * Convenient method for defining {@link Node#update}. Similar to {@link Node#onUpdate}, but
   * this method automatically sets the update type to `OBJECT`.
   *
   * @param {Function} callback - The update method.
   * @return {Node} A reference to this node.
   */
  onObjectUpdate(callback) {
    return this.onUpdate(callback, NodeUpdateType.OBJECT);
  }
  /**
   * Convenient method for defining {@link Node#updateReference}.
   *
   * @param {Function} callback - The update method.
   * @return {Node} A reference to this node.
   */
  onReference(callback) {
    this.updateReference = callback.bind(this.getSelf());
    return this;
  }
  /**
   * The `this` reference might point to a Proxy so this method can be used
   * to get the reference to the actual node instance.
   *
   * @return {Node} A reference to the node.
   */
  getSelf() {
    return this.self || this;
  }
  /**
   * Nodes might refer to other objects like materials. This method allows to dynamically update the reference
   * to such objects based on a given state (e.g. the current node frame or builder).
   *
   * @param {Any} state - This method can be invocated in different contexts so `state` can refer to any object type.
   * @return {Any} The updated reference.
   */
  updateReference() {
    return this;
  }
  /**
   * By default this method returns the value of the {@link Node#global} flag. This method
   * can be overwritten in derived classes if an analytical way is required to determine the
   * global status.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Boolean} Whether this node is global or not.
   */
  isGlobal() {
    return this.global;
  }
  /**
   * Generator function that can be used to iterate over the child nodes.
   *
   * @generator
   * @yields {Node} A child node.
   */
  *getChildren() {
    for (const { childNode } of getNodeChildren(this)) {
      yield childNode;
    }
  }
  /**
   * Calling this method dispatches the `dispose` event. This event can be used
   * to register event listeners for clean up tasks.
   */
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  /**
   * Callback for {@link Node#traverse}.
   *
   * @callback traverseCallback
   * @param {Node} node - The current node.
   */
  /**
   * Can be used to traverse through the node's hierarchy.
   *
   * @param {traverseCallback} callback - A callback that is executed per node.
   */
  traverse(callback) {
    callback(this);
    for (const childNode of this.getChildren()) {
      childNode.traverse(callback);
    }
  }
  /**
   * Returns the cache key for this node.
   *
   * @param {Boolean} [force=false] - When set to `true`, a recomputation of the cache key is forced.
   * @return {Number} The cache key of the node.
   */
  getCacheKey(force = false) {
    force = force || this.version !== this._cacheKeyVersion;
    if (force === true || this._cacheKey === null) {
      this._cacheKey = hash(getCacheKey(this, force), this.customCacheKey());
      this._cacheKeyVersion = this.version;
    }
    return this._cacheKey;
  }
  /**
   * Generate a custom cache key for this node.
   *
   * @return {Number} The cache key of the node.
   */
  customCacheKey() {
    return 0;
  }
  /**
   * Returns the references to this node which is by default `this`.
   *
   * @return {Node} A reference to this node.
   */
  getScope() {
    return this;
  }
  /**
   * Returns the hash of the node which is used to identify the node. By default it's
   * the {@link Node#uuid} however derived node classes might have to overwrite this method
   * depending on their implementation.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {String} The hash.
   */
  getHash() {
    return this.uuid;
  }
  /**
   * Returns the update type of {@link Node#update}.
   *
   * @return {NodeUpdateType} The update type.
   */
  getUpdateType() {
    return this.updateType;
  }
  /**
   * Returns the update type of {@link Node#updateBefore}.
   *
   * @return {NodeUpdateType} The update type.
   */
  getUpdateBeforeType() {
    return this.updateBeforeType;
  }
  /**
   * Returns the update type of {@link Node#updateAfter}.
   *
   * @return {NodeUpdateType} The update type.
   */
  getUpdateAfterType() {
    return this.updateAfterType;
  }
  /**
   * Certain types are composed of multiple elements. For example a `vec3`
   * is composed of three `float` values. This method returns the type of
   * these elements.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {String} The type of the node.
   */
  getElementType(builder) {
    const type = this.getNodeType(builder);
    const elementType = builder.getElementType(type);
    return elementType;
  }
  /**
   * Returns the node's type.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {String} The type of the node.
   */
  getNodeType(builder) {
    const nodeProperties = builder.getNodeProperties(this);
    if (nodeProperties.outputNode) {
      return nodeProperties.outputNode.getNodeType(builder);
    }
    return this.nodeType;
  }
  /**
   * This method is used during the build process of a node and ensures
   * equal nodes are not built multiple times but just once. For example if
   * `attribute( 'uv' )` is used multiple times by the user, the build
   * process makes sure to process just the first node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Node} The shared node if possible. Otherwise `this` is returned.
   */
  getShared(builder) {
    const hash2 = this.getHash(builder);
    const nodeFromHash = builder.getNodeFromHash(hash2);
    return nodeFromHash || this;
  }
  /**
   * Represents the setup stage which is the first step of the build process, see {@link Node#build} method.
   * This method is often overwritten in derived modules to prepare the node which is used as the output/result.
   * The output node must be returned in the `return` statement.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Node?} The output node.
   */
  setup(builder) {
    const nodeProperties = builder.getNodeProperties(this);
    let index = 0;
    for (const childNode of this.getChildren()) {
      nodeProperties["node" + index++] = childNode;
    }
    return nodeProperties.outputNode || null;
  }
  /**
   * Represents the analyze stage which is the second step of the build process, see {@link Node#build} method.
   * This stage analyzes the node hierarchy and ensures descendent nodes are built.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  analyze(builder) {
    const usageCount = builder.increaseUsage(this);
    if (usageCount === 1) {
      const nodeProperties = builder.getNodeProperties(this);
      for (const childNode of Object.values(nodeProperties)) {
        if (childNode && childNode.isNode === true) {
          childNode.build(builder);
        }
      }
    }
  }
  /**
   * Represents the generate stage which is the third step of the build process, see {@link Node#build} method.
   * This state builds the output node and returns the resulting shader string.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {String?} output - Can be used to define the output type.
   * @return {String?} The generated shader string.
   */
  generate(builder, output) {
    const { outputNode } = builder.getNodeProperties(this);
    if (outputNode && outputNode.isNode === true) {
      return outputNode.build(builder, output);
    }
  }
  /**
   * The method can be implemented to update the node's internal state before it is used to render an object.
   * The {@link Node#updateBeforeType} property defines how often the update is executed.
   *
   * @abstract
   * @param {NodeFrame} frame - A reference to the current node frame.
   * @return {Boolean?} An optional bool that indicates whether the implementation actually performed an update or not (e.g. due to caching).
   */
  updateBefore() {
    console.warn("Abstract function.");
  }
  /**
   * The method can be implemented to update the node's internal state after it was used to render an object.
   * The {@link Node#updateAfterType} property defines how often the update is executed.
   *
   * @abstract
   * @param {NodeFrame} frame - A reference to the current node frame.
   * @return {Boolean?} An optional bool that indicates whether the implementation actually performed an update or not (e.g. due to caching).
   */
  updateAfter() {
    console.warn("Abstract function.");
  }
  /**
   * The method can be implemented to update the node's internal state when it is used to render an object.
   * The {@link Node#updateType} property defines how often the update is executed.
   *
   * @abstract
   * @param {NodeFrame} frame - A reference to the current node frame.
   * @return {Boolean?} An optional bool that indicates whether the implementation actually performed an update or not (e.g. due to caching).
   */
  update() {
    console.warn("Abstract function.");
  }
  /**
   * This method performs the build of a node. The behavior of this method as well as its return value depend
   * on the current build stage (setup, analyze or generate).
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {String?} output - Can be used to define the output type.
   * @return {String?} When this method is executed in the setup or analyze stage, `null` is returned. In the generate stage, the generated shader string.
   */
  build(builder, output = null) {
    const refNode = this.getShared(builder);
    if (this !== refNode) {
      return refNode.build(builder, output);
    }
    builder.addNode(this);
    builder.addChain(this);
    let result = null;
    const buildStage = builder.getBuildStage();
    if (buildStage === "setup") {
      this.updateReference(builder);
      const properties = builder.getNodeProperties(this);
      if (properties.initialized !== true) {
        properties.initialized = true;
        const outputNode = this.setup(builder);
        const isNodeOutput = outputNode && outputNode.isNode === true;
        for (const childNode of Object.values(properties)) {
          if (childNode && childNode.isNode === true) {
            childNode.build(builder);
          }
        }
        if (isNodeOutput) {
          outputNode.build(builder);
        }
        properties.outputNode = outputNode;
      }
    } else if (buildStage === "analyze") {
      this.analyze(builder);
    } else if (buildStage === "generate") {
      const isGenerateOnce = this.generate.length === 1;
      if (isGenerateOnce) {
        const type = this.getNodeType(builder);
        const nodeData = builder.getDataFromNode(this);
        result = nodeData.snippet;
        if (result === void 0) {
          result = this.generate(builder) || "";
          nodeData.snippet = result;
        } else if (nodeData.flowCodes !== void 0 && builder.context.nodeBlock !== void 0) {
          builder.addFlowCodeHierarchy(this, builder.context.nodeBlock);
        }
        result = builder.format(result, type, output);
      } else {
        result = this.generate(builder, output) || "";
      }
    }
    builder.removeChain(this);
    builder.addSequentialNode(this);
    return result;
  }
  /**
   * Returns the child nodes as a JSON object.
   *
   * @return {Object} The serialized child objects as JSON.
   */
  getSerializeChildren() {
    return getNodeChildren(this);
  }
  /**
   * Serializes the node to JSON.
   *
   * @param {Object} json - The output JSON object.
   */
  serialize(json) {
    const nodeChildren = this.getSerializeChildren();
    const inputNodes = {};
    for (const { property: property2, index, childNode } of nodeChildren) {
      if (index !== void 0) {
        if (inputNodes[property2] === void 0) {
          inputNodes[property2] = Number.isInteger(index) ? [] : {};
        }
        inputNodes[property2][index] = childNode.toJSON(json.meta).uuid;
      } else {
        inputNodes[property2] = childNode.toJSON(json.meta).uuid;
      }
    }
    if (Object.keys(inputNodes).length > 0) {
      json.inputNodes = inputNodes;
    }
  }
  /**
   * Deserializes the node from the given JSON.
   *
   * @param {Object} json - The JSON object.
   */
  deserialize(json) {
    if (json.inputNodes !== void 0) {
      const nodes = json.meta.nodes;
      for (const property2 in json.inputNodes) {
        if (Array.isArray(json.inputNodes[property2])) {
          const inputArray = [];
          for (const uuid of json.inputNodes[property2]) {
            inputArray.push(nodes[uuid]);
          }
          this[property2] = inputArray;
        } else if (typeof json.inputNodes[property2] === "object") {
          const inputObject = {};
          for (const subProperty in json.inputNodes[property2]) {
            const uuid = json.inputNodes[property2][subProperty];
            inputObject[subProperty] = nodes[uuid];
          }
          this[property2] = inputObject;
        } else {
          const uuid = json.inputNodes[property2];
          this[property2] = nodes[uuid];
        }
      }
    }
  }
  /**
   * Serializes the node into the three.js JSON Object/Scene format.
   *
   * @param {Object?} meta - An optional JSON object that already holds serialized data from other scene objects.
   * @return {Object} The serialized node.
   */
  toJSON(meta) {
    const { uuid, type } = this;
    const isRoot = meta === void 0 || typeof meta === "string";
    if (isRoot) {
      meta = {
        textures: {},
        images: {},
        nodes: {}
      };
    }
    let data = meta.nodes[uuid];
    if (data === void 0) {
      data = {
        uuid,
        type,
        meta,
        metadata: {
          version: 4.6,
          type: "Node",
          generator: "Node.toJSON"
        }
      };
      if (isRoot !== true) meta.nodes[data.uuid] = data;
      this.serialize(data);
      delete data.meta;
    }
    function extractFromCache(cache2) {
      const values = [];
      for (const key in cache2) {
        const data2 = cache2[key];
        delete data2.metadata;
        values.push(data2);
      }
      return values;
    }
    if (isRoot) {
      const textures = extractFromCache(meta.textures);
      const images = extractFromCache(meta.images);
      const nodes = extractFromCache(meta.nodes);
      if (textures.length > 0) data.textures = textures;
      if (images.length > 0) data.images = images;
      if (nodes.length > 0) data.nodes = nodes;
    }
    return data;
  }
}
class ArrayElementNode extends Node {
  // @TODO: If extending from TempNode it breaks webgpu_compute
  static get type() {
    return "ArrayElementNode";
  }
  /**
   * Constructs an array element node.
   *
   * @param {Node} node - The array-like node.
   * @param {Node} indexNode - The index node that defines the element access.
   */
  constructor(node, indexNode) {
    super();
    this.node = node;
    this.indexNode = indexNode;
    this.isArrayElementNode = true;
  }
  /**
   * This method is overwritten since the node type is inferred from the array-like node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {String} The node type.
   */
  getNodeType(builder) {
    return this.node.getElementType(builder);
  }
  generate(builder) {
    const nodeSnippet = this.node.build(builder);
    const indexSnippet = this.indexNode.build(builder, "uint");
    return `${nodeSnippet}[ ${indexSnippet} ]`;
  }
}
class ConvertNode extends Node {
  static get type() {
    return "ConvertNode";
  }
  /**
   * Constructs a new convert node.
   *
   * @param {Node} node - The node which type should be converted.
   * @param {String} convertTo - The target node type. Multiple types can be defined by separating them with a `|` sign.
   */
  constructor(node, convertTo) {
    super();
    this.node = node;
    this.convertTo = convertTo;
  }
  /**
   * This method is overwritten since the implementation tries to infer the best
   * matching type from the {@link ConvertNode#convertTo} property.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {String} The node type.
   */
  getNodeType(builder) {
    const requestType = this.node.getNodeType(builder);
    let convertTo = null;
    for (const overloadingType of this.convertTo.split("|")) {
      if (convertTo === null || builder.getTypeLength(requestType) === builder.getTypeLength(overloadingType)) {
        convertTo = overloadingType;
      }
    }
    return convertTo;
  }
  serialize(data) {
    super.serialize(data);
    data.convertTo = this.convertTo;
  }
  deserialize(data) {
    super.deserialize(data);
    this.convertTo = data.convertTo;
  }
  generate(builder, output) {
    const node = this.node;
    const type = this.getNodeType(builder);
    const snippet = node.build(builder, type);
    return builder.format(snippet, type, output);
  }
}
class TempNode extends Node {
  static get type() {
    return "TempNode";
  }
  /**
   * Constructs a temp node.
   *
   * @param {String?} nodeType - The node type.
   */
  constructor(nodeType = null) {
    super(nodeType);
    this.isTempNode = true;
  }
  /**
   * Whether this node is used more than once in context of other nodes.
   *
   * @param {NodeBuilder} builder - The node builder.
   * @return {Boolean} A flag that indicates if there is more than one dependency to other nodes.
   */
  hasDependencies(builder) {
    return builder.getDataFromNode(this).usageCount > 1;
  }
  build(builder, output) {
    const buildStage = builder.getBuildStage();
    if (buildStage === "generate") {
      const type = builder.getVectorType(this.getNodeType(builder, output));
      const nodeData = builder.getDataFromNode(this);
      if (nodeData.propertyName !== void 0) {
        return builder.format(nodeData.propertyName, type, output);
      } else if (type !== "void" && output !== "void" && this.hasDependencies(builder)) {
        const snippet = super.build(builder, type);
        const nodeVar = builder.getVarFromNode(this, null, type);
        const propertyName = builder.getPropertyName(nodeVar);
        builder.addLineFlowCode(`${propertyName} = ${snippet}`, this);
        nodeData.snippet = snippet;
        nodeData.propertyName = propertyName;
        return builder.format(nodeData.propertyName, type, output);
      }
    }
    return super.build(builder, output);
  }
}
class JoinNode extends TempNode {
  static get type() {
    return "JoinNode";
  }
  /**
   * Constructs a new join node.
   *
   * @param {Array<Node>} nodes - An array of nodes that should be joined.
   * @param {String?} [nodeType=null] - The node type.
   */
  constructor(nodes = [], nodeType = null) {
    super(nodeType);
    this.nodes = nodes;
  }
  /**
   * This method is overwritten since the node type must be inferred from the
   * joined data length if not explicitly defined.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {String} The node type.
   */
  getNodeType(builder) {
    if (this.nodeType !== null) {
      return builder.getVectorType(this.nodeType);
    }
    return builder.getTypeFromLength(this.nodes.reduce((count, cur) => count + builder.getTypeLength(cur.getNodeType(builder)), 0));
  }
  generate(builder, output) {
    const type = this.getNodeType(builder);
    const nodes = this.nodes;
    const primitiveType = builder.getComponentType(type);
    const snippetValues = [];
    for (const input of nodes) {
      let inputSnippet = input.build(builder);
      const inputPrimitiveType = builder.getComponentType(input.getNodeType(builder));
      if (inputPrimitiveType !== primitiveType) {
        inputSnippet = builder.format(inputSnippet, inputPrimitiveType, primitiveType);
      }
      snippetValues.push(inputSnippet);
    }
    const snippet = `${builder.getType(type)}( ${snippetValues.join(", ")} )`;
    return builder.format(snippet, type, output);
  }
}
const _stringVectorComponents = vectorComponents.join("");
class SplitNode extends Node {
  static get type() {
    return "SplitNode";
  }
  /**
   * Constructs a new split node.
   *
   * @param {Node} node - The node that should be accessed.
   * @param {String} [components='x'] - The components that should be accessed.
   */
  constructor(node, components = "x") {
    super();
    this.node = node;
    this.components = components;
    this.isSplitNode = true;
  }
  /**
   * Returns the vector length which is computed based on the requested components.
   *
   * @return {Number} The vector length.
   */
  getVectorLength() {
    let vectorLength = this.components.length;
    for (const c of this.components) {
      vectorLength = Math.max(vectorComponents.indexOf(c) + 1, vectorLength);
    }
    return vectorLength;
  }
  /**
   * Returns the component type of the node's type.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {String} The component type.
   */
  getComponentType(builder) {
    return builder.getComponentType(this.node.getNodeType(builder));
  }
  /**
   * This method is overwritten since the node type is inferred from requested components.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {String} The node type.
   */
  getNodeType(builder) {
    return builder.getTypeFromLength(this.components.length, this.getComponentType(builder));
  }
  generate(builder, output) {
    const node = this.node;
    const nodeTypeLength = builder.getTypeLength(node.getNodeType(builder));
    let snippet = null;
    if (nodeTypeLength > 1) {
      let type = null;
      const componentsLength = this.getVectorLength();
      if (componentsLength >= nodeTypeLength) {
        type = builder.getTypeFromLength(this.getVectorLength(), this.getComponentType(builder));
      }
      const nodeSnippet = node.build(builder, type);
      if (this.components.length === nodeTypeLength && this.components === _stringVectorComponents.slice(0, this.components.length)) {
        snippet = builder.format(nodeSnippet, type, output);
      } else {
        snippet = builder.format(`${nodeSnippet}.${this.components}`, this.getNodeType(builder), output);
      }
    } else {
      snippet = node.build(builder, output);
    }
    return snippet;
  }
  serialize(data) {
    super.serialize(data);
    data.components = this.components;
  }
  deserialize(data) {
    super.deserialize(data);
    this.components = data.components;
  }
}
class SetNode extends TempNode {
  static get type() {
    return "SetNode";
  }
  /**
   * Constructs a new set node.
   *
   * @param {Node} sourceNode - The node that should be updated.
   * @param {String} components - The components that should be updated.
   * @param {Node} targetNode - The value node.
   */
  constructor(sourceNode, components, targetNode) {
    super();
    this.sourceNode = sourceNode;
    this.components = components;
    this.targetNode = targetNode;
  }
  /**
   * This method is overwritten since the node type is inferred from {@link SetNode#sourceNode}.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {String} The node type.
   */
  getNodeType(builder) {
    return this.sourceNode.getNodeType(builder);
  }
  generate(builder) {
    const { sourceNode, components, targetNode } = this;
    const sourceType = this.getNodeType(builder);
    const componentType = builder.getComponentType(targetNode.getNodeType(builder));
    const targetType = builder.getTypeFromLength(components.length, componentType);
    const targetSnippet = targetNode.build(builder, targetType);
    const sourceSnippet = sourceNode.build(builder, sourceType);
    const length2 = builder.getTypeLength(sourceType);
    const snippetValues = [];
    for (let i = 0; i < length2; i++) {
      const component = vectorComponents[i];
      if (component === components[0]) {
        snippetValues.push(targetSnippet);
        i += components.length - 1;
      } else {
        snippetValues.push(sourceSnippet + "." + component);
      }
    }
    return `${builder.getType(sourceType)}( ${snippetValues.join(", ")} )`;
  }
}
class FlipNode extends TempNode {
  static get type() {
    return "FlipNode";
  }
  /**
   * Constructs a new flip node.
   *
   * @param {Node} sourceNode - The node which component(s) should be flipped.
   * @param {String} components - The components that should be flipped e.g. `'x'` or `'xy'`.
   */
  constructor(sourceNode, components) {
    super();
    this.sourceNode = sourceNode;
    this.components = components;
  }
  /**
   * This method is overwritten since the node type is inferred from the source node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {String} The node type.
   */
  getNodeType(builder) {
    return this.sourceNode.getNodeType(builder);
  }
  generate(builder) {
    const { components, sourceNode } = this;
    const sourceType = this.getNodeType(builder);
    const sourceSnippet = sourceNode.build(builder);
    const sourceCache = builder.getVarFromNode(this);
    const sourceProperty = builder.getPropertyName(sourceCache);
    builder.addLineFlowCode(sourceProperty + " = " + sourceSnippet, this);
    const length2 = builder.getTypeLength(sourceType);
    const snippetValues = [];
    let componentIndex = 0;
    for (let i = 0; i < length2; i++) {
      const component = vectorComponents[i];
      if (component === components[componentIndex]) {
        snippetValues.push("1.0 - " + (sourceProperty + "." + component));
        componentIndex++;
      } else {
        snippetValues.push(sourceProperty + "." + component);
      }
    }
    return `${builder.getType(sourceType)}( ${snippetValues.join(", ")} )`;
  }
}
class InputNode extends Node {
  static get type() {
    return "InputNode";
  }
  /**
   * Constructs a new input node.
   *
   * @param {Any} value - The value of this node. This can be a any JS primitive, functions, array buffers or even three.js objects (vector, matrices, colors).
   * @param {String?} nodeType - The node type. If no explicit type is defined, the node tries to derive the type from its value.
   */
  constructor(value, nodeType = null) {
    super(nodeType);
    this.isInputNode = true;
    this.value = value;
    this.precision = null;
  }
  getNodeType() {
    if (this.nodeType === null) {
      return getValueType(this.value);
    }
    return this.nodeType;
  }
  /**
   * Returns the input type of the node which is by default the node type. Derived modules
   * might overwrite this method and use a fixed type or compute one analytically.
   *
   * A typical example for different input and node types are textures. The input type of a
   * normal RGBA texture is `texture` whereas its node type is `vec4`.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {String} The input type.
   */
  getInputType(builder) {
    return this.getNodeType(builder);
  }
  /**
   * Sets the precision to the given value. The method can be
   * overwritten in derived classes if the final precision must be computed
   * analytically.
   *
   * @param {('low'|'medium'|'high')} precision - The precision of the input value in the shader.
   * @return {InputNode} A reference to this node.
   */
  setPrecision(precision) {
    this.precision = precision;
    return this;
  }
  serialize(data) {
    super.serialize(data);
    data.value = this.value;
    if (this.value && this.value.toArray) data.value = this.value.toArray();
    data.valueType = getValueType(this.value);
    data.nodeType = this.nodeType;
    if (data.valueType === "ArrayBuffer") data.value = arrayBufferToBase64(data.value);
    data.precision = this.precision;
  }
  deserialize(data) {
    super.deserialize(data);
    this.nodeType = data.nodeType;
    this.value = Array.isArray(data.value) ? getValueFromType(data.valueType, ...data.value) : data.value;
    this.precision = data.precision || null;
    if (this.value && this.value.fromArray) this.value = this.value.fromArray(data.value);
  }
  generate() {
    console.warn("Abstract function.");
  }
}
class ConstNode extends InputNode {
  static get type() {
    return "ConstNode";
  }
  /**
   * Constructs a new input node.
   *
   * @param {Any} value - The value of this node. Usually a JS primitive or three.js object (vector, matrix, color).
   * @param {String?} nodeType - The node type. If no explicit type is defined, the node tries to derive the type from its value.
   */
  constructor(value, nodeType = null) {
    super(value, nodeType);
    this.isConstNode = true;
  }
  /**
   * Generates the shader string of the value with the current node builder.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {String} The generated value as a shader string.
   */
  generateConst(builder) {
    return builder.generateConst(this.getNodeType(builder), this.value);
  }
  generate(builder, output) {
    const type = this.getNodeType(builder);
    return builder.format(this.generateConst(builder), type, output);
  }
}
let currentStack = null;
const NodeElements = /* @__PURE__ */ new Map();
function addMethodChaining(name, nodeElement) {
  if (NodeElements.has(name)) {
    console.warn(`Redefinition of method chaining ${name}`);
    return;
  }
  if (typeof nodeElement !== "function") throw new Error(`Node element ${name} is not a function`);
  NodeElements.set(name, nodeElement);
}
const parseSwizzle = (props) => props.replace(/r|s/g, "x").replace(/g|t/g, "y").replace(/b|p/g, "z").replace(/a|q/g, "w");
const parseSwizzleAndSort = (props) => parseSwizzle(props).split("").sort().join("");
const shaderNodeHandler = {
  setup(NodeClosure, params) {
    const inputs = params.shift();
    return NodeClosure(nodeObjects(inputs), ...params);
  },
  get(node, prop, nodeObj) {
    if (typeof prop === "string" && node[prop] === void 0) {
      if (node.isStackNode !== true && prop === "assign") {
        return (...params) => {
          currentStack.assign(nodeObj, ...params);
          return nodeObj;
        };
      } else if (NodeElements.has(prop)) {
        const nodeElement = NodeElements.get(prop);
        return node.isStackNode ? (...params) => nodeObj.add(nodeElement(...params)) : (...params) => nodeElement(nodeObj, ...params);
      } else if (prop === "self") {
        return node;
      } else if (prop.endsWith("Assign") && NodeElements.has(prop.slice(0, prop.length - "Assign".length))) {
        const nodeElement = NodeElements.get(prop.slice(0, prop.length - "Assign".length));
        return node.isStackNode ? (...params) => nodeObj.assign(params[0], nodeElement(...params)) : (...params) => nodeObj.assign(nodeElement(nodeObj, ...params));
      } else if (/^[xyzwrgbastpq]{1,4}$/.test(prop) === true) {
        prop = parseSwizzle(prop);
        return nodeObject(new SplitNode(nodeObj, prop));
      } else if (/^set[XYZWRGBASTPQ]{1,4}$/.test(prop) === true) {
        prop = parseSwizzleAndSort(prop.slice(3).toLowerCase());
        return (value) => nodeObject(new SetNode(node, prop, value));
      } else if (/^flip[XYZWRGBASTPQ]{1,4}$/.test(prop) === true) {
        prop = parseSwizzleAndSort(prop.slice(4).toLowerCase());
        return () => nodeObject(new FlipNode(nodeObject(node), prop));
      } else if (prop === "width" || prop === "height" || prop === "depth") {
        if (prop === "width") prop = "x";
        else if (prop === "height") prop = "y";
        else if (prop === "depth") prop = "z";
        return nodeObject(new SplitNode(node, prop));
      } else if (/^\d+$/.test(prop) === true) {
        return nodeObject(new ArrayElementNode(nodeObj, new ConstNode(Number(prop), "uint")));
      }
    }
    return Reflect.get(node, prop, nodeObj);
  },
  set(node, prop, value, nodeObj) {
    if (typeof prop === "string" && node[prop] === void 0) {
      if (/^[xyzwrgbastpq]{1,4}$/.test(prop) === true || prop === "width" || prop === "height" || prop === "depth" || /^\d+$/.test(prop) === true) {
        nodeObj[prop].assign(value);
        return true;
      }
    }
    return Reflect.set(node, prop, value, nodeObj);
  }
};
const nodeObjectsCacheMap = /* @__PURE__ */ new WeakMap();
const nodeBuilderFunctionsCacheMap = /* @__PURE__ */ new WeakMap();
const ShaderNodeObject = function(obj, altType = null) {
  const type = getValueType(obj);
  if (type === "node") {
    let nodeObject2 = nodeObjectsCacheMap.get(obj);
    if (nodeObject2 === void 0) {
      nodeObject2 = new Proxy(obj, shaderNodeHandler);
      nodeObjectsCacheMap.set(obj, nodeObject2);
      nodeObjectsCacheMap.set(nodeObject2, nodeObject2);
    }
    return nodeObject2;
  } else if (altType === null && (type === "float" || type === "boolean") || type && type !== "shader" && type !== "string") {
    return nodeObject(getConstNode(obj, altType));
  } else if (type === "shader") {
    return Fn(obj);
  }
  return obj;
};
const ShaderNodeObjects = function(objects, altType = null) {
  for (const name in objects) {
    objects[name] = nodeObject(objects[name], altType);
  }
  return objects;
};
const ShaderNodeArray = function(array, altType = null) {
  const len = array.length;
  for (let i = 0; i < len; i++) {
    array[i] = nodeObject(array[i], altType);
  }
  return array;
};
const ShaderNodeProxy = function(NodeClass, scope = null, factor = null, settings = null) {
  const assignNode = (node) => nodeObject(settings !== null ? Object.assign(node, settings) : node);
  if (scope === null) {
    return (...params) => {
      return assignNode(new NodeClass(...nodeArray(params)));
    };
  } else if (factor !== null) {
    factor = nodeObject(factor);
    return (...params) => {
      return assignNode(new NodeClass(scope, ...nodeArray(params), factor));
    };
  } else {
    return (...params) => {
      return assignNode(new NodeClass(scope, ...nodeArray(params)));
    };
  }
};
class ShaderCallNodeInternal extends Node {
  constructor(shaderNode, inputNodes) {
    super();
    this.shaderNode = shaderNode;
    this.inputNodes = inputNodes;
  }
  getNodeType(builder) {
    return this.shaderNode.nodeType || this.getOutputNode(builder).getNodeType(builder);
  }
  call(builder) {
    const { shaderNode, inputNodes } = this;
    const properties = builder.getNodeProperties(shaderNode);
    if (properties.onceOutput) return properties.onceOutput;
    let result = null;
    if (shaderNode.layout) {
      let functionNodesCacheMap = nodeBuilderFunctionsCacheMap.get(builder.constructor);
      if (functionNodesCacheMap === void 0) {
        functionNodesCacheMap = /* @__PURE__ */ new WeakMap();
        nodeBuilderFunctionsCacheMap.set(builder.constructor, functionNodesCacheMap);
      }
      let functionNode = functionNodesCacheMap.get(shaderNode);
      if (functionNode === void 0) {
        functionNode = nodeObject(builder.buildFunctionNode(shaderNode));
        functionNodesCacheMap.set(shaderNode, functionNode);
      }
      if (builder.currentFunctionNode !== null) {
        builder.currentFunctionNode.includes.push(functionNode);
      }
      result = nodeObject(functionNode.call(inputNodes));
    } else {
      const jsFunc = shaderNode.jsFunc;
      const outputNode = inputNodes !== null ? jsFunc(inputNodes, builder) : jsFunc(builder);
      result = nodeObject(outputNode);
    }
    if (shaderNode.once) {
      properties.onceOutput = result;
    }
    return result;
  }
  getOutputNode(builder) {
    const properties = builder.getNodeProperties(this);
    if (properties.outputNode === null) {
      properties.outputNode = this.setupOutput(builder);
    }
    return properties.outputNode;
  }
  setup(builder) {
    return this.getOutputNode(builder);
  }
  setupOutput(builder) {
    builder.addStack();
    builder.stack.outputNode = this.call(builder);
    return builder.removeStack();
  }
  generate(builder, output) {
    const outputNode = this.getOutputNode(builder);
    return outputNode.build(builder, output);
  }
}
class ShaderNodeInternal extends Node {
  constructor(jsFunc, nodeType) {
    super(nodeType);
    this.jsFunc = jsFunc;
    this.layout = null;
    this.global = true;
    this.once = false;
  }
  setLayout(layout) {
    this.layout = layout;
    return this;
  }
  call(inputs = null) {
    nodeObjects(inputs);
    return nodeObject(new ShaderCallNodeInternal(this, inputs));
  }
  setup() {
    return this.call();
  }
}
const bools = [false, true];
const uints = [0, 1, 2, 3];
const ints = [-1, -2];
const floats = [0.5, 1.5, 1 / 3, 1e-6, 1e6, Math.PI, Math.PI * 2, 1 / Math.PI, 2 / Math.PI, 1 / (Math.PI * 2), Math.PI / 2];
const boolsCacheMap = /* @__PURE__ */ new Map();
for (const bool2 of bools) boolsCacheMap.set(bool2, new ConstNode(bool2));
const uintsCacheMap = /* @__PURE__ */ new Map();
for (const uint2 of uints) uintsCacheMap.set(uint2, new ConstNode(uint2, "uint"));
const intsCacheMap = new Map([...uintsCacheMap].map((el) => new ConstNode(el.value, "int")));
for (const int2 of ints) intsCacheMap.set(int2, new ConstNode(int2, "int"));
const floatsCacheMap = new Map([...intsCacheMap].map((el) => new ConstNode(el.value)));
for (const float2 of floats) floatsCacheMap.set(float2, new ConstNode(float2));
for (const float2 of floats) floatsCacheMap.set(-float2, new ConstNode(-float2));
const cacheMaps = { bool: boolsCacheMap, uint: uintsCacheMap, ints: intsCacheMap, float: floatsCacheMap };
const constNodesCacheMap = new Map([...boolsCacheMap, ...floatsCacheMap]);
const getConstNode = (value, type) => {
  if (constNodesCacheMap.has(value)) {
    return constNodesCacheMap.get(value);
  } else if (value.isNode === true) {
    return value;
  } else {
    return new ConstNode(value, type);
  }
};
const safeGetNodeType = (node) => {
  try {
    return node.getNodeType();
  } catch (_) {
    return void 0;
  }
};
const ConvertType = function(type, cacheMap = null) {
  return (...params) => {
    if (params.length === 0 || !["bool", "float", "int", "uint"].includes(type) && params.every((param) => typeof param !== "object")) {
      params = [getValueFromType(type, ...params)];
    }
    if (params.length === 1 && cacheMap !== null && cacheMap.has(params[0])) {
      return nodeObject(cacheMap.get(params[0]));
    }
    if (params.length === 1) {
      const node = getConstNode(params[0], type);
      if (safeGetNodeType(node) === type) return nodeObject(node);
      return nodeObject(new ConvertNode(node, type));
    }
    const nodes = params.map((param) => getConstNode(param));
    return nodeObject(new JoinNode(nodes, type));
  };
};
const getConstNodeType = (value) => value !== void 0 && value !== null ? value.nodeType || value.convertTo || (typeof value === "string" ? value : null) : null;
function ShaderNode(jsFunc, nodeType) {
  return new Proxy(new ShaderNodeInternal(jsFunc, nodeType), shaderNodeHandler);
}
const nodeObject = (val, altType = null) => (
  /* new */
  ShaderNodeObject(val, altType)
);
const nodeObjects = (val, altType = null) => new ShaderNodeObjects(val, altType);
const nodeArray = (val, altType = null) => new ShaderNodeArray(val, altType);
const nodeProxy = (...params) => new ShaderNodeProxy(...params);
const Fn = (jsFunc, nodeType) => {
  const shaderNode = new ShaderNode(jsFunc, nodeType);
  const fn = (...params) => {
    let inputs;
    nodeObjects(params);
    if (params[0] && params[0].isNode) {
      inputs = [...params];
    } else {
      inputs = params[0];
    }
    return shaderNode.call(inputs);
  };
  fn.shaderNode = shaderNode;
  fn.setLayout = (layout) => {
    shaderNode.setLayout(layout);
    return fn;
  };
  fn.once = () => {
    shaderNode.once = true;
    return fn;
  };
  return fn;
};
addMethodChaining("toGlobal", (node) => {
  node.global = true;
  return node;
});
function append(node) {
  return node;
}
addMethodChaining("append", append);
const color = new ConvertType("color");
const float = new ConvertType("float", cacheMaps.float);
const int = new ConvertType("int", cacheMaps.ints);
const uint = new ConvertType("uint", cacheMaps.uint);
const bool = new ConvertType("bool", cacheMaps.bool);
const vec2 = new ConvertType("vec2");
const ivec2 = new ConvertType("ivec2");
const uvec2 = new ConvertType("uvec2");
const bvec2 = new ConvertType("bvec2");
const vec3 = new ConvertType("vec3");
const ivec3 = new ConvertType("ivec3");
const uvec3 = new ConvertType("uvec3");
const bvec3 = new ConvertType("bvec3");
const vec4 = new ConvertType("vec4");
const ivec4 = new ConvertType("ivec4");
const uvec4 = new ConvertType("uvec4");
const bvec4 = new ConvertType("bvec4");
const mat2 = new ConvertType("mat2");
const mat3 = new ConvertType("mat3");
const mat4 = new ConvertType("mat4");
addMethodChaining("toColor", color);
addMethodChaining("toFloat", float);
addMethodChaining("toInt", int);
addMethodChaining("toUint", uint);
addMethodChaining("toBool", bool);
addMethodChaining("toVec2", vec2);
addMethodChaining("toIVec2", ivec2);
addMethodChaining("toUVec2", uvec2);
addMethodChaining("toBVec2", bvec2);
addMethodChaining("toVec3", vec3);
addMethodChaining("toIVec3", ivec3);
addMethodChaining("toUVec3", uvec3);
addMethodChaining("toBVec3", bvec3);
addMethodChaining("toVec4", vec4);
addMethodChaining("toIVec4", ivec4);
addMethodChaining("toUVec4", uvec4);
addMethodChaining("toBVec4", bvec4);
addMethodChaining("toMat2", mat2);
addMethodChaining("toMat3", mat3);
addMethodChaining("toMat4", mat4);
const element = /* @__PURE__ */ nodeProxy(ArrayElementNode);
const convert = (node, types) => nodeObject(new ConvertNode(nodeObject(node), types));
addMethodChaining("element", element);
addMethodChaining("convert", convert);
class UniformGroupNode extends Node {
  static get type() {
    return "UniformGroupNode";
  }
  /**
   * Constructs a new uniform group node.
   *
   * @param {String} name - The name of the uniform group node.
   * @param {Boolean} [shared=false] - Whether this uniform group node is shared or not.
   * @param {Number} [order=1] - Influences the internal sorting.
   */
  constructor(name, shared = false, order = 1) {
    super("string");
    this.name = name;
    this.shared = shared;
    this.order = order;
    this.isUniformGroup = true;
  }
  serialize(data) {
    super.serialize(data);
    data.name = this.name;
    data.version = this.version;
    data.shared = this.shared;
  }
  deserialize(data) {
    super.deserialize(data);
    this.name = data.name;
    this.version = data.version;
    this.shared = data.shared;
  }
}
const uniformGroup = (name) => new UniformGroupNode(name);
const sharedUniformGroup = (name, order = 0) => new UniformGroupNode(name, true, order);
const renderGroup = /* @__PURE__ */ sharedUniformGroup("render");
const objectGroup = /* @__PURE__ */ uniformGroup("object");
class UniformNode extends InputNode {
  static get type() {
    return "UniformNode";
  }
  /**
   * Constructs a new uniform node.
   *
   * @param {Any} value - The value of this node. Usually a JS primitive or three.js object (vector, matrix, color, texture).
   * @param {String?} nodeType - The node type. If no explicit type is defined, the node tries to derive the type from its value.
   */
  constructor(value, nodeType = null) {
    super(value, nodeType);
    this.isUniformNode = true;
    this.name = "";
    this.groupNode = objectGroup;
  }
  /**
   * Sets the {@link UniformNode#name} property.
   *
   * @param {String} name - The name of the uniform.
   * @return {UniformNode} A reference to this node.
   */
  label(name) {
    this.name = name;
    return this;
  }
  /**
   * Sets the {@link UniformNode#groupNode} property.
   *
   * @param {UniformGroupNode} group - The uniform group.
   * @return {UniformNode} A reference to this node.
   */
  setGroup(group) {
    this.groupNode = group;
    return this;
  }
  /**
   * Returns the {@link UniformNode#groupNode}.
   *
   * @return {UniformGroupNode} The uniform group.
   */
  getGroup() {
    return this.groupNode;
  }
  /**
   * By default, this method returns the result of {@link Node#getHash} but derived
   * classes might overwrite this method with a different implementation.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {String} The uniform hash.
   */
  getUniformHash(builder) {
    return this.getHash(builder);
  }
  onUpdate(callback, updateType) {
    const self2 = this.getSelf();
    callback = callback.bind(self2);
    return super.onUpdate((frame) => {
      const value = callback(frame, self2);
      if (value !== void 0) {
        this.value = value;
      }
    }, updateType);
  }
  generate(builder, output) {
    const type = this.getNodeType(builder);
    const hash2 = this.getUniformHash(builder);
    let sharedNode = builder.getNodeFromHash(hash2);
    if (sharedNode === void 0) {
      builder.setHashNode(this, hash2);
      sharedNode = this;
    }
    const sharedNodeType = sharedNode.getInputType(builder);
    const nodeUniform = builder.getUniformFromNode(sharedNode, sharedNodeType, builder.shaderStage, this.name || builder.context.label);
    const propertyName = builder.getPropertyName(nodeUniform);
    if (builder.context.label !== void 0) delete builder.context.label;
    return builder.format(propertyName, type, output);
  }
}
const uniform = (arg1, arg2) => {
  const nodeType = getConstNodeType(arg2 || arg1);
  const value = arg1;
  return nodeObject(new UniformNode(value, nodeType));
};
class PropertyNode extends Node {
  static get type() {
    return "PropertyNode";
  }
  /**
   * Constructs a new property node.
   *
   * @param {String} nodeType - The type of the node.
   * @param {String?} [name=null] - The name of the property in the shader.
   * @param {Boolean} [varying=false] - Whether this property is a varying or not.
   */
  constructor(nodeType, name = null, varying2 = false) {
    super(nodeType);
    this.name = name;
    this.varying = varying2;
    this.isPropertyNode = true;
  }
  getHash(builder) {
    return this.name || super.getHash(builder);
  }
  /**
   * The method is overwritten so it always returns `true`.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Boolean} Whether this node is global or not.
   */
  isGlobal() {
    return true;
  }
  generate(builder) {
    let nodeVar;
    if (this.varying === true) {
      nodeVar = builder.getVaryingFromNode(this, this.name);
      nodeVar.needsInterpolation = true;
    } else {
      nodeVar = builder.getVarFromNode(this, this.name);
    }
    return builder.getPropertyName(nodeVar);
  }
}
const property = (type, name) => nodeObject(new PropertyNode(type, name));
class AssignNode extends TempNode {
  static get type() {
    return "AssignNode";
  }
  /**
   * Constructs a new assign node.
   *
   * @param {Node} targetNode - The target node.
   * @param {Node} sourceNode - The source type.
   */
  constructor(targetNode, sourceNode) {
    super();
    this.targetNode = targetNode;
    this.sourceNode = sourceNode;
  }
  /**
   * Whether this node is used more than once in context of other nodes. This method
   * is overwritten since it always returns `false` (assigns are unique).
   *
   * @return {Boolean} A flag that indicates if there is more than one dependency to other nodes. Always `false`.
   */
  hasDependencies() {
    return false;
  }
  getNodeType(builder, output) {
    return output !== "void" ? this.targetNode.getNodeType(builder) : "void";
  }
  /**
   * Whether a split is required when assigning source to target. This can happen when the component length of
   * target and source data type does not match.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Boolean} Whether a split is required when assigning source to target.
   */
  needsSplitAssign(builder) {
    const { targetNode } = this;
    if (builder.isAvailable("swizzleAssign") === false && targetNode.isSplitNode && targetNode.components.length > 1) {
      const targetLength = builder.getTypeLength(targetNode.node.getNodeType(builder));
      const assignDifferentVector = vectorComponents.join("").slice(0, targetLength) !== targetNode.components;
      return assignDifferentVector;
    }
    return false;
  }
  generate(builder, output) {
    const { targetNode, sourceNode } = this;
    const needsSplitAssign = this.needsSplitAssign(builder);
    const targetType = targetNode.getNodeType(builder);
    const target = targetNode.context({ assign: true }).build(builder);
    const source = sourceNode.build(builder, targetType);
    const sourceType = sourceNode.getNodeType(builder);
    const nodeData = builder.getDataFromNode(this);
    let snippet;
    if (nodeData.initialized === true) {
      if (output !== "void") {
        snippet = target;
      }
    } else if (needsSplitAssign) {
      const sourceVar = builder.getVarFromNode(this, null, targetType);
      const sourceProperty = builder.getPropertyName(sourceVar);
      builder.addLineFlowCode(`${sourceProperty} = ${source}`, this);
      const targetRoot = targetNode.node.context({ assign: true }).build(builder);
      for (let i = 0; i < targetNode.components.length; i++) {
        const component = targetNode.components[i];
        builder.addLineFlowCode(`${targetRoot}.${component} = ${sourceProperty}[ ${i} ]`, this);
      }
      if (output !== "void") {
        snippet = target;
      }
    } else {
      snippet = `${target} = ${source}`;
      if (output === "void" || sourceType === "void") {
        builder.addLineFlowCode(snippet, this);
        if (output !== "void") {
          snippet = target;
        }
      }
    }
    nodeData.initialized = true;
    return builder.format(snippet, targetType, output);
  }
}
const assign = /* @__PURE__ */ nodeProxy(AssignNode);
addMethodChaining("assign", assign);
class FunctionCallNode extends TempNode {
  static get type() {
    return "FunctionCallNode";
  }
  /**
   * Constructs a new function call node.
   *
   * @param {FunctionNode?} functionNode - The function node.
   * @param {Object<String, Node>} [parameters={}] - The parameters for the function call.
   */
  constructor(functionNode = null, parameters = {}) {
    super();
    this.functionNode = functionNode;
    this.parameters = parameters;
  }
  /**
   * Sets the parameters of the function call node.
   *
   * @param {Object<String, Node>} parameters - The parameters to set.
   * @return {FunctionCallNode} A reference to this node.
   */
  setParameters(parameters) {
    this.parameters = parameters;
    return this;
  }
  /**
   * Returns the parameters of the function call node.
   *
   * @return {Object<String, Node>} The parameters of this node.
   */
  getParameters() {
    return this.parameters;
  }
  getNodeType(builder) {
    return this.functionNode.getNodeType(builder);
  }
  generate(builder) {
    const params = [];
    const functionNode = this.functionNode;
    const inputs = functionNode.getInputs(builder);
    const parameters = this.parameters;
    const generateInput = (node, inputNode) => {
      const type = inputNode.type;
      const pointer = type === "pointer";
      let output;
      if (pointer) output = "&" + node.build(builder);
      else output = node.build(builder, type);
      return output;
    };
    if (Array.isArray(parameters)) {
      for (let i = 0; i < parameters.length; i++) {
        params.push(generateInput(parameters[i], inputs[i]));
      }
    } else {
      for (const inputNode of inputs) {
        const node = parameters[inputNode.name];
        if (node !== void 0) {
          params.push(generateInput(node, inputNode));
        } else {
          throw new Error(`FunctionCallNode: Input '${inputNode.name}' not found in FunctionNode.`);
        }
      }
    }
    const functionName = functionNode.build(builder, "property");
    return `${functionName}( ${params.join(", ")} )`;
  }
}
const call = (func, ...params) => {
  params = params.length > 1 || params[0] && params[0].isNode === true ? nodeArray(params) : nodeObjects(params[0]);
  return nodeObject(new FunctionCallNode(nodeObject(func), params));
};
addMethodChaining("call", call);
class OperatorNode extends TempNode {
  static get type() {
    return "OperatorNode";
  }
  /**
   * Constructs a new operator node.
   *
   * @param {String} op - The operator.
   * @param {Node} aNode - The first input.
   * @param {Node} bNode - The second input.
   * @param {...Node} params - Additional input parameters.
   */
  constructor(op, aNode, bNode, ...params) {
    super();
    if (params.length > 0) {
      let finalOp = new OperatorNode(op, aNode, bNode);
      for (let i = 0; i < params.length - 1; i++) {
        finalOp = new OperatorNode(op, finalOp, params[i]);
      }
      aNode = finalOp;
      bNode = params[params.length - 1];
    }
    this.op = op;
    this.aNode = aNode;
    this.bNode = bNode;
  }
  /**
   * This method is overwritten since the node type is inferred from the operator
   * and the input node types.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {String} output - The current output string.
   * @return {String} The node type.
   */
  getNodeType(builder, output) {
    const op = this.op;
    const aNode = this.aNode;
    const bNode = this.bNode;
    const typeA = aNode.getNodeType(builder);
    const typeB = typeof bNode !== "undefined" ? bNode.getNodeType(builder) : null;
    if (typeA === "void" || typeB === "void") {
      return "void";
    } else if (op === "%") {
      return typeA;
    } else if (op === "~" || op === "&" || op === "|" || op === "^" || op === ">>" || op === "<<") {
      return builder.getIntegerType(typeA);
    } else if (op === "!" || op === "==" || op === "&&" || op === "||" || op === "^^") {
      return "bool";
    } else if (op === "<" || op === ">" || op === "<=" || op === ">=") {
      const typeLength = output ? builder.getTypeLength(output) : Math.max(builder.getTypeLength(typeA), builder.getTypeLength(typeB));
      return typeLength > 1 ? `bvec${typeLength}` : "bool";
    } else {
      if (typeA === "float" && builder.isMatrix(typeB)) {
        return typeB;
      } else if (builder.isMatrix(typeA) && builder.isVector(typeB)) {
        return builder.getVectorFromMatrix(typeA);
      } else if (builder.isVector(typeA) && builder.isMatrix(typeB)) {
        return builder.getVectorFromMatrix(typeB);
      } else if (builder.getTypeLength(typeB) > builder.getTypeLength(typeA)) {
        return typeB;
      }
      return typeA;
    }
  }
  generate(builder, output) {
    const op = this.op;
    const aNode = this.aNode;
    const bNode = this.bNode;
    const type = this.getNodeType(builder, output);
    let typeA = null;
    let typeB = null;
    if (type !== "void") {
      typeA = aNode.getNodeType(builder);
      typeB = typeof bNode !== "undefined" ? bNode.getNodeType(builder) : null;
      if (op === "<" || op === ">" || op === "<=" || op === ">=" || op === "==") {
        if (builder.isVector(typeA)) {
          typeB = typeA;
        } else if (typeA !== typeB) {
          typeA = typeB = "float";
        }
      } else if (op === ">>" || op === "<<") {
        typeA = type;
        typeB = builder.changeComponentType(typeB, "uint");
      } else if (builder.isMatrix(typeA) && builder.isVector(typeB)) {
        typeB = builder.getVectorFromMatrix(typeA);
      } else if (builder.isVector(typeA) && builder.isMatrix(typeB)) {
        typeA = builder.getVectorFromMatrix(typeB);
      } else {
        typeA = typeB = type;
      }
    } else {
      typeA = typeB = type;
    }
    const a = aNode.build(builder, typeA);
    const b = typeof bNode !== "undefined" ? bNode.build(builder, typeB) : null;
    const outputLength = builder.getTypeLength(output);
    const fnOpSnippet = builder.getFunctionOperator(op);
    if (output !== "void") {
      if (op === "<" && outputLength > 1) {
        if (builder.useComparisonMethod) {
          return builder.format(`${builder.getMethod("lessThan", output)}( ${a}, ${b} )`, type, output);
        } else {
          return builder.format(`( ${a} < ${b} )`, type, output);
        }
      } else if (op === "<=" && outputLength > 1) {
        if (builder.useComparisonMethod) {
          return builder.format(`${builder.getMethod("lessThanEqual", output)}( ${a}, ${b} )`, type, output);
        } else {
          return builder.format(`( ${a} <= ${b} )`, type, output);
        }
      } else if (op === ">" && outputLength > 1) {
        if (builder.useComparisonMethod) {
          return builder.format(`${builder.getMethod("greaterThan", output)}( ${a}, ${b} )`, type, output);
        } else {
          return builder.format(`( ${a} > ${b} )`, type, output);
        }
      } else if (op === ">=" && outputLength > 1) {
        if (builder.useComparisonMethod) {
          return builder.format(`${builder.getMethod("greaterThanEqual", output)}( ${a}, ${b} )`, type, output);
        } else {
          return builder.format(`( ${a} >= ${b} )`, type, output);
        }
      } else if (op === "!" || op === "~") {
        return builder.format(`(${op}${a})`, typeA, output);
      } else if (fnOpSnippet) {
        return builder.format(`${fnOpSnippet}( ${a}, ${b} )`, type, output);
      } else {
        return builder.format(`( ${a} ${op} ${b} )`, type, output);
      }
    } else if (typeA !== "void") {
      if (fnOpSnippet) {
        return builder.format(`${fnOpSnippet}( ${a}, ${b} )`, type, output);
      } else {
        return builder.format(`${a} ${op} ${b}`, type, output);
      }
    }
  }
  serialize(data) {
    super.serialize(data);
    data.op = this.op;
  }
  deserialize(data) {
    super.deserialize(data);
    this.op = data.op;
  }
}
const add = /* @__PURE__ */ nodeProxy(OperatorNode, "+");
const sub = /* @__PURE__ */ nodeProxy(OperatorNode, "-");
const mul = /* @__PURE__ */ nodeProxy(OperatorNode, "*");
const div = /* @__PURE__ */ nodeProxy(OperatorNode, "/");
const modInt = /* @__PURE__ */ nodeProxy(OperatorNode, "%");
const equal = /* @__PURE__ */ nodeProxy(OperatorNode, "==");
const notEqual = /* @__PURE__ */ nodeProxy(OperatorNode, "!=");
const lessThan = /* @__PURE__ */ nodeProxy(OperatorNode, "<");
const greaterThan = /* @__PURE__ */ nodeProxy(OperatorNode, ">");
const lessThanEqual = /* @__PURE__ */ nodeProxy(OperatorNode, "<=");
const greaterThanEqual = /* @__PURE__ */ nodeProxy(OperatorNode, ">=");
const and = /* @__PURE__ */ nodeProxy(OperatorNode, "&&");
const or = /* @__PURE__ */ nodeProxy(OperatorNode, "||");
const not = /* @__PURE__ */ nodeProxy(OperatorNode, "!");
const xor = /* @__PURE__ */ nodeProxy(OperatorNode, "^^");
const bitAnd = /* @__PURE__ */ nodeProxy(OperatorNode, "&");
const bitNot = /* @__PURE__ */ nodeProxy(OperatorNode, "~");
const bitOr = /* @__PURE__ */ nodeProxy(OperatorNode, "|");
const bitXor = /* @__PURE__ */ nodeProxy(OperatorNode, "^");
const shiftLeft = /* @__PURE__ */ nodeProxy(OperatorNode, "<<");
const shiftRight = /* @__PURE__ */ nodeProxy(OperatorNode, ">>");
addMethodChaining("add", add);
addMethodChaining("sub", sub);
addMethodChaining("mul", mul);
addMethodChaining("div", div);
addMethodChaining("modInt", modInt);
addMethodChaining("equal", equal);
addMethodChaining("notEqual", notEqual);
addMethodChaining("lessThan", lessThan);
addMethodChaining("greaterThan", greaterThan);
addMethodChaining("lessThanEqual", lessThanEqual);
addMethodChaining("greaterThanEqual", greaterThanEqual);
addMethodChaining("and", and);
addMethodChaining("or", or);
addMethodChaining("not", not);
addMethodChaining("xor", xor);
addMethodChaining("bitAnd", bitAnd);
addMethodChaining("bitNot", bitNot);
addMethodChaining("bitOr", bitOr);
addMethodChaining("bitXor", bitXor);
addMethodChaining("shiftLeft", shiftLeft);
addMethodChaining("shiftRight", shiftRight);
const remainder = (...params) => {
  console.warn("TSL.OperatorNode: .remainder() has been renamed to .modInt().");
  return modInt(...params);
};
addMethodChaining("remainder", remainder);
class MathNode extends TempNode {
  static get type() {
    return "MathNode";
  }
  /**
   * Constructs a new math node.
   *
   * @param {String} method - The method name.
   * @param {Node} aNode - The first input.
   * @param {Node?} [bNode=null] - The second input.
   * @param {Node?} [cNode=null] - The third input.
   */
  constructor(method, aNode, bNode = null, cNode = null) {
    super();
    this.method = method;
    this.aNode = aNode;
    this.bNode = bNode;
    this.cNode = cNode;
  }
  /**
   * The input type is inferred from the node types of the input nodes.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {String} The input type.
   */
  getInputType(builder) {
    const aType = this.aNode.getNodeType(builder);
    const bType = this.bNode ? this.bNode.getNodeType(builder) : null;
    const cType = this.cNode ? this.cNode.getNodeType(builder) : null;
    const aLen = builder.isMatrix(aType) ? 0 : builder.getTypeLength(aType);
    const bLen = builder.isMatrix(bType) ? 0 : builder.getTypeLength(bType);
    const cLen = builder.isMatrix(cType) ? 0 : builder.getTypeLength(cType);
    if (aLen > bLen && aLen > cLen) {
      return aType;
    } else if (bLen > cLen) {
      return bType;
    } else if (cLen > aLen) {
      return cType;
    }
    return aType;
  }
  /**
   * The selected method as well as the input type determine the node type of this node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {String} The node type.
   */
  getNodeType(builder) {
    const method = this.method;
    if (method === MathNode.LENGTH || method === MathNode.DISTANCE || method === MathNode.DOT) {
      return "float";
    } else if (method === MathNode.CROSS) {
      return "vec3";
    } else if (method === MathNode.ALL) {
      return "bool";
    } else if (method === MathNode.EQUALS) {
      return builder.changeComponentType(this.aNode.getNodeType(builder), "bool");
    } else if (method === MathNode.MOD) {
      return this.aNode.getNodeType(builder);
    } else {
      return this.getInputType(builder);
    }
  }
  generate(builder, output) {
    let method = this.method;
    const type = this.getNodeType(builder);
    const inputType = this.getInputType(builder);
    const a = this.aNode;
    const b = this.bNode;
    const c = this.cNode;
    const coordinateSystem = builder.renderer.coordinateSystem;
    if (method === MathNode.TRANSFORM_DIRECTION) {
      let tA = a;
      let tB = b;
      if (builder.isMatrix(tA.getNodeType(builder))) {
        tB = vec4(vec3(tB), 0);
      } else {
        tA = vec4(vec3(tA), 0);
      }
      const mulNode = mul(tA, tB).xyz;
      return normalize(mulNode).build(builder, output);
    } else if (method === MathNode.NEGATE) {
      return builder.format("( - " + a.build(builder, inputType) + " )", type, output);
    } else if (method === MathNode.ONE_MINUS) {
      return sub(1, a).build(builder, output);
    } else if (method === MathNode.RECIPROCAL) {
      return div(1, a).build(builder, output);
    } else if (method === MathNode.DIFFERENCE) {
      return abs(sub(a, b)).build(builder, output);
    } else {
      const params = [];
      if (method === MathNode.CROSS || method === MathNode.MOD) {
        params.push(
          a.build(builder, type),
          b.build(builder, type)
        );
      } else if (coordinateSystem === WebGLCoordinateSystem && method === MathNode.STEP) {
        params.push(
          a.build(builder, builder.getTypeLength(a.getNodeType(builder)) === 1 ? "float" : inputType),
          b.build(builder, inputType)
        );
      } else if (coordinateSystem === WebGLCoordinateSystem && (method === MathNode.MIN || method === MathNode.MAX) || method === MathNode.MOD) {
        params.push(
          a.build(builder, inputType),
          b.build(builder, builder.getTypeLength(b.getNodeType(builder)) === 1 ? "float" : inputType)
        );
      } else if (method === MathNode.REFRACT) {
        params.push(
          a.build(builder, inputType),
          b.build(builder, inputType),
          c.build(builder, "float")
        );
      } else if (method === MathNode.MIX) {
        params.push(
          a.build(builder, inputType),
          b.build(builder, inputType),
          c.build(builder, builder.getTypeLength(c.getNodeType(builder)) === 1 ? "float" : inputType)
        );
      } else {
        if (coordinateSystem === WebGPUCoordinateSystem && method === MathNode.ATAN && b !== null) {
          method = "atan2";
        }
        params.push(a.build(builder, inputType));
        if (b !== null) params.push(b.build(builder, inputType));
        if (c !== null) params.push(c.build(builder, inputType));
      }
      return builder.format(`${builder.getMethod(method, type)}( ${params.join(", ")} )`, type, output);
    }
  }
  serialize(data) {
    super.serialize(data);
    data.method = this.method;
  }
  deserialize(data) {
    super.deserialize(data);
    this.method = data.method;
  }
}
MathNode.ALL = "all";
MathNode.ANY = "any";
MathNode.RADIANS = "radians";
MathNode.DEGREES = "degrees";
MathNode.EXP = "exp";
MathNode.EXP2 = "exp2";
MathNode.LOG = "log";
MathNode.LOG2 = "log2";
MathNode.SQRT = "sqrt";
MathNode.INVERSE_SQRT = "inversesqrt";
MathNode.FLOOR = "floor";
MathNode.CEIL = "ceil";
MathNode.NORMALIZE = "normalize";
MathNode.FRACT = "fract";
MathNode.SIN = "sin";
MathNode.COS = "cos";
MathNode.TAN = "tan";
MathNode.ASIN = "asin";
MathNode.ACOS = "acos";
MathNode.ATAN = "atan";
MathNode.ABS = "abs";
MathNode.SIGN = "sign";
MathNode.LENGTH = "length";
MathNode.NEGATE = "negate";
MathNode.ONE_MINUS = "oneMinus";
MathNode.DFDX = "dFdx";
MathNode.DFDY = "dFdy";
MathNode.ROUND = "round";
MathNode.RECIPROCAL = "reciprocal";
MathNode.TRUNC = "trunc";
MathNode.FWIDTH = "fwidth";
MathNode.TRANSPOSE = "transpose";
MathNode.BITCAST = "bitcast";
MathNode.EQUALS = "equals";
MathNode.MIN = "min";
MathNode.MAX = "max";
MathNode.MOD = "mod";
MathNode.STEP = "step";
MathNode.REFLECT = "reflect";
MathNode.DISTANCE = "distance";
MathNode.DIFFERENCE = "difference";
MathNode.DOT = "dot";
MathNode.CROSS = "cross";
MathNode.POW = "pow";
MathNode.TRANSFORM_DIRECTION = "transformDirection";
MathNode.MIX = "mix";
MathNode.CLAMP = "clamp";
MathNode.REFRACT = "refract";
MathNode.SMOOTHSTEP = "smoothstep";
MathNode.FACEFORWARD = "faceforward";
const PI = /* @__PURE__ */ float(Math.PI);
const all = /* @__PURE__ */ nodeProxy(MathNode, MathNode.ALL);
const any = /* @__PURE__ */ nodeProxy(MathNode, MathNode.ANY);
const radians = /* @__PURE__ */ nodeProxy(MathNode, MathNode.RADIANS);
const degrees = /* @__PURE__ */ nodeProxy(MathNode, MathNode.DEGREES);
const exp = /* @__PURE__ */ nodeProxy(MathNode, MathNode.EXP);
const exp2 = /* @__PURE__ */ nodeProxy(MathNode, MathNode.EXP2);
const log = /* @__PURE__ */ nodeProxy(MathNode, MathNode.LOG);
const log2 = /* @__PURE__ */ nodeProxy(MathNode, MathNode.LOG2);
const sqrt = /* @__PURE__ */ nodeProxy(MathNode, MathNode.SQRT);
const inverseSqrt = /* @__PURE__ */ nodeProxy(MathNode, MathNode.INVERSE_SQRT);
const floor = /* @__PURE__ */ nodeProxy(MathNode, MathNode.FLOOR);
const ceil = /* @__PURE__ */ nodeProxy(MathNode, MathNode.CEIL);
const normalize = /* @__PURE__ */ nodeProxy(MathNode, MathNode.NORMALIZE);
const fract = /* @__PURE__ */ nodeProxy(MathNode, MathNode.FRACT);
const sin = /* @__PURE__ */ nodeProxy(MathNode, MathNode.SIN);
const cos = /* @__PURE__ */ nodeProxy(MathNode, MathNode.COS);
const tan = /* @__PURE__ */ nodeProxy(MathNode, MathNode.TAN);
const asin = /* @__PURE__ */ nodeProxy(MathNode, MathNode.ASIN);
const acos = /* @__PURE__ */ nodeProxy(MathNode, MathNode.ACOS);
const atan = /* @__PURE__ */ nodeProxy(MathNode, MathNode.ATAN);
const abs = /* @__PURE__ */ nodeProxy(MathNode, MathNode.ABS);
const sign = /* @__PURE__ */ nodeProxy(MathNode, MathNode.SIGN);
const length = /* @__PURE__ */ nodeProxy(MathNode, MathNode.LENGTH);
const negate = /* @__PURE__ */ nodeProxy(MathNode, MathNode.NEGATE);
const oneMinus = /* @__PURE__ */ nodeProxy(MathNode, MathNode.ONE_MINUS);
const dFdx = /* @__PURE__ */ nodeProxy(MathNode, MathNode.DFDX);
const dFdy = /* @__PURE__ */ nodeProxy(MathNode, MathNode.DFDY);
const round = /* @__PURE__ */ nodeProxy(MathNode, MathNode.ROUND);
const reciprocal = /* @__PURE__ */ nodeProxy(MathNode, MathNode.RECIPROCAL);
const trunc = /* @__PURE__ */ nodeProxy(MathNode, MathNode.TRUNC);
const fwidth = /* @__PURE__ */ nodeProxy(MathNode, MathNode.FWIDTH);
const transpose = /* @__PURE__ */ nodeProxy(MathNode, MathNode.TRANSPOSE);
/* @__PURE__ */ nodeProxy(MathNode, MathNode.BITCAST);
const equals = /* @__PURE__ */ nodeProxy(MathNode, MathNode.EQUALS);
const min = /* @__PURE__ */ nodeProxy(MathNode, MathNode.MIN);
const max = /* @__PURE__ */ nodeProxy(MathNode, MathNode.MAX);
const mod = /* @__PURE__ */ nodeProxy(MathNode, MathNode.MOD);
const step = /* @__PURE__ */ nodeProxy(MathNode, MathNode.STEP);
const reflect = /* @__PURE__ */ nodeProxy(MathNode, MathNode.REFLECT);
const distance = /* @__PURE__ */ nodeProxy(MathNode, MathNode.DISTANCE);
const difference = /* @__PURE__ */ nodeProxy(MathNode, MathNode.DIFFERENCE);
const dot = /* @__PURE__ */ nodeProxy(MathNode, MathNode.DOT);
const cross = /* @__PURE__ */ nodeProxy(MathNode, MathNode.CROSS);
const pow = /* @__PURE__ */ nodeProxy(MathNode, MathNode.POW);
const pow2 = /* @__PURE__ */ nodeProxy(MathNode, MathNode.POW, 2);
const pow3 = /* @__PURE__ */ nodeProxy(MathNode, MathNode.POW, 3);
const pow4 = /* @__PURE__ */ nodeProxy(MathNode, MathNode.POW, 4);
const transformDirection = /* @__PURE__ */ nodeProxy(MathNode, MathNode.TRANSFORM_DIRECTION);
const cbrt = (a) => mul(sign(a), pow(abs(a), 1 / 3));
const lengthSq = (a) => dot(a, a);
const mix = /* @__PURE__ */ nodeProxy(MathNode, MathNode.MIX);
const clamp = (value, low = 0, high = 1) => nodeObject(new MathNode(MathNode.CLAMP, nodeObject(value), nodeObject(low), nodeObject(high)));
const saturate = (value) => clamp(value);
const refract = /* @__PURE__ */ nodeProxy(MathNode, MathNode.REFRACT);
const smoothstep = /* @__PURE__ */ nodeProxy(MathNode, MathNode.SMOOTHSTEP);
const faceForward = /* @__PURE__ */ nodeProxy(MathNode, MathNode.FACEFORWARD);
const rand = /* @__PURE__ */ Fn(([uv]) => {
  const a = 12.9898, b = 78.233, c = 43758.5453;
  const dt = dot(uv.xy, vec2(a, b)), sn = mod(dt, PI);
  return fract(sin(sn).mul(c));
});
const mixElement = (t, e1, e2) => mix(e1, e2, t);
const smoothstepElement = (x, low, high) => smoothstep(low, high, x);
const atan2 = (y, x) => {
  console.warn('THREE.TSL: "atan2" is overloaded. Use "atan" instead.');
  return atan(y, x);
};
addMethodChaining("all", all);
addMethodChaining("any", any);
addMethodChaining("equals", equals);
addMethodChaining("radians", radians);
addMethodChaining("degrees", degrees);
addMethodChaining("exp", exp);
addMethodChaining("exp2", exp2);
addMethodChaining("log", log);
addMethodChaining("log2", log2);
addMethodChaining("sqrt", sqrt);
addMethodChaining("inverseSqrt", inverseSqrt);
addMethodChaining("floor", floor);
addMethodChaining("ceil", ceil);
addMethodChaining("normalize", normalize);
addMethodChaining("fract", fract);
addMethodChaining("sin", sin);
addMethodChaining("cos", cos);
addMethodChaining("tan", tan);
addMethodChaining("asin", asin);
addMethodChaining("acos", acos);
addMethodChaining("atan", atan);
addMethodChaining("abs", abs);
addMethodChaining("sign", sign);
addMethodChaining("length", length);
addMethodChaining("lengthSq", lengthSq);
addMethodChaining("negate", negate);
addMethodChaining("oneMinus", oneMinus);
addMethodChaining("dFdx", dFdx);
addMethodChaining("dFdy", dFdy);
addMethodChaining("round", round);
addMethodChaining("reciprocal", reciprocal);
addMethodChaining("trunc", trunc);
addMethodChaining("fwidth", fwidth);
addMethodChaining("atan2", atan2);
addMethodChaining("min", min);
addMethodChaining("max", max);
addMethodChaining("mod", mod);
addMethodChaining("step", step);
addMethodChaining("reflect", reflect);
addMethodChaining("distance", distance);
addMethodChaining("dot", dot);
addMethodChaining("cross", cross);
addMethodChaining("pow", pow);
addMethodChaining("pow2", pow2);
addMethodChaining("pow3", pow3);
addMethodChaining("pow4", pow4);
addMethodChaining("transformDirection", transformDirection);
addMethodChaining("mix", mixElement);
addMethodChaining("clamp", clamp);
addMethodChaining("refract", refract);
addMethodChaining("smoothstep", smoothstepElement);
addMethodChaining("faceForward", faceForward);
addMethodChaining("difference", difference);
addMethodChaining("saturate", saturate);
addMethodChaining("cbrt", cbrt);
addMethodChaining("transpose", transpose);
addMethodChaining("rand", rand);
class ConditionalNode extends Node {
  static get type() {
    return "ConditionalNode";
  }
  /**
   * Constructs a new conditional node.
   *
   * @param {Node} condNode - The node that defines the condition.
   * @param {Node} ifNode - The node that is evaluate when the condition ends up `true`.
   * @param {Node?} [elseNode=null] - The node that is evaluate when the condition ends up `false`.
   */
  constructor(condNode, ifNode, elseNode = null) {
    super();
    this.condNode = condNode;
    this.ifNode = ifNode;
    this.elseNode = elseNode;
  }
  /**
   * This method is overwritten since the node type is inferred from the if/else
   * nodes.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {String} The node type.
   */
  getNodeType(builder) {
    const { ifNode, elseNode } = builder.getNodeProperties(this);
    if (ifNode === void 0) {
      this.setup(builder);
      return this.getNodeType(builder);
    }
    const ifType = ifNode.getNodeType(builder);
    if (elseNode !== null) {
      const elseType = elseNode.getNodeType(builder);
      if (builder.getTypeLength(elseType) > builder.getTypeLength(ifType)) {
        return elseType;
      }
    }
    return ifType;
  }
  setup(builder) {
    const condNode = this.condNode.cache();
    const ifNode = this.ifNode.cache();
    const elseNode = this.elseNode ? this.elseNode.cache() : null;
    const currentNodeBlock = builder.context.nodeBlock;
    builder.getDataFromNode(ifNode).parentNodeBlock = currentNodeBlock;
    if (elseNode !== null) builder.getDataFromNode(elseNode).parentNodeBlock = currentNodeBlock;
    const properties = builder.getNodeProperties(this);
    properties.condNode = condNode;
    properties.ifNode = ifNode.context({ nodeBlock: ifNode });
    properties.elseNode = elseNode ? elseNode.context({ nodeBlock: elseNode }) : null;
  }
  generate(builder, output) {
    const type = this.getNodeType(builder);
    const nodeData = builder.getDataFromNode(this);
    if (nodeData.nodeProperty !== void 0) {
      return nodeData.nodeProperty;
    }
    const { condNode, ifNode, elseNode } = builder.getNodeProperties(this);
    const needsOutput = output !== "void";
    const nodeProperty = needsOutput ? property(type).build(builder) : "";
    nodeData.nodeProperty = nodeProperty;
    const nodeSnippet = condNode.build(builder, "bool");
    builder.addFlowCode(`
${builder.tab}if ( ${nodeSnippet} ) {

`).addFlowTab();
    let ifSnippet = ifNode.build(builder, type);
    if (ifSnippet) {
      if (needsOutput) {
        ifSnippet = nodeProperty + " = " + ifSnippet + ";";
      } else {
        ifSnippet = "return " + ifSnippet + ";";
      }
    }
    builder.removeFlowTab().addFlowCode(builder.tab + "	" + ifSnippet + "\n\n" + builder.tab + "}");
    if (elseNode !== null) {
      builder.addFlowCode(" else {\n\n").addFlowTab();
      let elseSnippet = elseNode.build(builder, type);
      if (elseSnippet) {
        if (needsOutput) {
          elseSnippet = nodeProperty + " = " + elseSnippet + ";";
        } else {
          elseSnippet = "return " + elseSnippet + ";";
        }
      }
      builder.removeFlowTab().addFlowCode(builder.tab + "	" + elseSnippet + "\n\n" + builder.tab + "}\n\n");
    } else {
      builder.addFlowCode("\n\n");
    }
    return builder.format(nodeProperty, type, output);
  }
}
const select = /* @__PURE__ */ nodeProxy(ConditionalNode);
addMethodChaining("select", select);
const cond = (...params) => {
  console.warn("TSL.ConditionalNode: cond() has been renamed to select().");
  return select(...params);
};
addMethodChaining("cond", cond);
class ContextNode extends Node {
  static get type() {
    return "ContextNode";
  }
  /**
   * Constructs a new context node.
   *
   * @param {Node} node - The node whose context should be modified.
   * @param {Object} [value={}] - The modified context data.
   */
  constructor(node, value = {}) {
    super();
    this.isContextNode = true;
    this.node = node;
    this.value = value;
  }
  /**
   * This method is overwritten to ensure it returns the reference to {@link module:ContextNode~ContextNode#node}.
   *
   * @return {Node} A reference to {@link module:ContextNode~ContextNode#node}.
   */
  getScope() {
    return this.node.getScope();
  }
  /**
   * This method is overwritten to ensure it returns the type of {@link module:ContextNode~ContextNode#node}.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {String} The node type.
   */
  getNodeType(builder) {
    return this.node.getNodeType(builder);
  }
  analyze(builder) {
    this.node.build(builder);
  }
  setup(builder) {
    const previousContext = builder.getContext();
    builder.setContext({ ...builder.context, ...this.value });
    const node = this.node.build(builder);
    builder.setContext(previousContext);
    return node;
  }
  generate(builder, output) {
    const previousContext = builder.getContext();
    builder.setContext({ ...builder.context, ...this.value });
    const snippet = this.node.build(builder, output);
    builder.setContext(previousContext);
    return snippet;
  }
}
const context = /* @__PURE__ */ nodeProxy(ContextNode);
const label = (node, name) => context(node, { label: name });
addMethodChaining("context", context);
addMethodChaining("label", label);
class VarNode extends Node {
  static get type() {
    return "VarNode";
  }
  /**
   * Constructs a new variable node.
   *
   * @param {Node} node - The node for which a variable should be created.
   * @param {String?} name - The name of the variable in the shader.
   */
  constructor(node, name = null) {
    super();
    this.node = node;
    this.name = name;
    this.global = true;
    this.isVarNode = true;
  }
  getHash(builder) {
    return this.name || super.getHash(builder);
  }
  getNodeType(builder) {
    return this.node.getNodeType(builder);
  }
  generate(builder) {
    const { node, name } = this;
    const nodeVar = builder.getVarFromNode(this, name, builder.getVectorType(this.getNodeType(builder)));
    const propertyName = builder.getPropertyName(nodeVar);
    const snippet = node.build(builder, nodeVar.type);
    builder.addLineFlowCode(`${propertyName} = ${snippet}`, this);
    return propertyName;
  }
}
const createVar = /* @__PURE__ */ nodeProxy(VarNode);
addMethodChaining("toVar", (...params) => createVar(...params).append());
const temp = (node) => {
  console.warn('TSL: "temp" is deprecated. Use ".toVar()" instead.');
  return createVar(node);
};
addMethodChaining("temp", temp);
class VaryingNode extends Node {
  static get type() {
    return "VaryingNode";
  }
  /**
   * Constructs a new varying node.
   *
   * @param {Node} node - The node for which a varying should be created.
   * @param {String?} name - The name of the varying in the shader.
   */
  constructor(node, name = null) {
    super();
    this.node = node;
    this.name = name;
    this.isVaryingNode = true;
  }
  /**
   * The method is overwritten so it always returns `true`.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Boolean} Whether this node is global or not.
   */
  isGlobal() {
    return true;
  }
  getHash(builder) {
    return this.name || super.getHash(builder);
  }
  getNodeType(builder) {
    return this.node.getNodeType(builder);
  }
  /**
   * This method performs the setup of a varying node with the current node builder.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {NodeVarying} The node varying from the node builder.
   */
  setupVarying(builder) {
    const properties = builder.getNodeProperties(this);
    let varying2 = properties.varying;
    if (varying2 === void 0) {
      const name = this.name;
      const type = this.getNodeType(builder);
      properties.varying = varying2 = builder.getVaryingFromNode(this, name, type);
      properties.node = this.node;
    }
    varying2.needsInterpolation || (varying2.needsInterpolation = builder.shaderStage === "fragment");
    return varying2;
  }
  setup(builder) {
    this.setupVarying(builder);
  }
  analyze(builder) {
    this.setupVarying(builder);
    return this.node.analyze(builder);
  }
  generate(builder) {
    const properties = builder.getNodeProperties(this);
    const varying2 = this.setupVarying(builder);
    const needsReassign = builder.shaderStage === "fragment" && properties.reassignPosition === true && builder.context.needsPositionReassign;
    if (properties.propertyName === void 0 || needsReassign) {
      const type = this.getNodeType(builder);
      const propertyName = builder.getPropertyName(varying2, NodeShaderStage.VERTEX);
      builder.flowNodeFromShaderStage(NodeShaderStage.VERTEX, this.node, type, propertyName);
      properties.propertyName = propertyName;
      if (needsReassign) {
        properties.reassignPosition = false;
      } else if (properties.reassignPosition === void 0 && builder.context.isPositionNodeInput) {
        properties.reassignPosition = true;
      }
    }
    return builder.getPropertyName(varying2);
  }
}
const varying = /* @__PURE__ */ nodeProxy(VaryingNode);
const vertexStage = (node) => varying(node);
addMethodChaining("varying", varying);
addMethodChaining("vertexStage", vertexStage);
const sRGBTransferEOTF = /* @__PURE__ */ Fn(([color2]) => {
  const a = color2.mul(0.9478672986).add(0.0521327014).pow(2.4);
  const b = color2.mul(0.0773993808);
  const factor = color2.lessThanEqual(0.04045);
  const rgbResult = mix(a, b, factor);
  return rgbResult;
}).setLayout({
  name: "sRGBTransferEOTF",
  type: "vec3",
  inputs: [
    { name: "color", type: "vec3" }
  ]
});
const sRGBTransferOETF = /* @__PURE__ */ Fn(([color2]) => {
  const a = color2.pow(0.41666).mul(1.055).sub(0.055);
  const b = color2.mul(12.92);
  const factor = color2.lessThanEqual(31308e-7);
  const rgbResult = mix(a, b, factor);
  return rgbResult;
}).setLayout({
  name: "sRGBTransferOETF",
  type: "vec3",
  inputs: [
    { name: "color", type: "vec3" }
  ]
});
const WORKING_COLOR_SPACE = "WorkingColorSpace";
const OUTPUT_COLOR_SPACE = "OutputColorSpace";
class ColorSpaceNode extends TempNode {
  static get type() {
    return "ColorSpaceNode";
  }
  /**
   * Constructs a new color space node.
   *
   * @param {Node} colorNode - Represents the color to convert.
   * @param {String} source - The source color space.
   * @param {String} target - The target color space.
   */
  constructor(colorNode, source, target) {
    super("vec4");
    this.colorNode = colorNode;
    this.source = source;
    this.target = target;
  }
  /**
   * This method resolves the constants `WORKING_COLOR_SPACE` and
   * `OUTPUT_COLOR_SPACE` based on the current configuration of the
   * color management and renderer.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {String} colorSpace - The color space to resolve.
   * @return {String} The resolved color space.
   */
  resolveColorSpace(builder, colorSpace) {
    if (colorSpace === WORKING_COLOR_SPACE) {
      return ColorManagement.workingColorSpace;
    } else if (colorSpace === OUTPUT_COLOR_SPACE) {
      return builder.context.outputColorSpace || builder.renderer.outputColorSpace;
    }
    return colorSpace;
  }
  setup(builder) {
    const { colorNode } = this;
    const source = this.resolveColorSpace(builder, this.source);
    const target = this.resolveColorSpace(builder, this.target);
    let outputNode = colorNode;
    if (ColorManagement.enabled === false || source === target || !source || !target) {
      return outputNode;
    }
    if (ColorManagement.getTransfer(source) === SRGBTransfer) {
      outputNode = vec4(sRGBTransferEOTF(outputNode.rgb), outputNode.a);
    }
    if (ColorManagement.getPrimaries(source) !== ColorManagement.getPrimaries(target)) {
      outputNode = vec4(
        mat3(ColorManagement._getMatrix(new Matrix32(), source, target)).mul(outputNode.rgb),
        outputNode.a
      );
    }
    if (ColorManagement.getTransfer(target) === SRGBTransfer) {
      outputNode = vec4(sRGBTransferOETF(outputNode.rgb), outputNode.a);
    }
    return outputNode;
  }
}
const toOutputColorSpace = (node) => nodeObject(new ColorSpaceNode(nodeObject(node), WORKING_COLOR_SPACE, OUTPUT_COLOR_SPACE));
const toWorkingColorSpace = (node) => nodeObject(new ColorSpaceNode(nodeObject(node), OUTPUT_COLOR_SPACE, WORKING_COLOR_SPACE));
const workingToColorSpace = (node, colorSpace) => nodeObject(new ColorSpaceNode(nodeObject(node), WORKING_COLOR_SPACE, colorSpace));
const colorSpaceToWorking = (node, colorSpace) => nodeObject(new ColorSpaceNode(nodeObject(node), colorSpace, WORKING_COLOR_SPACE));
addMethodChaining("toOutputColorSpace", toOutputColorSpace);
addMethodChaining("toWorkingColorSpace", toWorkingColorSpace);
addMethodChaining("workingToColorSpace", workingToColorSpace);
addMethodChaining("colorSpaceToWorking", colorSpaceToWorking);
class ReferenceElementNode extends ArrayElementNode {
  static get type() {
    return "ReferenceElementNode";
  }
  /**
   * Constructs a new reference element node.
   *
   * @param {Node?} referenceNode - The reference node.
   * @param {Node} indexNode - The index node that defines the element access.
   */
  constructor(referenceNode, indexNode) {
    super(referenceNode, indexNode);
    this.referenceNode = referenceNode;
    this.isReferenceElementNode = true;
  }
  /**
   * This method is overwritten since the node type is inferred from
   * the uniform type of the reference node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {String} The node type.
   */
  getNodeType() {
    return this.referenceNode.uniformType;
  }
  generate(builder) {
    const snippet = super.generate(builder);
    const arrayType = this.referenceNode.getNodeType();
    const elementType = this.getNodeType();
    return builder.format(snippet, arrayType, elementType);
  }
}
class ReferenceBaseNode extends Node {
  static get type() {
    return "ReferenceBaseNode";
  }
  /**
   * Constructs a new reference base node.
   *
   * @param {String} property - The name of the property the node refers to.
   * @param {String} uniformType - The uniform type that should be used to represent the property value.
   * @param {Object?} [object=null] - The object the property belongs to.
   * @param {Number?} [count=null] - When the linked property is an array-like, this parameter defines its length.
   */
  constructor(property2, uniformType, object = null, count = null) {
    super();
    this.property = property2;
    this.uniformType = uniformType;
    this.object = object;
    this.count = count;
    this.properties = property2.split(".");
    this.reference = object;
    this.node = null;
    this.group = null;
    this.updateType = NodeUpdateType.OBJECT;
  }
  /**
   * Sets the uniform group for this reference node.
   *
   * @param {UniformGroupNode} group - The uniform group to set.
   * @return {ReferenceBaseNode} A reference to this node.
   */
  setGroup(group) {
    this.group = group;
    return this;
  }
  /**
   * When the referred property is array-like, this method can be used
   * to access elements via an index node.
   *
   * @param {IndexNode} indexNode - indexNode.
   * @return {ReferenceElementNode} A reference to an element.
   */
  element(indexNode) {
    return nodeObject(new ReferenceElementNode(this, nodeObject(indexNode)));
  }
  /**
   * Sets the node type which automatically defines the internal
   * uniform type.
   *
   * @param {String} uniformType - The type to set.
   */
  setNodeType(uniformType) {
    const node = uniform(null, uniformType).getSelf();
    if (this.group !== null) {
      node.setGroup(this.group);
    }
    this.node = node;
  }
  /**
   * This method is overwritten since the node type is inferred from
   * the type of the reference node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {String} The node type.
   */
  getNodeType(builder) {
    if (this.node === null) {
      this.updateReference(builder);
      this.updateValue();
    }
    return this.node.getNodeType(builder);
  }
  /**
   * Returns the property value from the given referred object.
   *
   * @param {Object} [object=this.reference] - The object to retrieve the property value from.
   * @return {Any} The value.
   */
  getValueFromReference(object = this.reference) {
    const { properties } = this;
    let value = object[properties[0]];
    for (let i = 1; i < properties.length; i++) {
      value = value[properties[i]];
    }
    return value;
  }
  /**
   * Allows to update the reference based on the given state. The state is only
   * evaluated {@link module:ReferenceBaseNode~ReferenceBaseNode#object} is not set.
   *
   * @param {(NodeFrame|NodeBuilder)} state - The current state.
   * @return {Object} The updated reference.
   */
  updateReference(state) {
    this.reference = this.object !== null ? this.object : state.object;
    return this.reference;
  }
  /**
   * The output of the reference node is the internal uniform node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {UniformNode} The output node.
   */
  setup() {
    this.updateValue();
    return this.node;
  }
  /**
   * Overwritten to to update the internal uniform value.
   *
   * @param {NodeFrame} frame - A reference to the current node frame.
   */
  update() {
    this.updateValue();
  }
  /**
   * Retrieves the value from the referred object property and uses it
   * to updated the internal uniform.
   */
  updateValue() {
    if (this.node === null) this.setNodeType(this.uniformType);
    const value = this.getValueFromReference();
    if (Array.isArray(value)) {
      this.node.array = value;
    } else {
      this.node.value = value;
    }
  }
}
class RendererReferenceNode extends ReferenceBaseNode {
  static get type() {
    return "RendererReferenceNode";
  }
  /**
   * Constructs a new renderer reference node.
   *
   * @param {String} property - The name of the property the node refers to.
   * @param {String} inputType - The uniform type that should be used to represent the property value.
   * @param {Renderer?} [renderer=null] - The renderer the property belongs to. When no renderer is set,
   * the node refers to the renderer of the current state.
   */
  constructor(property2, inputType, renderer = null) {
    super(property2, inputType, renderer);
    this.renderer = renderer;
    this.setGroup(renderGroup);
  }
  /**
   * Updates the reference based on the given state. The state is only evaluated
   * {@link module:RendererReferenceNode~RendererReferenceNode#renderer} is not set.
   *
   * @param {(NodeFrame|NodeBuilder)} state - The current state.
   * @return {Object} The updated reference.
   */
  updateReference(state) {
    this.reference = this.renderer !== null ? this.renderer : state.renderer;
    return this.reference;
  }
}
const rendererReference = (name, type, renderer = null) => nodeObject(new RendererReferenceNode(name, type, renderer));
class ToneMappingNode extends TempNode {
  static get type() {
    return "ToneMappingNode";
  }
  /**
   * Constructs a new tone mapping node.
   *
   * @param {Number} toneMapping - The tone mapping type.
   * @param {Node} exposureNode - The tone mapping exposure.
   * @param {Node} [colorNode=null] - The color node to process.
   */
  constructor(toneMapping2, exposureNode = toneMappingExposure, colorNode = null) {
    super("vec3");
    this.toneMapping = toneMapping2;
    this.exposureNode = exposureNode;
    this.colorNode = colorNode;
  }
  /**
   * Overwrites the default `customCacheKey()` implementation by including the tone
   * mapping type into the cache key.
   *
   * @return {Number} The hash.
   */
  customCacheKey() {
    return hash(this.toneMapping);
  }
  setup(builder) {
    const colorNode = this.colorNode || builder.context.color;
    const toneMapping2 = this.toneMapping;
    if (toneMapping2 === NoToneMapping) return colorNode;
    let outputNode = null;
    const toneMappingFn = builder.renderer.library.getToneMappingFunction(toneMapping2);
    if (toneMappingFn !== null) {
      outputNode = vec4(toneMappingFn(colorNode.rgb, this.exposureNode), colorNode.a);
    } else {
      console.error("ToneMappingNode: Unsupported Tone Mapping configuration.", toneMapping2);
      outputNode = colorNode;
    }
    return outputNode;
  }
}
const toneMapping = (mapping, exposure, color2) => nodeObject(new ToneMappingNode(mapping, nodeObject(exposure), nodeObject(color2)));
const toneMappingExposure = /* @__PURE__ */ rendererReference("toneMappingExposure", "float");
addMethodChaining("toneMapping", (color2, mapping, exposure) => toneMapping(mapping, exposure, color2));
const _vector$1 = /* @__PURE__ */ new Vector32();
const _vector2 = /* @__PURE__ */ new Vector22();
class BufferAttribute2 {
  constructor(array, itemSize, normalized = false) {
    if (Array.isArray(array)) {
      throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
    }
    this.isBufferAttribute = true;
    this.name = "";
    this.array = array;
    this.itemSize = itemSize;
    this.count = array !== void 0 ? array.length / itemSize : 0;
    this.normalized = normalized;
    this.usage = StaticDrawUsage;
    this.updateRanges = [];
    this.gpuType = FloatType;
    this.version = 0;
  }
  onUploadCallback() {
  }
  set needsUpdate(value) {
    if (value === true) this.version++;
  }
  setUsage(value) {
    this.usage = value;
    return this;
  }
  addUpdateRange(start, count) {
    this.updateRanges.push({ start, count });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(source) {
    this.name = source.name;
    this.array = new source.array.constructor(source.array);
    this.itemSize = source.itemSize;
    this.count = source.count;
    this.normalized = source.normalized;
    this.usage = source.usage;
    this.gpuType = source.gpuType;
    return this;
  }
  copyAt(index1, attribute, index2) {
    index1 *= this.itemSize;
    index2 *= attribute.itemSize;
    for (let i = 0, l = this.itemSize; i < l; i++) {
      this.array[index1 + i] = attribute.array[index2 + i];
    }
    return this;
  }
  copyArray(array) {
    this.array.set(array);
    return this;
  }
  applyMatrix3(m) {
    if (this.itemSize === 2) {
      for (let i = 0, l = this.count; i < l; i++) {
        _vector2.fromBufferAttribute(this, i);
        _vector2.applyMatrix3(m);
        this.setXY(i, _vector2.x, _vector2.y);
      }
    } else if (this.itemSize === 3) {
      for (let i = 0, l = this.count; i < l; i++) {
        _vector$1.fromBufferAttribute(this, i);
        _vector$1.applyMatrix3(m);
        this.setXYZ(i, _vector$1.x, _vector$1.y, _vector$1.z);
      }
    }
    return this;
  }
  applyMatrix4(m) {
    for (let i = 0, l = this.count; i < l; i++) {
      _vector$1.fromBufferAttribute(this, i);
      _vector$1.applyMatrix4(m);
      this.setXYZ(i, _vector$1.x, _vector$1.y, _vector$1.z);
    }
    return this;
  }
  applyNormalMatrix(m) {
    for (let i = 0, l = this.count; i < l; i++) {
      _vector$1.fromBufferAttribute(this, i);
      _vector$1.applyNormalMatrix(m);
      this.setXYZ(i, _vector$1.x, _vector$1.y, _vector$1.z);
    }
    return this;
  }
  transformDirection(m) {
    for (let i = 0, l = this.count; i < l; i++) {
      _vector$1.fromBufferAttribute(this, i);
      _vector$1.transformDirection(m);
      this.setXYZ(i, _vector$1.x, _vector$1.y, _vector$1.z);
    }
    return this;
  }
  set(value, offset = 0) {
    this.array.set(value, offset);
    return this;
  }
  getComponent(index, component) {
    let value = this.array[index * this.itemSize + component];
    if (this.normalized) value = denormalize(value, this.array);
    return value;
  }
  setComponent(index, component, value) {
    if (this.normalized) value = normalize$1(value, this.array);
    this.array[index * this.itemSize + component] = value;
    return this;
  }
  getX(index) {
    let x = this.array[index * this.itemSize];
    if (this.normalized) x = denormalize(x, this.array);
    return x;
  }
  setX(index, x) {
    if (this.normalized) x = normalize$1(x, this.array);
    this.array[index * this.itemSize] = x;
    return this;
  }
  getY(index) {
    let y = this.array[index * this.itemSize + 1];
    if (this.normalized) y = denormalize(y, this.array);
    return y;
  }
  setY(index, y) {
    if (this.normalized) y = normalize$1(y, this.array);
    this.array[index * this.itemSize + 1] = y;
    return this;
  }
  getZ(index) {
    let z = this.array[index * this.itemSize + 2];
    if (this.normalized) z = denormalize(z, this.array);
    return z;
  }
  setZ(index, z) {
    if (this.normalized) z = normalize$1(z, this.array);
    this.array[index * this.itemSize + 2] = z;
    return this;
  }
  getW(index) {
    let w = this.array[index * this.itemSize + 3];
    if (this.normalized) w = denormalize(w, this.array);
    return w;
  }
  setW(index, w) {
    if (this.normalized) w = normalize$1(w, this.array);
    this.array[index * this.itemSize + 3] = w;
    return this;
  }
  setXY(index, x, y) {
    index *= this.itemSize;
    if (this.normalized) {
      x = normalize$1(x, this.array);
      y = normalize$1(y, this.array);
    }
    this.array[index + 0] = x;
    this.array[index + 1] = y;
    return this;
  }
  setXYZ(index, x, y, z) {
    index *= this.itemSize;
    if (this.normalized) {
      x = normalize$1(x, this.array);
      y = normalize$1(y, this.array);
      z = normalize$1(z, this.array);
    }
    this.array[index + 0] = x;
    this.array[index + 1] = y;
    this.array[index + 2] = z;
    return this;
  }
  setXYZW(index, x, y, z, w) {
    index *= this.itemSize;
    if (this.normalized) {
      x = normalize$1(x, this.array);
      y = normalize$1(y, this.array);
      z = normalize$1(z, this.array);
      w = normalize$1(w, this.array);
    }
    this.array[index + 0] = x;
    this.array[index + 1] = y;
    this.array[index + 2] = z;
    this.array[index + 3] = w;
    return this;
  }
  onUpload(callback) {
    this.onUploadCallback = callback;
    return this;
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const data = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.from(this.array),
      normalized: this.normalized
    };
    if (this.name !== "") data.name = this.name;
    if (this.usage !== StaticDrawUsage) data.usage = this.usage;
    return data;
  }
}
const _vector = /* @__PURE__ */ new Vector32();
class InterleavedBufferAttribute2 {
  constructor(interleavedBuffer, itemSize, offset, normalized = false) {
    this.isInterleavedBufferAttribute = true;
    this.name = "";
    this.data = interleavedBuffer;
    this.itemSize = itemSize;
    this.offset = offset;
    this.normalized = normalized;
  }
  get count() {
    return this.data.count;
  }
  get array() {
    return this.data.array;
  }
  set needsUpdate(value) {
    this.data.needsUpdate = value;
  }
  applyMatrix4(m) {
    for (let i = 0, l = this.data.count; i < l; i++) {
      _vector.fromBufferAttribute(this, i);
      _vector.applyMatrix4(m);
      this.setXYZ(i, _vector.x, _vector.y, _vector.z);
    }
    return this;
  }
  applyNormalMatrix(m) {
    for (let i = 0, l = this.count; i < l; i++) {
      _vector.fromBufferAttribute(this, i);
      _vector.applyNormalMatrix(m);
      this.setXYZ(i, _vector.x, _vector.y, _vector.z);
    }
    return this;
  }
  transformDirection(m) {
    for (let i = 0, l = this.count; i < l; i++) {
      _vector.fromBufferAttribute(this, i);
      _vector.transformDirection(m);
      this.setXYZ(i, _vector.x, _vector.y, _vector.z);
    }
    return this;
  }
  getComponent(index, component) {
    let value = this.array[index * this.data.stride + this.offset + component];
    if (this.normalized) value = denormalize(value, this.array);
    return value;
  }
  setComponent(index, component, value) {
    if (this.normalized) value = normalize$1(value, this.array);
    this.data.array[index * this.data.stride + this.offset + component] = value;
    return this;
  }
  setX(index, x) {
    if (this.normalized) x = normalize$1(x, this.array);
    this.data.array[index * this.data.stride + this.offset] = x;
    return this;
  }
  setY(index, y) {
    if (this.normalized) y = normalize$1(y, this.array);
    this.data.array[index * this.data.stride + this.offset + 1] = y;
    return this;
  }
  setZ(index, z) {
    if (this.normalized) z = normalize$1(z, this.array);
    this.data.array[index * this.data.stride + this.offset + 2] = z;
    return this;
  }
  setW(index, w) {
    if (this.normalized) w = normalize$1(w, this.array);
    this.data.array[index * this.data.stride + this.offset + 3] = w;
    return this;
  }
  getX(index) {
    let x = this.data.array[index * this.data.stride + this.offset];
    if (this.normalized) x = denormalize(x, this.array);
    return x;
  }
  getY(index) {
    let y = this.data.array[index * this.data.stride + this.offset + 1];
    if (this.normalized) y = denormalize(y, this.array);
    return y;
  }
  getZ(index) {
    let z = this.data.array[index * this.data.stride + this.offset + 2];
    if (this.normalized) z = denormalize(z, this.array);
    return z;
  }
  getW(index) {
    let w = this.data.array[index * this.data.stride + this.offset + 3];
    if (this.normalized) w = denormalize(w, this.array);
    return w;
  }
  setXY(index, x, y) {
    index = index * this.data.stride + this.offset;
    if (this.normalized) {
      x = normalize$1(x, this.array);
      y = normalize$1(y, this.array);
    }
    this.data.array[index + 0] = x;
    this.data.array[index + 1] = y;
    return this;
  }
  setXYZ(index, x, y, z) {
    index = index * this.data.stride + this.offset;
    if (this.normalized) {
      x = normalize$1(x, this.array);
      y = normalize$1(y, this.array);
      z = normalize$1(z, this.array);
    }
    this.data.array[index + 0] = x;
    this.data.array[index + 1] = y;
    this.data.array[index + 2] = z;
    return this;
  }
  setXYZW(index, x, y, z, w) {
    index = index * this.data.stride + this.offset;
    if (this.normalized) {
      x = normalize$1(x, this.array);
      y = normalize$1(y, this.array);
      z = normalize$1(z, this.array);
      w = normalize$1(w, this.array);
    }
    this.data.array[index + 0] = x;
    this.data.array[index + 1] = y;
    this.data.array[index + 2] = z;
    this.data.array[index + 3] = w;
    return this;
  }
  clone(data) {
    if (data === void 0) {
      console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
      const array = [];
      for (let i = 0; i < this.count; i++) {
        const index = i * this.data.stride + this.offset;
        for (let j = 0; j < this.itemSize; j++) {
          array.push(this.data.array[index + j]);
        }
      }
      return new BufferAttribute2(new this.array.constructor(array), this.itemSize, this.normalized);
    } else {
      if (data.interleavedBuffers === void 0) {
        data.interleavedBuffers = {};
      }
      if (data.interleavedBuffers[this.data.uuid] === void 0) {
        data.interleavedBuffers[this.data.uuid] = this.data.clone(data);
      }
      return new InterleavedBufferAttribute2(data.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
    }
  }
  toJSON(data) {
    if (data === void 0) {
      console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
      const array = [];
      for (let i = 0; i < this.count; i++) {
        const index = i * this.data.stride + this.offset;
        for (let j = 0; j < this.itemSize; j++) {
          array.push(this.data.array[index + j]);
        }
      }
      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array,
        normalized: this.normalized
      };
    } else {
      if (data.interleavedBuffers === void 0) {
        data.interleavedBuffers = {};
      }
      if (data.interleavedBuffers[this.data.uuid] === void 0) {
        data.interleavedBuffers[this.data.uuid] = this.data.toJSON(data);
      }
      return {
        isInterleavedBufferAttribute: true,
        itemSize: this.itemSize,
        data: this.data.uuid,
        offset: this.offset,
        normalized: this.normalized
      };
    }
  }
}
class InterleavedBuffer2 {
  constructor(array, stride) {
    this.isInterleavedBuffer = true;
    this.array = array;
    this.stride = stride;
    this.count = array !== void 0 ? array.length / stride : 0;
    this.usage = StaticDrawUsage;
    this.updateRanges = [];
    this.version = 0;
    this.uuid = generateUUID();
  }
  onUploadCallback() {
  }
  set needsUpdate(value) {
    if (value === true) this.version++;
  }
  setUsage(value) {
    this.usage = value;
    return this;
  }
  addUpdateRange(start, count) {
    this.updateRanges.push({ start, count });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(source) {
    this.array = new source.array.constructor(source.array);
    this.count = source.count;
    this.stride = source.stride;
    this.usage = source.usage;
    return this;
  }
  copyAt(index1, attribute, index2) {
    index1 *= this.stride;
    index2 *= attribute.stride;
    for (let i = 0, l = this.stride; i < l; i++) {
      this.array[index1 + i] = attribute.array[index2 + i];
    }
    return this;
  }
  set(value, offset = 0) {
    this.array.set(value, offset);
    return this;
  }
  clone(data) {
    if (data.arrayBuffers === void 0) {
      data.arrayBuffers = {};
    }
    if (this.array.buffer._uuid === void 0) {
      this.array.buffer._uuid = generateUUID();
    }
    if (data.arrayBuffers[this.array.buffer._uuid] === void 0) {
      data.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer;
    }
    const array = new this.array.constructor(data.arrayBuffers[this.array.buffer._uuid]);
    const ib = new this.constructor(array, this.stride);
    ib.setUsage(this.usage);
    return ib;
  }
  onUpload(callback) {
    this.onUploadCallback = callback;
    return this;
  }
  toJSON(data) {
    if (data.arrayBuffers === void 0) {
      data.arrayBuffers = {};
    }
    if (this.array.buffer._uuid === void 0) {
      this.array.buffer._uuid = generateUUID();
    }
    if (data.arrayBuffers[this.array.buffer._uuid] === void 0) {
      data.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer));
    }
    return {
      uuid: this.uuid,
      buffer: this.array.buffer._uuid,
      type: this.array.constructor.name,
      stride: this.stride
    };
  }
}
class BufferAttributeNode extends InputNode {
  static get type() {
    return "BufferAttributeNode";
  }
  /**
   * Constructs a new buffer attribute node.
   *
   * @param {BufferAttribute|InterleavedBuffer|TypedArray} value - The attribute data.
   * @param {String?} [bufferType=null] - The buffer type (e.g. `'vec3'`).
   * @param {Number} [bufferStride=0] - The buffer stride.
   * @param {Number} [bufferOffset=0] - The buffer offset.
   */
  constructor(value, bufferType = null, bufferStride = 0, bufferOffset = 0) {
    super(value, bufferType);
    this.isBufferNode = true;
    this.bufferType = bufferType;
    this.bufferStride = bufferStride;
    this.bufferOffset = bufferOffset;
    this.usage = StaticDrawUsage;
    this.instanced = false;
    this.attribute = null;
    this.global = true;
    if (value && value.isBufferAttribute === true) {
      this.attribute = value;
      this.usage = value.usage;
      this.instanced = value.isInstancedBufferAttribute;
    }
  }
  /**
   * This method is overwritten since the attribute data might be shared
   * and thus the hash should be shared as well.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {String} The hash.
   */
  getHash(builder) {
    if (this.bufferStride === 0 && this.bufferOffset === 0) {
      let bufferData = builder.globalCache.getData(this.value);
      if (bufferData === void 0) {
        bufferData = {
          node: this
        };
        builder.globalCache.setData(this.value, bufferData);
      }
      return bufferData.node.uuid;
    }
    return this.uuid;
  }
  /**
   * This method is overwritten since the node type is inferred from
   * the buffer attribute.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {String} The node type.
   */
  getNodeType(builder) {
    if (this.bufferType === null) {
      this.bufferType = builder.getTypeFromAttribute(this.attribute);
    }
    return this.bufferType;
  }
  /**
   * Depending on which value was passed to the node, `setup()` behaves
   * differently. If no instance of `BufferAttribute` was passed, the method
   * creates an internal attribute and configures it respectively.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  setup(builder) {
    if (this.attribute !== null) return;
    const type = this.getNodeType(builder);
    const array = this.value;
    const itemSize = builder.getTypeLength(type);
    const stride = this.bufferStride || itemSize;
    const offset = this.bufferOffset;
    const buffer = array.isInterleavedBuffer === true ? array : new InterleavedBuffer2(array, stride);
    const bufferAttribute2 = new InterleavedBufferAttribute2(buffer, itemSize, offset);
    buffer.setUsage(this.usage);
    this.attribute = bufferAttribute2;
    this.attribute.isInstancedBufferAttribute = this.instanced;
  }
  /**
   * Generates the code snippet of the buffer attribute node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {String} The generated code snippet.
   */
  generate(builder) {
    const nodeType = this.getNodeType(builder);
    const nodeAttribute = builder.getBufferAttributeFromNode(this, nodeType);
    const propertyName = builder.getPropertyName(nodeAttribute);
    let output = null;
    if (builder.shaderStage === "vertex" || builder.shaderStage === "compute") {
      this.name = propertyName;
      output = propertyName;
    } else {
      const nodeVarying = varying(this);
      output = nodeVarying.build(builder, nodeType);
    }
    return output;
  }
  /**
   * Overwrites the default implementation to return a fixed value `'bufferAttribute'`.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {String} The input type.
   */
  getInputType() {
    return "bufferAttribute";
  }
  /**
   * Sets the `usage` property to the given value.
   *
   * @param {Number} value - The usage to set.
   * @return {BufferAttributeNode} A reference to this node.
   */
  setUsage(value) {
    this.usage = value;
    if (this.attribute && this.attribute.isBufferAttribute === true) {
      this.attribute.usage = value;
    }
    return this;
  }
  /**
   * Sets the `instanced` property to the given value.
   *
   * @param {Number} value - The value to set.
   * @return {BufferAttributeNode} A reference to this node.
   */
  setInstanced(value) {
    this.instanced = value;
    return this;
  }
}
const bufferAttribute = (array, type = null, stride = 0, offset = 0) => nodeObject(new BufferAttributeNode(array, type, stride, offset));
addMethodChaining("toAttribute", (bufferNode) => bufferAttribute(bufferNode.value));
class ComputeNode extends Node {
  static get type() {
    return "ComputeNode";
  }
  /**
   * Constructs a new compute node.
   *
   * @param {Node} computeNode - TODO
   * @param {Number} count - TODO.
   * @param {Array<Number>} [workgroupSize=[64]] - TODO.
   */
  constructor(computeNode, count, workgroupSize = [64]) {
    super("void");
    this.isComputeNode = true;
    this.computeNode = computeNode;
    this.count = count;
    this.workgroupSize = workgroupSize;
    this.dispatchCount = 0;
    this.version = 1;
    this.name = "";
    this.updateBeforeType = NodeUpdateType.OBJECT;
    this.onInitFunction = null;
    this.updateDispatchCount();
  }
  /**
   * Executes the `dispose` event for this node.
   */
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  /**
   * Sets the {@link ComputeNode#name} property.
   *
   * @param {String} name - The name of the uniform.
   * @return {ComputeNode} A reference to this node.
   */
  label(name) {
    this.name = name;
    return this;
  }
  /**
   * TODO
   */
  updateDispatchCount() {
    const { count, workgroupSize } = this;
    let size = workgroupSize[0];
    for (let i = 1; i < workgroupSize.length; i++)
      size *= workgroupSize[i];
    this.dispatchCount = Math.ceil(count / size);
  }
  /**
   * TODO
   *
   * @param {Function} callback - TODO.
   * @return {ComputeNode} A reference to this node.
   */
  onInit(callback) {
    this.onInitFunction = callback;
    return this;
  }
  /**
   * The method execute the compute for this node.
   *
   * @param {NodeFrame} frame - A reference to the current node frame.
   */
  updateBefore({ renderer }) {
    renderer.compute(this);
  }
  generate(builder) {
    const { shaderStage } = builder;
    if (shaderStage === "compute") {
      const snippet = this.computeNode.build(builder, "void");
      if (snippet !== "") {
        builder.addLineFlowCode(snippet, this);
      }
    }
  }
}
const compute = (node, count, workgroupSize) => nodeObject(new ComputeNode(nodeObject(node), count, workgroupSize));
addMethodChaining("compute", compute);
class CacheNode extends Node {
  static get type() {
    return "CacheNode";
  }
  /**
   * Constructs a new cache node.
   *
   * @param {Node} node - The node that should be cached.
   * @param {Boolean} [parent=true] - Whether this node refers to a shared parent cache or not.
   */
  constructor(node, parent = true) {
    super();
    this.node = node;
    this.parent = parent;
    this.isCacheNode = true;
  }
  getNodeType(builder) {
    const previousCache = builder.getCache();
    const cache2 = builder.getCacheFromNode(this, this.parent);
    builder.setCache(cache2);
    const nodeType = this.node.getNodeType(builder);
    builder.setCache(previousCache);
    return nodeType;
  }
  build(builder, ...params) {
    const previousCache = builder.getCache();
    const cache2 = builder.getCacheFromNode(this, this.parent);
    builder.setCache(cache2);
    const data = this.node.build(builder, ...params);
    builder.setCache(previousCache);
    return data;
  }
}
const cache = (node, parent) => nodeObject(new CacheNode(nodeObject(node), parent));
addMethodChaining("cache", cache);
class BypassNode extends Node {
  static get type() {
    return "BypassNode";
  }
  /**
   * Constructs a new bypass node.
   *
   * @param {Node} outputNode - The output node.
   * @param {Node} callNode - The call node.
   */
  constructor(outputNode, callNode) {
    super();
    this.isBypassNode = true;
    this.outputNode = outputNode;
    this.callNode = callNode;
  }
  getNodeType(builder) {
    return this.outputNode.getNodeType(builder);
  }
  generate(builder) {
    const snippet = this.callNode.build(builder, "void");
    if (snippet !== "") {
      builder.addLineFlowCode(snippet, this);
    }
    return this.outputNode.build(builder);
  }
}
const bypass = /* @__PURE__ */ nodeProxy(BypassNode);
addMethodChaining("bypass", bypass);
class RemapNode extends Node {
  static get type() {
    return "RemapNode";
  }
  /**
   * Constructs a new remap node.
   *
   * @param {Node} node - The node that should be remapped.
   * @param {Node} inLowNode - The source or current lower bound of the range.
   * @param {Node} inHighNode - The source or current upper bound of the range.
   * @param {Node} [outLowNode=float(0)] - The target lower bound of the range.
   * @param {Node} [outHighNode=float(1)] - The target upper bound of the range.
   */
  constructor(node, inLowNode, inHighNode, outLowNode = float(0), outHighNode = float(1)) {
    super();
    this.node = node;
    this.inLowNode = inLowNode;
    this.inHighNode = inHighNode;
    this.outLowNode = outLowNode;
    this.outHighNode = outHighNode;
    this.doClamp = true;
  }
  setup() {
    const { node, inLowNode, inHighNode, outLowNode, outHighNode, doClamp } = this;
    let t = node.sub(inLowNode).div(inHighNode.sub(inLowNode));
    if (doClamp === true) t = t.clamp();
    return t.mul(outHighNode.sub(outLowNode)).add(outLowNode);
  }
}
const remap = /* @__PURE__ */ nodeProxy(RemapNode, null, null, { doClamp: false });
const remapClamp = /* @__PURE__ */ nodeProxy(RemapNode);
addMethodChaining("remap", remap);
addMethodChaining("remapClamp", remapClamp);
class ExpressionNode extends Node {
  static get type() {
    return "ExpressionNode";
  }
  /**
   * Constructs a new expression node.
   *
   * @param {String} [snippet=''] - The native code snippet.
   * @param {String} [nodeType='void'] - The node type.
   */
  constructor(snippet = "", nodeType = "void") {
    super(nodeType);
    this.snippet = snippet;
  }
  generate(builder, output) {
    const type = this.getNodeType(builder);
    const snippet = this.snippet;
    if (type === "void") {
      builder.addLineFlowCode(snippet, this);
    } else {
      return builder.format(`( ${snippet} )`, type, output);
    }
  }
}
const expression = /* @__PURE__ */ nodeProxy(ExpressionNode);
const Discard = (conditional2) => (conditional2 ? select(conditional2, expression("discard")) : expression("discard")).append();
addMethodChaining("discard", Discard);
class RenderOutputNode extends TempNode {
  static get type() {
    return "RenderOutputNode";
  }
  /**
   * Constructs a new render output node.
   *
   * @param {Node} colorNode - The color node to process.
   * @param {Number} toneMapping - The tone mapping type.
   * @param {String} outputColorSpace - The output color space.
   */
  constructor(colorNode, toneMapping2, outputColorSpace) {
    super("vec4");
    this.colorNode = colorNode;
    this.toneMapping = toneMapping2;
    this.outputColorSpace = outputColorSpace;
    this.isRenderOutputNode = true;
  }
  setup({ context: context2 }) {
    let outputNode = this.colorNode || context2.color;
    const toneMapping2 = (this.toneMapping !== null ? this.toneMapping : context2.toneMapping) || NoToneMapping;
    const outputColorSpace = (this.outputColorSpace !== null ? this.outputColorSpace : context2.outputColorSpace) || NoColorSpace;
    if (toneMapping2 !== NoToneMapping) {
      outputNode = outputNode.toneMapping(toneMapping2);
    }
    if (outputColorSpace !== NoColorSpace && outputColorSpace !== ColorManagement.workingColorSpace) {
      outputNode = outputNode.workingToColorSpace(outputColorSpace);
    }
    return outputNode;
  }
}
const renderOutput = (color2, toneMapping2 = null, outputColorSpace = null) => nodeObject(new RenderOutputNode(nodeObject(color2), toneMapping2, outputColorSpace));
addMethodChaining("renderOutput", renderOutput);
class Diagram {
  /**
   * Creates a new Diagram instance.
   * @param {HTMLElement} container - The HTML container element for the diagram.
   */
  constructor(container) {
    this.elements = [];
    this.connectors = [];
    this.mode = "VIEW";
    this.helpers = false;
    this.container = container;
    this.initScene();
    this.initCamera();
    this.setHelpers();
    this.initRenderer();
    this.initLighting();
    this.initControls();
    this.addEventListeners();
    this.animate();
    console.log("THREE", THREE);
    console.log(this);
  }
  /**
   * Initializes the THREE.js scene.
   */
  initScene() {
    this.scene = new Scene();
    this.scene.background = new Color$1(15790320);
  }
  /**
   * Initializes the camera with a perspective projection.
   */
  initCamera() {
    const aspectRatio = window.innerWidth / window.innerHeight;
    this.camera = new PerspectiveCamera(75, aspectRatio, 0.1, 2e3);
    this.camera.position.set(0, 0, 500);
    this.camera.updateProjectionMatrix();
  }
  // initCamera() { // Orthographic
  //     // const aspectRatio = this.container.clientWidth / window.innerHeight;
  //     const aspectRatio = window.innerWidth / window.innerHeight;
  //     const frustumSize = 100;
  //     this.camera = new THREE.OrthographicCamera(
  //         frustumSize * aspectRatio / -2, 
  //         frustumSize * aspectRatio / 2, 
  //         frustumSize / 2, 
  //         frustumSize / -2, 
  //         0.1, 
  //         1000
  //     );
  //     this.camera.position.set(0, 0, 50);
  // }
  /**
   * Sets up helpers (axes, grid, etc.) for the scene.
   */
  setHelpers() {
    this.axesHelper = new AxesHelper(100);
    this.cameraHelper = new CameraHelper(this.camera);
    const size = 400;
    const divisions = 50;
    this.gridHelper = new GridHelper(size, divisions);
    this.cameraDirection = new Vector3$1();
    this.camPositionSpan = document.querySelector("#position");
    this.camLookAtSpan = document.querySelector("#lookingAt");
    this.helpers = false;
  }
  /**
   * Shows the helpers in the scene.
   */
  showHelpers() {
    if (!this.helpers) {
      this.scene.add(this.axesHelper);
      this.scene.add(this.cameraHelper);
      this.scene.add(this.gridHelper);
      this.helpers = true;
    }
  }
  /**
   * Hides the helpers in the scene.
   */
  hideHelpers() {
    if (this.helpers) {
      this.scene.remove(this.axesHelper);
      this.scene.remove(this.cameraHelper);
      this.scene.remove(this.gridHelper);
      this.helpers = false;
    }
  }
  /**
   * Initializes the renderer and attaches it to the container.
   */
  initRenderer() {
    this.renderer = new WebGLRenderer({ antialias: true });
    this.renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(this.renderer.domElement);
    console.log("initRenderer", this.container, this.renderer.domElement);
  }
  /**
   * Initializes the lighting for the scene.
   */
  initLighting() {
    let mainLightColor = 16777215;
    let mainLightIntensity = 4;
    let mainLightDistance = 0;
    let mainLightDecay = 0;
    const mainLight = new PointLight(mainLightColor, mainLightIntensity, mainLightDistance, mainLightDecay);
    let mainLightPosX = -1 * (580 / 2) + 1 / 3 * 580;
    let mainLightPosY = -1 * 209 * 4;
    let mainLightPosZ = Math.abs(mainLightPosY);
    mainLight.position.set(mainLightPosX, mainLightPosY, mainLightPosZ);
    this.scene.add(mainLight);
    this.spotLight = new PointLight(16777215, 4, 0, 0);
    this.spotLightPosX = 0;
    this.spotLightPosY = -1 * 209 - 300;
    this.spotLightPosZ = 70;
    this.scene.add(this.spotLight);
    this.spotLightDirection = 1;
  }
  /**
   * Initializes the controls for the camera.
   */
  initControls() {
    this.controls = new MapControls(this.camera, this.renderer.domElement);
    this.controls.enableDamping = true;
    this.controls.dampingFactor = 0.1;
    this.controls.screenSpacePanning = true;
    this.controls.zoomToCursor = true;
    this.controls.saveState();
  }
  /**
   * Adds event listeners for window resize and other interactions.
   */
  addEventListeners() {
    window.addEventListener("resize", this.onWindowResize.bind(this), false);
  }
  // onDocumentMouseDown(event) {
  //     this.isDragging = true;
  //     this.previousMousePosition = { x: event.offsetX, y: event.offsetY };
  // }
  // onDocumentMouseMove(event) {
  //    if (this.isDragging && this.mugGroup) {
  //       const deltaMove = {
  //          x: event.offsetX - this.previousMousePosition.x,
  //          y: event.offsetY - this.previousMousePosition.y
  //       };
  //       let rotateAngleX = this.toRadians(deltaMove.y * 1);
  //       let rotateAngleY = this.toRadians(deltaMove.x * 1);
  //       this.currentRotation = this.currentRotation || { x: 0, y: 0 };
  //       this.currentRotation.x += rotateAngleX;
  //       this.currentRotation.y += rotateAngleY;
  //       const maxRotation = Math.PI / 2;
  //       this.currentRotation.x = Math.min(Math.max(this.currentRotation.x, -maxRotation), maxRotation);
  //       this.pivotGroup.rotation.x = this.currentRotation.x;
  //       this.pivotGroup.rotation.y = this.currentRotation.y;
  //       this.previousMousePosition = { x: event.offsetX, y: event.offsetY };
  //    }
  // }
  // onDocumentMouseUp() {
  //    this.isDragging = false;
  // }
  // toRadians(angle) {
  //    return angle * (Math.PI / 180);
  // }
  /**
   * Handles window resize events to update the camera and renderer.
   */
  onWindowResize() {
    this.camera.aspect = window.innerWidth / window.innerHeight;
    this.camera.updateProjectionMatrix();
    this.renderer.setSize(window.innerWidth, window.innerHeight);
  }
  /**
   * Animates the scene and updates controls.
   */
  animate() {
    if (this.tween) this.tween.update();
    requestAnimationFrame(this.animate.bind(this));
    this.controls.update();
    this.renderer.render(this.scene, this.camera);
    if (this.spotLightPosX > 500) {
      this.spotLightDirection = -1;
      this.spotLightPosX = 500;
    }
    if (this.spotLightPosX < -500) {
      this.spotLightDirection = 1;
      this.spotLightPosX = -500;
    }
    this.spotLightPosX += 10 * this.spotLightDirection;
    this.spotLight.position.set(this.spotLightPosX, this.spotLightPosY, this.spotLightPosZ);
  }
  reset() {
    this.hideHelpers();
    this.controls.reset();
    this.setMode("VIEW");
    this.fitScreen();
  }
  // ================================================================
  //   Diagram arrangement
  // ================================================================
  arrange() {
    if (this.scene.children.length === 0) {
      console.warn("Scene is empty. Cannot calculate center.");
      return;
    }
    const box = new Box3().setFromObject(this.scene);
    const center = box.getCenter(new Vector3$1());
    const translation = new Vector3$1(-center.x, -center.y, -center.z);
    this.scene.children.forEach((child) => {
      if (child instanceof Object3D) {
        child.position.add(translation);
      }
    });
  }
  /**
   * Calculates the optimal zoom distance for the camera to ensure the entire scene is visible.
   *
   * @returns {number} The optimal distance for the camera to fit the scene within the viewport.
   */
  calculateOptimalZoom() {
    const box = new Box3().setFromObject(this.scene);
    const size = box.getSize(new Vector3$1());
    const aspect2 = window.innerWidth / window.innerHeight;
    const fovRad = MathUtils$1.degToRad(this.camera.fov);
    const distanceForWidth = size.x / 2 / (Math.tan(fovRad / 2) * aspect2);
    const distanceForHeight = size.y / 2 / Math.tan(fovRad / 2);
    return Math.max(distanceForWidth, distanceForHeight);
  }
  /**
   * Adjusts the camera to fit the entire scene within the screen.
   * 
   * This method calculates the optimal zoom level and positions the camera
   * at a distance that ensures the entire scene is visible, with a small margin.
   * It also updates the camera's orientation to look at the center of the scene
   * and saves the current camera state for later restoration.
   */
  fitScreen() {
    const minZDistance = this.calculateOptimalZoom();
    const margin = 1.05;
    const cameraZ = minZDistance * margin;
    this.camera.position.set(0, 0, cameraZ);
    this.camera.lookAt(0, 0, 0);
    this.camera.updateProjectionMatrix();
    this.controls.saveState();
    this.initialCameraPosition = this.camera.position.clone();
    this.initialTarget = this.controls.target.clone();
  }
  /**
   * Centers the diagram by moving the camera to its initial position and target.
   * This method uses the Tween.js library to animate the camera movement.
   * 
   * Preconditions:
   * - `this.initialCameraPosition` and `this.initialTarget` must be defined.
   * 
   * Behavior:
   * - If the initial camera position or target is not defined, a warning is logged, and the method exits.
   * - Animates the camera's position and the controls' target to their initial states over 1200 milliseconds.
   * - Uses a Quartic easing function for smooth animation.
   * 
   * Dependencies:
   * - Tween.js library for animation.
   * 
   * @returns {void}
   */
  center() {
    if (!this.initialCameraPosition || !this.initialTarget) {
      console.warn("Initial camera position or target is not defined.");
      return;
    }
    const from = {
      cameraPositionX: this.camera.position.x,
      cameraPositionY: this.camera.position.y,
      cameraPositionZ: this.camera.position.z,
      controlsTargetX: this.controls.target.x,
      controlsTargetY: this.controls.target.y,
      controlsTargetZ: this.controls.target.z
    };
    const to = {
      cameraPositionX: this.initialCameraPosition.x,
      cameraPositionY: this.initialCameraPosition.y,
      cameraPositionZ: this.initialCameraPosition.z,
      controlsTargetX: this.initialTarget.x,
      controlsTargetY: this.initialTarget.y,
      controlsTargetZ: this.initialTarget.z
    };
    const camera = this.camera;
    const controls = this.controls;
    this.tween = new Tween$1(from).to(to, 1200).easing(Easing.Quartic.Out).onUpdate(function() {
      camera.position.set(
        from.cameraPositionX,
        from.cameraPositionY,
        from.cameraPositionZ
      );
      controls.target.set(
        from.controlsTargetX,
        from.controlsTargetY,
        from.controlsTargetZ
      );
    }).onComplete(function() {
    }).start();
  }
  /**
   * Rotates the diagram around the Y axis by a specified angle in degrees.
   * The method ensures the diagram is centered and calculates the new camera
   * and target positions based on the provided angle.
   *
   * @param {number} targetAngle - The angle in degrees to rotate the diagram (e.g., 60).
   * @returns {void} - Does not return a value.
   * 
   * @throws {Error} Logs a warning if the initial camera position or target is not defined.
   *
   * @example
   * // Rotate the diagram by 60 degrees
   * diagram.rotate(60);
   */
  rotate(targetAngle) {
    if (!this.initialCameraPosition || !this.initialTarget) {
      console.warn("Initial camera position or target is not defined.");
      return;
    }
    const radius = Math.sqrt(
      this.initialCameraPosition.y * this.initialCameraPosition.y + this.initialCameraPosition.z * this.initialCameraPosition.z
    );
    const from = {
      cameraPositionX: this.camera.position.x,
      cameraPositionY: this.camera.position.y,
      cameraPositionZ: this.camera.position.z,
      controlsTargetX: this.controls.target.x,
      controlsTargetY: this.controls.target.y,
      controlsTargetZ: this.controls.target.z
    };
    const targetAngleRad = MathUtils$1.degToRad(targetAngle);
    const to = {
      cameraPositionX: this.initialCameraPosition.x,
      cameraPositionY: radius * Math.sin(targetAngleRad),
      cameraPositionZ: radius * Math.cos(targetAngleRad),
      controlsTargetX: this.initialTarget.x,
      controlsTargetY: this.initialTarget.y,
      controlsTargetZ: this.initialTarget.z
    };
    console.log("rotate() -> from:", from);
    console.log("rotate() -> to:", to);
    const camera = this.camera;
    const controls = this.controls;
    this.tween = new Tween$1(from).to(to, 1200).easing(Easing.Quartic.Out).onUpdate(function() {
      camera.position.set(
        from.cameraPositionX,
        from.cameraPositionY,
        from.cameraPositionZ
      );
      controls.target.set(
        from.controlsTargetX,
        from.controlsTargetY,
        from.controlsTargetZ
      );
    }).start();
  }
  // ================================================================
  //   Diagram modes
  // ================================================================
  /**
   * Removes all elements of type 'ValueBarShape' from the diagram.
   * Iterates through the `elements` array in reverse order to safely remove
   * elements without affecting the iteration process. For each matching element,
   * it removes the element from its parent (and thus from the scene) and also 
   * removes it from the `elements` array.
   */
  removeValueBars() {
    for (let i = this.elements.length - 1; i >= 0; i--) {
      const element2 = this.elements[i];
      if (element2.type === "ValueBarShape") {
        if (element2.parent) {
          element2.parent.remove(element2);
        }
        this.scene.remove(element2);
        this.elements.splice(i, 1);
      }
    }
  }
  /**
   * Adds value bars to the diagram to visualize the elements' parameters.
   * 
   * This method processes the elements in the diagram, calculates the height
   * of the bars based on their parameter values, and assigns a color to each
   * bar based on a normalized value. The bars are then added to the scene.
   * 
   * @method
   * @memberof Diagram
   * @description
   * - Filters elements to include only those with a defined `parameters.value`.
   * - Calculates the range of parameter values to normalize them.
   * - Assigns a color to each bar using an HSL color scale (green to red).
   * - Calls the `valueBar` method on each element to set the bar's height and color.
   * 
   * @example
   * // Assuming `diagram` is an instance of Diagram with elements having parameters:
   * diagram.addValueBars();
   * 
   * @throws {Error} If no elements with `parameters.value` are found.
   */
  addValueBars() {
    const elements = this.elements.filter((el) => el.parameters && el.parameters.value !== void 0);
    if (elements.length === 0) {
      throw new Error("No elements with `parameters.value` found.");
    }
    const max2 = Math.max(...elements.map((el) => el.parameters.value));
    const min2 = 0;
    const range = max2 - min2;
    elements.forEach((element2, i) => {
      const value = element2.parameters.value;
      const normalizedValue = (value - min2) / range;
      const color2 = new Color$1(`hsl(${(normalizedValue * 120).toString(10)}, 100%, 50%)`);
      element2.addValueBar(normalizedValue * 100, color2);
    });
  }
  /**
   * Sets the mode of the diagram and adjusts its state accordingly.
   *
   * @param {string} mode - The mode to set. Possible values are:
   *   - 'EDIT': Sets the diagram to edit mode and resets rotation.
   *   - 'VIEW': Sets the diagram to view mode and resets rotation.
   *   - 'ANALYZE': Sets the diagram to analyze mode, rotates it to -60 degrees, 
   *                and adds value bars.
   *   - Any other value will log a warning about an unknown mode.
   */
  setMode(mode) {
    this.removeValueBars();
    this.mode = mode;
    switch (mode) {
      case "EDIT":
      case "VIEW":
        this.rotate(0);
        break;
      case "ANALYZE":
        this.rotate(-65);
        this.addValueBars();
        break;
      default:
        console.warn(`Unknown mode: ${mode}`);
    }
  }
  // ================================================================
  //   Diagram elements
  // ================================================================
  /**
   * Adds an element to the diagram.
   * @param {Object3D} element - The element to add.
   * @param {Vector3} [position] - The position to place the element.
   * @returns {Object3D} The added element.
   */
  addElement(element2, position) {
    this.elements.push(element2);
    this.scene.add(element2);
    if (position) element2.position.set(position.x, position.y, 0);
    element2.setDiagram(this);
    return element2;
  }
  /**
   * Removes an element from the diagram by its ID.
   * @param {string} elementId - The ID of the element to remove.
   */
  removeElement(elementId) {
    const element2 = this.elements.find((el) => el.id === elementId);
    if (element2) {
      this.scene.remove(element2);
      this.elements = this.elements.filter((el) => el.id !== elementId);
    }
  }
  /**
   * Retrieves an element from the `elements` array by its unique `elementId`.
   *
   * @param {string} elementId - The unique identifier of the element to find.
   * @returns {Object|undefined} The element with the matching `elementId`, or `undefined` if not found.
   */
  getElementById(elementId) {
    return this.elements.find((el) => el.elementId === elementId);
  }
  /**
   * Retrieves the elements of the diagram.
   *
   * @returns {Array} The array of elements in the diagram.
   */
  getElements() {
    return this.elements;
  }
  // ================================================================
  //   Diagram Connectors
  // ================================================================
  /**
   * Adds a connector to the diagram, registers it with the diagram, 
   * and adds it to the scene for rendering.
   *
   * @param {Object} connector - The connector object to be added to the diagram.
   * @returns {Object} The connector that was added.
   */
  addConnector(connector) {
    this.connectors.push(connector);
    this.scene.add(connector);
    connector.setDiagram(this);
    return connector;
  }
  // ================================================================
  //   Clear diagram
  // ================================================================
  /**
   * Clears all elements and connectors from the diagram.
   */
  clear() {
    this.elements = [];
    this.connectors = [];
    this.scene.children = this.scene.children.filter((child) => child instanceof AmbientLight);
  }
  // ================================================================
  //   Diagram JSON
  // ================================================================
  toJSON() {
    return JSON.stringify(this.elements);
  }
  fromJSON(json) {
    this.elements = JSON.parse(json);
  }
  // ================================================================
  //   Diagram export and import to/from file
  // ================================================================
  /**
   * Exports the diagram to a JSON file.
   */
  export() {
    const data = JSON.stringify(this.scene.toJSON());
    const blob = new Blob([data], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = "diagram.json";
    a.click();
    URL.revokeObjectURL(url);
  }
  /**
   * Placeholder for importing a diagram from a file.
   * This method should be implemented by subclasses.
   * @param {File} file - The file to import.
   * @throws {Error} If the method is not implemented.
   * @returns {Promise<void>}
   */
  import(file) {
    console.error("Import method should be implemented by subclasses.");
  }
}
const DiagramDimensions = {
  DISTANCE_BETWEEN_ELEMENTS: 48
};
const ExtrusionParameters$1 = {
  steps: 2,
  depth: 0.6,
  bevelEnabled: true,
  bevelThickness: 0.2,
  bevelSize: 0.4,
  bevelOffset: 0,
  bevelSegments: 4
};
const Colors = {
  ELEMENT_STROKE: 26265,
  ELEMENT_TEXT: 26265
};
class Shape2 {
  constructor(geometry, material) {
    this.geometry = geometry;
    this.material = material;
    this.width = this.getSize().x;
    this.height = this.getSize().y;
  }
  getSize() {
    var size = new Vector3$1();
    this.geometry.computeBoundingBox();
    this.geometry.boundingBox.getSize(size);
    return size;
  }
}
class DiagramEditMaterial extends MeshLambertMaterial {
  constructor(color2) {
    super({
      vertexColors: false,
      color: color2,
      side: DoubleSide,
      emissive: new Color$1(color2),
      emissiveIntensity: 0.1
    });
  }
}
class BoxShape extends Shape2 {
  constructor() {
    const color2 = 255;
    super(new BoxGeometry(1, 1, 1), new DiagramEditMaterial(color2));
  }
}
class FontLoader extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    const scope = this;
    const loader = new FileLoader(this.manager);
    loader.setPath(this.path);
    loader.setRequestHeader(this.requestHeader);
    loader.setWithCredentials(this.withCredentials);
    loader.load(url, function(text) {
      const font = scope.parse(JSON.parse(text));
      if (onLoad) onLoad(font);
    }, onProgress, onError);
  }
  parse(json) {
    return new Font(json);
  }
}
class Font {
  constructor(data) {
    this.isFont = true;
    this.type = "Font";
    this.data = data;
  }
  generateShapes(text, size = 100) {
    const shapes = [];
    const paths = createPaths(text, size, this.data);
    for (let p = 0, pl = paths.length; p < pl; p++) {
      shapes.push(...paths[p].toShapes());
    }
    return shapes;
  }
}
function createPaths(text, size, data) {
  const chars = Array.from(text);
  const scale = size / data.resolution;
  const line_height = (data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness) * scale;
  const paths = [];
  let offsetX = 0, offsetY = 0;
  for (let i = 0; i < chars.length; i++) {
    const char = chars[i];
    if (char === "\n") {
      offsetX = 0;
      offsetY -= line_height;
    } else {
      const ret = createPath(char, scale, offsetX, offsetY, data);
      offsetX += ret.offsetX;
      paths.push(ret.path);
    }
  }
  return paths;
}
function createPath(char, scale, offsetX, offsetY, data) {
  const glyph = data.glyphs[char] || data.glyphs["?"];
  if (!glyph) {
    console.error('THREE.Font: character "' + char + '" does not exists in font family ' + data.familyName + ".");
    return;
  }
  const path = new ShapePath();
  let x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2;
  if (glyph.o) {
    const outline = glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(" "));
    for (let i = 0, l = outline.length; i < l; ) {
      const action = outline[i++];
      switch (action) {
        case "m":
          x = outline[i++] * scale + offsetX;
          y = outline[i++] * scale + offsetY;
          path.moveTo(x, y);
          break;
        case "l":
          x = outline[i++] * scale + offsetX;
          y = outline[i++] * scale + offsetY;
          path.lineTo(x, y);
          break;
        case "q":
          cpx = outline[i++] * scale + offsetX;
          cpy = outline[i++] * scale + offsetY;
          cpx1 = outline[i++] * scale + offsetX;
          cpy1 = outline[i++] * scale + offsetY;
          path.quadraticCurveTo(cpx1, cpy1, cpx, cpy);
          break;
        case "b":
          cpx = outline[i++] * scale + offsetX;
          cpy = outline[i++] * scale + offsetY;
          cpx1 = outline[i++] * scale + offsetX;
          cpy1 = outline[i++] * scale + offsetY;
          cpx2 = outline[i++] * scale + offsetX;
          cpy2 = outline[i++] * scale + offsetY;
          path.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy);
          break;
      }
    }
  }
  return { offsetX: glyph.ha * scale, path };
}
class TextGeometry extends ExtrudeGeometry {
  constructor(text, parameters = {}) {
    const font = parameters.font;
    if (font === void 0) {
      super();
    } else {
      const shapes = font.generateShapes(text, parameters.size);
      if (parameters.depth === void 0 && parameters.height !== void 0) {
        console.warn("THREE.TextGeometry: .height is now depreciated. Please use .depth instead");
      }
      parameters.depth = parameters.depth !== void 0 ? parameters.depth : parameters.height !== void 0 ? parameters.height : 50;
      if (parameters.bevelThickness === void 0) parameters.bevelThickness = 10;
      if (parameters.bevelSize === void 0) parameters.bevelSize = 8;
      if (parameters.bevelEnabled === void 0) parameters.bevelEnabled = false;
      super(shapes, parameters);
    }
    this.type = "TextGeometry";
  }
}
const glyphs = /* @__PURE__ */ JSON.parse('{"0":{"ha":781,"x_min":78,"x_max":702,"o":"m 702 572 l 702 422 q 680 217 702 300 q 618 83 659 134 q 520 9 577 32 q 391 -14 463 -14 q 286 1 334 -14 q 199 46 237 15 q 134 129 161 78 q 92 252 106 180 q 78 422 78 325 l 78 572 q 100 776 78 694 q 163 908 122 858 q 261 979 203 958 q 389 1001 318 1001 q 495 987 447 1001 q 582 943 544 973 q 647 863 620 913 q 688 741 673 813 q 702 572 702 669 m 576 401 l 576 593 q 568 710 576 660 q 545 797 560 761 q 508 855 530 833 q 455 888 485 878 q 389 899 426 899 q 310 882 345 899 q 252 829 275 865 q 216 735 229 793 q 204 593 204 677 l 204 401 q 212 284 204 335 q 235 196 220 233 q 273 136 251 159 q 325 101 296 112 q 391 90 355 90 q 471 107 437 90 q 529 162 506 125 q 564 259 553 200 q 576 401 576 319 z "},"1":{"ha":781,"x_min":116,"x_max":494,"o":"m 494 993 l 494 0 l 369 0 l 369 836 l 116 744 l 116 857 l 475 993 l 494 993 z "},"2":{"ha":781,"x_min":64,"x_max":729,"o":"m 729 103 l 729 0 l 83 0 l 83 90 l 406 450 q 499 563 466 517 q 545 647 532 610 q 558 722 558 684 q 538 811 558 771 q 479 874 518 850 q 386 898 441 898 q 276 872 320 898 q 211 802 233 847 q 189 697 189 756 l 64 697 q 100 850 64 781 q 209 960 137 919 q 386 1001 281 1001 q 546 968 479 1001 q 648 876 612 935 q 684 737 684 817 q 669 649 684 694 q 629 561 654 605 q 570 474 604 517 q 498 390 536 431 l 234 103 l 729 103 z "},"3":{"ha":781,"x_min":64,"x_max":690,"o":"m 265 555 l 355 555 q 464 577 420 555 q 528 638 507 600 q 549 724 549 676 q 530 820 549 781 q 473 878 511 859 q 377 898 435 898 q 284 877 324 898 q 221 819 243 857 q 198 729 198 781 l 73 729 q 111 866 73 804 q 217 964 149 928 q 377 1001 286 1001 q 534 969 467 1001 q 638 876 601 938 q 675 722 675 814 q 658 642 675 684 q 605 563 641 600 q 511 503 568 526 q 372 479 453 479 l 265 479 l 265 555 m 265 452 l 265 528 l 372 528 q 528 505 467 528 q 626 446 590 483 q 676 364 661 408 q 690 275 690 319 q 667 153 690 206 q 601 62 644 99 q 502 5 559 24 q 378 -14 445 -14 q 257 5 313 -14 q 157 58 200 23 q 89 144 113 93 q 64 261 64 195 l 190 261 q 213 171 190 210 q 278 111 235 132 q 378 90 320 90 q 477 110 435 90 q 542 170 519 130 q 564 273 564 211 q 538 374 564 334 q 466 433 513 414 q 355 452 418 452 l 265 452 z "},"4":{"ha":781,"x_min":36,"x_max":749,"o":"m 749 332 l 749 229 l 36 229 l 36 303 l 478 987 l 581 987 l 471 789 l 178 332 l 749 332 m 612 987 l 612 0 l 486 0 l 486 987 l 612 987 z "},"5":{"ha":781,"x_min":104,"x_max":726,"o":"m 241 470 l 140 496 l 190 987 l 696 987 l 696 871 l 296 871 l 267 603 q 335 632 294 618 q 431 646 377 646 q 554 622 500 646 q 647 555 608 599 q 705 451 685 512 q 726 315 726 390 q 706 184 726 243 q 648 80 687 124 q 551 11 610 35 q 413 -14 492 -14 q 300 3 353 -14 q 205 54 247 20 q 137 139 163 88 q 104 260 111 191 l 224 260 q 256 166 232 204 q 320 109 281 128 q 413 90 360 90 q 492 105 458 90 q 551 150 527 121 q 587 220 574 179 q 600 313 600 262 q 587 400 600 360 q 548 470 574 440 q 486 516 523 500 q 402 533 450 533 q 307 516 339 533 q 241 470 275 499 z "},"6":{"ha":781,"x_min":90,"x_max":714,"o":"m 564 989 l 574 989 l 574 882 l 564 882 q 397 850 464 882 q 290 764 330 818 q 234 643 251 710 q 216 507 216 576 l 216 361 q 232 245 216 296 q 275 160 248 195 q 336 108 302 125 q 408 90 370 90 q 485 107 451 90 q 542 154 519 123 q 578 225 566 184 q 590 316 590 267 q 579 401 590 360 q 546 474 568 442 q 490 525 524 507 q 410 544 456 544 q 313 518 358 544 q 239 452 268 493 q 206 363 210 411 l 140 363 q 175 493 149 439 q 240 582 201 547 q 328 632 279 616 q 431 648 376 648 q 558 620 505 648 q 646 546 612 592 q 697 441 681 499 q 714 322 714 383 q 694 191 714 252 q 636 84 675 130 q 540 12 597 38 q 408 -14 483 -14 q 268 19 328 -14 q 169 107 208 52 q 110 229 130 162 q 90 366 90 296 l 90 425 q 111 629 90 529 q 184 811 132 730 q 328 941 236 892 q 564 989 420 989 z "},"7":{"ha":781,"x_min":53,"x_max":720,"o":"m 720 987 l 720 917 l 311 0 l 179 0 l 587 884 l 53 884 l 53 987 l 720 987 z "},"8":{"ha":781,"x_min":77,"x_max":705,"o":"m 705 267 q 663 114 705 177 q 550 19 621 52 q 391 -14 479 -14 q 231 19 302 -14 q 118 114 159 52 q 77 267 77 177 q 99 375 77 326 q 164 461 122 425 q 263 518 205 498 q 389 538 320 538 q 551 503 480 538 q 664 407 623 468 q 705 267 705 346 m 578 270 q 555 367 578 325 q 488 433 531 410 q 389 457 446 457 q 290 433 332 457 q 225 367 248 410 q 202 270 202 325 q 225 173 202 213 q 290 111 248 132 q 391 90 332 90 q 491 111 449 90 q 556 173 533 132 q 578 270 578 213 m 682 730 q 644 601 682 659 q 540 510 606 543 q 391 477 474 477 q 240 510 306 477 q 136 601 174 543 q 99 730 99 659 q 137 877 99 817 q 240 969 174 937 q 390 1001 306 1001 q 541 969 475 1001 q 644 877 606 937 q 682 730 682 817 m 556 728 q 535 816 556 778 q 477 876 514 854 q 390 898 439 898 q 303 877 340 898 q 246 819 267 857 q 225 728 225 781 q 246 640 225 677 q 304 581 267 602 q 391 559 341 559 q 477 581 440 559 q 535 640 514 602 q 556 728 556 677 z "},"9":{"ha":781,"x_min":68,"x_max":689,"o":"m 207 105 l 220 105 q 396 136 328 105 q 500 218 464 166 q 551 334 537 269 q 564 467 564 399 l 564 618 q 549 738 564 686 q 507 825 534 790 q 446 879 480 861 q 374 897 412 897 q 297 880 331 897 q 239 831 262 863 q 203 758 216 800 q 191 667 191 716 q 202 581 191 623 q 235 507 213 540 q 291 454 258 473 q 370 435 325 435 q 449 451 412 435 q 515 497 486 468 q 561 562 544 526 q 581 639 578 599 l 641 639 q 619 528 641 583 q 557 429 597 473 q 465 357 518 384 q 350 330 412 330 q 223 359 277 330 q 135 435 170 387 q 84 541 101 482 q 68 660 68 600 q 87 792 68 730 q 146 901 107 854 q 242 975 184 948 q 374 1001 299 1001 q 519 967 459 1001 q 616 876 578 933 q 671 748 654 819 q 689 602 689 677 l 689 556 q 679 400 689 479 q 642 250 669 321 q 562 121 614 178 q 426 32 510 64 q 220 -1 342 -1 l 207 -1 l 207 105 z "},"\\u0000":{"ha":0,"x_min":0,"x_max":0,"o":""},"\\u0002":{"ha":0,"x_min":0,"x_max":0,"o":""},"\\r":{"ha":345,"x_min":0,"x_max":0,"o":""}," ":{"ha":345,"x_min":0,"x_max":0,"o":""},"!":{"ha":358,"x_min":109,"x_max":258,"o":"m 245 987 l 236 279 l 123 279 l 113 987 l 245 987 m 109 63 q 128 115 109 94 q 183 136 146 136 q 238 115 219 136 q 258 63 258 94 q 238 13 258 34 q 183 -8 219 -8 q 128 13 146 -8 q 109 63 109 34 z "},"\\"":{"ha":445,"x_min":93,"x_max":372,"o":"m 189 1042 l 189 949 l 168 707 l 93 707 l 93 943 l 93 1042 l 189 1042 m 372 1042 l 372 949 l 351 707 l 276 707 l 276 948 l 276 1042 l 372 1042 z "},"#":{"ha":855,"x_min":81,"x_max":838,"o":"m 189 0 l 381 987 l 479 987 l 286 0 l 189 0 m 465 0 l 658 987 l 755 987 l 562 0 l 465 0 m 838 611 l 132 611 l 132 705 l 838 705 l 838 611 m 787 278 l 81 278 l 81 372 l 787 372 l 787 278 z "},"$":{"ha":781,"x_min":75,"x_max":707,"o":"m 457 1147 l 457 941 l 355 941 l 355 1147 l 457 1147 m 445 40 l 445 -141 l 344 -141 l 344 40 l 445 40 m 581 254 q 562 328 581 295 q 502 387 544 360 q 389 437 460 414 q 242 502 304 464 q 146 596 180 540 q 113 732 113 652 q 149 876 113 816 q 250 969 184 937 q 405 1002 316 1002 q 528 981 474 1002 q 620 920 583 960 q 678 820 658 879 q 698 684 698 761 l 573 684 q 562 767 573 729 q 530 833 551 805 q 477 877 508 861 q 405 892 446 892 q 311 872 348 892 q 256 817 274 852 q 239 734 239 781 q 256 659 239 691 q 316 600 274 626 q 433 549 359 574 q 582 483 521 521 q 675 391 643 446 q 707 256 707 336 q 667 108 707 168 q 557 17 628 48 q 390 -14 486 -14 q 276 1 332 -14 q 174 53 220 17 q 102 147 129 88 q 75 291 75 205 l 201 291 q 217 196 201 233 q 262 136 234 158 q 323 105 290 114 q 390 96 357 96 q 493 115 451 96 q 558 170 536 134 q 581 254 581 206 z "},"%":{"ha":1017,"x_min":71,"x_max":957,"o":"m 71 745 l 71 798 q 96 900 71 854 q 165 974 120 946 q 273 1002 211 1002 q 382 974 337 1002 q 452 900 427 946 q 476 798 476 854 l 476 745 q 452 644 476 690 q 383 570 428 598 q 275 543 338 543 q 166 570 212 543 q 96 644 120 598 q 71 745 71 690 m 165 798 l 165 745 q 177 686 165 714 q 214 641 189 659 q 275 624 238 624 q 335 641 311 624 q 370 686 359 659 q 382 745 382 714 l 382 798 q 370 858 382 829 q 334 903 358 886 q 273 920 310 920 q 213 903 237 920 q 177 858 189 886 q 165 798 165 829 m 552 189 l 552 242 q 576 344 552 298 q 646 418 601 390 q 754 446 692 446 q 863 418 818 446 q 932 344 908 390 q 957 242 957 298 l 957 189 q 933 87 957 134 q 864 14 909 41 q 755 -14 819 -14 q 647 14 692 -14 q 577 87 602 41 q 552 189 552 134 m 646 242 l 646 189 q 658 130 646 158 q 694 84 670 102 q 755 67 719 67 q 816 84 792 67 q 852 130 840 102 q 863 189 863 157 l 863 242 q 851 302 863 274 q 815 347 840 330 q 754 364 791 364 q 694 347 718 364 q 658 302 670 330 q 646 242 646 274 m 785 847 l 303 75 l 233 120 l 715 892 l 785 847 z "},"&":{"ha":864,"x_min":69,"x_max":859,"o":"m 278 548 l 426 653 q 492 712 469 682 q 515 793 515 741 q 484 866 515 833 q 396 899 453 899 q 330 880 357 899 q 289 832 302 862 q 275 766 275 802 q 290 703 275 735 q 332 635 305 670 q 392 560 358 600 l 859 0 l 709 0 l 326 458 q 235 568 275 518 q 172 665 195 618 q 149 762 149 711 q 180 892 149 839 q 267 973 211 945 q 397 1001 322 1001 q 522 972 469 1001 q 603 896 574 943 q 631 793 631 849 q 614 708 631 745 q 567 639 597 670 q 497 578 537 608 l 301 432 q 230 363 252 396 q 201 306 208 331 q 195 266 195 281 q 216 178 195 218 q 280 114 237 138 q 388 90 323 90 q 499 116 445 90 q 595 190 553 142 q 664 306 638 239 q 689 456 689 374 l 802 456 q 789 329 802 389 q 749 218 776 269 q 681 125 722 167 q 671 111 675 119 q 662 96 668 102 q 537 14 611 41 q 388 -14 463 -14 q 218 22 290 -14 q 108 121 146 58 q 69 266 69 184 q 96 376 69 328 q 170 465 123 423 q 278 548 217 506 z "},"\'":{"ha":243,"x_min":71,"x_max":172,"o":"m 172 1042 l 172 967 l 158 718 l 71 718 l 71 956 l 71 1042 l 172 1042 z "},"(":{"ha":475,"x_min":91,"x_max":449,"o":"m 91 395 l 91 401 q 124 669 91 549 q 209 879 157 789 q 317 1028 260 969 q 422 1114 374 1088 l 449 1031 q 368 947 409 1001 q 293 816 327 894 q 237 635 258 738 q 216 403 216 532 l 216 393 q 237 161 216 264 q 293 -21 258 58 q 368 -155 327 -100 q 449 -243 409 -210 l 422 -319 q 317 -233 374 -292 q 209 -84 260 -174 q 124 126 157 6 q 91 395 91 246 z "},")":{"ha":484,"x_min":26,"x_max":385,"o":"m 385 401 l 385 395 q 351 126 385 246 q 267 -84 318 6 q 158 -233 215 -174 q 53 -319 101 -292 l 26 -243 q 107 -158 66 -212 q 182 -23 148 -103 q 238 160 217 56 q 259 393 259 264 l 259 403 q 237 636 259 532 q 179 819 214 740 q 103 953 143 899 q 26 1038 62 1008 l 53 1114 q 158 1028 101 1088 q 267 879 215 969 q 351 669 318 789 q 385 401 385 549 z "},"*":{"ha":598,"x_min":19,"x_max":579,"o":"m 87 480 l 224 667 l 19 728 l 51 830 l 256 755 l 250 988 l 353 988 l 346 751 l 548 826 l 579 722 l 371 661 l 505 477 l 420 414 l 295 609 l 172 418 l 87 480 z "},"+":{"ha":788,"x_min":53,"x_max":730,"o":"m 730 530 l 730 412 l 53 412 l 53 530 l 730 530 m 454 818 l 454 99 l 329 99 l 329 818 l 454 818 z "},",":{"ha":273,"x_min":20,"x_max":210,"o":"m 210 149 l 210 48 q 178 -82 210 -14 q 91 -197 147 -151 l 20 -148 q 56 -87 41 -118 q 79 -23 71 -56 q 87 46 87 9 l 87 149 l 210 149 z "},"-":{"ha":384,"x_min":26,"x_max":357,"o":"m 357 471 l 357 368 l 26 368 l 26 471 l 357 471 z "},".":{"ha":366,"x_min":98,"x_max":254,"o":"m 98 66 q 118 120 98 98 q 176 142 138 142 q 234 120 214 142 q 254 66 254 98 q 234 14 254 35 q 176 -8 214 -8 q 118 14 138 -8 q 98 66 98 35 z "},"/":{"ha":573,"x_min":13,"x_max":532,"o":"m 532 987 l 121 -85 l 13 -85 l 425 987 l 532 987 z "},":":{"ha":336,"x_min":90,"x_max":247,"o":"m 90 66 q 110 120 90 98 q 168 142 130 142 q 226 120 206 142 q 246 66 246 98 q 226 14 246 35 q 168 -8 206 -8 q 110 14 130 -8 q 90 66 90 35 m 91 665 q 111 719 91 697 q 169 741 131 741 q 227 719 207 741 q 247 665 247 697 q 227 612 247 634 q 169 591 207 591 q 111 612 131 591 q 91 665 91 634 z "},";":{"ha":294,"x_min":28,"x_max":231,"o":"m 75 665 q 95 719 75 697 q 153 741 115 741 q 211 719 191 741 q 231 665 231 697 q 211 612 231 634 q 153 591 191 591 q 95 612 115 591 q 75 665 75 634 m 218 149 l 218 48 q 186 -82 218 -14 q 99 -197 155 -151 l 28 -148 q 64 -87 50 -118 q 87 -23 79 -56 q 95 46 95 9 l 95 149 l 218 149 z "},"<":{"ha":706,"x_min":49,"x_max":604,"o":"m 135 456 l 604 266 l 604 133 l 49 390 l 49 468 l 135 456 m 604 612 l 136 419 l 49 410 l 49 488 l 604 745 l 604 612 z "},"=":{"ha":762,"x_min":103,"x_max":669,"o":"m 669 661 l 669 552 l 103 552 l 103 661 l 669 661 m 669 380 l 669 271 l 103 271 l 103 380 l 669 380 z "},">":{"ha":726,"x_min":92,"x_max":671,"o":"m 574 429 l 92 616 l 92 746 l 671 490 l 671 410 l 574 429 m 92 263 l 575 455 l 671 469 l 671 391 l 92 134 l 92 263 z "},"?":{"ha":656,"x_min":51,"x_max":602,"o":"m 368 278 l 242 278 q 254 385 243 343 q 291 461 265 427 q 359 540 317 496 q 417 600 391 572 q 459 661 443 628 q 475 740 475 694 q 459 821 475 787 q 410 873 442 854 q 330 891 378 891 q 256 877 291 891 q 199 833 220 863 q 176 756 177 804 l 51 756 q 89 888 52 833 q 189 972 126 943 q 330 1001 252 1001 q 477 970 416 1001 q 570 881 538 939 q 602 743 602 823 q 577 631 602 682 q 513 535 552 580 q 431 450 475 490 q 381 372 394 415 q 368 278 368 328 m 237 63 q 256 115 237 94 q 311 136 275 136 q 366 115 347 136 q 385 63 385 94 q 366 13 385 34 q 311 -8 347 -8 q 256 13 275 -8 q 237 63 237 34 z "},"@":{"ha":1247,"x_min":74,"x_max":1182,"o":"m 1177 341 q 1158 216 1175 279 q 1109 101 1142 153 q 1025 17 1077 49 q 900 -14 973 -14 q 818 2 853 -14 q 761 50 783 19 q 731 125 739 81 q 728 224 722 170 l 762 600 l 862 600 l 827 224 q 830 143 823 174 q 850 95 836 112 q 881 73 863 79 q 914 66 898 66 q 987 88 955 66 q 1041 147 1019 109 q 1075 234 1063 184 q 1090 341 1087 284 q 1081 527 1095 442 q 1034 677 1067 612 q 948 789 1001 743 q 822 858 895 834 q 654 882 749 882 q 497 856 569 882 q 367 781 425 829 q 269 663 310 732 q 204 509 228 595 q 177 324 181 423 q 188 137 172 222 q 238 -15 203 52 q 327 -128 273 -81 q 451 -198 380 -174 q 608 -222 522 -222 q 729 -208 668 -222 q 832 -170 791 -194 l 858 -247 q 740 -292 810 -277 q 606 -307 669 -307 q 417 -279 503 -307 q 267 -197 332 -251 q 158 -66 201 -143 q 94 109 115 11 q 79 324 74 208 q 112 534 83 435 q 191 712 141 632 q 311 850 241 792 q 468 939 380 908 q 657 970 555 970 q 846 942 762 970 q 995 860 931 913 q 1101 729 1059 806 q 1163 554 1143 652 q 1177 341 1182 456 m 481 283 q 481 199 476 236 q 499 136 486 161 q 535 97 513 110 q 587 83 557 83 q 628 93 606 83 q 671 124 650 103 q 710 179 692 145 q 741 260 728 213 l 785 212 q 745 114 770 156 q 690 43 720 72 q 625 0 659 15 q 555 -14 591 -14 q 469 7 506 -14 q 408 68 431 28 q 376 162 385 107 q 373 283 367 216 q 398 415 379 355 q 445 523 417 475 q 509 604 473 570 q 585 654 545 637 q 667 671 625 671 q 782 650 740 671 q 862 600 824 629 l 804 532 q 753 568 785 551 q 677 584 721 584 q 608 565 640 584 q 549 508 575 546 q 505 414 523 470 q 481 283 488 358 z "},"A":{"ha":906,"x_min":20,"x_max":888,"o":"m 480 900 l 153 0 l 20 0 l 396 987 l 482 987 l 480 900 m 754 0 l 427 900 l 425 987 l 511 987 l 888 0 l 754 0 m 737 366 l 737 258 l 182 258 l 182 366 l 737 366 z "},"B":{"ha":865,"x_min":115,"x_max":787,"o":"m 467 462 l 216 462 l 215 567 l 442 567 q 541 586 498 567 q 606 641 583 605 q 629 726 629 676 q 609 814 629 780 q 546 864 588 848 q 438 880 503 880 l 245 880 l 245 0 l 115 0 l 115 987 l 438 987 q 574 972 514 987 q 675 925 633 957 q 739 843 717 892 q 760 724 760 793 q 729 614 760 663 q 643 534 698 565 q 513 494 587 503 l 467 462 m 460 0 l 165 0 l 239 106 l 460 106 q 567 128 523 106 q 633 190 610 150 q 656 283 656 229 q 637 378 656 338 q 575 440 617 418 q 467 462 533 462 l 280 462 l 281 567 l 536 567 l 564 529 q 685 489 635 523 q 761 401 734 454 q 787 285 787 349 q 746 129 787 193 q 633 33 706 66 q 460 0 559 0 z "},"C":{"ha":904,"x_min":81,"x_max":841,"o":"m 711 314 l 841 314 q 787 146 831 220 q 665 30 744 73 q 467 -14 585 -14 q 309 19 380 -14 q 187 112 238 52 q 109 256 136 172 q 81 444 81 340 l 81 543 q 109 731 81 646 q 188 876 136 815 q 313 968 240 936 q 478 1001 387 1001 q 667 959 590 1001 q 788 843 745 917 q 841 671 831 768 l 711 671 q 675 790 701 740 q 602 867 650 840 q 478 894 555 894 q 362 869 412 894 q 279 798 313 844 q 229 687 245 751 q 212 544 212 623 l 212 444 q 227 308 212 372 q 273 196 242 244 q 353 120 304 148 q 467 93 401 93 q 600 119 550 93 q 674 195 649 146 q 711 314 700 245 z "},"D":{"ha":911,"x_min":115,"x_max":829,"o":"m 382 0 l 176 0 l 177 106 l 382 106 q 558 151 488 106 q 664 276 629 195 q 700 464 700 356 l 700 524 q 680 675 700 609 q 620 787 659 741 q 524 857 581 833 q 394 880 467 880 l 172 880 l 172 987 l 394 987 q 571 955 491 987 q 709 862 651 923 q 798 716 767 802 q 829 523 829 630 l 829 464 q 798 271 829 357 q 708 125 767 185 q 567 32 650 64 q 382 0 485 0 m 245 987 l 245 0 l 115 0 l 115 987 l 245 987 z "},"E":{"ha":789,"x_min":115,"x_max":742,"o":"m 742 106 l 742 0 l 219 0 l 219 106 l 742 106 m 245 987 l 245 0 l 115 0 l 115 987 l 245 987 m 673 563 l 673 456 l 219 456 l 219 563 l 673 563 m 735 987 l 735 880 l 219 880 l 219 987 l 735 987 z "},"F":{"ha":768,"x_min":115,"x_max":726,"o":"m 245 987 l 245 0 l 115 0 l 115 987 l 245 987 m 659 543 l 659 436 l 217 436 l 217 543 l 659 543 m 726 987 l 726 880 l 217 880 l 217 987 l 726 987 z "},"G":{"ha":946,"x_min":83,"x_max":844,"o":"m 844 492 l 844 130 q 786 70 826 103 q 676 11 746 36 q 495 -14 606 -14 q 329 18 405 -14 q 198 110 254 50 q 113 258 143 171 q 83 456 83 345 l 83 532 q 109 730 83 643 q 186 877 135 817 q 311 969 237 938 q 480 1001 385 1001 q 670 962 593 1001 q 789 854 746 923 q 844 699 832 786 l 713 699 q 679 796 705 752 q 604 867 652 840 q 480 894 556 894 q 361 869 412 894 q 279 797 311 844 q 230 684 246 750 q 214 534 214 617 l 214 456 q 234 303 214 370 q 292 189 254 236 q 381 117 329 142 q 496 93 433 93 q 609 105 566 93 q 677 133 652 117 q 714 165 701 150 l 714 386 l 486 386 l 486 492 l 844 492 z "},"H":{"ha":991,"x_min":115,"x_max":873,"o":"m 760 563 l 760 456 l 225 456 l 225 563 l 760 563 m 245 987 l 245 0 l 115 0 l 115 987 l 245 987 m 873 987 l 873 0 l 743 0 l 743 987 l 873 987 z "},"I":{"ha":378,"x_min":124,"x_max":255,"o":"m 255 987 l 255 0 l 124 0 l 124 987 l 255 987 z "},"J":{"ha":766,"x_min":36,"x_max":659,"o":"m 529 288 l 529 987 l 659 987 l 659 288 q 619 123 659 191 q 509 21 579 56 q 348 -14 439 -14 q 186 18 257 -14 q 76 113 116 49 q 36 273 36 176 l 167 273 q 190 171 167 211 q 254 112 213 131 q 348 93 295 93 q 440 115 399 93 q 505 181 481 137 q 529 288 529 224 z "},"K":{"ha":871,"x_min":115,"x_max":871,"o":"m 245 987 l 245 0 l 115 0 l 115 987 l 245 987 m 842 987 l 431 527 l 201 288 l 179 427 l 353 618 l 684 987 l 842 987 m 715 0 l 350 481 l 428 585 l 871 0 l 715 0 z "},"L":{"ha":748,"x_min":115,"x_max":713,"o":"m 713 106 l 713 0 l 220 0 l 220 106 l 713 106 m 245 987 l 245 0 l 115 0 l 115 987 l 245 987 z "},"M":{"ha":1213,"x_min":115,"x_max":1097,"o":"m 156 987 l 283 987 l 606 182 l 929 987 l 1057 987 l 655 0 l 556 0 l 156 987 m 115 987 l 227 987 l 245 385 l 245 0 l 115 0 l 115 987 m 985 987 l 1097 987 l 1097 0 l 967 0 l 967 385 l 985 987 z "},"N":{"ha":991,"x_min":115,"x_max":874,"o":"m 874 987 l 874 0 l 743 0 l 245 762 l 245 0 l 115 0 l 115 987 l 245 987 l 745 224 l 745 987 l 874 987 z "},"O":{"ha":956,"x_min":81,"x_max":875,"o":"m 875 525 l 875 463 q 847 263 875 351 q 767 113 819 175 q 642 19 715 52 q 479 -14 569 -14 q 318 19 391 -14 q 192 113 245 52 q 110 263 139 175 q 81 463 81 351 l 81 525 q 110 724 81 636 q 191 874 138 812 q 317 968 244 936 q 477 1001 390 1001 q 641 968 568 1001 q 766 874 713 936 q 847 724 819 812 q 875 525 875 636 m 745 463 l 745 526 q 727 682 745 614 q 675 796 709 750 q 590 866 640 842 q 477 890 541 890 q 367 866 416 890 q 283 796 318 842 q 229 682 248 750 q 210 526 210 614 l 210 463 q 229 306 210 374 q 284 191 248 237 q 369 121 319 144 q 479 97 418 97 q 592 121 543 97 q 676 191 642 144 q 728 306 710 237 q 745 463 745 374 z "},"P":{"ha":876,"x_min":115,"x_max":825,"o":"m 479 387 l 215 387 l 215 494 l 479 494 q 603 518 555 494 q 672 586 650 543 q 694 685 694 629 q 672 781 694 736 q 603 853 650 825 q 479 880 555 880 l 245 880 l 245 0 l 115 0 l 115 987 l 479 987 q 668 949 591 987 q 785 842 745 910 q 825 686 825 774 q 785 524 825 591 q 668 422 745 457 q 479 387 591 387 z "},"Q":{"ha":956,"x_min":75,"x_max":872,"o":"m 621 113 l 872 -85 l 784 -167 l 537 29 l 621 113 m 869 525 l 869 463 q 841 263 869 351 q 761 113 813 175 q 636 19 709 52 q 473 -14 563 -14 q 312 19 385 -14 q 186 113 239 52 q 104 263 133 175 q 75 463 75 351 l 75 525 q 103 724 75 636 q 185 874 132 812 q 311 968 238 936 q 471 1001 384 1001 q 635 968 562 1001 q 760 874 708 936 q 841 724 812 812 q 869 525 869 636 m 739 463 l 739 526 q 721 682 739 614 q 669 796 703 750 q 585 866 634 842 q 471 890 535 890 q 362 866 411 890 q 277 796 313 842 q 223 682 242 750 q 204 526 204 614 l 204 463 q 223 306 204 374 q 278 191 242 237 q 363 121 313 144 q 473 97 412 97 q 586 121 536 97 q 670 191 635 144 q 722 306 704 237 q 739 463 739 374 z "},"R":{"ha":856,"x_min":115,"x_max":831,"o":"m 115 987 l 441 987 q 630 954 553 987 q 747 853 707 920 q 787 691 787 787 q 760 567 787 623 q 681 472 732 511 q 559 414 630 433 l 522 400 l 215 400 l 214 507 l 446 507 q 563 531 516 507 q 633 598 610 556 q 657 691 657 640 q 635 791 657 748 q 565 857 612 833 q 441 880 517 880 l 245 880 l 245 0 l 115 0 l 115 987 m 692 0 l 452 448 l 588 448 l 831 8 l 831 0 l 692 0 z "},"S":{"ha":825,"x_min":55,"x_max":772,"o":"m 641 250 q 630 311 641 284 q 594 359 620 338 q 522 401 568 381 q 406 441 476 420 q 274 489 333 463 q 173 551 215 516 q 109 630 131 585 q 86 732 86 675 q 110 839 86 790 q 178 924 134 888 q 284 981 222 960 q 422 1001 346 1001 q 611 959 533 1001 q 729 848 688 916 q 770 703 770 780 l 640 703 q 616 801 640 758 q 544 869 592 844 q 422 894 496 894 q 307 873 352 894 q 239 816 261 852 q 217 734 217 780 q 230 677 217 703 q 272 630 243 652 q 343 590 300 608 q 448 555 387 572 q 593 502 532 531 q 694 436 654 473 q 753 354 734 400 q 772 251 772 309 q 748 142 772 191 q 678 58 724 93 q 569 5 633 24 q 428 -14 506 -14 q 293 5 359 -14 q 173 62 227 24 q 87 156 119 100 q 55 286 55 212 l 185 286 q 205 199 185 235 q 259 139 224 163 q 337 104 293 115 q 428 93 380 93 q 544 112 496 93 q 616 166 591 131 q 641 250 641 201 z "},"T":{"ha":829,"x_min":34,"x_max":797,"o":"m 479 987 l 479 0 l 351 0 l 351 987 l 479 987 m 797 987 l 797 880 l 34 880 l 34 987 l 797 987 z "},"U":{"ha":901,"x_min":95,"x_max":810,"o":"m 680 987 l 810 987 l 810 319 q 760 134 810 208 q 629 23 711 60 q 452 -14 547 -14 q 270 23 351 -14 q 142 134 189 60 q 95 319 95 208 l 95 987 l 224 987 l 224 319 q 253 192 224 242 q 333 117 281 142 q 452 93 384 93 q 571 117 520 93 q 651 192 623 142 q 680 319 680 242 l 680 987 z "},"V":{"ha":884,"x_min":20,"x_max":866,"o":"m 433 150 l 724 987 l 866 987 l 500 0 l 399 0 l 433 150 m 161 987 l 450 150 l 486 0 l 385 0 l 20 987 l 161 987 z "},"W":{"ha":1232,"x_min":41,"x_max":1202,"o":"m 374 298 l 570 987 l 665 987 l 610 720 l 399 0 l 305 0 l 374 298 m 172 987 l 328 312 l 374 0 l 281 0 l 41 987 l 172 987 m 919 313 l 1072 987 l 1202 987 l 964 0 l 870 0 l 919 313 m 680 987 l 870 298 l 939 0 l 845 0 l 642 720 l 586 987 l 680 987 z "},"X":{"ha":871,"x_min":39,"x_max":834,"o":"m 199 987 l 437 609 l 674 987 l 827 987 l 515 498 l 834 0 l 680 0 l 437 386 l 193 0 l 39 0 l 359 498 l 47 987 l 199 987 z "},"Y":{"ha":834,"x_min":10,"x_max":822,"o":"m 160 987 l 416 492 l 673 987 l 822 987 l 481 369 l 481 0 l 351 0 l 351 369 l 10 987 l 160 987 z "},"Z":{"ha":832,"x_min":59,"x_max":777,"o":"m 777 106 l 777 0 l 109 0 l 109 106 l 777 106 m 755 892 l 140 0 l 59 0 l 59 98 l 674 987 l 755 987 l 755 892 m 700 987 l 700 880 l 68 880 l 68 987 l 700 987 z "},"[":{"ha":368,"x_min":100,"x_max":355,"o":"m 355 1128 l 355 1025 l 225 1025 l 225 -109 l 355 -109 l 355 -212 l 100 -212 l 100 1128 l 355 1128 z "},"\\\\":{"ha":570,"x_min":28,"x_max":559,"o":"m 440 -85 l 28 987 l 147 987 l 559 -85 l 440 -85 z "},"]":{"ha":368,"x_min":7,"x_max":263,"o":"m 7 1025 l 7 1128 l 263 1128 l 263 -212 l 7 -212 l 7 -109 l 137 -109 l 137 1025 l 7 1025 z "},"^":{"ha":581,"x_min":43,"x_max":535,"o":"m 298 842 l 160 494 l 43 494 l 246 987 l 322 987 l 298 842 m 418 494 l 281 842 l 256 987 l 333 987 l 535 494 l 418 494 z "},"_":{"ha":627,"x_min":3,"x_max":625,"o":"m 625 0 l 625 -103 l 3 -103 l 3 0 l 625 0 z "},"`":{"ha":429,"x_min":39,"x_max":321,"o":"m 191 1042 l 321 842 l 214 842 l 39 1042 l 191 1042 z "},"a":{"ha":755,"x_min":74,"x_max":680,"o":"m 528 125 l 528 503 q 511 579 528 547 q 459 629 494 611 q 374 646 425 646 q 291 630 326 646 q 235 587 255 614 q 215 530 215 561 l 90 530 q 110 608 90 570 q 169 679 130 647 q 261 729 207 710 q 381 747 315 747 q 523 720 461 747 q 619 638 584 693 q 654 502 654 584 l 654 160 q 660 82 654 123 q 680 11 667 41 l 680 0 l 549 0 q 534 58 539 22 q 528 125 528 94 m 550 445 l 551 357 l 425 357 q 329 348 371 357 q 258 323 287 340 q 215 280 230 306 q 200 221 200 255 q 216 158 200 186 q 263 113 231 130 q 340 96 294 96 q 442 121 398 96 q 512 180 486 145 q 541 249 538 216 l 594 189 q 568 125 589 160 q 512 59 547 91 q 430 7 477 28 q 322 -14 382 -14 q 192 16 248 -14 q 105 94 136 45 q 74 204 74 143 q 97 308 74 263 q 163 384 120 353 q 268 429 207 414 q 404 445 329 445 l 550 445 z "},"b":{"ha":780,"x_min":95,"x_max":717,"o":"m 95 1042 l 221 1042 l 221 142 l 210 0 l 95 0 l 95 1042 m 717 373 l 717 359 q 698 211 717 279 q 642 92 679 142 q 553 14 606 42 q 431 -14 500 -14 q 309 11 361 -14 q 220 80 256 35 q 163 190 184 125 q 134 335 142 254 l 134 397 q 163 543 142 479 q 220 653 184 608 q 309 723 256 699 q 430 747 361 747 q 553 721 499 747 q 643 644 606 694 q 698 526 679 595 q 717 373 717 457 m 591 359 l 591 373 q 581 476 591 428 q 548 562 570 525 q 489 620 526 599 q 399 642 452 642 q 316 625 351 642 q 257 582 281 609 q 217 519 233 554 q 195 447 202 484 l 195 283 q 230 192 205 236 q 297 121 255 149 q 400 93 338 93 q 487 114 451 93 q 546 171 524 134 q 580 256 569 208 q 591 359 591 304 z "},"c":{"ha":727,"x_min":63,"x_max":682,"o":"m 389 90 q 472 108 434 90 q 534 158 510 126 q 562 232 559 191 l 682 232 q 638 111 678 167 q 532 21 597 55 q 389 -14 467 -14 q 245 16 307 -14 q 143 96 184 45 q 83 213 103 146 q 63 353 63 279 l 63 381 q 83 521 63 455 q 143 638 103 587 q 245 718 184 689 q 389 747 307 747 q 540 712 475 747 q 641 617 604 677 q 682 481 678 557 l 562 481 q 537 564 559 527 q 477 622 515 600 q 389 644 439 644 q 293 622 332 644 q 231 561 254 599 q 198 476 208 522 q 189 381 189 429 l 189 353 q 198 258 189 304 q 230 173 208 211 q 292 112 253 135 q 389 90 331 90 z "},"d":{"ha":783,"x_min":64,"x_max":684,"o":"m 558 142 l 558 1042 l 684 1042 l 684 0 l 569 0 l 558 142 m 64 359 l 64 373 q 85 526 64 457 q 144 644 106 595 q 236 721 182 694 q 355 747 289 747 q 476 723 424 747 q 564 653 528 699 q 621 543 600 608 q 650 397 642 479 l 650 335 q 622 190 643 254 q 564 80 600 125 q 475 11 528 35 q 353 -14 423 -14 q 236 14 289 -14 q 144 92 182 42 q 85 211 106 142 q 64 359 64 279 m 191 373 l 191 359 q 202 256 191 304 q 237 171 213 208 q 297 114 260 134 q 385 93 334 93 q 487 119 447 93 q 552 189 528 146 q 590 283 576 233 l 590 447 q 567 519 582 484 q 527 582 551 554 q 468 625 503 609 q 386 642 433 642 q 297 620 334 642 q 237 562 260 599 q 202 476 213 525 q 191 373 191 428 z "},"e":{"ha":736,"x_min":63,"x_max":686,"o":"m 400 -14 q 261 13 323 -14 q 155 86 199 39 q 87 199 111 134 q 63 341 63 264 l 63 370 q 90 529 63 459 q 161 648 116 600 q 264 722 207 697 q 384 747 322 747 q 520 720 463 747 q 614 645 577 693 q 668 531 650 596 q 686 388 686 465 l 686 332 l 138 332 l 138 434 l 560 434 l 560 444 q 540 538 557 492 q 486 614 523 585 q 384 644 448 644 q 305 626 341 644 q 243 573 269 608 q 203 487 218 538 q 189 370 189 436 l 189 341 q 204 243 189 289 q 247 163 218 197 q 315 109 275 128 q 407 89 355 89 q 519 116 473 89 q 600 189 566 143 l 676 128 q 616 60 652 92 q 526 7 579 27 q 400 -14 473 -14 z "},"f":{"ha":483,"x_min":41,"x_max":485,"o":"m 283 0 l 157 0 l 157 811 q 186 945 157 890 q 269 1028 215 1000 q 398 1056 323 1056 q 442 1053 420 1056 q 485 1045 464 1050 l 478 943 q 446 947 464 946 q 410 949 428 949 q 341 933 370 949 q 298 886 313 917 q 283 811 283 856 l 283 0 m 439 734 l 439 637 l 41 637 l 41 734 l 439 734 z "},"g":{"ha":780,"x_min":66,"x_max":685,"o":"m 571 734 l 685 734 l 685 16 q 646 -150 685 -81 q 536 -254 606 -218 q 374 -290 466 -290 q 285 -278 336 -290 q 185 -238 234 -266 q 102 -162 136 -210 l 168 -87 q 265 -165 214 -143 q 365 -186 315 -186 q 468 -164 425 -186 q 535 -98 511 -142 q 559 9 559 -54 l 559 572 l 571 734 m 66 359 l 66 373 q 86 526 66 457 q 143 644 106 595 q 235 721 181 694 q 355 747 288 747 q 476 723 425 747 q 565 653 528 699 q 622 543 601 608 q 651 397 643 479 l 651 335 q 622 190 644 254 q 565 80 601 125 q 476 11 528 35 q 354 -14 424 -14 q 235 14 288 -14 q 144 92 182 42 q 86 211 106 142 q 66 359 66 279 m 191 373 l 191 359 q 202 256 191 304 q 237 171 214 208 q 297 114 260 134 q 385 93 334 93 q 488 119 447 93 q 552 189 528 146 q 590 283 576 233 l 590 447 q 567 519 583 484 q 528 582 552 554 q 469 625 504 609 q 386 642 433 642 q 297 620 334 642 q 237 562 260 599 q 202 476 214 525 q 191 373 191 428 z "},"h":{"ha":765,"x_min":96,"x_max":673,"o":"m 221 1042 l 221 0 l 96 0 l 96 1042 l 221 1042 m 191 395 l 139 397 q 161 536 140 472 q 222 648 183 600 q 316 721 262 695 q 437 747 371 747 q 535 733 492 747 q 609 686 578 718 q 656 604 640 654 q 673 481 673 553 l 673 0 l 547 0 l 547 482 q 530 575 547 540 q 480 626 513 610 q 400 642 448 642 q 315 622 353 642 q 249 568 277 602 q 207 489 222 533 q 191 395 191 444 z "},"i":{"ha":338,"x_min":96,"x_max":245,"o":"m 232 734 l 232 0 l 106 0 l 106 734 l 232 734 m 96 928 q 115 980 96 959 q 170 1001 134 1001 q 225 980 206 1001 q 245 928 245 959 q 225 879 245 899 q 170 858 206 858 q 115 879 134 858 q 96 928 96 899 z "},"j":{"ha":332,"x_min":-45,"x_max":235,"o":"m 99 734 l 225 734 l 225 -87 q 204 -201 225 -155 q 140 -272 182 -248 q 33 -296 98 -296 q -6 -293 16 -296 q -45 -285 -29 -290 l -44 -184 q -15 -188 -31 -186 q 14 -190 1 -190 q 60 -180 41 -190 q 89 -147 79 -170 q 99 -87 99 -125 l 99 734 m 86 928 q 105 980 86 959 q 160 1001 124 1001 q 216 980 197 1001 q 235 928 235 959 q 216 879 235 899 q 160 858 197 858 q 105 879 124 858 q 86 928 86 899 z "},"k":{"ha":704,"x_min":96,"x_max":703,"o":"m 222 1042 l 222 0 l 96 0 l 96 1042 l 222 1042 m 670 734 l 350 391 l 171 205 l 161 339 l 289 492 l 517 734 l 670 734 m 555 0 l 294 350 l 359 462 l 703 0 l 555 0 z "},"l":{"ha":338,"x_min":106,"x_max":232,"o":"m 232 1042 l 232 0 l 106 0 l 106 1042 l 232 1042 z "},"m":{"ha":1218,"x_min":94,"x_max":1124,"o":"m 220 588 l 220 0 l 94 0 l 94 734 l 214 734 l 220 588 m 195 395 l 136 397 q 156 536 137 472 q 212 648 175 600 q 305 721 250 695 q 434 747 361 747 q 529 733 486 747 q 604 687 572 718 q 654 607 636 656 q 671 489 671 558 l 671 0 l 546 0 l 546 483 q 527 575 546 541 q 472 626 507 610 q 389 642 437 642 q 296 622 334 642 q 237 568 259 602 q 204 489 214 533 q 195 395 195 444 m 670 464 l 586 438 q 606 554 587 498 q 662 653 625 610 q 753 722 699 696 q 878 747 808 747 q 982 732 937 747 q 1060 684 1028 716 q 1107 602 1091 652 q 1124 482 1124 551 l 1124 0 l 998 0 l 998 484 q 978 579 998 545 q 924 628 959 614 q 841 642 889 642 q 768 627 800 642 q 714 588 736 613 q 681 532 692 564 q 670 464 670 500 z "},"n":{"ha":767,"x_min":96,"x_max":673,"o":"m 221 577 l 221 0 l 96 0 l 96 734 l 214 734 l 221 577 m 191 395 l 139 397 q 161 536 140 472 q 222 648 183 600 q 316 721 262 695 q 437 747 371 747 q 535 733 492 747 q 609 686 578 718 q 656 604 640 654 q 673 481 673 553 l 673 0 l 547 0 l 547 482 q 530 575 547 540 q 480 626 513 610 q 400 642 448 642 q 315 622 353 642 q 249 568 277 602 q 207 489 222 533 q 191 395 191 444 z "},"o":{"ha":792,"x_min":62,"x_max":730,"o":"m 62 359 l 62 374 q 85 522 62 454 q 152 641 109 590 q 257 719 195 691 q 395 747 319 747 q 535 719 473 747 q 641 641 597 691 q 707 522 684 590 q 730 374 730 454 l 730 359 q 707 212 730 279 q 641 93 684 144 q 535 15 597 43 q 397 -14 474 -14 q 258 15 319 -14 q 152 93 196 43 q 85 212 109 144 q 62 359 62 279 m 188 374 l 188 359 q 201 255 188 304 q 240 170 214 207 q 305 111 266 132 q 397 90 345 90 q 487 111 448 90 q 552 170 526 132 q 591 255 578 207 q 604 359 604 304 l 604 374 q 591 477 604 429 q 552 563 578 526 q 487 623 526 601 q 395 644 448 644 q 305 623 344 644 q 240 563 266 601 q 201 477 214 526 q 188 374 188 429 z "},"p":{"ha":780,"x_min":95,"x_max":715,"o":"m 221 593 l 221 -282 l 95 -282 l 95 734 l 210 734 l 221 593 m 715 373 l 715 359 q 696 211 715 279 q 641 92 677 142 q 552 14 605 42 q 431 -14 499 -14 q 307 9 361 -14 q 216 77 254 33 q 157 182 179 121 q 127 321 135 244 l 127 397 q 157 543 135 479 q 217 653 180 608 q 307 723 254 699 q 429 747 359 747 q 551 721 498 747 q 642 644 605 694 q 697 526 678 595 q 715 373 715 457 m 589 359 l 589 373 q 578 476 589 428 q 542 562 566 525 q 481 620 518 599 q 392 642 444 642 q 310 625 345 642 q 250 582 275 609 q 211 519 226 554 q 188 447 195 484 l 188 271 q 226 182 201 224 q 291 115 250 140 q 393 90 332 90 q 481 111 444 90 q 542 170 518 132 q 578 255 566 207 q 589 359 589 304 z "},"q":{"ha":789,"x_min":64,"x_max":684,"o":"m 557 -282 l 557 593 l 568 734 l 684 734 l 684 -282 l 557 -282 m 64 359 l 64 373 q 84 526 64 457 q 142 644 104 595 q 234 721 180 694 q 357 747 288 747 q 478 723 426 747 q 568 653 531 699 q 627 543 605 608 q 656 397 648 479 l 656 335 q 627 190 649 254 q 569 80 606 125 q 478 11 532 35 q 355 -14 425 -14 q 234 14 288 -14 q 142 92 180 42 q 84 211 104 142 q 64 359 64 279 m 191 373 l 191 359 q 202 255 191 304 q 238 170 214 207 q 299 111 262 132 q 387 90 336 90 q 491 117 449 90 q 557 188 532 144 q 596 283 583 233 l 596 447 q 573 519 589 484 q 532 583 557 555 q 471 628 507 611 q 388 644 435 644 q 299 623 336 644 q 238 563 262 601 q 202 477 214 526 q 191 373 191 428 z "},"r":{"ha":471,"x_min":96,"x_max":450,"o":"m 221 618 l 221 0 l 96 0 l 96 734 l 218 734 l 221 618 m 450 738 l 450 621 q 420 626 434 625 q 389 627 406 627 q 312 613 345 627 q 256 575 279 600 q 219 517 233 551 q 202 444 206 484 l 167 423 q 180 548 167 490 q 221 651 193 606 q 292 722 249 696 q 395 747 335 747 q 426 744 408 747 q 450 738 444 741 z "},"s":{"ha":717,"x_min":64,"x_max":648,"o":"m 523 195 q 511 245 523 222 q 463 288 499 269 q 354 321 427 307 q 244 352 293 334 q 160 395 195 370 q 108 454 126 420 q 90 533 90 488 q 109 615 90 576 q 164 684 128 654 q 250 730 199 713 q 361 747 300 747 q 512 716 450 747 q 608 633 574 685 q 641 518 641 581 l 515 518 q 497 577 515 549 q 445 625 479 606 q 361 644 411 644 q 277 628 309 644 q 230 588 245 612 q 216 536 216 564 q 223 500 216 516 q 248 471 230 484 q 300 446 267 458 q 385 423 333 435 q 533 374 475 403 q 620 304 591 346 q 648 204 648 263 q 628 116 648 156 q 571 47 608 76 q 481 2 533 18 q 365 -14 429 -14 q 201 21 268 -14 q 99 111 134 56 q 64 227 64 165 l 191 227 q 220 145 193 175 q 287 102 248 115 q 365 90 326 90 q 451 103 416 90 q 505 140 486 117 q 523 195 523 164 z "},"t":{"ha":454,"x_min":6,"x_max":406,"o":"m 403 734 l 403 637 l 6 637 l 6 734 l 403 734 m 140 912 l 266 912 l 266 182 q 277 125 266 144 q 307 100 289 106 q 347 94 326 94 q 379 97 362 94 q 406 102 397 100 l 406 0 q 367 -9 391 -5 q 309 -14 343 -14 q 224 5 263 -14 q 163 66 186 23 q 140 182 140 109 l 140 912 z "},"u":{"ha":766,"x_min":93,"x_max":671,"o":"m 545 170 l 545 734 l 671 734 l 671 0 l 551 0 l 545 170 m 568 324 l 621 326 q 605 190 621 252 q 556 83 590 128 q 467 12 522 37 q 334 -14 412 -14 q 236 2 280 -14 q 159 50 191 18 q 110 135 127 83 q 93 260 93 187 l 93 734 l 218 734 l 218 259 q 230 177 218 210 q 260 126 241 145 q 303 100 279 108 q 353 93 328 93 q 480 124 433 93 q 548 207 527 155 q 568 324 568 260 z "},"v":{"ha":673,"x_min":22,"x_max":648,"o":"m 319 113 l 519 734 l 648 734 l 384 0 l 300 0 l 319 113 m 151 734 l 358 110 l 372 0 l 288 0 l 22 734 l 151 734 z "},"w":{"ha":1044,"x_min":29,"x_max":1011,"o":"m 281 130 l 470 734 l 553 734 l 536 614 l 345 0 l 264 0 l 281 130 m 155 734 l 315 123 l 327 0 l 242 0 l 29 734 l 155 734 m 733 128 l 886 734 l 1011 734 l 798 0 l 714 0 l 733 128 m 571 734 l 755 140 l 777 0 l 696 0 l 499 615 l 483 734 l 571 734 z "},"x":{"ha":689,"x_min":28,"x_max":659,"o":"m 180 734 l 341 467 l 504 734 l 651 734 l 411 372 l 659 0 l 513 0 l 344 275 l 174 0 l 28 0 l 275 372 l 36 734 l 180 734 z "},"y":{"ha":657,"x_min":15,"x_max":640,"o":"m 302 76 l 506 734 l 640 734 l 346 -113 q 319 -172 336 -140 q 277 -232 302 -203 q 215 -278 251 -260 q 128 -296 178 -296 q 90 -292 113 -296 q 58 -286 67 -288 l 57 -184 q 74 -185 62 -184 q 91 -186 86 -186 q 163 -175 134 -186 q 214 -138 193 -164 q 250 -66 235 -112 l 302 76 m 152 734 l 342 164 l 375 32 l 285 -14 l 15 734 l 152 734 z "},"z":{"ha":689,"x_min":60,"x_max":642,"o":"m 642 103 l 642 0 l 109 0 l 109 103 l 642 103 m 623 645 l 137 0 l 60 0 l 60 92 l 543 734 l 623 734 l 623 645 m 567 734 l 567 630 l 66 630 l 66 734 l 567 734 z "},"{":{"ha":470,"x_min":43,"x_max":455,"o":"m 429 1083 l 455 1006 q 344 916 374 981 q 313 768 313 851 l 313 627 q 286 504 313 559 q 199 416 258 449 q 43 384 140 384 l 43 467 q 154 510 120 467 q 187 627 187 553 l 187 768 q 209 901 187 839 q 284 1010 231 963 q 429 1083 336 1057 m 455 -170 l 429 -248 q 284 -175 336 -222 q 209 -66 231 -128 q 187 67 187 -4 l 187 207 q 172 292 187 256 q 126 348 157 328 q 43 368 94 368 l 43 451 q 199 418 140 451 q 286 331 258 386 q 313 207 313 275 l 313 67 q 327 -36 313 12 q 371 -118 340 -83 q 455 -170 401 -153 z "},"|":{"ha":339,"x_min":119,"x_max":220,"o":"m 220 987 l 220 -183 l 119 -183 l 119 987 l 220 987 z "},"}":{"ha":470,"x_min":14,"x_max":425,"o":"m 14 1006 l 40 1083 q 185 1010 133 1057 q 260 901 238 963 q 281 768 281 839 l 281 627 q 296 542 281 578 q 343 486 311 506 q 425 467 374 467 l 425 390 q 270 421 330 390 q 183 506 210 452 q 155 627 155 559 l 155 768 q 142 871 155 823 q 99 954 130 919 q 14 1006 68 989 m 40 -248 l 14 -170 q 98 -118 67 -153 q 142 -36 129 -83 q 155 67 155 12 l 155 207 q 183 329 155 275 q 270 413 210 382 q 425 444 330 444 l 425 368 q 315 325 349 368 q 281 207 281 281 l 281 67 q 260 -66 281 -4 q 185 -175 238 -128 q 40 -248 133 -222 z "},"~":{"ha":945,"x_min":89,"x_max":857,"o":"m 753 527 l 857 528 q 841 429 857 475 q 795 348 825 383 q 725 293 766 313 q 637 273 685 273 q 533 297 578 273 q 435 367 488 321 q 371 416 400 399 q 308 434 342 434 q 249 417 273 434 q 211 370 224 401 q 198 297 198 340 l 89 296 q 105 394 89 349 q 150 473 121 439 q 219 526 179 507 q 308 545 260 545 q 414 519 368 545 q 510 450 460 494 q 575 400 547 416 q 637 383 604 383 q 698 401 672 383 q 739 452 724 420 q 753 527 753 485 z "},"¡":{"ha":339,"x_min":94,"x_max":243,"o":"m 106 -245 l 116 464 l 229 464 l 239 -245 l 106 -245 m 243 675 q 224 625 243 646 q 169 604 205 604 q 114 625 133 604 q 94 675 94 646 q 114 726 94 705 q 169 747 133 747 q 224 726 205 747 q 243 675 243 705 z "},"¢":{"ha":760,"x_min":71,"x_max":690,"o":"m 454 894 l 454 699 l 328 699 l 328 894 l 454 894 m 454 28 l 454 -166 l 328 -166 l 328 28 l 454 28 m 398 90 q 481 108 443 90 q 543 158 519 126 q 571 232 568 191 l 690 232 q 646 111 687 167 q 541 21 606 55 q 398 -14 476 -14 q 254 16 315 -14 q 152 96 192 45 q 91 213 111 146 q 71 353 71 279 l 71 381 q 91 521 71 455 q 152 638 111 587 q 254 718 193 689 q 398 747 315 747 q 549 712 484 747 q 650 617 613 677 q 690 481 687 557 l 571 481 q 546 564 568 527 q 486 622 524 600 q 398 644 448 644 q 301 622 340 644 q 240 561 262 599 q 207 476 217 522 q 197 381 197 429 l 197 353 q 207 258 197 304 q 239 173 216 211 q 301 112 262 135 q 398 90 340 90 z "},"£":{"ha":808,"x_min":62,"x_max":765,"o":"m 765 0 l 64 0 l 64 106 l 765 106 l 765 0 m 517 422 l 62 422 l 62 529 l 517 529 l 517 422 m 295 705 l 310 273 q 292 154 311 209 q 235 71 273 98 l 117 106 q 154 141 140 113 q 174 205 168 169 q 180 272 180 242 l 165 705 q 204 864 165 798 q 312 966 243 930 q 466 1001 380 1001 q 617 968 555 1001 q 713 875 680 935 q 746 737 746 816 l 616 737 q 593 829 616 794 q 534 879 570 863 q 455 895 497 895 q 374 872 410 895 q 316 808 338 850 q 295 705 295 766 z "},"¤":{"ha":991,"x_min":71,"x_max":930,"o":"m 212 412 q 234 292 212 349 q 296 194 256 236 q 387 127 335 151 q 498 103 439 103 q 610 127 558 103 q 701 194 662 151 q 763 292 741 236 q 785 412 785 349 q 763 532 785 477 q 701 630 741 588 q 610 696 662 673 q 498 720 558 720 q 387 696 439 720 q 296 630 335 673 q 234 532 256 588 q 212 412 212 477 m 95 412 q 126 580 95 503 q 213 715 158 657 q 342 805 269 772 q 498 837 415 837 q 655 805 582 837 q 784 715 728 772 q 871 580 840 657 q 902 412 902 503 q 871 245 902 322 q 784 110 840 168 q 655 19 728 52 q 498 -14 582 -14 q 342 19 415 -14 q 213 110 269 52 q 126 245 158 168 q 95 412 95 322 m 930 765 l 793 625 l 703 718 l 840 858 l 930 765 m 297 122 l 160 -18 l 71 75 l 208 214 l 297 122 m 840 -18 l 703 121 l 793 214 l 930 75 l 840 -18 m 208 625 l 71 765 l 160 857 l 297 718 l 208 625 z "},"¥":{"ha":730,"x_min":10,"x_max":719,"o":"m 648 500 l 648 415 l 81 415 l 81 500 l 648 500 m 648 302 l 648 218 l 81 218 l 81 302 l 648 302 m 326 452 l 574 987 l 719 987 l 425 410 l 342 410 l 326 452 m 157 987 l 408 447 l 388 410 l 305 410 l 10 987 l 157 987 m 427 525 l 427 0 l 297 0 l 297 525 l 427 525 z "},"¦":{"ha":334,"x_min":100,"x_max":226,"o":"m 226 -183 l 100 -183 l 100 354 l 226 354 l 226 -183 m 226 987 l 226 473 l 100 473 l 100 987 l 226 987 z "},"§":{"ha":852,"x_min":62,"x_max":777,"o":"m 474 73 l 474 153 q 570 171 530 153 q 630 220 609 189 q 651 290 651 251 q 639 346 651 322 q 600 390 627 370 q 525 429 572 410 q 409 469 478 448 q 277 512 335 489 q 179 568 219 536 q 117 645 138 600 q 96 753 96 690 q 120 856 96 810 q 186 934 143 901 q 291 984 230 966 q 428 1002 352 1002 q 606 968 532 1002 q 721 869 681 934 q 761 709 761 804 l 635 709 q 611 805 635 762 q 541 873 587 848 q 428 899 495 899 q 311 879 357 899 q 244 827 266 859 q 222 755 222 794 q 232 696 222 721 q 269 653 243 672 q 341 617 294 634 q 458 580 387 600 q 593 535 534 559 q 693 478 652 511 q 755 401 734 446 q 777 292 777 355 q 755 200 777 241 q 694 131 734 159 q 598 88 654 103 q 474 73 543 73 m 356 593 l 356 511 q 263 493 300 511 q 209 445 227 475 q 191 375 191 414 q 202 316 191 341 q 239 272 212 292 q 312 235 265 252 q 432 197 359 217 q 566 152 507 176 q 664 97 624 128 q 725 20 704 65 q 746 -87 746 -24 q 723 -193 746 -146 q 656 -271 699 -239 q 552 -319 612 -302 q 416 -336 491 -336 q 288 -321 351 -336 q 173 -272 224 -306 q 92 -182 122 -238 q 62 -43 62 -125 l 187 -42 q 208 -133 187 -96 q 261 -191 228 -170 q 335 -223 295 -213 q 416 -233 376 -233 q 527 -214 481 -233 q 596 -162 572 -195 q 621 -89 621 -130 q 609 -34 621 -57 q 570 9 597 -10 q 497 47 543 28 q 382 85 451 65 q 250 130 309 106 q 150 186 191 154 q 87 265 109 219 q 66 374 66 311 q 86 464 66 424 q 144 533 106 505 q 236 577 182 562 q 356 593 290 593 z "},"¨":{"ha":581,"x_min":68,"x_max":509,"o":"m 68 930 q 87 981 68 960 q 142 1002 106 1002 q 198 981 179 1002 q 217 930 217 960 q 198 880 217 901 q 142 859 179 859 q 87 880 106 859 q 68 930 68 901 m 361 928 q 379 980 361 959 q 435 1001 398 1001 q 490 980 471 1001 q 509 928 509 959 q 490 879 509 899 q 435 858 471 858 q 379 879 398 858 q 361 928 361 899 z "},"©":{"ha":1091,"x_min":62,"x_max":1025,"o":"m 661 406 l 760 406 q 699 246 760 299 q 534 193 638 193 q 410 226 463 193 q 329 318 357 259 q 300 455 300 377 l 300 533 q 329 670 300 611 q 410 762 357 729 q 534 795 463 795 q 699 743 638 795 q 760 583 760 690 l 661 583 q 629 680 661 650 q 534 709 597 709 q 459 686 490 709 q 413 624 429 664 q 397 534 397 585 l 397 455 q 413 364 397 404 q 459 302 429 324 q 534 279 490 279 q 629 309 597 279 q 661 406 661 338 m 140 494 q 172 326 140 404 q 258 190 203 248 q 387 99 314 132 q 544 66 460 66 q 700 99 627 66 q 828 190 773 132 q 915 326 884 248 q 946 494 946 404 q 915 663 946 585 q 828 798 884 740 q 700 888 773 856 q 544 920 627 920 q 387 888 460 920 q 258 798 314 856 q 172 663 203 740 q 140 494 140 585 m 62 494 q 100 694 62 602 q 203 856 137 787 q 357 963 270 924 q 544 1001 444 1001 q 731 963 644 1001 q 884 856 818 924 q 987 694 950 787 q 1025 494 1025 602 q 987 294 1025 387 q 884 133 950 202 q 731 24 818 63 q 544 -14 644 -14 q 357 24 444 -14 q 203 133 270 63 q 100 294 137 202 q 62 494 62 387 z "},"ª":{"ha":621,"x_min":100,"x_max":532,"o":"m 404 585 l 404 815 q 394 865 404 844 q 367 896 385 885 q 319 906 348 906 q 246 888 273 906 q 219 835 219 870 l 110 844 q 136 925 110 890 q 209 981 162 961 q 319 1002 256 1002 q 421 981 378 1002 q 490 918 465 960 q 514 814 514 877 l 514 602 q 518 538 514 568 q 532 479 522 509 l 420 479 q 404 585 404 530 m 431 779 l 431 704 l 330 704 q 263 693 290 704 q 223 665 236 682 q 210 625 210 647 q 231 579 210 596 q 295 562 252 562 q 354 575 324 562 q 403 608 383 589 q 422 644 422 627 l 435 568 q 403 523 425 546 q 348 485 382 500 q 269 469 315 469 q 143 511 187 469 q 100 623 100 553 q 125 708 100 673 q 202 761 151 743 q 330 779 253 779 l 431 779 z "},"«":{"ha":652,"x_min":68,"x_max":589,"o":"m 365 642 l 188 369 l 68 370 l 68 378 l 269 642 l 365 642 m 188 375 l 365 102 l 269 102 l 68 366 l 68 374 l 188 375 m 589 642 l 412 369 l 293 370 l 293 378 l 493 642 l 589 642 m 412 375 l 589 102 l 493 102 l 293 366 l 293 374 l 412 375 z "},"¬":{"ha":769,"x_min":86,"x_max":650,"o":"m 650 543 l 650 433 l 86 433 l 86 543 l 650 543 m 650 492 l 650 255 l 524 255 l 524 492 l 650 492 z "},"®":{"ha":1092,"x_min":62,"x_max":1024,"o":"m 561 444 l 413 444 l 412 531 l 549 531 q 603 541 578 532 q 643 569 627 551 q 658 613 658 587 q 646 667 658 647 q 608 695 635 686 q 535 704 581 704 l 443 704 l 443 215 l 347 215 l 347 790 l 535 790 q 651 771 602 790 q 726 714 700 752 q 753 617 753 675 q 736 551 753 581 q 686 501 719 522 q 607 467 654 480 q 603 463 605 467 q 598 458 600 458 q 584 449 587 452 q 577 445 581 446 q 561 444 574 444 m 554 444 l 568 505 q 711 461 673 505 q 749 349 749 416 l 749 312 q 752 264 749 287 q 761 226 755 241 l 761 215 l 663 215 q 655 265 656 233 q 654 313 654 298 l 654 348 q 631 421 654 397 q 554 444 608 444 m 140 494 q 171 326 140 404 q 258 190 202 248 q 387 99 313 132 q 543 66 460 66 q 700 99 627 66 q 828 190 772 132 q 914 326 883 248 q 945 494 945 404 q 914 663 945 585 q 828 798 883 740 q 700 888 772 856 q 543 920 627 920 q 387 888 460 920 q 258 798 313 856 q 171 663 202 740 q 140 494 140 585 m 62 494 q 99 694 62 602 q 203 856 136 787 q 356 963 269 924 q 543 1001 444 1001 q 730 963 643 1001 q 883 856 817 924 q 987 694 949 787 q 1024 494 1024 602 q 987 294 1024 387 q 883 133 949 202 q 730 24 817 63 q 543 -14 643 -14 q 356 24 444 -14 q 203 133 269 63 q 99 294 136 202 q 62 494 62 387 z "},"¯":{"ha":637,"x_min":97,"x_max":552,"o":"m 552 980 l 552 884 l 97 884 l 97 980 l 552 980 z "},"°":{"ha":519,"x_min":89,"x_max":432,"o":"m 89 825 q 113 913 89 873 q 176 978 136 954 q 262 1002 215 1002 q 347 978 309 1002 q 409 913 386 954 q 432 825 432 873 q 409 738 432 777 q 347 674 386 698 q 262 651 309 651 q 176 674 215 651 q 113 738 136 698 q 89 825 89 777 m 173 825 q 199 763 173 788 q 262 738 225 738 q 323 763 298 738 q 348 825 348 788 q 323 889 348 863 q 262 915 298 915 q 199 889 225 915 q 173 825 173 863 z "},"±":{"ha":743,"x_min":66,"x_max":687,"o":"m 687 580 l 687 477 l 66 477 l 66 580 l 687 580 m 441 859 l 441 196 l 328 196 l 328 859 l 441 859 m 659 103 l 659 1 l 92 1 l 92 103 l 659 103 z "},"²":{"ha":509,"x_min":45,"x_max":463,"o":"m 463 539 l 463 452 l 58 452 l 58 526 l 253 709 q 301 760 283 738 q 327 801 319 783 q 334 833 334 819 q 313 887 334 866 q 251 908 291 908 q 176 882 200 908 q 152 818 152 857 l 45 818 q 69 907 45 867 q 139 971 94 947 q 248 995 184 995 q 353 975 309 995 q 419 920 396 956 q 442 835 442 884 q 426 768 442 799 q 381 705 410 736 q 312 638 352 674 l 193 539 l 463 539 z "},"³":{"ha":509,"x_min":43,"x_max":452,"o":"m 180 764 l 237 764 q 292 773 271 764 q 325 799 314 783 q 336 838 336 816 q 315 888 336 867 q 246 908 293 908 q 182 891 208 908 q 157 845 157 874 l 50 845 q 76 925 50 891 q 146 977 102 958 q 244 995 190 995 q 348 978 303 995 q 418 926 393 960 q 443 843 443 892 q 421 777 443 807 q 357 729 399 747 q 256 711 315 711 l 180 711 l 180 764 m 180 686 l 180 739 l 256 739 q 367 722 323 739 q 431 675 410 706 q 452 602 452 645 q 425 517 452 552 q 351 463 398 481 q 245 445 304 445 q 148 461 194 445 q 72 513 101 478 q 43 604 43 549 l 149 604 q 176 552 149 573 q 248 532 203 532 q 320 553 296 532 q 345 607 345 574 q 332 653 345 635 q 295 678 319 670 q 237 686 271 686 l 180 686 z "},"´":{"ha":435,"x_min":83,"x_max":366,"o":"m 83 842 l 215 1042 l 366 1042 l 184 842 l 83 842 z "},"µ":{"ha":787,"x_min":105,"x_max":682,"o":"m 557 734 l 682 734 l 682 0 l 569 0 l 557 170 l 557 734 m 579 341 l 626 342 q 612 200 626 265 q 569 87 598 135 q 494 12 540 39 q 385 -14 449 -14 q 293 -1 334 -14 q 224 41 253 12 q 176 116 195 70 l 151 312 l 230 312 q 241 198 230 242 q 274 130 253 154 q 321 98 294 106 q 380 89 349 89 q 479 107 440 89 q 540 160 518 126 q 570 240 562 194 q 579 341 579 286 m 105 734 l 230 734 l 230 -282 l 105 -282 l 105 734 z "},"¶":{"ha":680,"x_min":46,"x_max":565,"o":"m 565 0 l 439 0 l 439 353 l 380 353 q 197 394 272 353 q 84 507 123 435 q 46 670 46 578 q 84 833 46 761 q 197 946 123 905 q 380 987 272 987 l 565 987 l 565 0 z "},"·":{"ha":363,"x_min":100,"x_max":256,"o":"m 100 494 q 120 548 100 526 q 178 570 140 570 q 236 548 216 570 q 256 494 256 526 q 236 442 256 463 q 178 420 216 420 q 120 442 140 420 q 100 494 100 463 z "},"¸":{"ha":345,"x_min":79,"x_max":289,"o":"m 103 0 l 193 0 l 185 -36 q 257 -68 224 -43 q 289 -153 289 -94 q 276 -211 289 -185 q 237 -256 262 -237 q 173 -285 211 -275 q 83 -295 134 -295 l 79 -222 q 135 -216 110 -222 q 176 -194 161 -209 q 191 -155 191 -179 q 180 -120 191 -133 q 144 -101 168 -107 q 82 -92 120 -94 l 103 0 z "},"¹":{"ha":509,"x_min":83,"x_max":336,"o":"m 336 987 l 336 452 l 230 452 l 230 860 l 83 821 l 83 909 l 323 987 l 336 987 z "},"º":{"ha":632,"x_min":83,"x_max":547,"o":"m 83 707 l 83 762 q 112 886 83 832 q 192 971 140 940 q 315 1002 244 1002 q 439 971 387 1002 q 519 886 491 940 q 547 762 547 832 l 547 707 q 519 584 547 637 q 439 499 491 530 q 317 469 388 469 q 193 499 245 469 q 112 584 140 530 q 83 707 83 637 m 194 762 l 194 707 q 207 633 194 666 q 248 582 220 601 q 317 563 275 563 q 384 582 357 563 q 424 633 411 601 q 437 707 437 666 l 437 762 q 424 836 437 803 q 384 887 410 868 q 315 906 357 906 q 248 887 275 906 q 207 836 220 868 q 194 762 194 803 z "},"»":{"ha":651,"x_min":70,"x_max":603,"o":"m 70 104 l 247 376 l 366 376 l 366 367 l 166 104 l 70 104 m 70 644 l 166 644 l 366 380 l 366 371 l 247 370 l 70 644 m 307 104 l 484 376 l 603 376 l 603 367 l 403 104 l 307 104 m 307 644 l 403 644 l 603 380 l 603 371 l 484 370 l 307 644 z "},"¼":{"ha":1017,"x_min":58,"x_max":967,"o":"m 310 985 l 310 450 l 204 450 l 204 858 l 58 819 l 58 907 l 298 985 l 310 985 m 783 852 l 301 81 l 231 125 l 713 897 l 783 852 m 967 203 l 967 115 l 534 115 l 529 184 l 785 535 l 869 535 l 777 380 l 636 203 l 967 203 m 894 535 l 894 0 l 787 0 l 787 535 l 894 535 z "},"½":{"ha":1078,"x_min":54,"x_max":1004,"o":"m 753 852 l 271 81 l 201 125 l 683 897 l 753 852 m 307 985 l 307 450 l 201 450 l 201 858 l 54 819 l 54 907 l 294 985 l 307 985 m 1004 87 l 1004 0 l 599 0 l 599 73 l 794 257 q 842 308 825 286 q 868 348 860 330 q 876 381 876 366 q 854 435 876 414 q 792 456 832 456 q 717 430 741 456 q 693 366 693 404 l 586 366 q 610 454 586 414 q 680 518 635 494 q 789 543 726 543 q 894 523 850 543 q 960 468 937 503 q 983 382 983 432 q 967 315 983 347 q 922 253 951 284 q 853 186 893 222 l 734 87 l 1004 87 z "},"¾":{"ha":1080,"x_min":76,"x_max":1029,"o":"m 869 852 l 387 81 l 317 125 l 799 897 l 869 852 m 1029 203 l 1029 115 l 596 115 l 591 184 l 848 535 l 932 535 l 839 380 l 699 203 l 1029 203 m 956 535 l 956 0 l 850 0 l 850 535 l 956 535 m 214 764 l 271 764 q 326 773 304 764 q 358 799 347 783 q 370 838 370 816 q 348 888 370 867 q 279 908 326 908 q 215 891 241 908 q 190 845 190 874 l 83 845 q 109 925 83 891 q 179 977 135 958 q 277 995 223 995 q 381 978 336 995 q 451 926 426 960 q 476 843 476 892 q 454 777 476 807 q 390 729 432 747 q 289 711 349 711 l 214 711 l 214 764 m 214 686 l 214 739 l 289 739 q 400 722 357 739 q 465 675 444 706 q 486 602 486 645 q 458 517 486 552 q 384 463 431 481 q 278 445 337 445 q 181 461 227 445 q 105 513 134 478 q 76 604 76 549 l 182 604 q 210 552 182 573 q 281 532 237 532 q 354 553 329 532 q 378 607 378 574 q 365 653 378 635 q 328 678 352 670 q 271 686 304 686 l 214 686 z "},"¿":{"ha":658,"x_min":46,"x_max":603,"o":"m 273 461 l 399 461 q 388 356 399 396 q 352 281 376 315 q 285 202 327 248 q 231 143 256 172 q 189 81 205 115 q 172 0 172 47 q 190 -83 172 -50 q 241 -135 208 -117 q 324 -152 275 -152 q 399 -137 364 -152 q 455 -91 433 -122 q 477 -14 477 -60 l 603 -14 q 565 -146 602 -90 q 466 -232 528 -202 q 324 -262 403 -262 q 174 -231 236 -262 q 79 -143 112 -201 q 46 -4 46 -85 q 71 110 46 58 q 134 208 96 163 q 212 292 172 253 q 250 342 237 316 q 268 398 263 368 q 273 461 273 428 m 405 676 q 386 625 405 646 q 331 604 367 604 q 275 625 294 604 q 256 676 256 646 q 275 727 256 706 q 331 747 294 747 q 386 727 367 747 q 405 676 405 706 z "},"Æ":{"ha":1298,"x_min":-10,"x_max":1275,"o":"m 658 886 l 144 0 l -10 0 l 587 987 l 668 987 l 658 886 m 756 358 l 756 239 l 252 239 l 252 358 l 756 358 m 1275 103 l 1275 0 l 778 0 l 778 103 l 1275 103 m 760 987 l 802 0 l 675 0 l 634 987 l 760 987 m 1178 566 l 1178 463 l 751 463 l 751 566 l 1178 566 m 1233 987 l 1233 884 l 736 884 l 736 987 l 1233 987 z "},"×":{"ha":741,"x_min":60,"x_max":671,"o":"m 141 140 l 60 223 l 589 762 l 669 678 l 141 140 m 591 140 l 62 678 l 143 762 l 671 223 l 591 140 z "},"Ø":{"ha":956,"x_min":81,"x_max":888,"o":"m 888 1028 l 208 -63 l 111 -63 l 793 1028 l 888 1028 m 875 525 l 875 463 q 847 263 875 351 q 767 113 819 175 q 642 19 715 52 q 479 -14 569 -14 q 348 7 409 -14 q 238 69 287 28 q 153 167 189 109 q 99 299 118 225 q 81 463 81 374 l 81 525 q 110 724 81 636 q 191 874 138 812 q 317 968 244 936 q 477 1001 390 1001 q 611 980 549 1001 q 721 919 672 959 q 804 820 770 878 q 857 688 838 762 q 875 525 875 614 m 745 463 l 745 526 q 734 654 745 597 q 700 755 722 711 q 645 829 677 800 q 570 874 612 859 q 477 890 528 890 q 367 866 416 890 q 283 796 318 842 q 229 682 248 750 q 210 526 210 614 l 210 463 q 222 334 210 391 q 258 232 235 276 q 314 157 281 187 q 389 112 347 127 q 479 97 430 97 q 592 121 543 97 q 676 191 642 144 q 728 306 710 237 q 745 463 745 374 z "},"Þ":{"ha":821,"x_min":113,"x_max":758,"o":"m 113 987 l 239 987 l 239 0 l 113 0 l 113 987 m 176 789 l 427 789 q 608 751 534 789 q 720 649 682 714 q 758 500 758 584 q 720 353 758 418 q 608 250 682 288 q 427 213 534 213 l 211 213 l 211 315 l 427 315 q 546 342 500 315 q 611 411 591 369 q 632 499 632 453 q 611 589 632 547 q 546 659 591 632 q 427 686 500 686 l 237 686 l 176 789 z "},"ß":{"ha":826,"x_min":95,"x_max":766,"o":"m 220 754 l 220 0 l 95 0 l 95 754 q 114 885 95 829 q 169 978 134 941 q 253 1035 204 1016 q 361 1054 302 1054 q 493 1029 435 1054 q 583 955 550 1005 q 616 825 616 904 q 603 735 616 771 q 573 671 590 699 q 543 617 556 644 q 530 556 530 591 q 553 489 530 519 q 612 433 577 460 q 683 375 648 406 q 743 306 719 345 q 766 215 766 267 q 733 87 766 138 q 640 11 699 36 q 505 -14 581 -14 q 428 -6 469 -14 q 354 12 387 1 q 302 35 320 23 l 331 140 q 400 107 355 125 q 492 89 445 89 q 578 105 545 89 q 626 149 611 121 q 641 209 641 176 q 617 277 641 248 q 558 334 593 307 q 487 392 523 361 q 428 463 452 422 q 404 557 404 503 q 418 629 404 598 q 451 688 433 661 q 484 746 469 715 q 498 814 498 776 q 481 890 498 860 q 435 936 464 920 q 368 951 406 951 q 288 930 321 951 q 237 866 255 909 q 220 754 220 822 z "},"æ":{"ha":1173,"x_min":54,"x_max":1126,"o":"m 508 124 l 508 488 q 491 572 508 537 q 442 626 475 607 q 363 644 410 644 q 275 627 313 644 q 218 580 238 609 q 197 515 197 551 l 73 528 q 94 615 73 575 q 153 685 115 655 q 244 731 191 715 q 363 747 298 747 q 503 718 443 747 q 596 631 563 689 q 630 487 630 574 l 630 148 l 508 124 m 536 431 l 536 336 l 359 336 q 260 318 300 336 q 199 269 220 299 q 179 203 179 239 q 194 145 179 171 q 240 103 210 119 q 319 88 271 88 q 394 102 355 88 q 464 138 432 116 q 516 184 496 160 q 537 230 536 209 l 602 132 q 544 65 584 99 q 443 8 505 31 q 294 -14 380 -14 q 163 13 217 -14 q 81 90 109 40 q 54 206 54 140 q 73 301 54 260 q 131 372 92 343 q 226 416 169 401 q 357 431 283 431 l 536 431 m 857 -14 q 709 13 773 -14 q 602 89 646 40 q 536 205 559 138 q 514 353 514 273 l 514 382 q 537 530 514 463 q 603 646 561 597 q 703 721 646 694 q 827 747 760 748 q 956 725 900 747 q 1050 659 1012 702 q 1107 555 1088 616 q 1126 418 1126 494 l 1126 338 l 581 338 l 581 434 l 1000 434 l 1000 455 q 983 549 1000 507 q 928 618 966 592 q 827 644 890 644 q 744 624 780 644 q 683 568 708 604 q 646 484 659 532 q 633 382 633 437 l 633 353 q 646 250 633 298 q 686 166 659 202 q 755 109 713 130 q 857 89 798 89 q 987 114 937 89 q 1070 161 1036 138 l 1114 69 q 1066 38 1099 58 q 981 2 1034 18 q 857 -14 929 -14 z "},"ð":{"ha":814,"x_min":85,"x_max":726,"o":"m 173 964 l 212 1072 q 420 991 326 1046 q 583 853 515 935 q 689 664 652 770 q 726 429 726 557 l 726 363 q 702 210 726 279 q 636 91 679 141 q 535 14 593 41 q 408 -14 477 -14 q 278 12 337 -14 q 175 83 218 37 q 109 188 132 128 q 85 317 85 248 q 108 459 85 396 q 172 569 131 523 q 268 639 213 614 q 389 663 323 663 q 527 627 466 663 q 625 534 589 591 q 661 416 661 477 l 614 416 q 602 464 614 439 q 565 511 589 489 q 505 547 541 533 q 419 560 468 560 q 331 543 370 560 q 266 495 292 526 q 225 418 239 463 q 212 317 212 374 q 225 235 212 275 q 263 162 238 195 q 326 109 289 129 q 411 90 363 90 q 490 110 455 90 q 549 168 524 131 q 587 255 574 205 q 600 363 600 304 l 600 431 q 566 640 600 550 q 473 793 532 729 q 337 900 414 858 q 173 964 260 941 m 670 961 l 306 713 l 256 781 l 621 1028 l 670 961 z "},"÷":{"ha":793,"x_min":48,"x_max":725,"o":"m 725 532 l 725 407 l 48 407 l 48 532 l 725 532 m 313 745 q 333 799 313 777 q 391 821 353 821 q 449 799 429 821 q 469 745 469 777 q 449 692 469 713 q 391 671 429 671 q 333 692 353 671 q 313 745 313 713 m 313 191 q 333 245 313 223 q 391 267 353 267 q 449 245 429 267 q 469 191 469 223 q 449 138 469 160 q 391 117 429 117 q 333 138 353 117 q 313 191 313 160 z "},"ø":{"ha":787,"x_min":62,"x_max":730,"o":"m 667 820 l 217 -92 l 134 -92 l 583 820 l 667 820 m 62 359 l 62 374 q 85 522 62 454 q 152 641 109 590 q 257 719 195 691 q 395 747 319 747 q 535 719 473 747 q 640 641 597 691 q 707 522 684 590 q 730 374 730 454 l 730 359 q 707 212 730 279 q 640 93 684 144 q 535 15 597 43 q 397 -14 474 -14 q 258 15 319 -14 q 152 93 196 43 q 85 212 109 144 q 62 359 62 279 m 188 374 l 188 359 q 201 255 188 304 q 240 170 214 207 q 305 111 266 132 q 397 90 345 90 q 487 111 448 90 q 552 170 526 132 q 591 255 578 207 q 604 359 604 304 l 604 374 q 591 477 604 429 q 552 563 578 526 q 487 623 526 601 q 395 644 448 644 q 305 623 344 644 q 240 563 266 601 q 201 477 214 526 q 188 374 188 429 z "},"þ":{"ha":800,"x_min":101,"x_max":722,"o":"m 227 1042 l 227 -282 l 101 -282 l 101 1042 l 227 1042 m 722 373 l 722 359 q 703 211 722 279 q 647 92 684 142 q 558 14 611 42 q 437 -14 505 -14 q 313 9 367 -14 q 222 77 260 33 q 163 182 185 121 q 133 321 141 244 l 133 397 q 163 543 141 479 q 223 653 186 608 q 313 723 260 699 q 435 747 366 747 q 557 721 504 747 q 648 644 611 694 q 703 526 684 595 q 722 373 722 457 m 595 359 l 595 373 q 584 476 595 428 q 548 562 572 525 q 487 620 524 599 q 398 642 450 642 q 316 625 351 642 q 256 582 281 609 q 217 519 232 554 q 194 447 201 484 l 194 271 q 220 203 204 235 q 260 145 236 170 q 318 104 284 119 q 399 90 353 90 q 487 111 450 90 q 548 170 524 132 q 584 255 572 207 q 595 359 595 304 z "},"đ":{"ha":830,"x_min":64,"x_max":812,"o":"m 558 142 l 558 1042 l 684 1042 l 684 0 l 569 0 l 558 142 m 64 359 l 64 373 q 85 526 64 457 q 144 644 106 595 q 236 721 182 694 q 355 747 289 747 q 476 723 424 747 q 564 653 528 699 q 621 543 600 608 q 650 397 642 479 l 650 335 q 622 190 643 254 q 564 80 600 125 q 475 11 528 35 q 353 -14 423 -14 q 236 14 289 -14 q 144 92 182 42 q 85 211 106 142 q 64 359 64 279 m 191 373 l 191 359 q 202 256 191 304 q 237 171 213 208 q 297 114 260 134 q 385 93 334 93 q 487 119 447 93 q 552 189 528 146 q 590 283 576 233 l 590 447 q 567 519 582 484 q 527 582 551 554 q 468 625 503 609 q 386 642 433 642 q 297 620 334 642 q 237 562 260 599 q 202 476 213 525 q 191 373 191 428 m 812 939 l 812 836 l 380 836 l 380 939 l 812 939 z "},"Ħ":{"ha":973,"x_min":20,"x_max":961,"o":"m 961 791 l 961 694 l 20 694 l 20 791 l 961 791 m 755 563 l 755 456 l 221 456 l 221 563 l 755 563 m 241 987 l 241 0 l 111 0 l 111 987 l 241 987 m 870 987 l 870 0 l 739 0 l 739 987 l 870 987 z "},"ı":{"ha":344,"x_min":106,"x_max":231,"o":"m 231 734 l 231 0 l 106 0 l 106 734 l 231 734 z "},"ĸ":{"ha":773,"x_min":105,"x_max":738,"o":"m 231 734 l 231 0 l 105 0 l 105 734 l 231 734 m 713 734 l 351 313 l 189 313 l 170 423 l 293 423 l 562 734 l 713 734 m 579 0 l 287 332 l 368 423 l 738 0 l 579 0 z "},"Ł":{"ha":748,"x_min":24,"x_max":713,"o":"m 423 629 l 423 545 l 24 418 l 24 503 l 423 629 m 713 106 l 713 0 l 219 0 l 219 106 l 713 106 m 245 987 l 245 0 l 115 0 l 115 987 l 245 987 z "},"ł":{"ha":376,"x_min":24,"x_max":355,"o":"m 355 631 l 355 548 l 24 421 l 24 504 l 355 631 m 247 1042 l 247 0 l 121 0 l 121 1042 l 247 1042 z "},"Ŋ":{"ha":962,"x_min":110,"x_max":858,"o":"m 110 987 l 241 987 l 241 0 l 110 0 l 110 987 m 149 910 l 241 987 l 819 77 l 727 0 l 149 910 m 727 987 l 858 987 l 858 -57 q 831 -188 858 -134 q 755 -269 804 -241 q 636 -296 705 -296 q 597 -294 615 -296 q 558 -285 578 -292 l 568 -180 q 602 -187 579 -184 q 634 -189 624 -189 q 685 -173 664 -189 q 716 -128 705 -157 q 727 -57 727 -98 l 727 987 z "},"ŋ":{"ha":787,"x_min":99,"x_max":684,"o":"m 224 577 l 224 0 l 99 0 l 99 734 l 212 734 l 224 577 m 186 391 l 157 389 q 176 533 157 467 q 231 646 195 598 q 319 721 267 694 q 436 747 371 747 q 539 731 493 747 q 617 681 585 715 q 667 592 650 646 q 684 463 684 538 l 684 -60 q 658 -189 684 -136 q 583 -269 632 -242 q 465 -296 534 -296 q 426 -294 444 -296 q 388 -285 408 -292 l 397 -178 q 432 -184 408 -182 q 465 -186 456 -186 q 516 -172 495 -186 q 548 -130 536 -158 q 559 -60 559 -102 l 559 460 q 548 546 559 511 q 517 602 538 581 q 467 632 496 623 q 399 642 437 642 q 302 622 342 642 q 236 568 262 602 q 198 488 210 533 q 186 391 186 442 z "},"Œ":{"ha":1324,"x_min":71,"x_max":1221,"o":"m 448 1002 q 551 997 500 1002 q 647 987 602 993 l 647 880 q 552 893 602 888 q 448 899 501 899 q 343 879 390 899 q 264 822 297 860 q 214 728 231 784 q 197 598 197 672 l 197 391 q 214 260 197 317 q 265 166 232 204 q 345 108 298 127 q 449 89 391 89 q 552 94 502 89 q 647 107 603 99 l 647 0 q 551 -9 602 -5 q 449 -14 501 -14 q 295 15 365 -14 q 176 99 226 45 q 98 227 125 153 q 71 391 71 301 l 71 597 q 98 761 71 686 q 175 889 125 835 q 294 972 225 943 q 448 1002 363 1002 m 1221 106 l 1221 0 l 699 0 l 699 106 l 1221 106 m 725 987 l 725 0 l 594 0 l 594 987 l 725 987 m 1152 563 l 1152 456 l 699 456 l 699 563 l 1152 563 m 1215 987 l 1215 880 l 699 880 l 699 987 l 1215 987 z "},"œ":{"ha":1261,"x_min":66,"x_max":1215,"o":"m 935 -14 q 798 13 859 -14 q 693 89 736 40 q 626 205 650 138 q 603 353 603 273 l 603 382 q 628 530 603 463 q 697 646 654 597 q 798 721 741 694 q 916 747 854 748 q 1048 723 992 747 q 1142 655 1105 699 q 1197 552 1179 612 q 1215 420 1215 492 l 1215 338 l 677 338 l 677 440 l 1090 440 l 1090 458 q 1072 550 1090 507 q 1015 618 1053 592 q 916 644 977 644 q 841 624 875 644 q 781 568 806 604 q 743 484 756 532 q 729 382 729 437 l 729 353 q 742 250 729 298 q 781 166 755 202 q 846 109 807 130 q 935 89 884 89 q 1060 110 1010 89 q 1145 162 1111 132 l 1194 77 q 1098 15 1161 44 q 935 -14 1035 -14 m 66 359 l 66 374 q 88 522 66 454 q 153 641 111 590 q 256 719 195 691 q 393 747 316 747 q 532 719 471 747 q 635 641 593 691 q 700 522 677 590 q 722 374 722 454 l 722 359 q 700 211 722 279 q 635 93 677 143 q 532 14 593 42 q 394 -14 471 -14 q 256 14 317 -14 q 153 93 195 42 q 88 211 111 143 q 66 359 66 279 m 192 374 l 192 359 q 204 255 192 304 q 241 169 216 207 q 304 110 266 132 q 394 89 342 89 q 484 110 446 89 q 547 169 522 132 q 584 255 572 207 q 596 359 596 304 l 596 374 q 584 477 596 429 q 547 563 572 526 q 483 623 522 601 q 393 644 445 644 q 303 623 341 644 q 240 563 265 601 q 204 477 216 526 q 192 374 192 429 z "},"ſ":{"ha":345,"x_min":109,"x_max":436,"o":"m 235 0 l 109 0 l 109 811 q 137 945 109 890 q 216 1028 165 1000 q 338 1056 267 1056 q 387 1052 363 1056 q 436 1042 411 1048 l 420 945 q 393 951 408 949 q 358 953 378 953 q 291 936 318 953 q 249 887 263 919 q 235 811 235 856 l 235 0 z "},"Ə":{"ha":960,"x_min":64,"x_max":880,"o":"m 473 -14 q 296 18 372 -14 q 168 108 219 49 q 90 250 116 167 q 64 436 64 333 l 64 520 l 800 520 l 800 419 l 195 419 l 195 396 q 209 278 195 333 q 256 182 224 223 q 342 118 289 141 q 473 94 395 94 q 591 123 539 94 q 678 202 642 151 q 732 319 713 252 q 750 461 750 385 l 750 525 q 732 668 750 602 q 676 785 714 734 q 578 864 638 836 q 435 892 519 892 q 287 873 347 892 q 187 836 227 854 l 155 932 q 208 960 172 943 q 300 988 243 976 q 435 1001 357 1001 q 626 966 543 1001 q 765 868 709 931 q 851 717 822 804 q 880 525 880 630 l 880 461 q 849 269 880 356 q 761 118 817 182 q 631 21 705 55 q 473 -14 557 -14 z "},"ƒ":{"ha":473,"x_min":-20,"x_max":475,"o":"m 412 734 l 412 637 l 275 637 l 275 -60 q 249 -189 275 -136 q 174 -269 222 -242 q 56 -296 125 -296 q 18 -294 35 -296 q -20 -285 0 -292 l -10 -184 q 23 -191 0 -189 q 56 -193 47 -193 q 106 -177 85 -193 q 138 -132 127 -161 q 149 -60 149 -102 l 149 637 l 33 637 l 33 734 l 149 734 l 149 811 q 177 945 149 890 q 256 1028 204 1000 q 378 1056 307 1056 q 427 1052 403 1056 q 475 1042 451 1048 l 460 943 q 430 948 448 946 q 393 949 413 949 q 327 933 353 949 q 288 887 300 918 q 275 811 275 856 l 275 734 l 412 734 z "},"Ơ":{"ha":954,"x_min":69,"x_max":975,"o":"m 861 1080 l 975 1080 q 946 930 975 992 q 860 837 918 869 q 717 804 803 804 l 717 896 q 802 918 770 896 q 847 981 833 939 q 861 1080 861 1022 m 863 525 l 863 463 q 836 263 863 351 q 755 113 808 175 q 630 19 703 52 q 467 -14 557 -14 q 336 7 397 -14 q 226 69 275 28 q 142 167 177 109 q 88 299 106 225 q 69 463 69 374 l 69 525 q 98 724 69 636 q 180 874 127 812 q 306 968 233 936 q 466 1001 378 1001 q 600 980 538 1001 q 710 919 661 959 q 793 820 758 878 q 845 688 827 762 q 863 525 863 614 m 734 463 l 734 526 q 722 654 734 597 q 688 755 711 711 q 633 829 666 800 q 559 874 601 859 q 466 890 517 890 q 356 866 406 890 q 272 796 307 842 q 218 682 237 750 q 199 526 199 614 l 199 463 q 211 334 199 391 q 247 232 223 276 q 303 157 270 187 q 377 112 336 127 q 467 97 419 97 q 581 121 531 97 q 664 191 630 144 q 716 306 699 237 q 734 463 734 374 z "},"ơ":{"ha":794,"x_min":62,"x_max":821,"o":"m 720 814 l 821 814 q 800 686 821 740 q 732 603 780 632 q 604 574 685 574 l 604 652 q 679 673 654 652 q 712 730 704 693 q 720 814 720 766 m 62 359 l 62 374 q 85 522 62 454 q 152 641 109 590 q 257 719 195 691 q 395 747 319 747 q 535 719 473 747 q 640 641 597 691 q 707 522 684 590 q 730 374 730 454 l 730 359 q 707 212 730 279 q 640 93 684 144 q 535 15 597 43 q 397 -14 474 -14 q 258 15 319 -14 q 152 93 196 43 q 85 212 109 144 q 62 359 62 279 m 188 374 l 188 359 q 201 255 188 304 q 240 170 214 207 q 305 111 266 132 q 397 90 345 90 q 487 111 448 90 q 552 170 526 132 q 591 255 578 207 q 604 359 604 304 l 604 374 q 591 477 604 429 q 552 563 578 526 q 487 623 526 601 q 395 644 448 644 q 305 623 344 644 q 240 563 266 601 q 201 477 214 526 q 188 374 188 429 z "},"Ư":{"ha":966,"x_min":95,"x_max":1061,"o":"m 954 1043 l 1061 1043 q 1033 882 1061 947 q 943 784 1005 817 q 779 751 881 751 l 779 842 q 886 865 848 842 q 939 932 924 888 q 954 1043 954 977 m 680 987 l 810 987 l 810 319 q 760 134 810 208 q 629 23 711 60 q 452 -14 547 -14 q 270 23 351 -14 q 142 134 189 60 q 95 319 95 208 l 95 987 l 224 987 l 224 319 q 253 192 224 242 q 333 117 281 142 q 452 93 384 93 q 571 117 520 93 q 651 192 623 142 q 680 319 680 242 l 680 987 z "},"ư":{"ha":859,"x_min":93,"x_max":879,"o":"m 783 793 l 879 793 q 860 669 879 719 q 792 593 840 618 q 656 568 744 568 l 656 646 q 744 661 718 646 q 777 709 770 676 q 783 793 783 741 m 545 170 l 545 734 l 671 734 l 671 0 l 551 0 l 545 170 m 568 324 l 621 326 q 605 190 621 252 q 556 83 590 128 q 467 12 522 37 q 334 -14 412 -14 q 236 2 280 -14 q 159 50 191 18 q 110 135 127 83 q 93 260 93 187 l 93 734 l 218 734 l 218 259 q 230 177 218 210 q 260 126 241 145 q 303 100 279 108 q 353 93 328 93 q 480 124 433 93 q 548 207 527 155 q 568 324 568 260 z "},"ȷ":{"ha":350,"x_min":-52,"x_max":243,"o":"m 117 734 l 243 734 l 243 -60 q 217 -189 243 -136 q 142 -269 191 -242 q 24 -296 93 -296 q -14 -294 3 -296 q -52 -285 -32 -292 l -42 -184 q -8 -191 -32 -189 q 24 -193 15 -193 q 74 -177 54 -193 q 106 -132 95 -161 q 117 -60 117 -102 l 117 734 z "},"ə":{"ha":732,"x_min":67,"x_max":680,"o":"m 347 749 q 485 722 423 749 q 589 645 546 694 q 656 529 633 596 q 680 382 680 462 l 680 352 q 654 205 680 272 q 585 89 629 138 q 484 13 541 40 q 366 -13 428 -14 q 234 11 290 -13 q 141 79 178 35 q 85 182 104 123 q 67 314 67 242 l 67 397 l 605 397 l 605 294 l 193 294 l 193 277 q 211 185 193 228 q 268 116 229 142 q 366 90 307 90 q 441 110 407 90 q 500 166 475 130 q 539 250 526 202 q 553 352 553 298 l 553 382 q 540 484 553 436 q 501 568 527 532 q 437 625 475 604 q 347 646 398 646 q 222 624 273 646 q 138 572 172 603 l 88 658 q 185 720 122 690 q 347 749 248 749 z "},"ˆ":{"ha":654,"x_min":115,"x_max":526,"o":"m 357 1042 l 526 857 l 526 850 l 421 850 l 319 964 l 218 850 l 115 850 l 115 857 l 281 1042 l 357 1042 z "},"ˇ":{"ha":617,"x_min":96,"x_max":515,"o":"m 202 1041 l 304 926 l 407 1041 l 515 1041 l 515 1034 l 343 848 l 266 848 l 96 1034 l 96 1041 l 202 1041 z "},"ˉ":{"ha":637,"x_min":97,"x_max":552,"o":"m 552 980 l 552 884 l 97 884 l 97 980 l 552 980 z "},"˘":{"ha":593,"x_min":88,"x_max":494,"o":"m 392 1014 l 494 1014 q 469 920 494 961 q 399 856 445 879 q 292 833 354 833 q 143 883 197 833 q 88 1014 88 934 l 190 1014 q 213 943 190 974 q 292 913 236 913 q 369 943 346 913 q 392 1014 392 974 z "},"˙":{"ha":338,"x_min":96,"x_max":245,"o":"m 96 928 q 115 979 96 958 q 170 1000 134 1000 q 225 979 206 1000 q 245 928 245 958 q 225 877 245 898 q 170 857 206 857 q 115 877 134 857 q 96 928 96 898 z "},"˚":{"ha":465,"x_min":82,"x_max":374,"o":"m 82 956 q 101 1027 82 995 q 154 1078 121 1059 q 228 1097 186 1097 q 332 1055 290 1097 q 374 956 374 1014 q 354 885 374 916 q 302 835 335 853 q 228 817 269 817 q 124 857 166 817 q 82 956 82 896 m 149 956 q 171 902 149 926 q 228 878 193 878 q 284 901 262 878 q 307 956 307 924 q 284 1011 307 987 q 228 1036 262 1036 q 171 1011 193 1036 q 149 956 149 987 z "},"˛":{"ha":376,"x_min":34,"x_max":273,"o":"m 209 39 l 259 0 q 203 -45 230 -22 q 160 -95 177 -68 q 143 -151 143 -121 q 155 -186 143 -173 q 196 -200 167 -200 q 236 -194 218 -200 q 264 -182 254 -187 l 273 -264 q 230 -284 256 -275 q 164 -294 204 -294 q 72 -261 109 -294 q 34 -165 34 -229 q 52 -92 34 -128 q 109 -23 70 -56 q 209 39 147 10 z "},"˜":{"ha":655,"x_min":83,"x_max":564,"o":"m 479 1025 l 564 1018 q 544 931 564 968 q 491 873 524 894 q 417 853 458 853 q 360 863 382 853 q 320 885 338 873 q 283 908 302 898 q 235 918 264 918 q 188 896 207 918 q 168 842 168 874 l 83 846 q 103 933 83 896 q 155 992 122 971 q 229 1014 189 1014 q 280 1004 258 1014 q 322 982 302 994 q 363 959 342 969 q 411 949 384 949 q 459 971 439 949 q 479 1025 479 994 z "},"˝":{"ha":518,"x_min":64,"x_max":551,"o":"m 254 836 l 410 1041 l 551 1041 l 369 836 l 254 836 m 64 836 l 180 1041 l 314 1041 l 166 836 l 64 836 z "},"˳":{"ha":408,"x_min":86,"x_max":319,"o":"m 86 -165 q 121 -83 86 -115 q 204 -52 156 -52 q 285 -83 251 -52 q 319 -165 319 -115 q 285 -245 319 -214 q 204 -275 251 -275 q 121 -245 156 -275 q 86 -165 86 -214 m 145 -165 q 162 -204 145 -188 q 204 -221 180 -221 q 244 -205 227 -221 q 260 -165 260 -189 q 244 -123 260 -140 q 204 -106 227 -106 q 162 -123 180 -106 q 145 -165 145 -140 z "},"̀":{"ha":0,"x_min":-581,"x_max":-299,"o":"m -430 1042 l -299 842 l -406 842 l -581 1042 l -430 1042 z "},"́":{"ha":0,"x_min":-446,"x_max":-163,"o":"m -446 842 l -315 1042 l -163 1042 l -345 842 l -446 842 z "},"̃":{"ha":0,"x_min":-601,"x_max":-121,"o":"m -205 1025 l -121 1018 q -140 931 -121 968 q -193 873 -160 894 q -267 853 -226 853 q -324 863 -302 853 q -364 885 -347 873 q -401 908 -382 898 q -449 918 -420 918 q -497 896 -477 918 q -516 842 -516 874 l -601 846 q -582 933 -601 896 q -529 992 -562 971 q -455 1014 -496 1014 q -404 1004 -426 1014 q -362 982 -382 994 q -321 959 -342 969 q -273 949 -300 949 q -225 971 -245 949 q -205 1025 -205 994 z "},"̉":{"ha":0,"x_min":-458,"x_max":-248,"o":"m -353 842 l -443 842 l -444 945 q -387 952 -409 947 q -355 968 -366 958 q -345 996 -345 979 q -354 1020 -345 1010 q -378 1037 -363 1030 q -414 1046 -394 1043 q -458 1048 -435 1048 l -453 1120 q -365 1112 -403 1120 q -300 1086 -326 1103 q -261 1045 -274 1069 q -248 994 -248 1022 q -280 919 -248 942 q -352 890 -313 895 l -353 842 z "},"̏":{"ha":0,"x_min":-668,"x_max":-170,"o":"m -347 849 l -461 849 l -668 1029 l -515 1029 l -347 849 m -170 849 l -271 849 l -438 1029 l -298 1029 l -170 849 z "},"̣":{"ha":0,"x_min":-483,"x_max":-334,"o":"m -483 -167 q -464 -115 -483 -136 q -409 -94 -446 -94 q -354 -115 -373 -94 q -334 -167 -334 -136 q -354 -217 -334 -196 q -409 -237 -373 -237 q -464 -217 -446 -237 q -483 -167 -483 -196 z "},"΄":{"ha":357,"x_min":125,"x_max":279,"o":"m 125 857 l 161 1084 l 279 1084 l 201 857 l 125 857 z "},"΅":{"ha":703,"x_min":77,"x_max":610,"o":"m 294 956 l 326 1135 l 454 1135 l 386 956 l 294 956 m 77 930 q 96 981 77 960 q 151 1002 115 1002 q 207 981 187 1002 q 226 930 226 960 q 207 880 226 901 q 151 859 187 859 q 96 880 115 859 q 77 930 77 901 m 461 928 q 480 980 461 959 q 535 1001 499 1001 q 591 980 572 1001 q 610 928 610 959 q 591 879 610 899 q 535 858 572 858 q 480 879 499 858 q 461 928 461 899 z "},"·":{"ha":363,"x_min":100,"x_max":256,"o":"m 100 494 q 120 548 100 526 q 178 570 140 570 q 236 548 216 570 q 256 494 256 526 q 236 442 256 463 q 178 420 216 420 q 120 442 140 420 q 100 494 100 463 z "},"Γ":{"ha":772,"x_min":121,"x_max":727,"o":"m 727 987 l 727 880 l 251 880 l 251 0 l 121 0 l 121 987 l 727 987 z "},"Δ":{"ha":979,"x_min":22,"x_max":947,"o":"m 522 895 l 156 0 l 22 0 l 438 987 l 520 987 l 522 895 m 812 0 l 467 901 l 471 987 l 553 987 l 947 0 l 812 0 m 844 106 l 844 0 l 121 0 l 121 106 l 844 106 z "},"∆":{"ha":979,"x_min":22,"x_max":947,"o":"m 522 895 l 156 0 l 22 0 l 438 987 l 520 987 l 522 895 m 812 0 l 467 901 l 471 987 l 553 987 l 947 0 l 812 0 m 844 106 l 844 0 l 121 0 l 121 106 l 844 106 z "},"Θ":{"ha":945,"x_min":70,"x_max":864,"o":"m 651 550 l 651 448 l 301 448 l 301 550 l 651 550 m 864 525 l 864 463 q 836 263 864 351 q 756 113 808 175 q 631 19 704 52 q 468 -14 558 -14 q 337 7 398 -14 q 227 69 276 28 q 142 167 178 109 q 89 299 107 225 q 70 463 70 374 l 70 525 q 99 724 70 636 q 180 874 127 812 q 306 968 233 936 q 467 1001 379 1001 q 600 980 538 1001 q 710 919 662 959 q 793 820 759 878 q 846 688 828 762 q 864 525 864 614 m 734 463 l 734 526 q 723 654 734 597 q 689 755 711 711 q 634 829 667 800 q 559 874 602 859 q 467 890 517 890 q 357 866 406 890 q 273 796 308 842 q 218 682 237 750 q 199 526 199 614 l 199 463 q 212 334 199 391 q 247 232 224 276 q 303 157 271 187 q 378 112 336 127 q 468 97 420 97 q 581 121 532 97 q 665 191 631 144 q 717 306 699 237 q 734 463 734 374 z "},"Λ":{"ha":911,"x_min":34,"x_max":870,"o":"m 484 880 l 174 0 l 34 0 l 394 987 l 479 987 l 484 880 m 730 0 l 418 884 l 425 987 l 511 987 l 870 0 l 730 0 z "},"Ξ":{"ha":793,"x_min":81,"x_max":718,"o":"m 81 0 l 81 106 l 718 106 l 718 0 l 81 0 m 140 457 l 140 564 l 652 564 l 652 457 l 140 457 m 84 880 l 84 987 l 706 987 l 706 880 l 84 880 z "},"Π":{"ha":991,"x_min":121,"x_max":869,"o":"m 869 987 l 869 0 l 739 0 l 739 880 l 252 880 l 252 0 l 121 0 l 121 987 l 869 987 z "},"Σ":{"ha":793,"x_min":47,"x_max":741,"o":"m 741 107 l 741 0 l 98 0 l 98 107 l 741 107 m 708 987 l 708 880 l 79 880 l 79 987 l 708 987 m 512 503 l 512 487 l 126 0 l 47 0 l 47 97 l 374 495 l 47 890 l 47 987 l 126 987 l 512 503 z "},"Φ":{"ha":995,"x_min":53,"x_max":947,"o":"m 555 119 l 444 119 q 284 146 356 119 q 160 222 212 173 q 81 339 109 271 q 53 490 53 408 q 102 684 53 600 q 239 815 152 768 q 441 863 326 863 l 557 863 q 715 836 644 863 q 838 759 786 809 q 918 642 890 709 q 947 491 947 574 q 898 297 947 381 q 761 166 849 214 q 555 119 673 119 m 444 227 l 556 227 q 703 260 645 227 q 789 352 760 292 q 817 491 817 411 q 801 600 817 551 q 752 683 785 648 q 672 736 720 718 q 559 755 623 755 l 441 755 q 297 722 355 755 q 211 630 239 689 q 182 490 182 570 q 198 381 182 430 q 246 298 214 333 q 328 245 279 264 q 444 227 378 227 m 566 987 l 566 0 l 435 0 l 435 987 l 566 987 z "},"Ψ":{"ha":961,"x_min":61,"x_max":891,"o":"m 760 987 l 891 987 l 891 631 q 838 420 891 507 q 692 289 785 334 q 480 243 599 243 l 460 243 q 301 269 374 243 q 174 344 228 294 q 91 466 121 393 q 61 631 61 538 l 61 987 l 191 987 l 191 631 q 211 511 191 564 q 267 423 231 459 q 353 369 303 387 q 461 351 402 351 l 481 351 q 627 383 564 351 q 725 478 690 416 q 760 631 760 541 l 760 987 m 536 987 l 536 0 l 406 0 l 406 987 l 536 987 z "},"Ω":{"ha":924,"x_min":77,"x_max":833,"o":"m 701 492 l 701 571 q 684 711 701 650 q 634 812 667 771 q 556 874 602 853 q 454 895 511 895 q 352 874 397 895 q 275 812 307 853 q 227 711 243 771 q 210 571 210 650 l 210 492 q 224 338 210 406 q 266 223 239 271 q 331 148 293 176 q 414 111 368 119 l 414 15 q 279 67 340 24 q 173 177 218 110 q 102 325 127 243 q 77 492 77 406 l 77 570 q 104 745 77 666 q 182 881 132 824 q 301 970 232 939 q 454 1001 370 1001 q 608 970 538 1001 q 728 881 677 939 q 805 745 778 824 q 833 570 833 666 l 833 492 q 808 326 833 407 q 739 177 783 244 q 633 67 694 111 q 500 15 572 24 l 500 111 q 582 148 545 120 q 646 224 619 176 q 686 339 672 272 q 701 492 701 406 m 500 0 l 500 106 l 828 106 l 828 0 l 500 0 m 80 0 l 80 106 l 414 106 l 414 0 l 80 0 z "},"Ω":{"ha":924,"x_min":77,"x_max":833,"o":"m 701 492 l 701 571 q 684 711 701 650 q 634 812 667 771 q 556 874 602 853 q 454 895 511 895 q 352 874 397 895 q 275 812 307 853 q 227 711 243 771 q 210 571 210 650 l 210 492 q 224 338 210 406 q 266 223 239 271 q 331 148 293 176 q 414 111 368 119 l 414 15 q 279 67 340 24 q 173 177 218 110 q 102 325 127 243 q 77 492 77 406 l 77 570 q 104 745 77 666 q 182 881 132 824 q 301 970 232 939 q 454 1001 370 1001 q 608 970 538 1001 q 728 881 677 939 q 805 745 778 824 q 833 570 833 666 l 833 492 q 808 326 833 407 q 739 177 783 244 q 633 67 694 111 q 500 15 572 24 l 500 111 q 582 148 545 120 q 646 224 619 176 q 686 339 672 272 q 701 492 701 406 m 500 0 l 500 106 l 828 106 l 828 0 l 500 0 m 80 0 l 80 106 l 414 106 l 414 0 l 80 0 z "},"α":{"ha":785,"x_min":68,"x_max":776,"o":"m 68 340 l 68 354 q 87 513 68 441 q 142 637 106 585 q 232 719 178 690 q 355 747 286 747 q 450 732 408 747 q 525 686 492 716 q 581 613 557 656 q 618 515 604 570 q 638 394 632 460 l 638 338 q 610 192 631 256 q 555 81 590 127 q 471 10 521 35 q 353 -14 420 -14 q 232 12 286 -14 q 142 85 179 38 q 87 198 106 133 q 68 340 68 262 m 194 354 l 194 340 q 205 242 194 288 q 238 162 216 197 q 297 108 261 127 q 385 89 334 89 q 469 109 434 89 q 529 164 505 130 q 569 244 553 199 q 595 337 585 289 l 595 382 q 572 478 587 431 q 532 563 557 525 q 471 622 507 600 q 386 644 435 644 q 298 621 334 644 q 239 558 262 598 q 205 466 216 518 q 194 354 194 413 m 576 734 l 683 734 l 683 200 q 687 149 683 169 q 699 118 691 130 q 716 103 707 107 q 737 98 726 98 q 750 100 744 98 q 760 102 755 101 l 776 9 q 734 -10 755 -6 q 692 -14 714 -14 q 635 -2 661 -14 q 593 35 610 9 q 566 101 575 60 q 557 200 557 142 l 557 574 l 576 734 z "},"β":{"ha":823,"x_min":109,"x_max":747,"o":"m 351 559 l 450 559 q 611 523 545 559 q 712 427 677 488 q 747 288 747 366 q 708 124 747 192 q 598 22 668 57 q 439 -14 529 -14 q 335 1 387 -14 q 240 47 283 16 q 172 127 197 78 q 146 243 146 176 l 196 271 q 225 180 196 221 q 306 114 254 138 q 427 89 358 89 q 532 114 489 89 q 598 184 576 140 q 621 286 621 229 q 601 377 621 333 q 543 450 581 422 q 448 479 504 479 l 351 479 l 351 559 m 411 1001 q 564 967 499 1001 q 665 873 629 933 q 701 735 701 813 q 665 617 701 671 q 564 532 629 564 q 411 500 498 500 l 351 500 l 351 582 l 408 582 q 505 602 468 582 q 558 657 541 622 q 575 738 575 692 q 557 815 575 779 q 502 875 538 852 q 411 898 466 898 q 321 876 361 898 q 258 815 281 854 q 235 728 235 777 l 235 -260 l 109 -260 l 109 728 q 151 865 109 803 q 260 964 192 927 q 411 1001 329 1001 z "},"γ":{"ha":696,"x_min":32,"x_max":673,"o":"m 415 90 l 415 -283 l 290 -283 l 290 90 l 415 90 m 349 170 l 544 734 l 673 734 l 401 0 l 317 0 l 349 170 m 160 734 l 361 170 l 389 0 l 305 0 l 32 734 l 160 734 z "},"δ":{"ha":787,"x_min":66,"x_max":722,"o":"m 150 861 q 181 967 150 922 q 270 1037 212 1013 q 407 1061 327 1061 q 503 1052 460 1061 q 591 1023 546 1043 l 591 916 q 510 941 559 927 q 404 956 460 956 q 337 944 366 956 q 293 912 309 933 q 277 864 277 892 q 284 835 277 850 q 308 803 291 819 q 355 770 325 787 q 434 737 386 753 q 595 651 531 704 q 690 525 659 597 q 722 360 722 452 l 722 345 q 700 203 722 269 q 635 89 677 138 q 532 14 593 41 q 395 -14 471 -14 q 256 14 317 -14 q 152 89 195 41 q 88 203 110 138 q 66 345 66 269 l 66 360 q 97 507 66 441 q 179 616 128 572 q 290 675 231 661 l 290 678 q 214 723 245 696 q 166 785 182 750 q 150 861 150 821 m 192 360 l 192 345 q 204 247 192 293 q 241 165 216 201 q 304 109 266 130 q 395 89 342 89 q 484 109 446 89 q 546 165 522 130 q 583 247 571 201 q 595 345 595 293 l 595 360 q 581 446 595 404 q 540 524 566 488 q 477 584 513 559 q 396 618 441 609 q 306 597 345 618 q 242 541 267 576 q 204 458 217 505 q 192 360 192 412 z "},"ε":{"ha":749,"x_min":68,"x_max":681,"o":"m 356 398 l 505 398 l 505 325 l 366 325 q 272 312 310 325 q 214 274 233 300 q 194 206 194 248 q 206 161 194 182 q 241 123 218 140 q 298 98 264 107 q 374 88 332 88 q 470 106 429 88 q 533 154 511 125 q 556 217 556 184 l 681 217 q 654 114 681 157 q 584 42 628 70 q 485 0 540 14 q 374 -14 431 -14 q 252 1 308 -14 q 155 45 196 16 q 91 114 113 73 q 68 207 68 155 q 87 289 68 253 q 143 349 106 324 q 234 386 180 373 q 356 398 288 398 m 505 351 l 356 351 q 243 365 294 351 q 156 405 192 379 q 100 463 119 430 q 81 534 81 496 q 101 626 81 586 q 161 692 122 665 q 254 733 199 719 q 374 747 308 747 q 488 732 435 747 q 582 688 541 717 q 646 620 623 660 q 669 530 669 580 l 544 530 q 521 588 544 562 q 460 630 498 614 q 374 645 422 645 q 279 629 317 645 q 224 588 242 613 q 206 534 206 562 q 215 490 206 510 q 243 455 224 470 q 293 433 262 441 q 366 425 323 425 l 505 425 l 505 351 z "},"ζ":{"ha":720,"x_min":74,"x_max":654,"o":"m 597 987 l 654 987 l 654 906 l 416 617 q 327 500 363 555 q 272 388 291 445 q 254 262 254 331 q 260 205 254 229 q 279 164 266 182 q 312 136 292 147 q 361 116 333 124 l 450 90 q 539 63 500 76 q 602 23 579 50 q 625 -60 625 -4 q 605 -135 625 -96 q 557 -207 585 -174 q 505 -260 530 -241 l 439 -203 q 474 -159 460 -179 q 497 -119 489 -138 q 505 -79 505 -100 q 494 -51 505 -64 q 460 -27 483 -38 q 401 -7 437 -16 l 340 9 q 240 46 281 25 q 175 96 200 67 q 139 165 150 125 q 127 258 127 205 q 146 374 127 309 q 207 514 165 439 q 317 670 249 589 l 597 987 m 74 987 l 614 987 l 614 885 l 74 885 l 74 987 z "},"η":{"ha":787,"x_min":99,"x_max":684,"o":"m 224 577 l 224 0 l 99 0 l 99 734 l 212 734 l 224 577 m 199 391 l 146 389 q 165 533 146 467 q 223 646 185 598 q 314 721 260 694 q 436 747 368 747 q 539 734 493 747 q 617 688 585 720 q 667 603 650 656 q 684 471 684 550 l 684 -281 l 559 -281 l 559 469 q 548 553 559 519 q 517 607 538 587 q 467 635 496 627 q 399 644 437 644 q 307 624 345 644 q 245 569 269 604 q 210 488 221 534 q 199 391 199 442 z "},"θ":{"ha":791,"x_min":83,"x_max":707,"o":"m 395 1001 q 500 984 452 1001 q 587 933 549 968 q 652 847 625 899 q 693 723 679 794 q 707 559 707 651 l 707 434 q 693 271 707 342 q 652 145 679 199 q 588 56 626 92 q 502 4 550 21 q 396 -14 454 -14 q 291 4 339 -14 q 204 56 243 21 q 139 145 166 92 q 98 271 112 199 q 83 434 83 342 l 83 559 q 98 723 83 651 q 139 847 112 794 q 203 933 165 899 q 290 984 241 968 q 395 1001 338 1001 m 395 899 q 315 878 350 899 q 257 816 280 857 q 221 716 233 775 q 209 581 209 657 l 209 543 l 581 543 l 581 581 q 573 692 581 642 q 551 781 566 742 q 513 845 536 819 q 461 885 490 871 q 395 899 431 899 m 396 90 q 462 104 433 90 q 514 145 492 118 q 551 212 536 172 q 574 302 566 252 q 581 414 581 353 l 581 441 l 209 441 l 209 414 q 217 302 209 353 q 240 212 224 252 q 278 145 256 172 q 331 104 301 118 q 396 90 360 90 z "},"ι":{"ha":450,"x_min":132,"x_max":399,"o":"m 132 734 l 258 734 l 258 187 q 270 131 258 150 q 300 105 281 112 q 339 99 318 99 q 372 102 355 99 q 398 107 389 105 l 399 5 q 360 -4 384 1 q 302 -9 336 -9 q 217 10 256 -9 q 155 72 178 28 q 132 188 132 115 l 132 734 z "},"λ":{"ha":770,"x_min":26,"x_max":734,"o":"m 366 547 l 165 0 l 26 0 l 311 747 l 399 739 l 366 547 m 178 1029 q 243 1021 216 1029 q 291 998 271 1013 q 325 960 311 982 q 348 911 338 939 l 637 159 q 656 123 647 136 q 677 104 666 110 q 705 98 689 98 q 719 99 711 98 q 730 100 726 99 l 734 -3 q 712 -9 727 -6 q 682 -12 698 -12 q 611 -2 641 -12 q 559 38 582 8 q 515 126 537 67 l 307 663 l 227 858 q 206 899 217 884 q 180 920 195 913 q 145 926 165 926 q 130 926 140 926 q 113 925 119 926 l 113 1021 q 143 1027 123 1025 q 178 1029 163 1029 z "},"ξ":{"ha":681,"x_min":69,"x_max":636,"o":"m 616 975 l 599 874 q 548 886 574 881 q 497 895 523 892 q 444 899 471 899 q 327 881 372 899 q 260 834 281 863 q 239 771 239 805 q 251 710 239 738 q 290 663 264 683 q 359 633 317 644 q 460 623 401 623 l 555 623 l 555 544 l 457 544 q 316 561 379 544 q 208 609 253 578 q 138 680 162 640 q 113 768 113 721 q 136 867 113 824 q 203 940 159 910 q 307 985 246 970 q 442 1001 367 1001 q 506 998 474 1001 q 567 988 538 994 q 616 975 595 982 m 457 595 l 555 595 l 555 519 l 460 519 q 316 496 376 519 q 226 424 257 473 q 195 301 195 376 q 222 199 195 241 q 292 133 249 158 q 385 96 336 109 l 460 79 q 555 50 516 65 q 615 7 594 34 q 636 -68 636 -20 q 615 -143 635 -104 q 568 -214 595 -181 q 517 -267 541 -248 l 444 -210 q 481 -168 465 -186 q 507 -130 497 -149 q 516 -83 516 -110 q 506 -54 516 -66 q 472 -33 495 -42 q 412 -15 450 -24 l 372 -5 q 250 33 305 10 q 154 89 194 55 q 91 176 113 123 q 69 304 69 228 q 98 430 69 376 q 178 521 126 484 q 301 577 230 558 q 457 595 372 595 z "},"π":{"ha":828,"x_min":28,"x_max":806,"o":"m 771 734 l 771 630 l 28 630 l 28 734 l 771 734 m 269 734 l 269 0 l 142 0 l 142 734 l 269 734 m 540 734 l 666 734 l 666 187 q 677 131 666 150 q 707 105 689 112 q 747 99 726 99 q 780 102 762 99 q 806 107 797 105 l 806 5 q 767 -4 791 1 q 709 -9 743 -9 q 625 10 663 -9 q 563 72 586 28 q 540 188 540 115 l 540 734 z "},"ρ":{"ha":787,"x_min":99,"x_max":716,"o":"m 99 -282 l 99 393 q 123 546 99 480 q 189 657 146 612 q 285 725 231 702 q 401 747 340 747 q 539 719 480 747 q 637 637 597 690 q 696 513 677 585 q 716 354 716 441 l 716 340 q 698 198 716 262 q 644 85 680 133 q 555 12 608 38 q 435 -14 503 -14 q 311 9 364 -14 q 220 76 257 33 q 160 182 182 120 q 131 321 138 243 q 147 308 132 321 q 177 283 162 296 q 192 271 192 271 q 230 182 205 224 q 294 115 254 140 q 397 90 335 90 q 484 109 448 90 q 544 162 521 128 q 579 242 568 197 q 590 340 590 288 l 590 354 q 580 466 590 413 q 547 558 570 518 q 489 621 525 598 q 401 644 453 644 q 320 621 354 644 q 266 559 287 597 q 235 477 245 522 q 225 391 225 433 l 224 -282 l 99 -282 z "},"ς":{"ha":747,"x_min":68,"x_max":674,"o":"m 389 747 q 536 716 471 747 q 637 626 600 685 q 674 481 674 566 l 555 481 q 536 564 555 527 q 481 623 518 601 q 389 644 444 644 q 301 622 338 644 q 240 561 264 599 q 206 476 217 522 q 195 381 195 429 l 195 353 q 221 243 195 292 q 302 159 248 195 q 435 102 355 124 q 531 73 489 88 q 598 29 574 58 q 623 -56 623 0 q 603 -130 623 -91 q 556 -201 583 -168 q 505 -254 528 -234 l 438 -197 q 473 -155 459 -173 q 495 -117 488 -136 q 503 -72 503 -98 q 492 -39 503 -52 q 458 -17 481 -26 q 397 0 435 -8 q 218 70 291 24 q 106 187 144 117 q 68 353 68 258 l 68 381 q 90 521 68 455 q 152 638 111 587 q 253 718 193 689 q 389 747 313 747 z "},"σ":{"ha":787,"x_min":66,"x_max":779,"o":"m 66 359 l 66 374 q 88 516 66 451 q 152 631 110 582 q 255 707 195 680 q 393 734 316 734 q 431 719 414 732 q 469 691 448 707 q 525 667 490 676 q 631 590 587 637 q 699 482 675 543 q 722 349 722 421 l 722 334 q 700 203 722 266 q 635 92 677 141 q 532 15 593 43 q 394 -14 471 -14 q 256 15 317 -14 q 153 93 195 43 q 88 212 110 144 q 66 359 66 279 m 191 374 l 191 359 q 203 255 191 304 q 240 170 216 207 q 303 111 265 132 q 394 90 342 90 q 484 111 446 90 q 547 170 522 132 q 583 255 571 207 q 595 359 595 304 l 595 374 q 583 471 595 425 q 546 553 571 517 q 483 610 522 589 q 393 630 445 630 q 303 610 341 630 q 240 553 264 589 q 203 471 216 517 q 191 374 191 425 m 779 734 l 779 630 l 392 630 l 392 734 l 779 734 z "},"τ":{"ha":724,"x_min":55,"x_max":669,"o":"m 669 734 l 669 632 l 55 632 l 55 734 l 669 734 m 291 734 l 416 734 l 416 183 q 426 127 416 146 q 452 100 436 107 q 488 93 469 93 q 523 98 507 93 q 551 111 539 104 l 578 22 q 517 -7 547 -1 q 456 -14 488 -14 q 367 7 404 -14 q 311 72 330 27 q 291 190 291 117 l 291 734 z "},"υ":{"ha":758,"x_min":98,"x_max":688,"o":"m 98 734 l 223 734 l 223 289 q 233 196 223 235 q 262 134 243 158 q 306 100 281 111 q 360 89 331 89 q 448 114 410 89 q 511 182 486 140 q 549 277 536 225 q 562 381 562 329 q 537 562 561 473 q 479 734 513 650 l 611 734 q 649 639 631 692 q 677 522 667 586 q 688 382 688 458 q 669 232 688 304 q 610 105 650 161 q 509 18 570 50 q 366 -14 449 -14 q 255 4 304 -14 q 170 59 205 22 q 116 153 135 96 q 98 290 98 211 l 98 734 z "},"φ":{"ha":979,"x_min":60,"x_max":920,"o":"m 421 -324 l 421 580 q 443 662 421 627 q 502 715 464 696 q 591 734 541 734 q 718 707 659 734 q 823 630 777 680 q 894 514 868 581 q 920 369 920 448 q 896 225 920 294 q 820 102 872 156 q 685 17 768 48 q 484 -14 602 -14 q 287 18 368 -14 q 156 106 206 50 q 83 233 106 161 q 60 382 60 304 q 79 524 60 458 q 138 642 99 589 q 233 734 176 695 l 301 644 q 236 566 261 609 q 199 475 211 522 q 185 382 187 429 q 201 278 185 330 q 251 183 216 226 q 343 115 286 140 q 484 89 400 89 q 666 131 598 89 q 764 238 734 174 q 794 369 794 302 q 780 465 793 418 q 741 549 766 512 q 678 609 715 587 q 591 631 641 631 q 558 616 570 631 q 547 585 547 602 l 547 -324 l 421 -324 z "},"ψ":{"ha":972,"x_min":65,"x_max":913,"o":"m 65 734 l 191 734 l 191 403 q 212 257 191 317 q 273 160 234 197 q 364 106 312 123 q 477 89 416 89 q 624 115 564 89 q 720 184 684 140 q 772 280 755 227 q 788 385 788 332 q 762 564 786 476 q 702 734 738 651 l 834 734 q 873 640 855 692 q 902 524 891 587 q 913 385 913 460 q 891 234 913 306 q 818 106 868 162 q 685 18 768 50 q 484 -14 603 -14 q 311 10 388 -14 q 178 85 233 35 q 94 216 123 136 q 65 404 65 295 l 65 734 m 415 734 l 541 734 l 541 -321 l 415 -321 l 415 734 z "},"ω":{"ha":1144,"x_min":83,"x_max":1059,"o":"m 836 734 l 967 734 q 1013 638 991 691 q 1046 521 1034 585 q 1059 380 1059 457 q 1045 231 1059 302 q 999 105 1030 160 q 916 18 967 50 q 791 -14 864 -14 q 687 8 732 -14 q 610 73 642 30 q 562 178 578 115 q 546 321 546 240 l 546 522 l 634 522 l 634 319 q 645 213 634 256 q 677 141 656 169 q 725 101 697 114 q 784 89 752 89 q 853 112 825 89 q 899 175 882 135 q 925 268 917 216 q 933 380 933 321 q 904 561 931 473 q 836 734 876 650 m 175 734 l 307 734 q 238 561 266 650 q 209 380 211 473 q 214 290 209 333 q 230 210 219 246 q 258 146 241 174 q 300 104 275 119 q 357 89 325 89 q 417 101 390 89 q 465 141 445 114 q 497 213 486 169 q 508 319 508 256 l 508 522 l 596 522 l 596 321 q 580 178 596 240 q 532 73 564 115 q 455 8 500 30 q 351 -14 410 -14 q 248 6 292 -14 q 172 64 203 27 q 121 152 140 102 q 92 260 101 201 q 83 380 83 318 q 96 521 83 457 q 130 638 109 585 q 175 734 151 691 z "},"ϑ":{"ha":804,"x_min":83,"x_max":777,"o":"m 772 527 l 777 426 q 711 408 748 415 q 638 401 674 401 q 420 448 513 401 q 276 576 327 495 q 225 757 225 656 l 225 768 q 255 895 225 842 q 335 975 284 947 q 451 1003 386 1003 q 546 986 504 1003 q 618 937 589 970 q 664 858 648 905 q 680 750 680 810 l 680 296 q 643 126 680 195 q 541 21 606 57 q 387 -14 475 -14 q 263 7 319 -14 q 166 70 207 29 q 104 168 126 111 q 83 296 83 224 l 83 522 l 208 523 l 208 296 q 230 186 208 232 q 292 117 252 141 q 387 93 332 93 q 477 115 440 93 q 535 181 515 136 q 555 296 555 227 l 555 750 q 548 815 555 788 q 529 861 542 843 q 496 887 515 879 q 451 896 477 896 q 400 883 422 896 q 364 843 377 871 q 351 768 351 814 l 351 755 q 384 633 351 690 q 480 543 416 577 q 638 509 545 509 q 708 514 673 509 q 772 527 743 519 z "},"ϒ":{"ha":740,"x_min":-26,"x_max":770,"o":"m 437 466 l 437 0 l 307 0 l 307 466 l 437 466 m 368 516 l 524 869 q 570 946 547 919 q 622 985 593 974 q 685 996 650 996 q 729 992 709 996 q 770 978 749 988 l 745 875 q 731 879 742 878 q 710 881 721 881 q 683 876 696 881 q 659 860 670 871 q 638 827 648 848 l 427 368 l 336 369 l 368 516 m 222 869 l 378 511 l 407 369 l 316 368 l 106 827 q 85 860 96 848 q 61 876 73 871 q 34 881 48 881 q 12 879 23 881 q -2 875 1 878 l -26 977 q 15 992 -5 987 q 58 996 35 996 q 121 986 92 996 q 174 948 149 976 q 222 869 199 921 z "},"ϖ":{"ha":1090,"x_min":51,"x_max":1060,"o":"m 1060 734 l 1060 631 l 51 631 l 51 734 l 1060 734 m 787 734 l 920 734 q 965 638 944 691 q 998 521 985 585 q 1011 380 1011 457 q 1003 260 1011 318 q 977 152 994 201 q 930 64 959 102 q 861 6 901 27 q 768 -14 821 -14 q 664 8 709 -14 q 587 73 618 30 q 540 178 556 115 q 524 321 524 240 l 524 490 l 612 490 l 612 319 q 623 213 612 256 q 654 141 634 169 q 702 101 675 114 q 762 89 729 89 q 809 104 789 89 q 844 146 829 119 q 868 210 859 173 q 881 290 877 246 q 886 380 886 333 q 856 561 883 473 q 787 734 828 650 m 178 734 l 310 734 q 241 561 269 650 q 212 380 214 473 q 216 290 212 333 q 230 210 220 246 q 253 146 239 174 q 288 104 268 119 q 336 89 309 89 q 395 101 368 89 q 443 141 422 114 q 474 213 463 169 q 486 319 486 256 l 486 490 l 574 490 l 574 321 q 557 178 574 240 q 510 73 541 115 q 433 8 478 30 q 329 -14 387 -14 q 236 6 276 -14 q 167 64 195 27 q 120 152 138 102 q 94 260 102 201 q 85 380 85 318 q 98 521 85 457 q 133 638 111 585 q 178 734 154 691 z "},"Ђ":{"ha":1042,"x_min":29,"x_max":989,"o":"m 389 441 l 389 554 q 470 580 425 568 q 559 598 515 591 q 637 605 603 605 q 825 569 747 605 q 946 463 904 532 q 989 294 989 393 q 967 167 989 223 q 904 72 946 111 q 799 13 862 33 q 651 -8 735 -8 l 650 94 q 748 109 708 94 q 812 149 788 123 q 847 212 836 176 q 858 293 858 249 q 833 401 858 357 q 759 469 808 446 q 636 492 709 492 q 551 486 593 492 q 467 468 508 479 q 389 441 426 457 m 441 987 l 441 0 l 311 0 l 311 987 l 441 987 m 795 987 l 795 880 l 29 880 l 29 987 l 795 987 z "},"Є":{"ha":937,"x_min":83,"x_max":844,"o":"m 601 552 l 601 446 l 196 446 l 196 552 l 601 552 m 713 314 l 844 314 q 790 146 834 220 q 667 30 747 73 q 470 -14 588 -14 q 311 19 382 -14 q 189 112 240 52 q 111 256 138 172 q 83 444 83 340 l 83 542 q 111 730 83 646 q 190 876 138 815 q 316 968 242 936 q 481 1001 389 1001 q 670 959 593 1001 q 791 843 747 917 q 844 671 834 768 l 713 671 q 678 790 704 740 q 605 867 652 840 q 481 894 557 894 q 366 869 416 894 q 282 797 316 844 q 232 686 249 751 q 215 543 215 622 l 215 444 q 225 333 215 386 q 254 237 235 281 q 304 160 274 193 q 376 111 335 128 q 470 93 417 93 q 602 119 553 93 q 677 195 652 145 q 713 314 703 244 z "},"Љ":{"ha":1488,"x_min":34,"x_max":1429,"o":"m 254 987 l 385 987 l 362 504 q 346 318 357 399 q 315 176 335 236 q 262 77 294 116 q 182 19 229 38 q 69 0 135 0 l 34 0 l 34 106 l 61 109 q 126 126 99 111 q 173 170 154 140 q 205 248 193 200 q 224 364 217 295 q 235 525 231 433 l 254 987 m 744 987 l 744 880 l 299 880 l 299 987 l 744 987 m 825 605 l 1095 605 q 1277 566 1203 605 q 1390 458 1352 526 q 1429 302 1429 389 q 1407 182 1429 237 q 1343 86 1385 127 q 1238 22 1300 45 q 1095 0 1176 0 l 726 0 l 726 987 l 857 987 l 857 106 l 1095 106 q 1212 135 1167 106 q 1278 209 1257 163 q 1299 303 1299 254 q 1278 397 1299 353 q 1212 470 1257 441 q 1095 498 1167 498 l 825 498 l 825 605 z "},"Њ":{"ha":1501,"x_min":121,"x_max":1441,"o":"m 756 559 l 756 453 l 231 453 l 231 559 l 756 559 m 252 987 l 252 0 l 121 0 l 121 987 l 252 987 m 838 574 l 1107 574 q 1290 538 1215 574 q 1402 438 1364 502 q 1441 290 1441 374 q 1419 174 1441 227 q 1355 82 1398 121 q 1250 22 1312 43 q 1107 0 1188 0 l 738 0 l 738 987 l 869 987 l 869 113 l 1107 113 q 1224 138 1179 113 q 1291 204 1270 163 q 1312 292 1312 245 q 1291 378 1312 338 q 1224 443 1270 418 q 1107 468 1179 468 l 838 468 l 838 574 z "},"Ћ":{"ha":1131,"x_min":42,"x_max":1012,"o":"m 1012 0 l 882 0 l 882 309 q 859 429 882 386 q 791 490 836 472 q 677 507 745 507 q 598 504 636 507 q 523 494 559 500 q 451 480 486 488 q 380 460 415 471 l 380 568 q 447 587 414 578 q 514 602 479 595 q 589 611 549 608 q 677 614 629 614 q 857 584 782 614 q 972 487 932 554 q 1012 309 1012 420 l 1012 0 m 450 987 l 450 0 l 319 0 l 319 987 l 450 987 m 808 987 l 808 880 l 42 880 l 42 987 l 808 987 z "},"Џ":{"ha":990,"x_min":119,"x_max":868,"o":"m 119 0 l 119 987 l 251 987 l 251 106 l 737 106 l 737 987 l 868 987 l 868 0 l 119 0 m 564 94 l 564 -243 l 433 -243 l 433 94 l 564 94 z "},"Б":{"ha":876,"x_min":111,"x_max":814,"o":"m 717 987 l 717 880 l 241 880 l 241 0 l 111 0 l 111 987 l 717 987 m 210 585 l 479 585 q 663 549 588 585 q 776 448 737 513 q 814 295 814 382 q 793 176 814 230 q 728 82 771 122 q 623 21 686 43 q 479 0 561 0 l 111 0 l 111 987 l 241 987 l 241 106 l 479 106 q 597 133 552 106 q 663 203 642 160 q 684 296 684 247 q 663 387 684 346 q 597 453 642 429 q 479 478 552 478 l 210 478 l 210 585 z "},"Д":{"ha":1044,"x_min":35,"x_max":1005,"o":"m 891 106 l 891 0 l 144 0 l 144 106 l 891 106 m 165 106 l 165 -243 l 35 -243 l 35 106 l 165 106 m 1005 106 l 1004 -242 l 874 -242 l 874 106 l 1005 106 m 763 987 l 763 880 l 330 880 l 330 987 l 763 987 m 876 987 l 876 0 l 745 0 l 745 987 l 876 987 m 286 987 l 416 987 l 396 590 q 379 425 392 500 q 347 287 366 349 q 304 175 328 224 q 252 91 279 126 q 194 32 224 55 q 133 0 163 9 l 73 0 l 73 106 l 115 106 q 156 161 133 125 q 201 255 178 197 q 241 395 224 312 q 264 590 258 477 l 286 987 z "},"Ж":{"ha":1261,"x_min":18,"x_max":1252,"o":"m 397 451 l 45 987 l 198 987 l 460 559 l 646 559 l 625 451 l 397 451 m 468 461 l 181 0 l 18 0 l 385 574 l 468 461 m 703 987 l 703 0 l 573 0 l 573 987 l 703 987 m 1226 987 l 872 451 l 651 451 l 631 559 l 810 559 l 1072 987 l 1226 987 m 1089 0 l 803 461 l 886 574 l 1252 0 l 1089 0 z "},"З":{"ha":825,"x_min":54,"x_max":767,"o":"m 417 474 l 300 474 l 300 557 l 412 557 q 533 578 487 557 q 600 637 579 600 q 621 723 621 674 q 598 809 621 770 q 527 871 575 848 q 403 895 479 895 q 300 873 346 895 q 227 814 254 852 q 199 728 199 777 l 68 728 q 95 841 68 791 q 168 927 121 892 q 274 982 214 963 q 403 1001 335 1001 q 547 983 482 1001 q 657 930 611 965 q 728 842 703 895 q 752 721 752 790 q 728 625 752 670 q 661 547 705 581 q 555 493 616 513 q 417 474 493 474 m 300 532 l 417 532 q 566 515 500 532 q 675 465 631 498 q 744 385 720 433 q 767 275 767 337 q 740 153 767 206 q 665 62 713 99 q 549 5 616 24 q 403 -14 482 -14 q 277 3 339 -14 q 165 55 215 20 q 84 144 115 90 q 54 274 54 198 l 185 274 q 213 183 185 224 q 289 117 240 142 q 403 92 338 92 q 529 116 477 92 q 609 180 581 139 q 636 273 636 221 q 622 352 636 318 q 579 407 607 385 q 509 439 551 429 q 412 450 467 450 l 300 450 l 300 532 z "},"И":{"ha":991,"x_min":121,"x_max":868,"o":"m 251 227 l 737 987 l 868 987 l 868 0 l 737 0 l 737 762 l 251 0 l 121 0 l 121 987 l 251 987 l 251 227 z "},"Л":{"ha":983,"x_min":33,"x_max":862,"o":"m 749 987 l 749 880 l 298 880 l 298 987 l 749 987 m 862 987 l 862 0 l 731 0 l 731 987 l 862 987 m 253 987 l 383 987 l 361 504 q 345 318 356 399 q 313 176 334 236 q 260 77 293 116 q 181 19 228 38 q 68 0 134 0 l 33 0 l 33 106 l 60 109 q 125 126 98 111 q 172 170 153 140 q 203 248 191 200 q 223 364 216 295 q 234 525 230 433 l 253 987 z "},"У":{"ha":873,"x_min":52,"x_max":832,"o":"m 420 328 l 682 987 l 832 987 l 483 165 q 450 98 468 130 q 405 41 431 66 q 339 1 378 16 q 243 -14 300 -14 q 204 -13 227 -14 q 175 -9 182 -11 l 179 96 q 208 93 186 94 q 240 92 230 92 q 301 108 279 92 q 337 148 323 123 q 363 197 351 172 l 420 328 m 199 987 l 473 372 l 506 251 l 396 243 l 52 987 l 199 987 z "},"Ф":{"ha":1072,"x_min":57,"x_max":1022,"o":"m 457 889 l 621 889 q 779 860 706 889 q 906 779 852 831 q 991 653 961 726 q 1022 492 1022 580 q 991 330 1022 404 q 906 204 961 257 q 779 122 852 151 q 621 93 706 93 l 457 93 q 299 122 372 93 q 172 203 227 151 q 87 329 117 256 q 57 490 57 402 q 87 651 57 578 q 172 778 117 724 q 299 860 227 831 q 457 889 372 889 m 457 786 q 307 749 368 786 q 213 646 245 712 q 181 490 181 579 q 199 369 181 423 q 252 276 217 315 q 339 216 288 237 q 457 195 391 195 l 622 195 q 771 232 710 195 q 865 336 833 269 q 897 492 897 403 q 879 612 897 558 q 826 705 861 667 q 740 765 791 744 q 622 786 688 786 l 457 786 m 602 1028 l 602 -41 l 477 -41 l 477 1028 l 602 1028 z "},"Ц":{"ha":1016,"x_min":119,"x_max":971,"o":"m 971 110 l 959 -238 l 842 -238 l 842 0 l 745 0 l 745 110 l 971 110 m 119 0 l 119 987 l 250 987 l 250 106 l 736 106 l 736 987 l 867 987 l 867 0 l 119 0 z "},"Ч":{"ha":951,"x_min":102,"x_max":831,"o":"m 102 987 l 233 987 l 233 679 q 256 559 233 602 q 323 498 278 515 q 437 480 369 480 q 516 484 477 480 q 591 493 554 487 q 663 508 627 499 q 733 527 699 517 l 733 420 q 667 401 700 410 q 599 386 634 392 q 525 376 564 380 q 437 373 485 373 q 257 403 332 373 q 142 500 182 433 q 102 679 102 568 l 102 987 m 700 987 l 831 987 l 831 0 l 700 0 l 700 987 z "},"Ш":{"ha":1307,"x_min":119,"x_max":1188,"o":"m 119 987 l 251 987 l 251 106 l 590 106 l 590 987 l 720 987 l 720 106 l 1057 106 l 1057 987 l 1188 987 l 1188 0 l 119 0 l 119 987 z "},"Щ":{"ha":1345,"x_min":119,"x_max":1288,"o":"m 1288 103 l 1276 -238 l 1163 -238 l 1163 0 l 1067 0 l 1067 103 l 1288 103 m 119 987 l 251 987 l 251 106 l 590 106 l 590 987 l 720 987 l 720 106 l 1057 106 l 1057 987 l 1188 987 l 1188 0 l 119 0 l 119 987 z "},"Ъ":{"ha":1054,"x_min":12,"x_max":994,"o":"m 12 884 l 12 987 l 321 987 l 321 884 l 12 884 m 389 585 l 658 585 q 841 549 766 585 q 955 448 916 513 q 994 295 994 382 q 971 176 994 230 q 907 82 949 122 q 802 21 864 43 q 658 0 739 0 l 290 0 l 290 987 l 420 987 l 420 106 l 658 106 q 775 133 730 106 q 842 203 821 160 q 863 296 863 247 q 842 387 863 346 q 775 453 821 429 q 658 478 730 478 l 389 478 l 389 585 z "},"Ы":{"ha":1201,"x_min":121,"x_max":1075,"o":"m 220 585 l 490 585 q 673 549 598 585 q 786 448 747 513 q 825 295 825 382 q 803 176 825 230 q 739 82 781 122 q 633 21 696 43 q 490 0 571 0 l 121 0 l 121 987 l 252 987 l 252 106 l 490 106 q 607 133 562 106 q 673 203 652 160 q 694 296 694 247 q 673 387 694 346 q 607 453 652 429 q 490 478 562 478 l 220 478 l 220 585 m 1075 987 l 1075 0 l 944 0 l 944 987 l 1075 987 z "},"Ь":{"ha":871,"x_min":111,"x_max":814,"o":"m 210 585 l 479 585 q 663 549 588 585 q 776 448 737 513 q 814 295 814 382 q 793 176 814 230 q 728 82 771 122 q 623 21 686 43 q 479 0 561 0 l 111 0 l 111 987 l 241 987 l 241 106 l 479 106 q 597 133 552 106 q 663 203 642 160 q 684 296 684 247 q 663 387 684 346 q 597 453 642 429 q 479 478 552 478 l 210 478 l 210 585 z "},"Э":{"ha":937,"x_min":100,"x_max":860,"o":"m 746 546 l 746 439 l 341 439 l 341 546 l 746 546 m 100 314 l 231 314 q 267 195 241 244 q 342 119 292 145 q 475 93 391 93 q 589 120 541 93 q 668 196 637 148 q 714 308 699 244 q 730 444 730 372 l 730 543 q 719 660 730 606 q 686 757 708 714 q 632 831 665 800 q 558 878 600 861 q 463 894 515 894 q 339 867 387 894 q 266 790 292 840 q 231 671 241 740 l 100 671 q 154 843 111 768 q 274 959 197 917 q 463 1001 351 1001 q 628 968 555 1001 q 753 876 701 936 q 832 730 805 815 q 860 542 860 646 l 860 444 q 832 256 860 340 q 754 112 805 172 q 632 19 703 52 q 475 -14 562 -14 q 277 30 356 -14 q 154 146 197 73 q 100 314 111 220 z "},"Ю":{"ha":1242,"x_min":124,"x_max":1190,"o":"m 255 987 l 255 0 l 124 0 l 124 987 l 255 987 m 481 535 l 481 432 l 247 432 l 247 535 l 481 535 m 1190 525 l 1190 463 q 1162 263 1190 351 q 1082 113 1135 175 q 957 19 1030 52 q 794 -14 884 -14 q 634 19 707 -14 q 508 113 561 52 q 425 263 454 175 q 396 463 396 351 l 396 525 q 425 724 396 636 q 507 874 454 812 q 632 968 559 936 q 793 1001 705 1001 q 956 968 883 1001 q 1081 874 1029 936 q 1162 724 1134 812 q 1190 525 1190 636 m 1061 463 l 1061 526 q 1043 682 1061 614 q 990 796 1025 750 q 906 866 956 842 q 793 890 856 890 q 683 866 732 890 q 598 796 633 842 q 545 682 564 750 q 526 526 526 614 l 526 463 q 545 306 526 374 q 599 191 564 237 q 684 121 635 144 q 794 97 733 97 q 907 121 858 97 q 991 191 957 144 q 1043 306 1025 237 q 1061 463 1061 374 z "},"Я":{"ha":884,"x_min":61,"x_max":763,"o":"m 663 385 l 385 385 l 321 411 q 156 515 214 445 q 98 690 98 585 q 141 852 98 785 q 261 953 183 918 q 447 987 340 987 l 763 987 l 763 0 l 632 0 l 632 880 l 447 880 q 284 829 338 880 q 229 690 229 777 q 253 588 229 633 q 325 517 277 543 q 443 492 372 492 l 663 492 l 663 385 m 440 452 l 200 0 l 61 0 l 308 452 l 440 452 z "},"б":{"ha":768,"x_min":66,"x_max":722,"o":"m 566 1053 l 669 1053 q 649 948 669 987 q 594 888 629 909 q 515 856 559 867 q 425 835 471 845 q 316 797 366 823 q 231 723 267 770 q 179 600 195 675 q 170 412 162 524 l 170 349 l 66 349 l 66 412 q 91 631 66 537 q 159 789 115 724 q 263 891 203 853 q 397 943 324 929 q 488 965 450 954 q 546 998 526 977 q 566 1053 566 1018 m 418 692 q 546 667 490 692 q 642 597 602 642 q 702 491 681 552 q 722 359 722 431 l 722 345 q 700 202 722 268 q 636 89 678 137 q 533 13 593 40 q 395 -14 472 -14 q 257 13 317 -14 q 153 89 196 40 q 89 202 111 137 q 66 345 66 268 l 66 359 q 73 393 66 376 q 88 426 79 409 q 104 462 97 443 q 173 575 130 523 q 278 660 217 627 q 418 692 340 692 m 393 589 q 280 557 324 589 q 214 473 235 526 q 192 359 192 420 l 192 345 q 204 247 192 293 q 241 165 216 201 q 304 109 266 130 q 395 89 342 89 q 485 109 447 89 q 547 165 523 130 q 584 247 572 201 q 596 345 596 293 l 596 359 q 584 447 596 406 q 547 520 572 488 q 484 571 522 552 q 393 589 446 589 z "},"в":{"ha":794,"x_min":107,"x_max":722,"o":"m 440 323 l 199 323 l 198 423 l 395 423 q 492 435 453 423 q 551 469 531 446 q 570 526 570 492 q 559 573 570 553 q 526 606 548 593 q 470 626 503 619 q 393 632 437 632 l 233 632 l 233 0 l 107 0 l 107 734 l 393 734 q 519 722 463 734 q 615 685 575 709 q 675 622 654 660 q 696 532 696 584 q 683 469 696 499 q 643 416 669 439 q 578 379 616 393 q 489 360 539 364 l 440 323 m 440 0 l 154 0 l 216 102 l 440 102 q 527 115 492 102 q 579 153 562 128 q 596 212 596 178 q 579 272 596 247 q 527 310 562 296 q 440 323 492 323 l 250 323 l 251 423 l 489 423 l 534 385 q 637 355 595 380 q 701 292 679 330 q 722 209 722 254 q 703 118 722 157 q 647 53 684 79 q 558 13 610 26 q 440 0 506 0 z "},"г":{"ha":583,"x_min":105,"x_max":570,"o":"m 570 734 l 570 630 l 231 630 l 231 0 l 105 0 l 105 734 l 570 734 z "},"д":{"ha":838,"x_min":31,"x_max":795,"o":"m 228 734 l 353 734 l 342 459 q 319 279 338 355 q 269 150 299 203 q 200 60 238 96 q 123 0 163 24 l 60 0 l 64 102 l 90 103 q 133 158 112 130 q 172 225 154 186 q 201 320 189 264 q 216 459 213 377 l 228 734 m 259 734 l 701 734 l 701 0 l 575 0 l 575 618 l 259 618 l 259 734 m 32 103 l 795 103 l 795 -216 l 669 -216 l 669 0 l 157 0 l 157 -216 l 31 -216 l 32 103 z "},"ж":{"ha":1064,"x_min":15,"x_max":1044,"o":"m 318 319 l 40 734 l 191 734 l 381 430 l 528 430 l 509 319 l 318 319 m 387 332 l 174 0 l 15 0 l 307 423 l 387 332 m 592 734 l 592 0 l 467 0 l 467 734 l 592 734 m 1020 734 l 742 319 l 551 319 l 531 430 l 678 430 l 868 734 l 1020 734 m 886 0 l 672 332 l 753 423 l 1044 0 l 886 0 z "},"з":{"ha":705,"x_min":60,"x_max":638,"o":"m 370 351 l 235 351 l 235 428 l 359 428 q 442 441 412 428 q 486 478 473 454 q 498 534 498 502 q 484 588 498 562 q 437 629 469 613 q 352 645 406 645 q 273 630 309 645 q 217 588 238 614 q 197 530 197 562 l 71 530 q 110 645 71 597 q 212 720 148 694 q 352 747 276 747 q 466 733 416 747 q 552 692 517 719 q 606 626 587 665 q 625 534 625 586 q 607 463 625 496 q 556 405 589 430 q 476 365 523 379 q 370 351 429 351 m 235 398 l 370 398 q 486 386 435 398 q 570 349 536 373 q 621 289 604 324 q 638 207 638 253 q 617 114 638 155 q 559 45 597 73 q 468 1 521 16 q 352 -14 416 -14 q 214 11 281 -14 q 103 86 146 35 q 60 217 60 138 l 185 217 q 206 154 185 184 q 265 106 227 124 q 352 87 302 87 q 440 104 405 87 q 493 147 475 120 q 511 206 511 174 q 495 273 511 248 q 445 310 479 298 q 359 321 412 321 l 235 321 l 235 398 z "},"и":{"ha":802,"x_min":106,"x_max":696,"o":"m 231 199 l 570 734 l 696 734 l 696 0 l 570 0 l 570 535 l 231 0 l 106 0 l 106 734 l 231 734 l 231 199 z "},"к":{"ha":751,"x_min":106,"x_max":738,"o":"m 232 734 l 232 0 l 106 0 l 106 734 l 232 734 m 713 734 l 366 313 l 190 313 l 171 423 l 315 423 l 561 734 l 713 734 m 578 0 l 309 332 l 389 423 l 738 0 l 578 0 z "},"л":{"ha":803,"x_min":30,"x_max":696,"o":"m 586 734 l 586 630 l 231 630 l 231 734 l 586 734 m 696 734 l 696 0 l 571 0 l 571 734 l 696 734 m 201 734 l 327 734 l 308 380 q 293 235 303 298 q 264 127 282 172 q 219 55 246 83 q 155 13 193 26 q 69 0 118 0 l 30 0 l 30 111 l 57 113 q 107 126 86 115 q 142 160 127 138 q 165 219 156 183 q 179 304 174 255 q 187 420 184 354 l 201 734 z "},"м":{"ha":1030,"x_min":107,"x_max":924,"o":"m 517 167 l 767 734 l 888 734 l 561 0 l 474 0 l 149 734 l 269 734 l 517 167 m 233 734 l 233 0 l 107 0 l 107 734 l 233 734 m 798 0 l 798 734 l 924 734 l 924 0 l 798 0 z "},"н":{"ha":801,"x_min":106,"x_max":695,"o":"m 593 416 l 593 314 l 205 314 l 205 416 l 593 416 m 232 734 l 232 0 l 106 0 l 106 734 l 232 734 m 695 734 l 695 0 l 569 0 l 569 734 l 695 734 z "},"п":{"ha":802,"x_min":106,"x_max":696,"o":"m 585 734 l 585 630 l 214 630 l 214 734 l 585 734 m 232 734 l 232 0 l 106 0 l 106 734 l 232 734 m 696 734 l 696 0 l 570 0 l 570 734 l 696 734 z "},"т":{"ha":668,"x_min":27,"x_max":641,"o":"m 395 734 l 395 0 l 269 0 l 269 734 l 395 734 m 641 734 l 641 632 l 27 632 l 27 734 l 641 734 z "},"ф":{"ha":1008,"x_min":68,"x_max":939,"o":"m 939 354 l 939 340 q 922 198 939 262 q 872 85 905 133 q 789 12 838 38 q 674 -14 739 -14 q 580 0 621 -14 q 511 43 539 15 q 466 110 483 71 q 444 197 450 149 l 444 523 q 466 616 450 575 q 511 687 483 658 q 579 732 539 716 q 673 747 619 747 q 768 729 726 747 q 843 675 810 710 q 896 592 875 641 q 928 484 918 544 q 939 354 939 423 m 814 340 l 814 354 q 807 445 814 401 q 788 524 801 488 q 753 587 774 560 q 703 629 732 614 q 635 644 673 644 q 568 634 595 644 q 526 607 541 624 q 505 572 511 591 l 505 147 q 528 119 513 132 q 570 97 544 106 q 637 89 597 89 q 718 108 684 89 q 773 162 751 127 q 804 242 794 197 q 814 340 814 288 m 68 340 l 68 354 q 79 484 68 423 q 111 592 90 544 q 165 675 133 641 q 240 729 197 710 q 335 747 282 747 q 426 732 387 747 q 492 687 465 716 q 536 616 519 658 q 559 523 552 575 l 559 210 q 536 117 553 159 q 493 46 520 76 q 426 1 466 17 q 334 -14 387 -14 q 219 12 269 -14 q 136 85 170 38 q 85 198 102 133 q 68 340 68 262 m 194 354 l 194 340 q 203 242 194 288 q 232 162 212 197 q 285 108 252 127 q 365 89 317 89 q 432 99 406 89 q 474 125 458 109 q 498 159 490 142 l 498 572 q 476 607 491 591 q 434 634 460 624 q 366 644 408 644 q 286 621 319 644 q 232 558 252 598 q 203 466 212 518 q 194 354 194 413 m 435 -282 l 435 1042 l 562 1042 l 562 -282 l 435 -282 z "},"ц":{"ha":823,"x_min":106,"x_max":783,"o":"m 106 0 l 106 734 l 232 734 l 232 103 l 570 103 l 570 734 l 696 734 l 696 0 l 106 0 m 783 103 l 770 -218 l 659 -218 l 659 0 l 563 0 l 563 103 l 783 103 z "},"ч":{"ha":755,"x_min":71,"x_max":649,"o":"m 649 734 l 649 0 l 524 0 l 524 734 l 649 734 m 606 397 l 606 294 q 529 268 568 279 q 447 251 490 257 q 354 244 404 244 q 203 274 267 244 q 105 366 140 304 q 71 521 71 427 l 71 735 l 196 735 l 196 521 q 214 422 196 460 q 268 366 233 384 q 354 348 303 348 q 446 354 403 348 q 529 372 489 361 q 606 397 568 382 z "},"ш":{"ha":1124,"x_min":106,"x_max":1020,"o":"m 106 734 l 232 734 l 232 103 l 500 103 l 500 734 l 627 734 l 627 103 l 895 103 l 895 734 l 1020 734 l 1020 0 l 106 0 l 106 734 z "},"щ":{"ha":1149,"x_min":99,"x_max":1116,"o":"m 1116 103 l 1103 -218 l 991 -218 l 991 0 l 896 0 l 896 103 l 1116 103 m 99 734 l 224 734 l 224 103 l 493 103 l 493 734 l 619 734 l 619 103 l 887 103 l 887 734 l 1013 734 l 1013 0 l 99 0 l 99 734 z "},"ъ":{"ha":862,"x_min":20,"x_max":825,"o":"m 342 734 l 342 631 l 20 631 l 20 734 l 342 734 m 330 481 l 551 481 q 701 451 640 481 q 793 366 762 420 q 825 243 825 312 q 807 148 825 193 q 754 71 789 104 q 668 19 720 37 q 551 0 617 0 l 238 0 l 238 734 l 364 734 l 364 103 l 551 103 q 637 123 605 103 q 684 174 669 142 q 698 239 698 205 q 684 304 698 272 q 637 357 669 336 q 551 378 605 378 l 330 378 l 330 481 z "},"ы":{"ha":1078,"x_min":107,"x_max":954,"o":"m 199 481 l 419 481 q 569 451 508 481 q 662 366 630 420 q 693 243 693 312 q 675 148 693 193 q 623 71 658 104 q 537 19 588 37 q 419 0 486 0 l 107 0 l 107 734 l 233 734 l 233 103 l 419 103 q 506 123 473 103 q 553 174 538 142 q 567 239 567 205 q 553 304 567 272 q 506 357 538 336 q 419 378 473 378 l 199 378 l 199 481 m 954 734 l 954 0 l 829 0 l 829 734 l 954 734 z "},"ь":{"ha":754,"x_min":107,"x_max":693,"o":"m 199 481 l 419 481 q 569 451 508 481 q 662 366 630 420 q 693 243 693 312 q 675 148 693 193 q 623 71 658 104 q 537 19 588 37 q 419 0 486 0 l 107 0 l 107 734 l 233 734 l 233 103 l 419 103 q 506 123 473 103 q 553 174 538 142 q 567 239 567 205 q 553 304 567 272 q 506 357 538 336 q 419 378 473 378 l 199 378 l 199 481 z "},"э":{"ha":747,"x_min":68,"x_max":673,"o":"m 353 644 q 274 626 311 644 q 212 575 236 608 q 188 501 188 543 l 68 501 q 109 623 68 567 q 214 713 149 679 q 353 747 279 747 q 490 718 430 747 q 590 638 549 689 q 652 521 631 587 q 673 381 673 455 l 673 353 q 652 213 673 279 q 590 95 631 146 q 489 15 549 44 q 353 -14 430 -14 q 207 21 271 -14 q 105 116 142 56 q 68 252 68 176 l 188 252 q 210 169 188 206 q 269 111 232 132 q 353 89 307 89 q 441 112 404 89 q 502 173 478 135 q 537 258 526 211 q 548 353 548 305 l 548 381 q 537 476 548 429 q 502 561 526 523 q 442 622 479 599 q 353 644 405 644 m 609 425 l 609 323 l 271 323 l 271 425 l 609 425 z "},"ю":{"ha":1134,"x_min":107,"x_max":1074,"o":"m 513 422 l 513 320 l 123 320 l 123 422 l 513 422 m 233 734 l 233 0 l 107 0 l 107 734 l 233 734 m 406 359 l 406 374 q 429 522 406 454 q 496 641 452 590 q 601 719 540 691 q 739 747 663 747 q 879 719 817 747 q 984 641 941 691 q 1051 522 1028 590 q 1074 374 1074 454 l 1074 359 q 1051 212 1074 279 q 985 93 1028 144 q 880 15 941 43 q 741 -14 818 -14 q 602 15 663 -14 q 496 93 540 43 q 429 212 452 144 q 406 359 406 279 m 532 374 l 532 359 q 545 255 532 304 q 584 170 558 207 q 649 111 610 132 q 741 90 688 90 q 832 111 793 90 q 897 170 871 132 q 936 255 922 207 q 949 359 949 304 l 949 374 q 936 477 949 429 q 896 563 922 526 q 831 623 870 601 q 739 644 791 644 q 649 623 688 644 q 584 563 610 601 q 545 477 558 526 q 532 374 532 429 z "},"я":{"ha":762,"x_min":32,"x_max":656,"o":"m 244 350 l 380 350 l 168 0 l 32 0 l 244 350 m 349 734 l 656 734 l 656 0 l 530 0 l 530 632 l 349 632 q 262 614 296 632 q 212 568 228 596 q 197 509 197 539 q 211 451 197 479 q 256 406 225 424 q 334 389 286 389 l 564 389 l 564 286 l 334 286 q 222 302 271 286 q 140 350 174 319 q 88 421 106 380 q 71 510 71 462 q 89 599 71 558 q 143 670 108 640 q 231 717 179 701 q 349 734 283 734 z "},"ђ":{"ha":765,"x_min":-17,"x_max":673,"o":"m 547 308 l 673 308 l 673 -60 q 647 -189 673 -136 q 572 -269 621 -242 q 454 -296 523 -296 q 415 -294 433 -296 q 376 -285 397 -292 l 387 -184 q 420 -191 397 -189 q 454 -193 444 -193 q 504 -177 484 -193 q 536 -132 525 -161 q 547 -60 547 -102 l 547 308 m 221 1042 l 221 0 l 96 0 l 96 1042 l 221 1042 m 191 395 l 139 397 q 161 536 140 472 q 222 648 183 600 q 316 721 262 695 q 437 747 371 747 q 535 733 492 747 q 609 686 578 718 q 656 604 640 654 q 673 481 673 553 l 673 0 l 547 0 l 547 482 q 530 575 547 540 q 480 626 513 610 q 400 642 448 642 q 315 622 353 642 q 249 568 277 602 q 207 489 222 533 q 191 395 191 444 m 415 923 l 415 820 l -17 820 l -17 923 l 415 923 z "},"є":{"ha":747,"x_min":70,"x_max":688,"o":"m 471 418 l 471 315 l 96 315 l 96 418 l 471 418 m 397 90 q 479 108 441 90 q 542 158 517 126 q 570 232 566 191 l 688 232 q 645 111 685 167 q 539 21 604 55 q 397 -14 475 -14 q 252 16 314 -14 q 150 96 191 45 q 90 213 110 146 q 70 353 70 279 l 70 381 q 90 521 70 455 q 151 638 110 587 q 253 718 191 689 q 396 747 314 747 q 547 712 482 747 q 648 617 611 677 q 688 481 685 557 l 570 481 q 544 564 566 527 q 485 622 522 600 q 396 644 447 644 q 299 622 338 644 q 238 561 260 599 q 205 476 215 522 q 195 381 195 429 l 195 353 q 205 258 195 304 q 238 173 215 211 q 299 112 260 135 q 397 90 338 90 z "},"љ":{"ha":1178,"x_min":26,"x_max":1133,"o":"m 198 734 l 323 734 l 304 380 q 290 235 300 298 q 261 127 279 172 q 216 55 243 83 q 152 13 189 26 q 66 0 115 0 l 26 0 l 26 111 l 54 113 q 103 126 83 115 q 138 160 124 138 q 162 219 153 183 q 176 304 171 255 q 184 420 182 354 l 198 734 m 562 734 l 562 630 l 224 630 l 224 734 l 562 734 m 638 454 l 859 454 q 1009 425 948 454 q 1101 345 1070 396 q 1133 230 1133 294 q 1115 140 1133 182 q 1062 67 1097 98 q 977 18 1027 35 q 859 0 926 0 l 547 0 l 547 734 l 672 734 l 672 102 l 859 102 q 946 121 913 102 q 992 171 978 141 q 1006 231 1006 201 q 992 289 1006 261 q 946 334 978 317 q 859 352 913 352 l 638 352 l 638 454 z "},"њ":{"ha":1196,"x_min":106,"x_max":1156,"o":"m 593 456 l 593 355 l 205 355 l 205 456 l 593 456 m 232 734 l 232 0 l 106 0 l 106 734 l 232 734 m 661 454 l 882 454 q 1031 425 970 454 q 1124 345 1093 396 q 1156 230 1156 294 q 1138 140 1156 182 q 1085 67 1120 98 q 999 18 1050 35 q 882 0 948 0 l 569 0 l 569 734 l 695 734 l 695 102 l 882 102 q 968 121 936 102 q 1015 171 1000 141 q 1029 231 1029 201 q 1015 289 1029 261 q 968 334 1000 317 q 882 352 936 352 l 661 352 l 661 454 z "},"ћ":{"ha":787,"x_min":-2,"x_max":673,"o":"m 221 1042 l 221 0 l 96 0 l 96 1042 l 221 1042 m 191 395 l 139 397 q 161 536 140 472 q 222 648 183 600 q 316 721 262 695 q 437 747 371 747 q 535 733 492 747 q 609 686 578 718 q 656 604 640 654 q 673 481 673 553 l 673 0 l 547 0 l 547 482 q 530 575 547 540 q 480 626 513 610 q 400 642 448 642 q 315 622 353 642 q 249 568 277 602 q 207 489 222 533 q 191 395 191 444 m 430 926 l 430 823 l -2 823 l -2 926 l 430 926 z "},"џ":{"ha":802,"x_min":106,"x_max":696,"o":"m 340 103 l 466 103 l 466 -241 l 340 -241 l 340 103 m 106 734 l 232 734 l 232 103 l 570 103 l 570 734 l 696 734 l 696 0 l 106 0 l 106 734 z "},"Ѡ":{"ha":1221,"x_min":106,"x_max":1122,"o":"m 547 987 l 652 987 l 652 270 q 632 145 652 199 q 575 56 612 92 q 489 3 538 21 q 380 -14 439 -14 q 271 3 321 -14 q 184 56 221 21 q 126 145 147 92 q 106 270 106 199 l 106 987 l 237 987 l 237 270 q 248 192 237 225 q 278 136 258 159 q 323 103 297 114 q 380 92 349 92 q 466 112 429 92 q 525 171 504 132 q 547 270 547 210 l 547 987 m 991 987 l 1122 987 l 1122 270 q 1084 112 1122 175 q 983 17 1047 48 q 836 -14 918 -14 q 733 3 781 -14 q 650 56 685 21 q 595 145 615 92 q 576 270 576 199 l 576 987 l 682 987 l 682 270 q 693 192 682 225 q 725 136 705 159 q 774 103 746 114 q 836 92 803 92 q 916 112 881 92 q 971 171 951 132 q 991 270 991 210 l 991 987 z "},"ѡ":{"ha":1072,"x_min":87,"x_max":986,"o":"m 473 734 l 575 734 l 575 240 q 557 129 575 176 q 506 49 539 81 q 429 1 473 17 q 332 -14 385 -14 q 234 1 279 -14 q 157 49 190 17 q 106 129 124 81 q 87 240 87 176 l 87 734 l 214 734 l 214 240 q 222 174 214 202 q 247 126 231 145 q 284 98 263 108 q 332 89 306 89 q 404 105 372 89 q 455 156 436 122 q 473 240 473 189 l 473 734 m 861 734 l 986 734 l 986 240 q 953 98 986 155 q 862 14 920 42 q 730 -14 804 -14 q 638 1 680 -14 q 564 49 595 17 q 516 129 533 81 q 498 240 498 176 l 498 734 l 600 734 l 600 240 q 610 174 600 202 q 637 126 619 145 q 678 98 654 108 q 730 89 702 89 q 782 98 758 89 q 823 126 806 108 q 851 174 841 145 q 861 240 861 202 l 861 734 z "},"ѣ":{"ha":753,"x_min":-25,"x_max":692,"o":"m 197 506 l 418 506 q 568 473 507 506 q 661 385 629 441 q 692 256 692 328 q 661 126 692 184 q 568 34 629 68 q 418 0 507 0 l 106 0 l 106 1057 l 231 1057 l 231 103 l 418 103 q 505 124 472 103 q 551 180 537 146 q 566 251 566 214 q 551 322 566 287 q 505 380 537 357 q 418 404 472 404 l 197 404 l 197 506 m 450 837 l 450 734 l -25 734 l -25 837 l 450 837 z "},"Ѥ":{"ha":1245,"x_min":125,"x_max":1151,"o":"m 888 565 l 888 462 l 205 462 l 205 565 l 888 565 m 1020 315 l 1151 315 q 1097 147 1141 221 q 974 30 1053 73 q 776 -13 895 -13 q 618 20 689 -13 q 496 112 547 52 q 418 257 446 172 q 391 445 391 341 l 391 543 q 418 731 391 647 q 497 876 446 816 q 623 969 549 937 q 787 1002 696 1002 q 977 960 899 1002 q 1097 843 1054 918 q 1151 671 1141 769 l 1020 671 q 985 790 1010 741 q 911 867 959 840 q 787 895 864 895 q 672 869 722 895 q 589 798 623 844 q 538 688 555 752 q 522 545 522 623 l 522 445 q 531 334 522 387 q 561 237 541 281 q 611 161 581 193 q 682 111 641 129 q 776 94 724 94 q 909 120 859 94 q 984 196 958 146 q 1020 315 1009 245 m 256 987 l 256 0 l 125 0 l 125 987 l 256 987 z "},"ѥ":{"ha":1037,"x_min":104,"x_max":977,"o":"m 783 418 l 783 315 l 185 315 l 185 418 l 783 418 m 686 90 q 768 108 730 90 q 831 158 806 126 q 859 232 855 191 l 977 232 q 933 111 974 167 q 828 21 893 55 q 686 -14 764 -14 q 541 16 603 -14 q 439 96 479 45 q 379 213 399 146 q 359 353 359 279 l 359 381 q 379 521 359 455 q 439 638 399 587 q 542 718 480 689 q 686 747 603 747 q 836 712 772 747 q 937 617 900 677 q 977 481 974 557 l 859 481 q 833 564 855 527 q 773 622 811 600 q 686 644 736 644 q 589 622 627 644 q 527 561 550 599 q 495 476 505 522 q 485 381 485 429 l 485 353 q 494 258 485 304 q 527 173 504 211 q 588 112 549 135 q 686 90 627 90 m 230 734 l 230 0 l 104 0 l 104 734 l 230 734 z "},"Ѧ":{"ha":838,"x_min":27,"x_max":850,"o":"m 468 882 l 161 0 l 27 0 l 383 987 l 467 987 l 468 882 m 715 0 l 414 887 l 417 987 l 500 987 l 850 0 l 715 0 m 677 408 l 677 298 l 198 298 l 198 408 l 677 408 m 499 374 l 499 0 l 371 0 l 371 374 l 499 374 z "},"ѧ":{"ha":743,"x_min":10,"x_max":720,"o":"m 347 519 l 139 0 l 10 0 l 311 734 l 406 734 l 347 519 m 591 0 l 379 519 l 322 734 l 418 734 l 720 0 l 591 0 m 570 304 l 570 201 l 167 201 l 167 304 l 570 304 m 429 279 l 429 0 l 304 0 l 304 279 l 429 279 z "},"Ѩ":{"ha":1223,"x_min":137,"x_max":1208,"o":"m 583 408 l 583 299 l 212 299 l 212 408 l 583 408 m 827 882 l 520 0 l 386 0 l 742 987 l 825 987 l 827 882 m 1074 0 l 772 887 l 776 987 l 859 987 l 1208 0 l 1074 0 m 1036 408 l 1036 298 l 557 298 l 557 408 l 1036 408 m 858 374 l 858 0 l 730 0 l 730 374 l 858 374 m 268 987 l 268 0 l 137 0 l 137 987 l 268 987 z "},"ѩ":{"ha":1050,"x_min":128,"x_max":1023,"o":"m 504 304 l 504 201 l 186 201 l 186 304 l 504 304 m 650 519 l 442 0 l 313 0 l 614 734 l 709 734 l 650 519 m 895 0 l 682 519 l 625 734 l 722 734 l 1023 0 l 895 0 m 873 304 l 873 201 l 470 201 l 470 304 l 873 304 m 732 279 l 732 0 l 607 0 l 607 279 l 732 279 m 254 734 l 254 0 l 128 0 l 128 734 l 254 734 z "},"Ѫ":{"ha":1184,"x_min":100,"x_max":1085,"o":"m 231 0 l 100 0 l 100 251 q 139 426 100 360 q 252 521 178 492 q 429 550 326 550 l 755 550 q 933 521 859 550 q 1046 426 1006 492 q 1085 251 1085 360 l 1085 0 l 954 0 l 954 251 q 932 367 954 326 q 867 426 911 409 q 755 443 823 443 l 429 443 q 280 403 329 443 q 231 251 231 363 l 231 0 m 871 987 l 871 880 l 329 880 l 329 987 l 871 987 m 554 467 l 857 987 l 1005 987 l 657 414 l 574 414 l 554 467 m 338 987 l 643 462 l 620 414 l 538 414 l 189 987 l 338 987 m 660 530 l 660 0 l 530 0 l 530 530 l 660 530 z "},"ѫ":{"ha":1021,"x_min":102,"x_max":919,"o":"m 228 0 l 102 0 l 102 111 q 138 286 102 220 q 242 380 174 351 q 404 410 310 410 l 617 410 q 779 380 711 410 q 883 286 846 351 q 919 111 919 220 l 919 0 l 793 0 l 793 111 q 774 230 793 188 q 716 290 755 273 q 617 307 677 307 l 404 307 q 306 290 345 307 q 247 230 267 273 q 228 111 228 188 l 228 0 m 760 734 l 760 631 l 292 631 l 292 734 l 760 734 m 478 339 l 699 734 l 840 734 l 572 287 l 496 287 l 478 339 m 331 734 l 554 336 l 534 287 l 458 287 l 190 734 l 331 734 m 576 394 l 576 0 l 450 0 l 450 394 l 576 394 z "},"Ѭ":{"ha":1566,"x_min":124,"x_max":1466,"o":"m 857 551 l 857 448 l 238 448 l 238 551 l 857 551 m 255 987 l 255 0 l 124 0 l 124 987 l 255 987 m 612 0 l 481 0 l 481 251 q 521 426 481 360 q 634 521 560 492 q 810 550 707 550 l 1137 550 q 1315 521 1241 550 q 1427 426 1388 492 q 1466 251 1466 360 l 1466 0 l 1336 0 l 1336 251 q 1314 367 1336 326 q 1249 426 1293 409 q 1137 443 1204 443 l 810 443 q 662 403 711 443 q 612 251 612 363 l 612 0 m 1253 987 l 1253 880 l 711 880 l 711 987 l 1253 987 m 936 467 l 1238 987 l 1387 987 l 1038 414 l 956 414 l 936 467 m 720 987 l 1025 462 l 1002 414 l 920 414 l 571 987 l 720 987 m 1042 530 l 1042 0 l 911 0 l 911 530 l 1042 530 z "},"ѭ":{"ha":1357,"x_min":106,"x_max":1255,"o":"m 846 410 l 846 307 l 172 307 l 172 410 l 846 410 m 231 734 l 231 0 l 106 0 l 106 734 l 231 734 m 564 0 l 439 0 l 439 111 q 475 286 439 220 q 578 380 511 351 q 741 410 646 410 l 954 410 q 1115 380 1048 410 q 1219 286 1183 351 q 1255 111 1255 220 l 1255 0 l 1130 0 l 1130 111 q 1111 230 1130 188 q 1052 290 1091 273 q 954 307 1013 307 l 741 307 q 642 290 681 307 q 584 230 603 273 q 564 111 564 188 l 564 0 m 1096 734 l 1096 631 l 628 631 l 628 734 l 1096 734 m 814 339 l 1035 734 l 1176 734 l 908 287 l 832 287 l 814 339 m 667 734 l 890 336 l 871 287 l 795 287 l 526 734 l 667 734 m 912 394 l 912 0 l 787 0 l 787 394 l 912 394 z "},"Ѯ":{"ha":719,"x_min":54,"x_max":636,"o":"m 90 987 l 297 987 q 427 969 368 987 q 530 917 486 951 q 597 833 573 882 q 621 721 621 783 q 597 626 621 670 q 530 550 574 583 q 424 498 486 517 q 286 480 362 480 l 188 480 l 188 558 l 283 558 q 406 579 359 558 q 474 637 452 600 q 495 724 495 675 q 474 804 495 768 q 409 863 453 841 q 297 884 366 884 l 90 884 l 90 987 m 188 532 l 286 532 q 435 515 370 532 q 545 465 500 498 q 613 385 590 433 q 636 275 636 337 q 612 153 636 206 q 544 62 587 99 q 440 6 500 25 q 311 -13 381 -13 l 275 -13 q 197 -34 220 -13 q 174 -90 174 -56 q 193 -150 174 -125 q 237 -191 212 -175 q 283 -216 263 -206 l 233 -300 q 151 -252 191 -282 q 82 -180 110 -222 q 54 -83 55 -138 q 82 15 54 -24 q 160 71 109 53 q 280 90 210 90 l 311 90 q 395 103 357 90 q 458 141 432 117 q 497 200 484 166 q 511 273 511 233 q 496 353 511 319 q 452 410 481 387 q 381 445 423 433 q 283 456 338 456 l 188 456 l 188 532 m 267 1306 l 369 1191 l 471 1306 l 580 1306 l 580 1299 l 408 1114 l 330 1114 l 160 1299 l 160 1306 l 267 1306 z "},"ѯ":{"ha":669,"x_min":52,"x_max":602,"o":"m 87 734 l 292 734 q 409 720 355 734 q 503 678 463 705 q 565 612 543 651 q 587 524 587 573 q 565 452 587 485 q 503 393 543 418 q 406 354 463 368 q 281 340 350 340 l 182 340 l 182 418 l 278 418 q 384 432 343 418 q 442 470 424 446 q 460 527 460 494 q 450 567 460 549 q 419 600 440 586 q 367 622 399 614 q 292 630 335 630 l 87 630 l 87 734 m 182 392 l 281 392 q 417 380 357 392 q 518 344 477 368 q 580 286 559 320 q 602 206 602 251 q 579 114 602 155 q 517 45 557 73 q 423 2 477 16 q 305 -13 369 -13 l 272 -13 q 194 -34 217 -13 q 171 -90 171 -56 q 190 -150 171 -125 q 235 -191 209 -175 q 281 -216 260 -206 l 230 -300 q 148 -252 189 -282 q 80 -180 107 -222 q 52 -83 52 -138 q 79 15 52 -24 q 157 71 106 53 q 277 90 208 90 l 305 90 q 377 98 345 90 q 430 122 408 106 q 464 158 452 137 q 475 203 475 178 q 463 253 475 232 q 425 288 450 274 q 363 309 399 302 q 278 316 326 316 l 182 316 l 182 392 m 212 1075 l 314 960 l 416 1075 l 525 1075 l 525 1067 l 353 882 l 275 882 l 105 1068 l 105 1075 l 212 1075 z "},"Ѳ":{"ha":945,"x_min":70,"x_max":864,"o":"m 467 1001 q 600 980 538 1001 q 710 919 662 959 q 793 820 759 878 q 846 688 828 762 q 864 525 864 614 l 864 463 q 836 263 864 351 q 756 113 808 175 q 631 19 704 52 q 468 -14 558 -14 q 337 7 398 -14 q 227 69 276 28 q 142 167 178 109 q 89 299 107 225 q 70 463 70 374 l 70 525 q 99 724 70 636 q 180 874 127 812 q 306 968 233 936 q 467 1001 379 1001 m 467 890 q 366 870 412 890 q 285 812 319 850 q 229 716 251 773 q 201 586 208 660 q 200 563 201 575 q 199 539 199 551 l 734 539 q 734 562 734 551 q 732 585 734 574 q 706 716 726 659 q 651 811 686 772 q 571 870 617 850 q 467 890 524 890 m 468 97 q 573 117 526 97 q 653 176 620 137 q 707 274 687 216 q 732 407 727 332 q 733 421 733 414 q 734 436 734 429 l 200 436 q 201 415 201 425 q 203 395 202 405 q 231 267 210 323 q 288 174 253 212 q 368 116 322 136 q 468 97 414 97 z "},"ѳ":{"ha":789,"x_min":62,"x_max":730,"o":"m 395 747 q 535 719 473 747 q 640 641 597 691 q 707 522 684 590 q 730 374 730 454 l 730 359 q 707 212 730 279 q 640 93 684 144 q 535 15 597 43 q 397 -14 474 -14 q 258 15 319 -14 q 152 93 196 43 q 85 212 109 144 q 62 359 62 279 l 62 374 q 85 522 62 454 q 152 641 109 590 q 257 719 195 691 q 395 747 319 747 m 395 644 q 313 627 349 644 q 252 579 277 610 q 211 508 227 549 q 191 422 196 468 l 602 422 q 581 508 597 468 q 540 579 566 549 q 478 627 514 610 q 395 644 441 644 m 397 90 q 480 107 444 90 q 542 156 516 125 q 583 230 568 188 q 602 319 598 271 l 190 319 q 209 230 194 271 q 250 156 224 188 q 313 107 276 125 q 397 90 349 90 z "},"Ѵ":{"ha":876,"x_min":15,"x_max":844,"o":"m 439 254 l 614 802 q 663 917 636 873 q 727 980 690 960 q 813 1000 763 1000 l 844 1000 l 844 884 l 836 884 q 795 875 812 884 q 764 845 778 866 q 736 787 750 824 l 473 0 l 372 0 l 439 254 m 157 987 l 393 254 l 459 0 l 358 0 l 15 987 l 157 987 z "},"ѵ":{"ha":697,"x_min":32,"x_max":703,"o":"m 355 214 l 462 583 q 507 678 481 642 q 565 731 533 714 q 630 747 596 747 q 668 745 650 747 q 703 730 686 742 l 688 630 q 677 634 685 632 q 659 635 669 635 q 632 628 646 635 q 606 607 618 621 q 587 573 595 593 l 385 0 l 302 0 l 355 214 m 160 734 l 323 214 l 373 0 l 290 0 l 32 734 l 160 734 z "},"Ѻ":{"ha":945,"x_min":70,"x_max":864,"o":"m 536 1078 l 536 816 l 410 816 l 410 1078 l 536 1078 m 536 172 l 536 -96 l 410 -96 l 410 172 l 536 172 m 864 525 l 864 463 q 836 263 864 351 q 756 113 808 175 q 631 19 704 52 q 468 -14 558 -14 q 337 7 398 -14 q 227 69 276 28 q 142 167 178 109 q 89 299 107 225 q 70 463 70 374 l 70 525 q 99 724 70 636 q 180 874 127 812 q 306 968 233 936 q 467 1001 379 1001 q 600 980 538 1001 q 710 919 662 959 q 793 820 759 878 q 846 688 828 762 q 864 525 864 614 m 734 463 l 734 526 q 723 654 734 597 q 689 755 711 711 q 634 829 667 800 q 559 874 602 859 q 467 890 517 890 q 357 866 406 890 q 273 796 308 842 q 218 682 237 750 q 199 526 199 614 l 199 463 q 212 334 199 391 q 247 232 224 276 q 303 157 271 187 q 378 112 336 127 q 468 97 420 97 q 581 121 532 97 q 665 191 631 144 q 717 306 699 237 q 734 463 734 374 z "},"ѻ":{"ha":787,"x_min":62,"x_max":730,"o":"m 457 818 l 457 568 l 331 568 l 331 818 l 457 818 m 457 168 l 457 -81 l 331 -81 l 331 168 l 457 168 m 62 359 l 62 374 q 85 522 62 454 q 152 641 109 590 q 257 719 195 691 q 395 747 319 747 q 535 719 473 747 q 640 641 597 691 q 707 522 684 590 q 730 374 730 454 l 730 359 q 707 212 730 279 q 640 93 684 144 q 535 15 597 43 q 397 -14 474 -14 q 258 15 319 -14 q 152 93 196 43 q 85 212 109 144 q 62 359 62 279 m 188 374 l 188 359 q 201 255 188 304 q 240 170 214 207 q 305 111 266 132 q 397 90 345 90 q 487 111 448 90 q 552 170 526 132 q 591 255 578 207 q 604 359 604 304 l 604 374 q 591 477 604 429 q 552 563 578 526 q 487 623 526 601 q 395 644 448 644 q 305 623 344 644 q 240 563 266 601 q 201 477 214 526 q 188 374 188 429 z "},"Ѽ":{"ha":1216,"x_min":106,"x_max":1117,"o":"m 886 1185 l 913 1185 l 913 1099 l 885 1099 q 780 1112 826 1099 q 697 1142 734 1125 q 628 1171 660 1158 q 566 1184 596 1184 q 510 1166 531 1184 q 489 1111 489 1148 l 489 1099 l 402 1099 l 402 1123 q 445 1234 402 1198 q 563 1271 488 1271 q 640 1258 604 1271 q 712 1228 675 1245 q 790 1198 748 1211 q 886 1185 833 1185 m 589 898 l 537 935 q 571 986 559 962 q 583 1037 583 1010 l 583 1101 l 690 1101 l 690 1032 q 674 980 690 1006 q 634 932 658 954 q 589 898 610 910 m 380 987 l 380 880 q 307 858 339 880 q 256 792 275 836 q 237 680 237 747 l 237 293 q 248 204 237 242 q 278 142 258 167 q 323 104 297 117 q 380 92 349 92 q 466 112 429 92 q 525 171 504 132 q 547 270 547 210 l 547 560 l 652 560 l 652 270 q 632 145 652 199 q 575 56 612 92 q 489 3 538 21 q 380 -14 439 -14 q 271 5 321 -14 q 184 62 221 24 q 126 158 147 100 q 106 293 106 216 l 106 680 q 142 851 106 783 q 240 953 178 919 q 380 987 302 987 m 843 880 l 843 987 q 952 968 902 987 q 1039 910 1002 949 q 1097 814 1076 872 q 1117 680 1117 757 l 1117 293 q 1097 158 1117 216 q 1039 62 1076 100 q 952 5 1002 24 q 843 -14 902 -14 q 735 3 785 -14 q 649 56 686 21 q 592 145 612 92 q 572 270 572 199 l 572 560 l 677 560 l 677 270 q 690 192 677 225 q 724 136 702 159 q 777 103 747 114 q 843 92 807 92 q 900 104 874 92 q 946 142 926 117 q 976 204 965 167 q 987 293 987 242 l 987 680 q 976 768 987 730 q 946 831 965 806 q 900 868 926 856 q 843 880 874 880 z "},"ѽ":{"ha":1066,"x_min":85,"x_max":983,"o":"m 827 946 l 855 946 l 855 860 l 825 860 q 720 873 766 860 q 637 903 674 886 q 569 932 600 920 q 507 945 537 945 q 451 927 472 945 q 429 871 429 909 l 429 859 l 342 859 l 342 884 q 386 995 342 958 q 504 1031 429 1031 q 580 1019 545 1031 q 652 989 616 1006 q 731 959 688 972 q 827 946 773 946 m 528 652 l 477 690 q 512 741 500 717 q 524 791 524 766 l 524 856 l 630 856 l 630 787 q 614 734 630 761 q 574 686 597 708 q 528 652 551 665 m 330 741 l 330 638 q 269 619 296 638 q 227 561 242 600 q 212 462 212 522 l 212 265 q 220 187 212 220 q 245 132 229 154 q 282 100 261 111 q 330 89 304 89 q 386 98 360 89 q 431 126 412 108 q 461 174 450 145 q 472 240 472 202 l 472 399 l 573 399 l 573 240 q 555 129 573 176 q 504 49 537 81 q 427 1 471 17 q 330 -14 382 -14 q 232 3 277 -14 q 155 55 188 20 q 104 143 122 90 q 85 265 85 195 l 85 462 q 117 617 85 555 q 204 710 149 680 q 330 741 259 741 m 739 638 l 739 741 q 837 723 792 741 q 915 671 882 706 q 965 585 947 637 q 983 462 983 532 l 983 265 q 965 143 983 195 q 915 55 947 90 q 837 3 882 20 q 739 -14 792 -14 q 643 1 687 -14 q 565 49 598 17 q 514 129 532 81 q 496 240 496 176 l 496 399 l 597 399 l 597 240 q 608 174 597 202 q 638 126 619 145 q 683 98 657 108 q 739 89 709 89 q 787 100 765 89 q 824 132 808 111 q 849 187 840 154 q 858 265 858 220 l 858 462 q 849 540 858 507 q 824 595 840 573 q 787 627 808 616 q 739 638 765 638 z "},"Ѿ":{"ha":1221,"x_min":106,"x_max":1122,"o":"m 554 1145 l 342 1145 l 342 1218 l 892 1218 l 892 1145 l 668 1145 l 668 1060 l 554 1060 l 554 1145 m 547 987 l 652 987 l 652 270 q 632 145 652 199 q 575 56 612 92 q 489 3 538 21 q 380 -14 439 -14 q 271 3 321 -14 q 184 56 221 21 q 126 145 147 92 q 106 270 106 199 l 106 987 l 237 987 l 237 270 q 248 192 237 225 q 278 136 258 159 q 323 103 297 114 q 380 92 349 92 q 466 112 429 92 q 525 171 504 132 q 547 270 547 210 l 547 987 m 991 987 l 1122 987 l 1122 270 q 1084 112 1122 175 q 983 17 1047 48 q 836 -14 918 -14 q 733 3 781 -14 q 650 56 685 21 q 595 145 615 92 q 576 270 576 199 l 576 987 l 682 987 l 682 270 q 693 192 682 225 q 725 136 705 159 q 774 103 746 114 q 836 92 803 92 q 916 112 881 92 q 971 171 951 132 q 991 270 991 210 l 991 987 z "},"ѿ":{"ha":1072,"x_min":87,"x_max":986,"o":"m 478 915 l 266 915 l 266 988 l 816 988 l 818 915 l 592 915 l 592 829 l 478 829 l 478 915 m 473 734 l 575 734 l 575 240 q 557 129 575 176 q 506 49 539 81 q 429 1 473 17 q 332 -14 385 -14 q 234 1 279 -14 q 157 49 190 17 q 106 129 124 81 q 87 240 87 176 l 87 734 l 214 734 l 214 240 q 222 174 214 202 q 247 126 231 145 q 284 98 263 108 q 332 89 306 89 q 404 105 372 89 q 455 156 436 122 q 473 240 473 189 l 473 734 m 861 734 l 986 734 l 986 240 q 953 98 986 155 q 862 14 920 42 q 730 -14 804 -14 q 638 1 680 -14 q 564 49 595 17 q 516 129 533 81 q 498 240 498 176 l 498 734 l 600 734 l 600 240 q 610 174 600 202 q 637 126 619 145 q 678 98 654 108 q 730 89 702 89 q 782 98 758 89 q 823 126 806 108 q 851 174 841 145 q 861 240 861 202 l 861 734 z "},"Ҁ":{"ha":902,"x_min":80,"x_max":822,"o":"m 457 92 l 457 -14 q 332 6 390 -14 q 228 64 274 26 q 148 155 181 102 q 98 271 115 207 q 80 409 80 336 l 80 578 q 107 747 80 670 q 185 881 134 824 q 305 970 235 939 q 458 1002 374 1002 q 651 962 570 1002 q 777 847 732 922 q 822 671 821 773 l 692 671 q 664 790 691 741 q 585 867 637 840 q 458 895 534 895 q 355 870 401 895 q 277 803 309 846 q 228 703 245 760 q 211 580 211 646 l 211 409 q 222 309 211 356 q 253 221 233 261 q 304 153 274 182 q 372 108 334 124 q 457 92 411 92 m 535 92 l 535 -258 l 405 -258 l 405 92 l 535 92 z "},"ҁ":{"ha":743,"x_min":68,"x_max":673,"o":"m 389 89 l 389 -14 q 252 15 312 -14 q 152 95 193 44 q 89 213 111 146 q 68 353 68 279 l 68 381 q 89 521 68 455 q 152 638 111 587 q 252 718 193 689 q 389 747 312 747 q 535 712 471 747 q 636 617 600 677 q 673 481 673 557 l 555 481 q 533 564 555 527 q 473 623 511 601 q 389 644 435 644 q 300 622 337 644 q 240 561 263 599 q 205 476 216 522 q 194 381 194 429 l 194 353 q 205 257 194 304 q 239 172 216 210 q 300 112 262 134 q 389 89 337 89 m 458 89 l 458 -259 l 332 -259 l 332 89 l 458 89 z "},"҂":{"ha":867,"x_min":79,"x_max":793,"o":"m 548 550 l 408 303 l 604 186 l 557 102 l 359 218 l 236 0 l 122 0 l 275 270 l 79 386 l 125 469 l 323 353 l 463 601 l 266 717 l 313 802 l 511 686 l 638 910 l 750 910 l 594 634 l 793 518 l 743 435 l 548 550 z "},"҃":{"ha":0,"x_min":-625,"x_max":-147,"o":"m -147 892 l -513 892 l -513 807 l -625 808 l -625 966 l -258 966 l -259 1039 l -147 1038 l -147 892 z "},"҄":{"ha":0,"x_min":-618,"x_max":-106,"o":"m -618 970 l -590 970 q -494 983 -536 970 q -415 1013 -452 996 q -343 1043 -379 1030 q -267 1056 -308 1056 q -149 1019 -192 1056 q -106 908 -106 983 l -106 884 l -193 884 l -193 896 q -214 951 -193 934 q -270 969 -235 969 q -332 956 -300 969 q -400 927 -363 943 q -484 897 -437 910 q -589 884 -530 884 l -618 884 l -618 970 z "},"҅":{"ha":0,"x_min":-452,"x_max":-290,"o":"m -343 884 l -452 1017 l -452 1101 l -330 1101 l -331 1006 l -290 928 l -343 884 z "},"҆":{"ha":0,"x_min":-410,"x_max":-248,"o":"m -248 1017 l -358 884 l -410 928 l -370 1006 l -371 1101 l -248 1101 l -248 1017 z "},"҈":{"ha":0,"x_min":-1024,"x_max":297,"o":"m -439 859 l -516 859 q -478 951 -516 916 q -374 987 -439 987 q -269 951 -307 987 q -231 859 -231 916 l -307 859 q -322 907 -307 886 q -374 928 -337 928 q -425 907 -410 928 q -439 859 -439 886 m -38 671 l -115 671 q -77 763 -115 728 q 27 799 -39 799 q 132 763 94 799 q 171 671 171 728 l 94 671 q 79 719 94 699 q 27 740 64 740 q -23 719 -8 740 q -38 671 -38 699 m 88 330 l 12 330 q 50 422 12 387 q 154 458 88 458 q 259 422 220 458 q 297 330 297 387 l 221 330 q 206 378 221 357 q 154 399 191 399 q 103 378 119 399 q 88 330 88 357 m -45 -22 l -122 -22 q -84 70 -122 35 q 20 106 -45 106 q 125 70 87 106 q 163 -22 163 35 l 87 -22 q 73 26 87 5 q 20 47 58 47 q -30 26 -15 47 q -45 -22 -45 5 m -436 -214 l -513 -214 q -474 -122 -513 -158 q -370 -87 -436 -87 q -266 -122 -304 -87 q -227 -214 -227 -158 l -303 -214 q -318 -166 -303 -187 q -370 -146 -334 -146 q -421 -166 -406 -146 q -436 -214 -436 -187 m -827 671 l -905 671 q -866 763 -905 728 q -762 799 -827 799 q -657 763 -695 799 q -618 671 -618 728 l -694 671 q -710 719 -694 699 q -762 740 -725 740 q -812 719 -798 740 q -827 671 -827 699 m -947 330 l -1024 330 q -986 422 -1024 387 q -882 458 -947 458 q -777 422 -815 458 q -739 330 -739 387 l -814 330 q -829 378 -814 357 q -882 399 -844 399 q -932 378 -917 399 q -947 330 -947 357 m -834 -22 l -911 -22 q -873 70 -911 35 q -769 106 -835 106 q -664 70 -703 106 q -625 -22 -625 35 l -702 -22 q -717 26 -702 5 q -769 47 -732 47 q -819 26 -804 47 q -834 -22 -834 5 z "},"҉":{"ha":0,"x_min":-1013,"x_max":246,"o":"m -409 -41 l -316 -41 l -309 -50 l -391 -280 l -456 -280 l -409 -41 m -356 764 l -448 764 l -456 773 l -374 1002 l -309 1002 l -356 764 m 12 334 l 12 428 l 20 436 l 246 352 l 246 286 l 12 334 m -778 388 l -778 294 l -787 286 l -1013 370 l -1013 436 l -778 388 m -85 612 l -151 680 l -150 690 l 68 794 l 114 748 l -85 612 m -681 81 l -615 14 l -616 3 l -833 -101 l -880 -54 l -681 81 m -644 650 l -710 583 l -722 585 l -822 806 l -778 852 l -644 650 m -123 42 l -58 109 l -46 108 l 55 -113 l 10 -161 l -123 42 z "},"Ҋ":{"ha":1048,"x_min":121,"x_max":990,"o":"m 251 227 l 737 987 l 868 987 l 868 0 l 737 0 l 737 762 l 251 0 l 121 0 l 121 987 l 251 987 l 251 227 m 599 1232 l 701 1232 q 676 1138 701 1179 q 606 1074 652 1097 q 498 1051 561 1051 q 350 1102 404 1051 q 295 1232 295 1152 l 397 1232 q 420 1162 397 1192 q 498 1131 443 1131 q 576 1162 553 1131 q 599 1232 599 1192 m 990 103 l 990 2 q 959 -129 990 -60 q 871 -243 928 -197 l 800 -194 q 837 -133 822 -164 q 860 -70 852 -102 q 867 0 867 -37 l 867 103 l 990 103 z "},"ҋ":{"ha":855,"x_min":106,"x_max":819,"o":"m 231 199 l 570 734 l 696 734 l 696 0 l 570 0 l 570 535 l 231 0 l 106 0 l 106 734 l 231 734 l 231 199 m 501 1000 l 603 1000 q 578 906 603 947 q 509 842 554 865 q 401 819 463 819 q 252 869 307 819 q 197 1000 197 920 l 299 1000 q 322 929 299 960 q 401 899 345 899 q 478 929 455 899 q 501 1000 501 960 m 819 103 l 819 2 q 787 -129 819 -60 q 700 -243 756 -197 l 629 -194 q 665 -133 650 -164 q 688 -70 680 -102 q 696 0 696 -37 l 696 103 l 819 103 z "},"ҍ":{"ha":753,"x_min":-25,"x_max":692,"o":"m 197 506 l 418 506 q 568 473 507 506 q 661 385 629 441 q 692 256 692 328 q 661 126 692 184 q 568 34 629 68 q 418 0 507 0 l 106 0 l 106 1119 l 231 1119 l 231 103 l 418 103 q 505 124 472 103 q 551 180 537 146 q 566 251 566 214 q 551 322 566 287 q 505 380 537 357 q 418 404 472 404 l 197 404 l 197 506 m 450 987 l 450 884 l -25 884 l -25 987 l 450 987 z "},"Ҏ":{"ha":886,"x_min":115,"x_max":841,"o":"m 591 665 l 841 390 l 766 321 l 517 595 l 591 665 m 479 387 l 215 387 l 215 494 l 479 494 q 603 518 555 494 q 672 586 650 543 q 694 685 694 629 q 672 781 694 736 q 603 853 650 825 q 479 880 555 880 l 245 880 l 245 0 l 115 0 l 115 987 l 479 987 q 668 949 591 987 q 785 842 745 910 q 825 686 825 774 q 785 524 825 591 q 668 422 745 457 q 479 387 591 387 z "},"ҏ":{"ha":788,"x_min":95,"x_max":718,"o":"m 494 264 l 718 10 l 644 -60 l 420 194 l 494 264 m 221 593 l 221 -282 l 95 -282 l 95 734 l 210 734 l 221 593 m 715 373 l 715 359 q 696 211 715 279 q 641 92 677 142 q 552 14 605 42 q 431 -14 499 -14 q 307 9 361 -14 q 216 77 254 33 q 157 182 179 121 q 127 321 135 244 l 127 397 q 157 543 135 479 q 217 653 180 608 q 307 723 254 699 q 429 747 359 747 q 551 721 498 747 q 642 644 605 694 q 697 526 678 595 q 715 373 715 457 m 589 359 l 589 373 q 578 476 589 428 q 542 562 566 525 q 481 620 518 599 q 392 642 444 642 q 310 625 345 642 q 250 582 275 609 q 211 519 226 554 q 188 447 195 484 l 188 271 q 214 203 198 235 q 254 145 230 170 q 312 104 278 119 q 393 90 347 90 q 481 111 444 90 q 542 170 518 132 q 578 255 566 207 q 589 359 589 304 z "},"Ґ":{"ha":762,"x_min":110,"x_max":719,"o":"m 719 1215 l 719 884 l 593 884 l 593 1215 l 719 1215 m 717 987 l 717 880 l 241 880 l 241 0 l 110 0 l 110 987 l 717 987 z "},"ґ":{"ha":619,"x_min":99,"x_max":566,"o":"m 566 949 l 566 630 l 440 630 l 440 949 l 566 949 m 564 734 l 564 630 l 224 630 l 224 0 l 99 0 l 99 734 l 564 734 z "},"Ҕ":{"ha":843,"x_min":121,"x_max":779,"o":"m 727 987 l 727 880 l 251 880 l 251 0 l 121 0 l 121 987 l 727 987 m 229 456 l 229 565 l 374 565 q 544 538 469 565 q 672 461 619 512 q 751 338 724 411 q 779 174 779 266 q 758 17 779 85 q 697 -100 738 -52 q 597 -172 657 -147 q 458 -197 537 -197 l 456 -97 q 549 -78 511 -97 q 610 -23 587 -58 q 643 63 633 13 q 653 174 653 113 q 635 295 652 242 q 583 383 617 347 q 496 437 548 419 q 374 456 444 456 l 229 456 z "},"ҕ":{"ha":699,"x_min":99,"x_max":650,"o":"m 124 328 l 124 438 l 303 438 q 482 400 404 438 q 605 290 560 361 q 650 115 650 218 q 636 31 650 78 q 591 -63 622 -17 q 511 -144 561 -109 q 389 -193 462 -179 l 356 -94 q 457 -46 420 -77 q 509 26 494 -16 q 524 115 525 68 q 496 232 524 184 q 418 304 467 279 q 303 328 368 328 l 124 328 m 564 734 l 564 630 l 224 630 l 224 0 l 99 0 l 99 734 l 564 734 z "},"Җ":{"ha":1325,"x_min":18,"x_max":1303,"o":"m 397 451 l 45 987 l 198 987 l 460 559 l 646 559 l 625 451 l 397 451 m 468 461 l 181 0 l 18 0 l 385 574 l 468 461 m 703 987 l 703 0 l 573 0 l 573 987 l 703 987 m 1226 987 l 872 451 l 651 451 l 631 559 l 810 559 l 1072 987 l 1226 987 m 1089 0 l 803 461 l 886 574 l 1252 0 l 1089 0 m 1303 104 l 1303 -243 l 1178 -243 l 1178 104 l 1303 104 z "},"җ":{"ha":1107,"x_min":15,"x_max":1083,"o":"m 318 319 l 40 734 l 191 734 l 381 430 l 528 430 l 509 319 l 318 319 m 387 332 l 174 0 l 15 0 l 307 423 l 387 332 m 592 734 l 592 0 l 467 0 l 467 734 l 592 734 m 1020 734 l 742 319 l 551 319 l 531 430 l 678 430 l 868 734 l 1020 734 m 886 0 l 672 332 l 753 423 l 1044 0 l 886 0 m 1083 104 l 1083 -243 l 958 -243 l 958 104 l 1083 104 z "},"Қ":{"ha":972,"x_min":121,"x_max":914,"o":"m 252 987 l 252 0 l 121 0 l 121 987 l 252 987 m 860 987 l 431 444 l 199 444 l 179 553 l 353 553 l 698 987 l 860 987 m 728 0 l 357 461 l 431 576 l 888 0 l 728 0 m 914 102 l 914 -245 l 789 -245 l 789 102 l 914 102 z "},"қ":{"ha":819,"x_min":106,"x_max":782,"o":"m 232 734 l 232 0 l 106 0 l 106 734 l 232 734 m 713 734 l 366 313 l 190 313 l 171 423 l 315 423 l 561 734 l 713 734 m 578 0 l 309 332 l 389 423 l 738 0 l 578 0 m 782 104 l 782 -243 l 656 -243 l 656 104 l 782 104 z "},"Ҝ":{"ha":875,"x_min":111,"x_max":867,"o":"m 111 987 l 241 987 l 241 0 l 111 0 l 111 987 m 312 727 l 413 727 l 413 279 l 312 279 l 312 727 m 684 987 l 838 987 l 522 444 l 189 444 l 170 553 l 465 553 l 684 987 m 458 461 l 535 574 l 867 0 l 704 0 l 458 461 z "},"ҝ":{"ha":780,"x_min":105,"x_max":781,"o":"m 105 734 l 231 734 l 231 0 l 105 0 l 105 734 m 299 568 l 400 568 l 400 181 l 299 181 l 299 568 m 604 734 l 756 734 l 479 313 l 189 313 l 170 423 l 429 423 l 604 734 m 422 332 l 503 423 l 781 0 l 622 0 l 422 332 z "},"Ҡ":{"ha":1137,"x_min":47,"x_max":1136,"o":"m 408 987 l 408 884 l 47 884 l 47 987 l 408 987 m 499 987 l 499 0 l 369 0 l 369 987 l 499 987 m 1108 987 l 679 444 l 447 444 l 427 553 l 601 553 l 945 987 l 1108 987 m 976 0 l 605 461 l 678 576 l 1136 0 l 976 0 z "},"ҡ":{"ha":958,"x_min":43,"x_max":953,"o":"m 387 734 l 387 631 l 43 631 l 43 734 l 387 734 m 448 734 l 448 0 l 321 0 l 321 734 l 448 734 m 928 734 l 581 313 l 405 313 l 386 423 l 530 423 l 776 734 l 928 734 m 793 0 l 524 332 l 604 423 l 953 0 l 793 0 z "},"Ң":{"ha":1041,"x_min":115,"x_max":983,"o":"m 760 563 l 760 456 l 225 456 l 225 563 l 760 563 m 245 987 l 245 0 l 115 0 l 115 987 l 245 987 m 873 987 l 873 0 l 743 0 l 743 987 l 873 987 m 983 104 l 983 -243 l 857 -243 l 857 104 l 983 104 z "},"ң":{"ha":842,"x_min":106,"x_max":804,"o":"m 593 416 l 593 314 l 205 314 l 205 416 l 593 416 m 232 734 l 232 0 l 106 0 l 106 734 l 232 734 m 695 734 l 695 0 l 569 0 l 569 734 l 695 734 m 804 104 l 804 -243 l 679 -243 l 679 104 l 804 104 z "},"Ҥ":{"ha":1356,"x_min":115,"x_max":1305,"o":"m 1305 987 l 1305 884 l 864 884 l 784 987 l 1305 987 m 759 563 l 759 456 l 225 456 l 225 563 l 759 563 m 245 987 l 245 0 l 115 0 l 115 987 l 245 987 m 873 987 l 873 0 l 743 0 l 743 987 l 873 987 z "},"ҥ":{"ha":990,"x_min":99,"x_max":940,"o":"m 940 734 l 940 630 l 624 630 l 624 734 l 940 734 m 587 416 l 587 314 l 198 314 l 198 416 l 587 416 m 224 734 l 224 0 l 99 0 l 99 734 l 224 734 m 688 734 l 688 0 l 562 0 l 562 734 l 688 734 z "},"Ҧ":{"ha":1422,"x_min":119,"x_max":1354,"o":"m 867 987 l 867 0 l 737 0 l 737 880 l 250 880 l 250 0 l 119 0 l 119 987 l 867 987 m 804 456 l 804 565 l 949 565 q 1120 538 1045 565 q 1247 461 1195 512 q 1327 338 1300 411 q 1354 174 1354 266 q 1334 17 1354 85 q 1273 -100 1314 -52 q 1173 -172 1233 -147 q 1034 -197 1113 -197 l 1032 -97 q 1125 -78 1087 -97 q 1185 -23 1162 -58 q 1219 63 1208 13 q 1229 174 1229 113 q 1211 295 1228 242 q 1158 383 1193 347 q 1072 437 1124 419 q 949 456 1019 456 l 804 456 z "},"ҧ":{"ha":1207,"x_min":99,"x_max":1161,"o":"m 616 328 l 616 438 l 802 438 q 987 400 906 438 q 1115 290 1068 361 q 1161 115 1161 218 q 1147 31 1161 78 q 1103 -63 1133 -17 q 1022 -144 1072 -109 q 901 -193 972 -179 l 867 -94 q 968 -46 931 -77 q 1020 26 1004 -16 q 1036 115 1036 68 q 1005 232 1036 184 q 923 304 975 279 q 802 328 870 328 l 616 328 m 577 734 l 577 630 l 206 630 l 206 734 l 577 734 m 224 734 l 224 0 l 99 0 l 99 734 l 224 734 m 688 734 l 688 0 l 562 0 l 562 734 l 688 734 z "},"Ҩ":{"ha":1030,"x_min":77,"x_max":979,"o":"m 979 90 l 979 -19 q 748 17 852 -19 q 568 119 644 53 q 453 275 493 184 q 412 474 412 366 l 412 628 q 432 775 412 707 q 489 893 452 842 q 577 971 526 943 q 690 1000 628 1000 q 805 972 753 1000 q 893 895 856 945 q 950 776 930 844 q 970 625 970 707 l 970 460 q 937 273 970 359 q 840 122 903 186 q 691 22 778 58 q 498 -14 604 -14 q 325 22 403 -14 q 192 122 248 58 q 106 272 136 186 q 77 458 77 358 l 77 574 q 99 743 77 665 q 163 879 121 821 q 261 969 204 937 q 389 1002 319 1002 l 389 890 q 313 867 347 890 q 257 800 280 843 q 221 700 233 758 q 209 576 209 643 l 209 458 q 229 315 209 380 q 287 200 249 249 q 377 124 324 151 q 498 96 431 96 q 643 124 579 96 q 750 201 706 152 q 817 317 793 251 q 840 460 840 383 l 840 629 q 829 734 840 687 q 800 817 819 782 q 753 870 781 852 q 690 889 726 889 q 628 870 656 889 q 582 815 601 850 q 553 733 563 780 q 543 630 543 686 l 543 473 q 571 317 543 387 q 655 196 600 246 q 792 118 711 145 q 979 90 873 90 z "},"ҩ":{"ha":838,"x_min":75,"x_max":801,"o":"m 801 98 l 801 -8 q 609 22 694 -8 q 463 106 523 52 q 370 232 402 160 q 338 389 338 304 l 338 458 q 353 575 338 522 q 395 667 368 628 q 463 727 423 706 q 553 749 503 749 q 642 726 602 749 q 710 661 682 703 q 753 564 739 620 q 768 444 768 509 l 768 373 q 743 220 768 291 q 669 97 717 150 q 555 15 621 44 q 408 -14 489 -14 q 272 16 334 -14 q 167 101 211 47 q 99 229 123 156 q 75 387 75 302 l 75 425 q 92 553 75 494 q 141 655 109 612 q 216 723 172 699 q 313 747 260 747 l 313 641 q 267 625 288 641 q 231 580 246 609 q 208 512 216 551 q 200 427 200 473 l 200 387 q 214 271 200 324 q 256 177 229 217 q 321 115 283 137 q 408 93 359 93 q 506 114 463 93 q 580 174 549 136 q 626 262 610 212 q 642 373 642 313 l 642 446 q 636 523 642 487 q 619 585 631 558 q 591 627 608 612 q 553 642 574 642 q 514 629 531 642 q 486 591 497 616 q 469 533 475 567 q 463 460 463 500 l 463 387 q 486 270 463 323 q 552 179 509 217 q 658 119 595 140 q 801 98 721 98 z "},"Ҳ":{"ha":884,"x_min":39,"x_max":863,"o":"m 199 987 l 437 609 l 674 987 l 827 987 l 515 498 l 834 0 l 680 0 l 437 386 l 193 0 l 39 0 l 359 498 l 47 987 l 199 987 m 863 104 l 863 -243 l 737 -243 l 737 104 l 863 104 z "},"ҳ":{"ha":723,"x_min":28,"x_max":699,"o":"m 180 734 l 341 467 l 504 734 l 651 734 l 411 372 l 659 0 l 513 0 l 344 275 l 174 0 l 28 0 l 275 372 l 36 734 l 180 734 m 699 104 l 699 -243 l 573 -243 l 573 104 l 699 104 z "},"Ҵ":{"ha":1246,"x_min":35,"x_max":1142,"o":"m 682 987 l 682 884 l 35 884 l 35 987 l 682 987 m 1142 110 l 1130 -238 l 1013 -238 l 1013 0 l 916 0 l 916 110 l 1142 110 m 290 0 l 290 987 l 421 987 l 421 106 l 908 106 l 908 987 l 1038 987 l 1038 0 l 290 0 z "},"ҵ":{"ha":931,"x_min":21,"x_max":884,"o":"m 501 734 l 501 631 l 21 631 l 21 734 l 501 734 m 207 0 l 207 734 l 333 734 l 333 103 l 671 103 l 671 734 l 796 734 l 796 0 l 207 0 m 884 103 l 871 -218 l 759 -218 l 759 0 l 663 0 l 663 103 l 884 103 z "},"Ҷ":{"ha":996,"x_min":102,"x_max":938,"o":"m 102 987 l 233 987 l 233 679 q 256 559 233 602 q 323 498 278 515 q 437 480 369 480 q 516 484 477 480 q 591 493 554 487 q 663 508 627 499 q 733 527 699 517 l 733 420 q 667 401 700 410 q 599 386 634 392 q 525 376 564 380 q 437 373 485 373 q 257 403 332 373 q 142 500 182 433 q 102 679 102 568 l 102 987 m 700 987 l 831 987 l 831 0 l 700 0 l 700 987 m 938 104 l 938 -243 l 812 -243 l 812 104 l 938 104 z "},"ҷ":{"ha":796,"x_min":71,"x_max":759,"o":"m 649 734 l 649 0 l 524 0 l 524 734 l 649 734 m 606 397 l 606 294 q 529 268 568 279 q 447 251 490 257 q 354 244 404 244 q 203 274 267 244 q 105 366 140 304 q 71 521 71 427 l 71 735 l 196 735 l 196 521 q 214 422 196 460 q 268 366 233 384 q 354 348 303 348 q 446 354 403 348 q 529 372 489 361 q 606 397 568 382 m 759 104 l 759 -243 l 633 -243 l 633 104 l 759 104 z "},"Ҹ":{"ha":944,"x_min":102,"x_max":831,"o":"m 536 691 l 536 216 l 435 216 l 435 691 l 536 691 m 102 987 l 233 987 l 233 679 q 256 559 233 602 q 323 498 278 515 q 437 480 369 480 q 516 484 477 480 q 591 493 554 487 q 663 508 627 499 q 733 527 699 517 l 733 420 q 667 401 700 410 q 599 386 634 392 q 525 376 564 380 q 437 373 485 373 q 257 403 332 373 q 142 500 182 433 q 102 679 102 568 l 102 987 m 700 987 l 831 987 l 831 0 l 700 0 l 700 987 z "},"ҹ":{"ha":767,"x_min":90,"x_max":668,"o":"m 438 539 l 438 155 l 337 155 l 337 539 l 438 539 m 668 734 l 668 0 l 543 0 l 543 734 l 668 734 m 625 397 l 625 294 q 548 268 587 279 q 466 251 509 257 q 373 244 423 244 q 222 274 286 244 q 124 366 159 304 q 90 521 90 427 l 90 735 l 215 735 l 215 521 q 233 422 215 460 q 287 366 252 384 q 373 348 322 348 q 465 354 422 348 q 548 372 508 361 q 625 397 587 382 z "},"Һ":{"ha":944,"x_min":93,"x_max":821,"o":"m 821 0 l 690 0 l 690 309 q 668 429 690 386 q 601 490 646 472 q 487 507 555 507 q 408 504 446 507 q 333 494 370 500 q 261 479 296 488 q 191 460 225 471 l 191 568 q 257 587 224 578 q 325 602 290 595 q 399 611 359 608 q 487 614 439 614 q 667 584 592 614 q 781 487 741 554 q 821 309 821 420 l 821 0 m 224 0 l 93 0 l 93 987 l 224 987 l 224 0 z "},"Ҽ":{"ha":1074,"x_min":43,"x_max":997,"o":"m 43 733 l 146 733 q 163 647 146 684 q 218 589 181 610 q 314 568 256 568 l 314 473 q 164 505 225 473 q 73 596 104 537 q 43 733 43 654 m 679 -16 q 500 16 578 -16 q 368 104 422 47 q 287 238 315 161 q 260 409 260 316 l 260 578 q 288 748 260 671 q 367 883 317 826 q 485 970 418 939 q 629 1000 551 1001 q 788 969 720 1000 q 904 878 857 937 q 974 736 950 819 q 997 549 997 652 l 997 473 l 339 473 l 339 567 l 866 567 l 866 589 q 853 707 866 652 q 813 804 841 762 q 740 868 785 845 q 629 892 694 892 q 527 867 572 892 q 452 800 483 843 q 406 700 422 756 q 390 578 390 643 l 390 409 q 406 286 390 343 q 457 185 422 229 q 547 117 492 142 q 679 92 602 92 q 819 111 763 92 q 913 149 876 130 l 945 52 q 895 25 929 41 q 808 -3 861 9 q 679 -16 754 -16 z "},"ҽ":{"ha":823,"x_min":-24,"x_max":762,"o":"m -24 581 l 77 581 q 111 475 77 515 q 218 435 144 435 l 218 343 q 85 372 139 343 q 4 454 31 401 q -24 581 -24 508 m 476 -14 q 337 13 399 -14 q 231 86 275 39 q 163 199 186 134 q 139 341 139 264 l 139 370 q 165 529 139 459 q 237 648 192 600 q 340 722 283 697 q 460 747 398 747 q 596 720 539 747 q 690 645 653 693 q 745 531 727 596 q 762 388 762 465 l 762 332 l 214 332 l 214 434 l 636 434 l 636 444 q 624 516 634 480 q 594 581 614 551 q 541 627 574 610 q 460 644 508 644 q 381 626 417 644 q 319 573 345 608 q 279 487 294 538 q 265 370 265 436 l 265 341 q 280 243 265 289 q 322 163 294 197 q 391 109 351 128 q 483 89 431 89 q 595 116 549 89 q 676 189 642 143 l 753 128 q 692 60 729 92 q 602 7 655 27 q 476 -14 549 -14 z "},"Ӄ":{"ha":875,"x_min":111,"x_max":833,"o":"m 241 987 l 241 0 l 111 0 l 111 987 l 241 987 m 833 987 l 389 448 l 189 448 l 170 564 l 332 564 l 680 987 l 833 987 m 277 448 l 277 562 l 426 562 q 596 535 521 562 q 724 459 671 509 q 803 335 776 408 q 831 170 831 262 q 810 15 831 83 q 749 -103 790 -54 q 648 -177 709 -151 q 507 -202 587 -202 l 505 -99 q 597 -79 560 -99 q 658 -24 635 -60 q 691 61 681 12 q 701 169 701 110 q 683 289 700 237 q 631 377 665 341 q 545 430 596 412 q 426 448 494 448 l 277 448 z "},"ӄ":{"ha":755,"x_min":105,"x_max":712,"o":"m 231 734 l 231 0 l 105 0 l 105 734 l 231 734 m 712 734 l 345 313 l 189 313 l 170 423 l 293 423 l 559 734 l 712 734 m 159 313 l 159 422 l 347 422 q 532 389 451 422 q 660 289 613 356 q 706 119 706 221 q 691 38 705 83 q 647 -52 677 -7 q 567 -129 617 -96 q 446 -176 517 -163 l 412 -77 q 513 -32 476 -61 q 565 35 549 -3 q 581 119 581 74 q 550 231 581 189 q 468 294 520 274 q 347 313 416 313 l 159 313 z "},"Ӆ":{"ha":1040,"x_min":33,"x_max":983,"o":"m 749 987 l 749 880 l 298 880 l 298 987 l 749 987 m 862 987 l 862 0 l 731 0 l 731 987 l 862 987 m 253 987 l 383 987 l 361 504 q 345 318 356 399 q 313 176 334 236 q 260 77 293 116 q 181 19 228 38 q 68 0 134 0 l 33 0 l 33 106 l 60 109 q 125 126 98 111 q 172 170 153 140 q 203 248 191 200 q 223 364 216 295 q 234 525 230 433 l 253 987 m 983 103 l 983 2 q 951 -129 983 -60 q 864 -243 920 -197 l 793 -194 q 829 -133 814 -164 q 852 -70 844 -102 q 860 0 860 -37 l 860 103 l 983 103 z "},"ӆ":{"ha":857,"x_min":30,"x_max":819,"o":"m 586 734 l 586 630 l 231 630 l 231 734 l 586 734 m 696 734 l 696 0 l 571 0 l 571 734 l 696 734 m 201 734 l 327 734 l 308 380 q 293 235 303 298 q 264 127 282 172 q 219 55 246 83 q 155 13 193 26 q 69 0 118 0 l 30 0 l 30 111 l 57 113 q 107 126 86 115 q 142 160 127 138 q 165 219 156 183 q 179 304 174 255 q 187 420 184 354 l 201 734 m 819 103 l 819 2 q 788 -129 819 -60 q 701 -243 757 -197 l 629 -194 q 666 -133 651 -164 q 689 -70 681 -102 q 696 0 696 -37 l 696 103 l 819 103 z "},"Ӈ":{"ha":989,"x_min":121,"x_max":867,"o":"m 121 987 l 252 987 l 252 542 l 736 542 l 736 987 l 867 987 l 867 -57 q 841 -188 867 -134 q 764 -269 814 -241 q 646 -296 715 -296 q 607 -294 625 -296 q 568 -285 589 -292 l 578 -180 q 611 -187 589 -184 q 644 -189 634 -189 q 694 -173 673 -189 q 726 -128 715 -157 q 736 -57 736 -98 l 736 435 l 252 435 l 252 0 l 121 0 l 121 987 z "},"ӈ":{"ha":787,"x_min":99,"x_max":688,"o":"m 99 734 l 224 734 l 224 416 l 562 416 l 562 734 l 688 734 l 688 -60 q 662 -189 688 -136 q 586 -269 635 -242 q 469 -296 537 -296 q 430 -294 448 -296 q 393 -285 412 -292 l 403 -184 q 436 -191 413 -189 q 469 -193 460 -193 q 519 -177 498 -193 q 551 -132 540 -161 q 562 -60 562 -102 l 562 314 l 224 314 l 224 0 l 99 0 l 99 734 z "},"Ӊ":{"ha":1054,"x_min":115,"x_max":996,"o":"m 760 563 l 760 456 l 225 456 l 225 563 l 760 563 m 245 987 l 245 0 l 115 0 l 115 987 l 245 987 m 873 987 l 873 0 l 743 0 l 743 987 l 873 987 m 996 103 l 996 2 q 965 -129 996 -60 q 878 -243 934 -197 l 806 -194 q 843 -133 828 -164 q 866 -70 858 -102 q 873 0 873 -37 l 873 103 l 996 103 z "},"ӊ":{"ha":854,"x_min":106,"x_max":818,"o":"m 593 416 l 593 314 l 205 314 l 205 416 l 593 416 m 232 734 l 232 0 l 106 0 l 106 734 l 232 734 m 695 734 l 695 0 l 569 0 l 569 734 l 695 734 m 818 103 l 818 2 q 787 -129 818 -60 q 699 -243 755 -197 l 628 -194 q 665 -133 650 -164 q 687 -70 680 -102 q 695 0 695 -37 l 695 103 l 818 103 z "},"Ӎ":{"ha":1269,"x_min":115,"x_max":1211,"o":"m 156 987 l 283 987 l 606 182 l 929 987 l 1057 987 l 655 0 l 556 0 l 156 987 m 115 987 l 227 987 l 245 385 l 245 0 l 115 0 l 115 987 m 985 987 l 1097 987 l 1097 0 l 967 0 l 967 385 l 985 987 m 1211 103 l 1211 2 q 1180 -129 1211 -60 q 1093 -243 1149 -197 l 1021 -194 q 1058 -133 1043 -164 q 1081 -70 1073 -102 q 1088 0 1088 -37 l 1088 103 l 1211 103 z "},"ӎ":{"ha":1084,"x_min":107,"x_max":1047,"o":"m 517 167 l 767 734 l 888 734 l 561 0 l 474 0 l 149 734 l 269 734 l 517 167 m 233 734 l 233 0 l 107 0 l 107 734 l 233 734 m 798 0 l 798 734 l 924 734 l 924 0 l 798 0 m 1047 103 l 1047 2 q 1016 -129 1047 -60 q 928 -243 985 -197 l 857 -194 q 894 -133 879 -164 q 917 -70 909 -102 q 924 0 924 -37 l 924 103 l 1047 103 z "},"Ә":{"ha":960,"x_min":64,"x_max":880,"o":"m 435 1001 q 626 966 543 1001 q 765 868 709 931 q 851 717 822 804 q 880 525 880 630 l 880 461 q 849 269 880 356 q 761 118 817 181 q 631 20 705 55 q 473 -14 557 -14 q 296 18 372 -14 q 168 108 219 49 q 90 250 116 167 q 64 436 64 333 l 64 520 l 800 520 l 800 419 l 195 419 l 195 396 q 209 278 195 333 q 256 182 224 223 q 342 118 289 141 q 473 94 395 94 q 591 123 539 94 q 678 202 642 151 q 732 319 713 252 q 750 461 750 385 l 750 525 q 732 668 750 602 q 676 785 714 734 q 578 864 638 836 q 435 892 519 892 q 287 873 347 892 q 187 836 227 854 l 155 932 q 208 960 172 943 q 300 988 243 976 q 435 1001 357 1001 z "},"Ӡ":{"ha":808,"x_min":71,"x_max":724,"o":"m 100 987 l 694 987 l 694 903 l 355 499 l 278 499 l 278 578 l 541 880 l 100 880 l 100 987 m 278 577 l 380 578 q 566 543 489 578 q 684 440 643 507 q 724 275 724 372 q 700 152 724 206 q 630 61 675 98 q 524 5 585 24 q 391 -14 463 -14 q 275 2 332 -14 q 172 54 218 19 q 98 143 125 89 q 71 274 71 198 l 201 274 q 225 183 201 224 q 291 117 249 142 q 391 92 334 92 q 500 116 455 92 q 570 180 546 139 q 594 273 594 221 q 569 389 594 344 q 495 455 544 434 q 374 476 446 476 l 278 476 l 278 577 z "},"ӡ":{"ha":808,"x_min":72,"x_max":722,"o":"m 100 734 l 690 734 l 691 654 l 361 245 l 277 245 l 277 323 l 529 630 l 100 630 l 100 734 m 277 320 l 376 320 q 563 286 485 320 q 681 184 640 251 q 722 21 722 117 q 697 -102 722 -48 q 628 -192 673 -155 q 523 -249 584 -229 q 390 -268 463 -268 q 275 -251 332 -268 q 173 -200 218 -235 q 99 -110 127 -165 q 72 20 72 -56 l 197 20 q 221 -73 197 -31 q 289 -140 245 -115 q 390 -165 332 -165 q 502 -141 456 -165 q 572 -76 547 -117 q 596 18 596 -35 q 570 135 596 90 q 495 200 545 180 q 373 221 445 221 l 277 221 l 277 320 z "},"Ӻ":{"ha":819,"x_min":39,"x_max":773,"o":"m 773 987 l 773 880 l 297 880 l 297 0 l 167 0 l 167 987 l 773 987 m 471 588 l 471 485 l 39 485 l 39 588 l 471 588 m 281 104 l 408 104 l 408 -60 q 381 -189 408 -136 q 307 -269 355 -242 q 189 -296 258 -296 q 151 -294 168 -296 q 113 -285 133 -292 l 123 -178 q 156 -184 133 -182 q 189 -186 180 -186 q 239 -172 218 -186 q 271 -130 260 -158 q 281 -60 281 -102 l 281 104 z "},"ӻ":{"ha":637,"x_min":39,"x_max":623,"o":"m 623 734 l 623 630 l 284 630 l 284 0 l 159 0 l 159 734 l 623 734 m 471 467 l 471 363 l 39 363 l 39 467 l 471 467 m 271 104 l 397 104 l 397 -60 q 371 -189 397 -136 q 296 -269 345 -242 q 178 -296 247 -296 q 140 -294 157 -296 q 102 -285 122 -292 l 112 -178 q 145 -184 122 -182 q 178 -186 169 -186 q 228 -172 208 -186 q 260 -130 249 -158 q 271 -60 271 -102 l 271 104 z "},"Ӽ":{"ha":899,"x_min":39,"x_max":878,"o":"m 199 987 l 437 609 l 674 987 l 827 987 l 515 498 l 834 0 l 680 0 l 437 386 l 193 0 l 39 0 l 359 498 l 47 987 l 199 987 m 752 104 l 878 104 l 878 -60 q 852 -189 878 -136 q 777 -269 826 -242 q 660 -296 728 -296 q 621 -294 639 -296 q 584 -285 604 -292 l 593 -178 q 627 -184 604 -182 q 660 -186 650 -186 q 710 -172 689 -186 q 741 -130 730 -158 q 752 -60 752 -102 l 752 104 z "},"ӽ":{"ha":738,"x_min":28,"x_max":714,"o":"m 180 734 l 341 467 l 504 734 l 651 734 l 411 372 l 659 0 l 513 0 l 344 275 l 174 0 l 28 0 l 275 372 l 36 734 l 180 734 m 588 104 l 714 104 l 714 -60 q 688 -189 714 -136 q 613 -269 662 -242 q 496 -296 564 -296 q 457 -294 475 -296 q 420 -285 439 -292 l 429 -178 q 463 -184 439 -182 q 496 -186 486 -186 q 546 -172 525 -186 q 577 -130 566 -158 q 588 -60 588 -102 l 588 104 z "},"Ԁ":{"ha":862,"x_min":59,"x_max":763,"o":"m 394 599 l 663 599 l 663 492 l 394 492 q 276 465 321 492 q 211 396 231 439 q 190 303 190 353 q 211 209 190 254 q 276 135 231 163 q 394 106 321 106 l 632 106 l 632 987 l 763 987 l 763 0 l 394 0 q 211 39 286 0 q 98 147 136 79 q 59 302 59 215 q 81 422 59 368 q 145 516 102 476 q 250 577 188 555 q 394 599 313 599 z "},"Ԃ":{"ha":1143,"x_min":61,"x_max":1112,"o":"m 396 599 l 665 599 l 665 492 l 396 492 q 279 465 323 492 q 213 396 234 439 q 193 303 193 353 q 213 209 193 254 q 279 135 234 163 q 396 106 323 106 l 635 106 l 635 987 l 765 987 l 765 0 l 396 0 q 213 39 288 0 q 100 147 138 79 q 61 302 61 215 q 83 422 61 368 q 147 516 104 476 q 252 577 190 555 q 396 599 315 599 m 825 0 l 730 0 l 730 106 l 825 106 q 909 130 876 107 q 960 194 943 153 q 979 290 978 235 q 977 344 980 316 q 969 401 975 372 q 957 459 964 431 q 939 513 949 487 l 1065 513 q 1087 440 1077 478 q 1105 365 1098 403 q 1110 290 1112 326 q 1069 129 1109 193 q 965 32 1029 64 q 825 0 901 0 z "},"ԃ":{"ha":1197,"x_min":68,"x_max":1117,"o":"m 68 340 l 68 354 q 87 513 68 441 q 142 637 106 585 q 232 719 178 690 q 355 747 286 747 q 450 732 408 747 q 525 686 492 716 q 581 614 557 656 q 618 517 604 571 q 638 397 632 463 l 638 335 q 610 190 631 254 q 555 80 590 125 q 471 10 521 34 q 353 -14 420 -14 q 232 12 286 -14 q 142 85 179 38 q 87 198 106 133 q 68 340 68 262 m 194 354 l 194 340 q 205 242 194 288 q 238 164 216 197 q 297 111 261 130 q 385 92 334 92 q 487 119 447 92 q 552 189 528 146 q 590 283 576 233 l 590 447 q 567 519 582 484 q 527 582 551 554 q 468 625 503 609 q 386 642 433 642 q 298 619 334 642 q 239 557 262 597 q 205 465 216 517 q 194 354 194 413 m 550 234 l 550 1058 l 676 1058 l 676 234 q 690 158 675 191 q 730 107 704 125 q 792 89 756 89 q 876 109 840 90 q 937 163 912 127 q 976 248 962 198 q 989 359 989 297 q 980 495 991 427 q 948 632 968 564 l 1070 632 q 1103 497 1088 566 q 1116 359 1117 429 q 1088 194 1114 264 q 1017 78 1062 124 q 914 9 972 32 q 792 -14 857 -14 q 667 9 720 -16 q 584 90 614 35 q 550 234 554 145 z "},"Ԅ":{"ha":1101,"x_min":37,"x_max":1012,"o":"m 305 429 l 173 429 l 173 536 l 271 536 q 395 556 348 536 q 464 614 442 575 q 486 710 486 652 q 474 780 486 749 q 438 834 463 811 q 374 868 413 857 q 280 880 335 880 l 37 880 l 37 987 l 280 987 q 424 969 361 987 q 529 916 487 951 q 594 829 572 881 q 616 709 616 777 q 606 637 616 671 q 576 576 595 604 q 527 526 556 548 q 460 487 498 504 q 376 460 422 471 q 371 455 374 460 q 367 447 369 451 q 362 442 364 443 q 327 434 335 435 q 305 429 319 433 m 477 207 l 477 208 l 477 252 q 456 345 477 305 q 397 407 435 385 q 305 429 359 429 l 317 503 q 457 485 401 503 q 546 433 513 467 q 593 354 579 399 q 608 254 608 308 l 608 207 q 620 148 608 174 q 654 107 631 122 q 708 92 677 92 q 781 112 749 93 q 834 166 812 131 q 868 250 856 201 q 880 359 880 299 q 870 495 882 427 q 838 632 859 564 l 965 632 q 997 497 983 566 q 1010 359 1012 429 q 984 195 1009 265 q 918 79 960 125 q 821 9 876 33 q 707 -14 767 -14 q 588 7 638 -16 q 509 78 537 29 q 477 207 481 127 z "},"ԅ":{"ha":898,"x_min":33,"x_max":852,"o":"m 252 300 l 92 300 l 91 401 l 218 401 q 311 415 275 401 q 362 454 346 429 q 379 512 379 479 q 362 574 379 547 q 309 617 345 601 q 215 633 273 633 l 37 633 l 33 734 l 215 734 q 373 708 308 734 q 471 633 437 682 q 505 516 505 585 q 493 454 505 482 q 456 405 480 427 q 395 367 431 383 q 312 339 359 351 q 309 332 311 338 q 306 318 307 325 q 302 310 304 311 q 273 304 279 305 q 252 300 268 303 m 504 144 l 504 145 q 517 102 503 119 q 568 85 530 85 q 634 99 606 85 q 683 139 663 113 q 714 201 703 165 q 726 284 725 238 q 716 392 727 336 q 683 500 705 448 l 805 500 q 838 393 823 448 q 851 284 852 338 q 826 151 850 208 q 763 57 803 94 q 673 0 724 19 q 568 -18 623 -18 q 488 -10 522 -19 q 429 18 453 -1 q 393 70 406 38 q 378 145 380 101 l 378 197 q 362 252 378 229 q 314 288 346 275 q 235 300 282 300 l 259 372 q 407 350 353 372 q 482 288 460 327 q 504 197 504 248 l 504 144 z "},"Ԇ":{"ha":745,"x_min":56,"x_max":688,"o":"m 269 429 l 119 429 l 119 532 l 229 532 q 358 553 310 532 q 428 612 406 573 q 450 708 450 652 q 429 802 450 762 q 362 863 408 841 q 243 884 317 884 l 56 884 l 56 987 l 243 987 q 425 956 351 987 q 537 861 498 924 q 575 707 575 799 q 565 636 575 669 q 536 575 555 603 q 488 525 517 547 q 421 486 459 503 q 338 458 384 469 q 333 454 336 458 q 328 447 330 450 q 323 442 326 443 q 297 436 306 438 q 283 433 289 434 q 269 429 277 432 m 268 429 l 279 503 q 456 471 392 503 q 546 382 519 439 q 572 252 572 325 l 572 159 q 577 105 572 132 q 591 56 581 79 q 618 17 602 34 l 618 0 l 490 0 q 460 50 469 19 q 449 112 451 81 q 447 161 447 143 l 447 250 q 425 344 447 304 q 363 407 404 385 q 268 429 323 429 m 688 144 l 688 43 q 656 -87 688 -18 q 569 -202 625 -156 l 498 -153 q 534 -92 519 -123 q 557 -28 549 -61 q 565 41 565 5 l 565 144 l 688 144 z "},"ԇ":{"ha":700,"x_min":82,"x_max":668,"o":"m 312 299 l 132 299 l 132 401 l 275 401 q 370 414 334 401 q 422 453 406 428 q 438 512 438 478 q 422 574 438 547 q 370 617 406 602 q 275 632 334 632 l 82 632 l 83 734 l 275 734 q 398 719 345 734 q 489 676 452 705 q 545 608 526 648 q 564 516 564 568 q 552 454 564 481 q 515 404 539 426 q 454 366 490 382 q 370 338 418 349 q 365 325 368 338 q 359 310 361 311 q 337 305 344 307 q 327 302 331 303 q 312 299 322 300 m 295 299 l 320 372 q 467 347 414 372 q 542 280 520 323 q 564 182 564 237 l 564 117 q 568 80 564 100 q 580 42 571 60 q 604 13 589 24 l 604 0 l 475 0 q 449 36 456 12 q 440 83 441 60 q 438 117 438 106 l 438 182 q 422 244 438 218 q 374 285 406 271 q 295 299 342 299 m 668 134 l 668 33 q 637 -98 668 -29 q 550 -213 606 -167 l 478 -163 q 515 -103 500 -134 q 537 -39 530 -72 q 545 31 545 -6 l 545 134 l 668 134 z "},"Ԉ":{"ha":1347,"x_min":47,"x_max":1292,"o":"m 267 987 l 397 987 l 375 504 q 359 318 370 399 q 328 176 348 236 q 275 77 307 116 q 195 19 242 38 q 82 0 148 0 l 47 0 l 47 106 l 74 109 q 139 126 112 111 q 186 170 167 140 q 218 248 205 200 q 237 364 230 295 q 248 525 244 433 l 267 987 m 747 987 l 747 880 l 314 880 l 314 987 l 747 987 m 722 235 l 722 987 l 852 987 l 852 235 q 860 177 852 203 q 883 132 868 151 q 919 102 898 113 q 966 92 940 92 q 1048 111 1013 92 q 1108 165 1084 130 q 1146 249 1133 200 q 1160 359 1159 298 q 1150 495 1161 427 q 1118 632 1139 564 l 1245 632 q 1278 497 1263 566 q 1291 359 1292 429 q 1263 194 1289 264 q 1192 78 1236 124 q 1089 9 1147 32 q 966 -14 1031 -14 q 838 11 892 -14 q 752 91 783 36 q 722 235 722 146 z "},"ԉ":{"ha":1122,"x_min":43,"x_max":1081,"o":"m 214 734 l 340 734 l 321 380 q 306 235 316 298 q 277 127 296 172 q 232 55 259 83 q 168 13 205 26 q 82 0 131 0 l 43 0 l 43 111 l 71 113 q 120 126 99 115 q 155 160 140 138 q 178 219 169 183 q 193 304 187 255 q 201 420 198 354 l 214 734 m 576 734 l 576 630 l 242 630 l 242 734 l 576 734 m 554 234 l 554 734 l 680 734 l 680 234 q 688 175 680 201 q 711 129 696 148 q 747 99 726 109 q 795 89 768 89 q 862 106 833 89 q 911 154 891 123 q 942 229 931 185 q 954 328 953 273 q 944 458 955 393 q 913 587 932 523 l 1034 587 q 1066 459 1052 524 q 1080 328 1081 394 q 1055 178 1078 242 q 992 71 1031 113 q 902 7 953 28 q 795 -14 851 -14 q 696 0 741 -14 q 621 43 652 14 q 571 120 589 73 q 554 234 554 168 z "},"Ԋ":{"ha":1385,"x_min":115,"x_max":1292,"o":"m 226 542 l 741 542 l 741 435 l 226 435 l 226 542 m 115 987 l 245 987 l 245 0 l 115 0 l 115 987 m 722 987 l 852 987 l 852 235 q 866 161 852 193 q 905 110 880 128 q 966 92 931 92 q 1048 112 1013 93 q 1108 165 1084 130 q 1146 249 1133 200 q 1160 359 1160 298 q 1150 495 1162 427 q 1118 632 1139 564 l 1244 632 q 1277 497 1263 566 q 1291 359 1292 429 q 1263 194 1289 264 q 1192 78 1236 124 q 1089 9 1147 32 q 966 -14 1031 -14 q 840 9 893 -16 q 756 90 786 35 q 722 235 726 146 l 722 987 z "},"ԋ":{"ha":1152,"x_min":98,"x_max":1094,"o":"m 584 415 l 584 313 l 197 313 l 197 415 l 584 415 m 224 734 l 224 0 l 98 0 l 98 734 l 224 734 m 566 234 l 566 734 l 692 734 l 692 234 q 700 175 692 201 q 723 129 708 148 q 759 99 738 110 q 807 89 781 89 q 874 106 845 90 q 924 154 904 123 q 955 229 944 185 q 966 328 966 273 q 956 458 968 393 q 925 587 945 523 l 1046 587 q 1079 459 1064 524 q 1093 328 1094 394 q 1068 178 1091 242 q 1005 71 1045 113 q 915 7 966 28 q 807 -14 864 -14 q 710 -1 753 -15 q 635 42 667 12 q 587 120 604 72 q 566 234 570 168 z "},"Ԍ":{"ha":862,"x_min":80,"x_max":804,"o":"m 473 -14 q 313 17 385 -14 q 189 105 241 49 q 108 238 136 162 q 80 405 80 315 l 80 583 q 108 749 80 673 q 189 882 136 825 q 313 970 241 939 q 473 1002 385 1002 q 610 987 551 1002 q 713 943 669 972 l 673 848 q 581 883 630 871 q 473 895 532 895 q 362 870 411 895 q 280 803 314 846 q 229 704 246 760 q 211 584 211 648 l 211 405 q 229 284 211 340 q 280 184 246 227 q 362 117 314 141 q 473 92 411 92 q 581 117 536 93 q 648 185 625 141 q 672 289 671 229 q 664 411 673 349 q 638 533 654 473 l 765 533 q 791 412 778 473 q 803 289 804 351 q 755 119 802 186 q 635 19 709 52 q 473 -14 560 -14 z "},"ԍ":{"ha":715,"x_min":69,"x_max":656,"o":"m 402 89 q 478 104 450 90 q 517 143 505 118 q 530 204 529 169 q 527 284 530 242 q 516 364 524 326 l 637 364 q 650 284 644 325 q 655 204 656 244 q 621 82 654 130 q 531 9 587 33 q 402 -14 474 -14 q 260 15 322 -14 q 155 96 198 45 q 91 213 113 147 q 69 353 69 279 l 69 381 q 90 520 69 454 q 152 637 111 587 q 252 718 193 688 q 388 747 311 747 q 501 736 453 747 q 578 703 549 724 l 549 606 q 476 634 517 624 q 388 644 435 644 q 300 621 336 644 q 240 560 263 598 q 205 475 216 522 q 195 381 195 428 l 195 353 q 207 258 195 305 q 243 173 218 212 q 308 112 268 135 q 402 89 347 89 z "},"Ԏ":{"ha":986,"x_min":24,"x_max":917,"o":"m 806 987 l 806 880 l 24 880 l 24 987 l 806 987 m 347 235 l 347 987 l 477 987 l 477 235 q 485 177 477 203 q 507 132 492 151 q 543 103 522 113 q 591 92 564 92 q 673 112 637 93 q 733 165 709 130 q 770 249 758 200 q 785 359 783 298 q 774 495 786 427 q 743 632 763 564 l 869 632 q 902 497 888 566 q 915 359 917 429 q 887 194 913 264 q 817 78 861 124 q 714 9 772 32 q 591 -14 656 -14 q 464 9 517 -16 q 381 90 411 35 q 347 235 351 146 z "},"ԏ":{"ha":890,"x_min":47,"x_max":819,"o":"m 663 734 l 663 632 l 47 632 l 47 734 l 663 734 m 291 234 l 291 734 l 416 734 l 416 234 q 430 158 416 191 q 471 107 444 125 q 533 89 497 89 q 600 103 571 90 q 650 143 629 117 q 681 207 670 170 q 692 290 692 243 q 682 400 694 343 q 651 510 671 456 l 772 510 q 804 401 789 456 q 818 290 819 345 q 793 156 817 213 q 730 61 770 98 q 640 4 691 23 q 533 -14 589 -14 q 435 -1 479 -15 q 361 42 392 12 q 312 120 330 72 q 291 234 294 168 z "},"Ԑ":{"ha":937,"x_min":102,"x_max":867,"o":"m 479 532 l 609 532 l 609 450 l 484 450 q 376 439 422 450 q 297 407 329 429 q 250 352 266 385 q 233 273 233 318 q 251 201 233 234 q 301 144 268 168 q 383 106 334 119 q 493 92 431 92 q 621 117 566 92 q 707 183 676 142 q 737 274 737 224 l 867 274 q 836 143 867 198 q 750 54 804 89 q 629 2 696 19 q 493 -14 562 -14 q 336 5 408 -14 q 213 61 265 24 q 131 152 160 98 q 102 275 102 206 q 127 385 102 337 q 201 465 153 433 q 319 515 249 498 q 479 532 389 532 m 609 474 l 479 474 q 331 493 397 474 q 217 547 264 513 q 143 625 169 581 q 117 721 117 670 q 144 842 117 790 q 220 930 170 895 q 338 984 269 966 q 493 1002 408 1002 q 673 968 591 1002 q 805 874 755 935 q 854 728 854 812 l 724 728 q 693 814 724 777 q 610 873 662 852 q 493 895 557 895 q 354 871 408 895 q 274 809 300 848 q 248 723 248 770 q 261 656 248 686 q 303 604 275 626 q 376 569 332 581 q 484 557 421 557 l 609 557 l 609 474 z "},"Ԓ":{"ha":1043,"x_min":33,"x_max":985,"o":"m 749 987 l 749 880 l 298 880 l 298 987 l 749 987 m 862 987 l 862 0 l 731 0 l 731 987 l 862 987 m 253 987 l 383 987 l 361 504 q 345 318 356 399 q 313 176 334 236 q 260 77 293 116 q 181 19 228 38 q 68 0 134 0 l 33 0 l 33 106 l 60 109 q 125 126 98 111 q 172 170 153 140 q 203 248 191 200 q 223 364 216 295 q 234 525 230 433 l 253 987 m 859 104 l 985 104 l 985 -60 q 959 -189 985 -136 q 884 -269 933 -242 q 767 -296 836 -296 q 728 -294 746 -296 q 691 -285 711 -292 l 701 -178 q 734 -184 711 -182 q 767 -186 758 -186 q 817 -172 796 -186 q 848 -130 838 -158 q 859 -60 859 -102 l 859 104 z "},"ԓ":{"ha":859,"x_min":30,"x_max":822,"o":"m 586 734 l 586 630 l 231 630 l 231 734 l 586 734 m 696 734 l 696 0 l 571 0 l 571 734 l 696 734 m 201 734 l 327 734 l 308 380 q 293 235 303 298 q 264 127 282 172 q 219 55 246 83 q 155 13 193 26 q 69 0 118 0 l 30 0 l 30 111 l 57 113 q 107 126 86 115 q 142 160 127 138 q 165 219 156 183 q 179 304 174 255 q 187 420 184 354 l 201 734 m 696 104 l 822 104 l 822 -60 q 796 -189 822 -136 q 721 -269 770 -242 q 604 -296 672 -296 q 565 -294 583 -296 q 528 -285 547 -292 l 537 -178 q 571 -184 547 -182 q 604 -186 594 -186 q 653 -172 633 -186 q 685 -130 674 -158 q 696 -60 696 -102 l 696 104 z "}," ":{"ha":708,"x_min":0,"x_max":0,"o":""}," ":{"ha":1417,"x_min":0,"x_max":0,"o":""}," ":{"ha":708,"x_min":0,"x_max":0,"o":""}," ":{"ha":1417,"x_min":0,"x_max":0,"o":""}," ":{"ha":473,"x_min":0,"x_max":0,"o":""}," ":{"ha":354,"x_min":0,"x_max":0,"o":""}," ":{"ha":236,"x_min":0,"x_max":0,"o":""}," ":{"ha":781,"x_min":0,"x_max":0,"o":""}," ":{"ha":380,"x_min":0,"x_max":0,"o":""}," ":{"ha":283,"x_min":0,"x_max":0,"o":""}," ":{"ha":142,"x_min":0,"x_max":0,"o":""},"​":{"ha":0,"x_min":0,"x_max":0,"o":""},"‐":{"ha":382,"x_min":26,"x_max":357,"o":"m 357 471 l 357 368 l 26 368 l 26 471 l 357 471 z "},"‑":{"ha":382,"x_min":26,"x_max":357,"o":"m 357 471 l 357 368 l 26 368 l 26 471 l 357 471 z "},"–":{"ha":911,"x_min":110,"x_max":789,"o":"m 789 545 l 789 441 l 110 441 l 110 545 l 789 545 z "},"—":{"ha":1084,"x_min":98,"x_max":1004,"o":"m 1004 545 l 1004 441 l 98 441 l 98 545 l 1004 545 z "},"‗":{"ha":633,"x_min":9,"x_max":630,"o":"m 630 -172 l 630 -275 l 9 -275 l 9 -172 l 630 -172 m 630 0 l 630 -103 l 9 -103 l 9 0 l 630 0 z "},"‘":{"ha":278,"x_min":66,"x_max":255,"o":"m 66 728 l 66 810 q 80 896 66 851 q 120 983 94 941 q 184 1055 146 1025 l 255 1006 q 207 914 224 961 q 190 812 190 867 l 190 728 l 66 728 z "},"’":{"ha":278,"x_min":33,"x_max":222,"o":"m 222 1042 l 222 955 q 209 869 222 914 q 168 782 195 824 q 104 709 142 741 l 33 759 q 81 851 64 804 q 98 953 98 898 l 98 1042 l 222 1042 z "},"‚":{"ha":277,"x_min":24,"x_max":214,"o":"m 214 123 l 214 54 q 200 -32 214 13 q 160 -119 186 -77 q 96 -192 134 -161 l 24 -143 q 73 -51 56 -98 q 89 52 89 -3 l 89 123 l 214 123 z "},"‛":{"ha":278,"x_min":54,"x_max":243,"o":"m 54 1042 l 178 1042 l 178 953 q 195 851 178 898 q 243 759 212 804 l 172 709 q 108 782 135 741 q 67 869 81 824 q 54 955 54 914 l 54 1042 z "},"“":{"ha":491,"x_min":71,"x_max":474,"o":"m 71 728 l 71 810 q 85 896 71 851 q 125 983 99 941 q 189 1055 152 1025 l 260 1006 q 212 914 229 961 q 195 812 195 867 l 195 728 l 71 728 m 285 728 l 285 810 q 299 896 285 851 q 339 983 313 941 q 403 1055 366 1025 l 474 1006 q 426 914 443 961 q 409 812 409 867 l 409 728 l 285 728 z "},"”":{"ha":496,"x_min":41,"x_max":439,"o":"m 231 1042 l 231 955 q 217 869 231 914 q 176 782 203 824 q 113 709 150 741 l 41 759 q 89 851 73 804 q 106 953 106 898 l 106 1042 l 231 1042 m 439 1042 l 439 955 q 425 869 439 914 q 385 782 411 824 q 321 709 358 741 l 249 759 q 297 851 281 804 q 314 953 314 898 l 314 1042 l 439 1042 z "},"„":{"ha":479,"x_min":24,"x_max":415,"o":"m 214 167 l 214 54 q 200 -37 214 10 q 160 -129 186 -85 q 96 -205 134 -172 l 24 -155 q 73 -57 56 -107 q 89 52 89 -7 l 89 167 l 214 167 m 415 167 l 415 54 q 401 -37 415 10 q 361 -129 387 -85 q 297 -205 334 -172 l 225 -155 q 273 -57 257 -107 q 290 52 290 -7 l 290 167 l 415 167 z "},"†":{"ha":766,"x_min":47,"x_max":719,"o":"m 445 987 l 445 0 l 319 0 l 319 987 l 445 987 m 719 734 l 719 630 l 47 630 l 47 734 l 719 734 z "},"‡":{"ha":792,"x_min":59,"x_max":730,"o":"m 454 987 l 454 -282 l 329 -282 l 329 987 l 454 987 m 730 734 l 730 630 l 59 630 l 59 734 l 730 734 m 730 103 l 730 0 l 59 0 l 59 103 l 730 103 z "},"•":{"ha":469,"x_min":94,"x_max":371,"o":"m 94 496 l 94 524 q 131 621 94 583 q 232 659 168 659 q 334 621 296 659 q 371 524 371 583 l 371 496 q 334 401 371 439 q 233 363 297 363 q 132 401 169 363 q 94 496 94 439 z "},"‥":{"ha":654,"x_min":100,"x_max":553,"o":"m 100 66 q 120 120 100 98 q 178 142 140 142 q 236 120 216 142 q 256 66 256 98 q 236 14 256 35 q 178 -8 216 -8 q 120 14 140 -8 q 100 66 100 35 m 397 66 q 417 120 397 98 q 475 142 437 142 q 533 120 513 142 q 553 66 553 98 q 533 14 553 35 q 475 -8 513 -8 q 417 14 437 -8 q 397 66 397 35 z "},"…":{"ha":929,"x_min":100,"x_max":834,"o":"m 100 66 q 120 120 100 98 q 178 142 140 142 q 236 120 216 142 q 256 66 256 98 q 236 14 256 35 q 178 -8 216 -8 q 120 14 140 -8 q 100 66 100 35 m 397 66 q 417 120 397 98 q 475 142 437 142 q 533 120 513 142 q 553 66 553 98 q 533 14 553 35 q 475 -8 513 -8 q 417 14 437 -8 q 397 66 397 35 m 678 66 q 698 120 678 98 q 756 142 718 142 q 814 120 794 142 q 834 66 834 98 q 814 14 834 35 q 756 -8 794 -8 q 698 14 718 -8 q 678 66 678 35 z "},"‧":{"ha":260,"x_min":56,"x_max":204,"o":"m 56 420 q 75 471 56 450 q 130 492 94 492 q 185 471 166 492 q 204 420 204 450 q 185 369 204 390 q 130 349 166 349 q 75 369 94 349 q 56 420 56 390 z "},"‰":{"ha":1331,"x_min":46,"x_max":1274,"o":"m 46 745 l 46 798 q 71 900 46 854 q 140 974 95 946 q 248 1002 186 1002 q 357 974 312 1002 q 427 900 403 946 q 451 798 451 854 l 451 745 q 427 644 451 690 q 358 570 403 598 q 250 543 313 543 q 141 570 186 543 q 71 644 96 598 q 46 745 46 690 m 140 798 l 140 745 q 152 686 140 714 q 189 641 164 659 q 250 624 213 624 q 310 641 286 624 q 346 686 334 659 q 357 745 357 714 l 357 798 q 346 858 357 829 q 310 903 334 886 q 248 920 286 920 q 188 903 212 920 q 152 858 164 886 q 140 798 140 829 m 558 189 l 558 242 q 583 344 558 298 q 652 418 607 390 q 760 446 698 446 q 862 418 820 446 q 927 344 905 390 q 950 242 950 298 l 950 189 q 927 87 950 134 q 863 14 905 41 q 762 -14 821 -14 q 653 14 699 -14 q 583 87 608 41 q 558 189 558 134 m 652 242 l 652 189 q 664 130 652 158 q 701 84 676 102 q 762 67 725 67 q 822 84 798 67 q 858 130 846 102 q 869 189 869 157 l 869 242 q 858 302 869 274 q 822 347 846 330 q 760 364 798 364 q 700 347 724 364 q 664 302 676 330 q 652 242 652 274 m 882 189 l 882 242 q 905 344 882 298 q 970 418 928 390 q 1072 446 1013 446 q 1180 418 1135 446 q 1250 344 1225 390 q 1274 242 1274 298 l 1274 189 q 1250 87 1274 134 q 1181 14 1226 41 q 1073 -14 1136 -14 q 971 14 1014 -14 q 905 87 928 41 q 882 189 882 134 m 963 242 l 963 189 q 975 130 963 158 q 1011 84 987 102 q 1072 67 1036 67 q 1133 84 1109 67 q 1168 130 1156 102 q 1180 189 1180 157 l 1180 242 q 1168 302 1180 274 q 1132 347 1156 330 q 1071 364 1108 364 q 1011 347 1035 364 q 975 302 987 330 q 963 242 963 274 m 774 847 l 292 75 l 220 120 l 703 892 l 774 847 z "},"‹":{"ha":417,"x_min":73,"x_max":370,"o":"m 370 644 l 193 371 l 73 372 l 73 380 l 273 644 l 370 644 m 193 377 l 370 104 l 273 104 l 73 368 l 73 376 l 193 377 z "},"›":{"ha":417,"x_min":61,"x_max":357,"o":"m 61 104 l 238 376 l 357 376 l 357 367 l 157 104 l 61 104 m 61 644 l 157 644 l 357 380 l 357 371 l 238 370 l 61 644 z "},"⁄":{"ha":631,"x_min":41,"x_max":593,"o":"m 593 847 l 111 75 l 41 120 l 523 892 l 593 847 z "},"⁰":{"ha":509,"x_min":55,"x_max":454,"o":"m 454 767 l 454 673 q 430 545 454 595 q 360 470 405 494 q 256 445 315 445 q 150 470 195 445 q 80 545 105 494 q 55 673 55 595 l 55 767 q 80 895 55 844 q 150 970 104 945 q 254 995 195 995 q 359 970 315 995 q 429 895 404 945 q 454 767 454 844 m 347 664 l 347 777 q 336 851 347 822 q 305 893 326 880 q 254 907 284 907 q 204 893 224 907 q 172 851 183 880 q 161 777 161 822 l 161 664 q 172 589 161 618 q 204 546 183 560 q 256 532 226 532 q 306 546 286 532 q 337 589 326 560 q 347 664 347 618 z "},"⁴":{"ha":509,"x_min":37,"x_max":475,"o":"m 475 656 l 475 568 l 41 568 l 37 637 l 293 987 l 377 987 l 284 832 l 144 656 l 475 656 m 401 987 l 401 452 l 295 452 l 295 987 l 401 987 z "},"⁵":{"ha":509,"x_min":62,"x_max":461,"o":"m 161 694 l 77 715 l 110 987 l 435 987 l 435 899 l 198 899 l 182 783 q 221 795 195 788 q 277 803 246 803 q 376 782 335 803 q 439 722 417 761 q 461 627 461 682 q 439 537 461 579 q 374 470 418 496 q 262 445 330 445 q 167 463 212 445 q 94 515 122 481 q 62 599 65 550 l 168 599 q 197 548 171 564 q 262 532 222 532 q 333 559 311 532 q 354 629 354 587 q 328 697 354 671 q 252 724 301 724 q 195 714 214 724 q 161 694 176 705 z "},"⁶":{"ha":509,"x_min":58,"x_max":464,"o":"m 360 994 l 375 994 l 375 905 l 368 905 q 256 886 301 905 q 188 827 210 867 q 165 726 165 787 l 165 647 q 178 583 165 609 q 213 545 191 557 q 264 532 235 532 q 313 545 292 532 q 346 579 334 557 q 357 628 357 601 q 333 695 357 670 q 263 721 309 721 q 210 710 234 721 q 172 681 186 699 q 157 644 158 663 l 128 676 q 150 735 130 705 q 207 787 170 766 q 292 808 243 808 q 388 784 349 808 q 445 720 426 760 q 464 629 464 679 q 440 535 464 576 q 371 469 416 493 q 266 445 327 445 q 156 471 202 445 q 84 545 109 497 q 58 658 58 593 l 58 695 q 78 821 58 766 q 135 915 97 876 q 230 974 174 954 q 360 994 286 994 z "},"⁷":{"ha":509,"x_min":40,"x_max":460,"o":"m 460 987 l 460 926 l 222 452 l 110 452 l 347 900 l 40 900 l 40 987 l 460 987 z "},"⁸":{"ha":509,"x_min":54,"x_max":455,"o":"m 455 599 q 429 514 455 548 q 357 462 403 479 q 255 445 312 445 q 153 462 198 445 q 80 514 107 479 q 54 599 54 548 q 80 678 54 645 q 151 730 106 711 q 254 748 197 748 q 357 730 312 748 q 429 678 403 711 q 455 599 455 645 m 349 607 q 337 647 349 631 q 303 673 325 664 q 254 682 282 682 q 205 673 226 682 q 172 647 184 664 q 161 607 161 631 q 172 567 161 584 q 205 541 184 550 q 255 532 227 532 q 304 541 283 532 q 337 567 326 550 q 349 607 349 584 m 442 846 q 418 772 442 804 q 352 723 394 741 q 255 706 310 706 q 158 723 200 706 q 91 772 115 741 q 67 846 67 804 q 91 927 67 894 q 158 978 115 960 q 254 995 200 995 q 351 978 309 995 q 418 927 393 960 q 442 846 442 894 m 335 839 q 325 875 335 860 q 297 899 315 890 q 254 908 279 908 q 195 890 217 908 q 174 839 174 871 q 183 803 174 819 q 212 779 193 787 q 255 770 230 770 q 314 789 292 770 q 335 839 335 808 z "},"⁹":{"ha":509,"x_min":50,"x_max":448,"o":"m 142 534 l 151 534 q 261 551 219 534 q 323 606 303 569 q 342 698 342 642 l 342 797 q 330 859 342 834 q 296 895 317 883 q 248 907 275 907 q 199 893 220 907 q 167 856 178 879 q 156 804 156 832 q 166 755 156 777 q 198 721 177 734 q 250 708 219 708 q 302 720 280 708 q 337 749 325 731 q 351 784 350 766 l 382 753 q 361 693 381 722 q 306 644 340 663 q 226 625 271 625 q 130 648 169 625 q 70 711 90 671 q 50 804 50 751 q 74 900 50 857 q 143 969 98 943 q 248 995 187 995 q 356 969 311 995 q 425 894 401 943 q 448 777 448 845 l 448 742 q 431 616 448 671 q 376 524 413 562 q 284 467 340 486 q 152 448 229 448 l 142 448 l 142 534 z "},"⁺":{"ha":559,"x_min":54,"x_max":505,"o":"m 505 727 l 505 639 l 54 639 l 54 727 l 505 727 m 324 922 l 324 444 l 235 444 l 235 922 l 324 922 z "},"⁻":{"ha":515,"x_min":54,"x_max":461,"o":"m 461 730 l 461 642 l 54 642 l 54 730 l 461 730 z "},"⁼":{"ha":515,"x_min":54,"x_max":461,"o":"m 461 646 l 461 557 l 54 557 l 54 646 l 461 646 m 461 806 l 461 718 l 54 718 l 54 806 l 461 806 z "},"⁽":{"ha":337,"x_min":57,"x_max":283,"o":"m 57 676 l 57 688 q 89 884 57 801 q 166 1020 121 967 q 248 1094 211 1073 l 283 1015 q 229 948 256 990 q 184 842 202 905 q 167 688 167 778 l 167 675 q 177 551 167 604 q 204 459 187 498 q 242 393 221 420 q 283 345 262 366 l 248 271 q 187 319 220 286 q 124 404 154 353 q 76 523 95 455 q 57 676 57 591 z "},"⁾":{"ha":337,"x_min":54,"x_max":280,"o":"m 280 688 l 280 676 q 248 479 280 563 q 171 344 216 396 q 89 271 126 292 l 54 345 q 109 413 82 372 q 153 516 135 453 q 170 675 170 580 l 170 688 q 160 808 170 755 q 133 900 150 861 q 95 968 116 939 q 54 1015 75 996 l 89 1094 q 150 1044 117 1078 q 212 960 182 1010 q 261 841 242 909 q 280 688 280 772 z "},"ⁿ":{"ha":587,"x_min":83,"x_max":516,"o":"m 198 868 l 198 441 l 83 441 l 83 984 l 170 984 l 198 868 m 182 731 l 151 730 q 164 836 151 787 q 202 919 177 884 q 261 975 227 955 q 340 994 296 994 q 433 973 393 994 q 494 905 473 951 q 516 786 516 859 l 516 441 l 401 441 l 401 764 q 389 843 401 814 q 354 884 376 871 q 302 897 332 897 q 234 874 261 897 q 195 815 208 852 q 182 731 182 778 z "},"₀":{"ha":509,"x_min":55,"x_max":454,"o":"m 454 65 l 454 -29 q 430 -157 454 -106 q 360 -232 405 -208 q 256 -257 315 -257 q 150 -232 195 -257 q 80 -157 105 -208 q 55 -29 55 -106 l 55 65 q 80 193 55 142 q 150 268 104 243 q 254 293 195 293 q 359 268 315 293 q 429 193 404 243 q 454 65 454 142 m 347 -38 l 347 75 q 336 149 347 120 q 305 192 326 178 q 254 205 284 205 q 204 192 224 205 q 172 149 183 178 q 161 75 161 120 l 161 -38 q 172 -113 161 -83 q 204 -156 183 -142 q 256 -170 226 -170 q 306 -156 286 -170 q 337 -113 326 -142 q 347 -38 347 -83 z "},"₁":{"ha":509,"x_min":83,"x_max":336,"o":"m 336 286 l 336 -249 l 230 -249 l 230 159 l 83 120 l 83 208 l 323 286 l 336 286 z "},"₂":{"ha":509,"x_min":45,"x_max":463,"o":"m 463 -162 l 463 -249 l 58 -249 l 58 -176 l 253 8 q 301 59 283 37 q 327 99 319 81 q 334 132 334 117 q 313 186 334 165 q 251 207 291 207 q 176 181 200 207 q 152 117 152 155 l 45 117 q 69 205 45 165 q 139 270 94 245 q 248 294 184 294 q 353 274 309 294 q 419 219 396 254 q 442 134 442 183 q 426 66 442 98 q 381 4 410 35 q 312 -63 352 -27 l 193 -162 l 463 -162 z "},"₃":{"ha":509,"x_min":43,"x_max":452,"o":"m 180 62 l 237 62 q 292 72 271 62 q 325 98 314 81 q 336 136 336 115 q 315 186 336 166 q 246 207 293 207 q 182 190 208 207 q 157 144 157 173 l 50 144 q 76 223 50 190 q 146 275 102 257 q 244 294 190 294 q 348 276 303 294 q 418 225 393 259 q 443 142 443 191 q 421 76 443 106 q 357 27 399 45 q 256 9 315 9 l 180 9 l 180 62 m 180 -16 l 180 37 l 256 37 q 367 21 323 37 q 431 -26 410 5 q 452 -100 452 -56 q 425 -184 452 -149 q 351 -238 398 -220 q 245 -256 304 -256 q 148 -240 194 -256 q 72 -188 101 -223 q 43 -98 43 -153 l 149 -98 q 176 -149 149 -128 q 248 -170 203 -170 q 320 -149 296 -170 q 345 -94 345 -127 q 332 -48 345 -66 q 295 -23 319 -31 q 237 -16 271 -16 l 180 -16 z "},"₄":{"ha":509,"x_min":37,"x_max":475,"o":"m 475 -45 l 475 -134 l 41 -134 l 37 -64 l 293 286 l 377 286 l 284 131 l 144 -45 l 475 -45 m 401 286 l 401 -249 l 295 -249 l 295 286 l 401 286 z "},"₅":{"ha":509,"x_min":62,"x_max":461,"o":"m 161 -7 l 77 14 l 110 286 l 435 286 l 435 197 l 198 197 l 182 81 q 221 94 195 87 q 277 102 246 102 q 376 81 335 102 q 439 20 417 60 q 461 -74 461 -19 q 439 -164 461 -122 q 374 -231 418 -205 q 262 -256 330 -256 q 167 -238 212 -256 q 94 -186 122 -220 q 62 -102 65 -151 l 168 -102 q 197 -153 171 -137 q 262 -170 222 -170 q 333 -142 311 -170 q 354 -73 354 -114 q 328 -4 354 -31 q 252 22 301 22 q 195 13 214 22 q 161 -7 176 3 z "},"₆":{"ha":509,"x_min":58,"x_max":464,"o":"m 360 293 l 375 293 l 375 204 l 368 204 q 256 185 301 204 q 188 125 210 165 q 165 24 165 85 l 165 -54 q 178 -118 165 -92 q 213 -157 191 -144 q 264 -170 235 -170 q 313 -157 292 -170 q 346 -122 334 -144 q 357 -73 357 -100 q 333 -6 357 -31 q 263 20 309 20 q 210 8 234 20 q 172 -20 186 -3 q 157 -57 158 -38 l 128 -25 q 150 34 130 4 q 207 85 170 64 q 292 106 243 106 q 388 83 349 106 q 445 18 426 59 q 464 -73 464 -22 q 440 -166 464 -125 q 371 -232 416 -208 q 266 -256 327 -256 q 156 -230 202 -256 q 84 -156 109 -204 q 58 -43 58 -109 l 58 -6 q 78 120 58 64 q 135 214 97 175 q 230 273 174 252 q 360 293 286 293 z "},"₇":{"ha":509,"x_min":40,"x_max":460,"o":"m 460 286 l 460 225 l 222 -249 l 110 -249 l 347 199 l 40 199 l 40 286 l 460 286 z "},"₈":{"ha":509,"x_min":54,"x_max":455,"o":"m 455 -102 q 429 -188 455 -153 q 357 -239 403 -222 q 255 -256 312 -256 q 153 -239 198 -256 q 80 -188 107 -222 q 54 -102 54 -153 q 80 -23 54 -56 q 151 28 106 10 q 254 47 197 47 q 357 28 312 47 q 429 -23 403 10 q 455 -102 455 -56 m 349 -94 q 337 -54 349 -71 q 303 -28 325 -37 q 254 -19 282 -19 q 205 -28 226 -19 q 172 -54 184 -37 q 161 -94 161 -71 q 172 -134 161 -117 q 205 -160 184 -151 q 255 -170 227 -170 q 304 -160 283 -170 q 337 -134 326 -151 q 349 -94 349 -117 m 442 144 q 418 71 442 102 q 352 22 394 39 q 255 5 310 5 q 158 22 200 5 q 91 71 115 39 q 67 144 67 102 q 91 226 67 193 q 158 276 115 259 q 254 294 200 294 q 351 276 309 294 q 418 226 393 259 q 442 144 442 193 m 335 138 q 325 174 335 159 q 297 198 315 189 q 254 207 279 207 q 195 189 217 207 q 174 138 174 170 q 183 102 174 117 q 212 77 193 86 q 255 68 230 68 q 314 87 292 68 q 335 138 335 106 z "},"₉":{"ha":509,"x_min":50,"x_max":448,"o":"m 142 -168 l 151 -168 q 261 -150 219 -168 q 323 -96 303 -132 q 342 -3 342 -59 l 342 96 q 330 157 342 133 q 296 194 317 182 q 248 206 275 206 q 199 192 220 206 q 167 154 178 178 q 156 103 156 131 q 166 54 156 76 q 198 20 177 33 q 250 7 219 7 q 302 18 280 7 q 337 47 325 30 q 351 83 350 65 l 382 52 q 361 -8 381 21 q 306 -57 340 -38 q 226 -76 271 -76 q 130 -53 169 -76 q 70 10 90 -31 q 50 103 50 50 q 74 198 50 155 q 143 268 98 241 q 248 294 187 294 q 356 268 311 294 q 425 193 401 241 q 448 75 448 144 l 448 41 q 431 -85 448 -31 q 376 -177 413 -140 q 284 -234 340 -215 q 152 -254 229 -254 l 142 -254 l 142 -168 z "},"₊":{"ha":559,"x_min":54,"x_max":505,"o":"m 505 50 l 505 -38 l 54 -38 l 54 50 l 505 50 m 324 245 l 324 -233 l 235 -233 l 235 245 l 324 245 z "},"₋":{"ha":515,"x_min":54,"x_max":461,"o":"m 461 53 l 461 -35 l 54 -35 l 54 53 l 461 53 z "},"₌":{"ha":515,"x_min":54,"x_max":461,"o":"m 461 -31 l 461 -119 l 54 -119 l 54 -31 l 461 -31 m 461 130 l 461 41 l 54 41 l 54 130 l 461 130 z "},"₍":{"ha":337,"x_min":57,"x_max":283,"o":"m 57 20 l 57 32 q 89 218 57 139 q 166 347 121 297 q 248 416 211 397 l 283 338 q 229 275 256 315 q 184 176 202 235 q 167 33 167 117 l 167 20 q 184 -129 167 -70 q 229 -225 202 -188 q 283 -289 256 -263 l 248 -364 q 187 -317 220 -349 q 124 -237 154 -286 q 76 -125 95 -189 q 57 20 57 -60 z "},"₎":{"ha":337,"x_min":54,"x_max":280,"o":"m 280 39 l 280 28 q 248 -162 280 -81 q 171 -293 216 -242 q 89 -363 126 -343 l 54 -288 q 109 -223 82 -262 q 153 -125 135 -185 q 170 27 170 -64 l 170 40 q 153 180 170 122 q 109 277 135 238 q 54 338 82 315 l 89 416 q 150 371 117 402 q 213 292 183 340 q 261 181 242 245 q 280 39 280 118 z "},"₤":{"ha":808,"x_min":62,"x_max":765,"o":"m 765 0 l 64 0 l 64 106 l 765 106 l 765 0 m 295 705 l 310 273 q 292 154 311 209 q 235 71 273 98 l 117 106 q 154 141 140 113 q 174 205 168 169 q 180 272 180 242 l 165 705 q 204 864 165 798 q 312 966 243 930 q 466 1001 380 1001 q 617 968 555 1001 q 713 875 680 935 q 746 737 746 816 l 616 737 q 593 829 616 794 q 534 879 570 863 q 455 895 497 895 q 374 872 410 895 q 316 808 338 850 q 295 705 295 766 m 536 581 l 536 496 l 62 496 l 62 581 l 536 581 m 536 404 l 536 319 l 62 319 l 62 404 l 536 404 z "},"₦":{"ha":1100,"x_min":21,"x_max":1079,"o":"m 1079 638 l 1079 535 l 21 535 l 21 638 l 1079 638 m 1079 435 l 1079 332 l 21 332 l 21 435 l 1079 435 m 927 987 l 927 0 l 796 0 l 299 762 l 299 0 l 168 0 l 168 987 l 299 987 l 798 224 l 798 987 l 927 987 z "},"₧":{"ha":1140,"x_min":113,"x_max":1044,"o":"m 370 383 l 211 383 l 211 486 l 370 486 q 489 515 448 486 q 543 589 529 543 q 557 684 557 634 q 543 781 557 735 q 489 856 529 827 q 370 884 448 884 l 239 884 l 239 0 l 113 0 l 113 987 l 370 987 q 551 948 481 987 q 652 841 620 909 q 684 686 684 772 q 652 530 684 599 q 551 422 620 462 q 370 383 481 383 m 1040 734 l 1040 637 l 644 637 l 644 734 l 1040 734 m 778 912 l 903 912 l 903 182 q 915 125 903 144 q 945 100 926 106 q 984 94 963 94 q 1017 97 1000 94 q 1043 102 1034 100 l 1044 0 q 1005 -9 1029 -5 q 947 -14 981 -14 q 863 5 901 -14 q 801 66 824 23 q 778 182 778 109 l 778 912 z "},"₨":{"ha":1469,"x_min":115,"x_max":1400,"o":"m 115 987 l 441 987 q 630 954 553 987 q 747 853 707 920 q 787 691 787 787 q 760 567 787 623 q 681 472 732 511 q 559 414 630 433 l 522 400 l 215 400 l 214 507 l 446 507 q 563 531 516 507 q 633 598 610 556 q 657 691 657 640 q 635 791 657 748 q 565 857 612 833 q 441 880 517 880 l 245 880 l 245 0 l 115 0 l 115 987 m 692 0 l 452 448 l 588 448 l 831 8 l 831 0 l 692 0 m 1275 195 q 1263 245 1275 222 q 1215 288 1251 269 q 1106 321 1179 307 q 996 352 1045 334 q 912 395 947 370 q 860 454 878 420 q 842 533 842 488 q 861 615 842 576 q 916 684 880 654 q 1002 730 951 713 q 1114 747 1052 747 q 1264 716 1202 747 q 1360 633 1326 685 q 1393 518 1393 581 l 1267 518 q 1250 577 1267 549 q 1197 625 1232 606 q 1114 644 1163 644 q 1029 628 1061 644 q 982 588 997 612 q 968 536 968 564 q 975 500 968 516 q 1000 471 982 484 q 1052 446 1019 458 q 1137 423 1085 435 q 1285 374 1227 403 q 1372 304 1343 346 q 1400 204 1400 263 q 1380 116 1400 156 q 1323 47 1360 76 q 1233 2 1285 18 q 1117 -14 1181 -14 q 953 21 1020 -14 q 851 111 886 56 q 817 227 817 165 l 943 227 q 972 145 945 175 q 1039 102 1000 115 q 1117 90 1078 90 q 1203 103 1168 90 q 1257 140 1238 117 q 1275 195 1275 164 z "},"₩":{"ha":1027,"x_min":21,"x_max":1006,"o":"m 1006 665 l 1006 562 l 21 562 l 21 665 l 1006 665 m 1006 430 l 1006 328 l 21 328 l 21 430 l 1006 430 m 289 0 l 334 320 l 454 987 l 543 987 l 498 667 l 376 0 l 289 0 m 172 987 l 298 323 l 334 0 l 251 0 l 41 987 l 172 987 m 694 0 l 730 323 l 853 987 l 984 987 l 774 0 l 694 0 m 576 987 l 696 322 l 740 0 l 649 0 l 531 669 l 488 987 l 576 987 z "},"₪":{"ha":1071,"x_min":95,"x_max":976,"o":"m 95 734 l 474 734 q 572 719 528 734 q 646 673 615 705 q 693 588 677 641 q 709 460 709 536 l 709 237 l 583 237 l 583 461 q 574 541 583 508 q 546 593 564 573 q 500 622 527 613 q 437 631 473 631 l 221 631 l 221 0 l 95 0 l 95 734 m 741 0 l 362 0 l 362 498 l 488 498 l 488 103 l 703 103 q 784 119 751 103 q 833 173 817 136 q 850 273 850 210 l 850 734 l 976 734 l 976 274 q 960 145 976 198 q 912 61 943 93 q 838 15 882 29 q 741 0 795 0 z "},"€":{"ha":781,"x_min":64,"x_max":714,"o":"m 553 92 q 629 98 592 92 q 701 115 667 104 l 714 7 q 635 -8 676 -3 q 551 -14 593 -14 q 404 11 471 -14 q 288 85 336 36 q 212 208 239 134 q 185 380 185 281 l 185 606 q 212 779 185 705 q 287 902 238 852 q 402 976 336 951 q 551 1001 469 1001 q 633 995 593 1001 q 714 980 673 989 l 701 871 q 629 888 667 882 q 552 895 591 895 q 454 877 498 895 q 379 824 410 859 q 332 734 349 789 q 316 607 316 680 l 316 380 q 333 252 316 307 q 380 163 349 198 q 455 110 412 127 q 553 92 499 92 m 576 629 l 576 544 l 64 544 l 64 629 l 576 629 m 576 452 l 576 368 l 64 368 l 64 452 l 576 452 z "},"₱":{"ha":1016,"x_min":21,"x_max":996,"o":"m 996 823 l 996 720 l 21 720 l 21 823 l 996 823 m 996 656 l 996 553 l 21 553 l 21 656 l 996 656 m 519 387 l 256 387 l 256 494 l 519 494 q 644 518 596 494 q 713 586 691 543 q 735 685 735 629 q 713 781 735 736 q 644 853 691 825 q 519 880 596 880 l 286 880 l 286 0 l 155 0 l 155 987 l 519 987 q 709 949 631 987 q 826 842 786 910 q 866 686 866 774 q 826 524 866 591 q 709 422 786 457 q 519 387 631 387 z "},"₹":{"ha":718,"x_min":29,"x_max":690,"o":"m 690 746 l 659 639 l 29 639 l 60 746 l 690 746 m 408 0 l 49 419 l 48 503 l 214 503 q 333 527 286 503 q 404 593 380 551 q 427 686 427 634 q 405 787 427 743 q 335 856 382 831 q 210 880 287 880 l 31 880 l 62 987 l 210 987 q 405 952 328 987 q 519 848 481 916 q 557 684 557 781 q 526 536 557 602 q 422 433 494 471 q 228 396 350 396 l 562 8 l 562 0 l 408 0 m 690 987 l 659 880 l 151 880 l 182 987 l 690 987 z "},"₺":{"ha":773,"x_min":22,"x_max":713,"o":"m 318 987 l 318 0 l 188 0 l 188 987 l 318 987 m 583 523 l 713 523 l 713 463 q 685 264 713 353 q 604 114 656 176 q 479 20 552 52 q 315 -13 406 -13 q 252 -9 283 -13 q 188 0 220 -5 l 315 98 q 430 122 380 98 q 514 191 480 145 q 566 306 548 237 q 583 463 583 374 l 583 523 m 488 892 l 488 771 l 22 558 l 22 679 l 488 892 m 488 667 l 488 547 l 22 334 l 22 454 l 488 667 z "},"₼":{"ha":917,"x_min":63,"x_max":854,"o":"m 854 0 l 728 0 l 728 127 q 717 257 728 199 q 683 358 705 315 q 627 432 660 402 q 552 477 594 462 q 458 492 509 492 q 347 468 397 492 q 262 399 298 445 q 208 285 227 353 q 189 127 189 217 l 189 0 l 63 0 l 63 126 q 92 326 63 237 q 173 475 121 414 q 298 570 226 537 q 458 602 370 602 q 591 581 530 602 q 701 520 652 560 q 784 421 749 479 q 836 289 818 363 q 854 126 854 215 l 854 0 m 521 734 l 521 0 l 395 0 l 395 734 l 521 734 z "},"₽":{"ha":922,"x_min":21,"x_max":871,"o":"m 526 387 l 21 387 l 21 494 l 526 494 q 648 517 600 494 q 718 585 695 541 q 741 687 741 628 q 719 779 741 735 q 651 852 698 823 q 526 880 604 880 l 292 880 l 292 0 l 161 0 l 161 987 l 526 987 q 715 949 638 987 q 831 843 791 911 q 871 688 871 776 q 831 526 871 593 q 715 423 791 458 q 526 387 638 387 m 518 294 l 518 187 l 21 187 l 21 294 l 518 294 z "},"℅":{"ha":1025,"x_min":83,"x_max":957,"o":"m 368 715 l 462 715 q 439 629 462 668 q 375 566 417 589 q 275 543 334 543 q 173 570 216 543 q 107 644 130 598 q 83 745 83 690 l 83 798 q 106 900 83 854 q 172 974 130 946 q 273 1002 215 1002 q 374 978 332 1002 q 439 915 416 954 q 462 828 462 876 l 368 828 q 345 892 368 864 q 273 920 321 920 q 220 903 241 920 q 188 858 199 886 q 178 798 178 829 l 178 745 q 189 686 178 714 q 221 641 199 659 q 275 624 243 624 q 345 653 323 624 q 368 715 368 683 m 552 189 l 552 242 q 576 344 552 298 q 646 418 601 390 q 754 446 692 446 q 863 418 818 446 q 932 344 908 390 q 957 242 957 298 l 957 189 q 933 87 957 134 q 864 14 909 41 q 755 -14 819 -14 q 647 14 692 -14 q 577 87 602 41 q 552 189 552 134 m 646 242 l 646 189 q 658 130 646 158 q 694 84 670 102 q 755 67 719 67 q 816 84 792 67 q 852 130 840 102 q 863 189 863 157 l 863 242 q 851 302 863 274 q 815 347 840 330 q 754 364 791 364 q 694 347 718 364 q 658 302 670 330 q 646 242 646 274 m 785 847 l 302 75 l 232 120 l 714 892 l 785 847 z "},"ℓ":{"ha":661,"x_min":71,"x_max":593,"o":"m 486 93 l 486 -14 q 365 7 416 -14 q 279 70 313 29 q 229 166 245 110 q 212 292 212 223 l 212 798 q 225 905 212 858 q 264 986 239 953 q 327 1037 290 1019 q 410 1055 363 1055 q 483 1040 450 1055 q 541 997 516 1025 q 580 930 566 969 q 593 840 593 890 l 593 812 q 571 669 593 743 q 505 527 549 595 q 398 404 462 458 q 253 317 335 349 q 71 285 171 285 l 71 404 q 250 444 175 404 q 373 546 326 484 q 444 680 421 609 q 467 811 467 750 l 467 840 q 463 888 467 868 q 451 922 459 909 q 433 941 444 935 q 410 947 422 947 q 378 938 391 947 q 356 910 365 929 q 342 863 347 891 q 338 798 338 836 l 338 292 q 345 209 338 245 q 370 146 353 172 q 415 106 387 120 q 486 93 444 93 z "},"№":{"ha":1428,"x_min":110,"x_max":1350,"o":"m 1327 376 l 1327 280 l 909 280 l 909 376 l 1327 376 m 886 698 l 886 765 q 914 887 886 835 q 995 969 943 940 q 1118 998 1046 998 q 1241 969 1190 998 q 1321 887 1293 940 q 1350 765 1350 835 l 1350 698 q 1322 576 1350 628 q 1242 494 1294 524 q 1119 465 1190 465 q 995 494 1047 465 q 914 576 943 524 q 886 698 886 628 m 996 765 l 996 698 q 1009 625 996 656 q 1050 577 1023 594 q 1119 559 1078 559 q 1186 577 1160 559 q 1226 625 1213 594 q 1240 698 1240 656 l 1240 765 q 1226 837 1240 806 q 1186 886 1213 868 q 1118 903 1159 903 q 1050 886 1077 903 q 1009 837 1023 868 q 996 765 996 806 m 777 987 l 777 0 l 638 0 l 236 769 l 236 0 l 110 0 l 110 987 l 248 987 l 652 216 l 652 987 l 777 987 z "},"™":{"ha":869,"x_min":71,"x_max":732,"o":"m 671 623 l 671 891 l 577 623 l 542 623 l 447 890 l 447 623 l 386 623 l 386 987 l 462 987 l 559 718 l 656 987 l 732 987 l 732 623 l 671 623 m 332 987 l 332 932 l 232 932 l 232 623 l 170 623 l 170 932 l 71 932 l 71 987 l 332 987 z "},"℮":{"ha":884,"x_min":103,"x_max":794,"o":"m 708 134 l 709 64 q 589 7 652 28 q 458 -14 525 -14 q 320 16 385 -14 q 207 98 256 46 q 131 220 158 151 q 103 367 103 289 q 133 514 103 446 q 214 635 163 583 q 329 718 265 688 q 458 747 392 747 q 589 720 528 747 q 696 643 650 692 q 768 527 742 593 q 794 380 794 460 q 794 372 794 378 q 794 349 794 366 l 273 349 l 273 126 q 358 72 311 92 q 458 52 406 52 q 585 72 522 52 q 708 134 648 92 m 458 684 q 360 661 408 684 q 273 601 312 639 l 273 413 l 640 413 l 640 607 q 557 663 604 642 q 458 684 511 684 z "},"⅛":{"ha":1067,"x_min":57,"x_max":989,"o":"m 309 973 l 309 438 l 203 438 l 203 846 l 57 807 l 57 895 l 297 973 l 309 973 m 749 847 l 267 75 l 197 120 l 679 892 l 749 847 m 989 146 q 963 61 989 96 q 892 10 937 27 q 789 -7 846 -7 q 687 10 732 -7 q 615 61 642 27 q 588 146 588 96 q 614 226 588 193 q 686 277 640 259 q 789 296 731 296 q 892 277 846 296 q 963 226 937 259 q 989 146 989 193 m 884 155 q 871 195 884 178 q 838 221 859 212 q 789 230 817 230 q 739 221 760 230 q 707 195 718 212 q 695 155 695 178 q 707 115 695 132 q 740 89 718 98 q 789 79 761 79 q 839 89 817 79 q 872 115 860 98 q 884 155 884 132 m 977 393 q 952 320 977 351 q 886 271 928 288 q 789 254 844 254 q 692 271 734 254 q 626 320 650 288 q 602 393 602 351 q 626 475 602 441 q 692 525 650 508 q 789 543 734 543 q 885 525 843 543 q 952 475 928 508 q 977 393 977 441 m 869 387 q 860 423 869 408 q 832 447 850 438 q 789 456 814 456 q 730 437 751 456 q 708 387 708 419 q 718 351 708 366 q 746 326 728 335 q 789 317 764 317 q 848 336 827 317 q 869 387 869 355 z "},"⅜":{"ha":1187,"x_min":68,"x_max":1098,"o":"m 206 759 l 263 759 q 318 768 296 759 q 351 794 340 778 q 362 833 362 811 q 340 883 362 863 q 272 903 319 903 q 208 886 233 903 q 182 840 182 869 l 76 840 q 102 920 76 886 q 172 972 127 954 q 270 990 216 990 q 374 973 329 990 q 444 922 418 956 q 469 838 469 888 q 447 772 469 802 q 383 724 425 742 q 281 706 341 706 l 206 706 l 206 759 m 206 681 l 206 734 l 281 734 q 393 718 349 734 q 457 671 436 701 q 478 597 478 640 q 451 512 478 547 q 377 458 424 477 q 271 440 330 440 q 173 457 220 440 q 98 509 127 473 q 68 599 68 544 l 175 599 q 202 548 175 568 q 274 527 229 527 q 346 548 321 527 q 371 602 371 569 q 358 648 371 631 q 320 673 345 665 q 263 681 296 681 l 206 681 m 879 847 l 397 75 l 326 120 l 808 892 l 879 847 m 1098 146 q 1072 61 1098 96 q 1000 10 1046 27 q 898 -7 955 -7 q 795 10 841 -7 q 723 61 750 27 q 696 146 696 96 q 723 226 696 193 q 794 277 749 259 q 897 296 840 296 q 1000 277 955 296 q 1072 226 1046 259 q 1098 146 1098 193 m 992 155 q 980 195 992 178 q 946 221 968 212 q 897 230 925 230 q 848 221 869 230 q 815 195 827 212 q 804 155 804 178 q 815 115 804 132 q 848 89 827 98 q 898 79 869 79 q 947 89 926 79 q 980 115 968 98 q 992 155 992 132 m 1085 393 q 1061 320 1085 351 q 995 271 1037 288 q 898 254 953 254 q 801 271 843 254 q 734 320 758 288 q 710 393 710 351 q 734 475 710 441 q 801 525 758 508 q 897 543 843 543 q 994 525 951 543 q 1061 475 1036 508 q 1085 393 1085 441 m 978 387 q 968 423 978 408 q 940 447 958 438 q 897 456 922 456 q 838 437 860 456 q 817 387 817 419 q 826 351 817 366 q 854 326 836 335 q 898 317 873 317 q 957 336 935 317 q 978 387 978 355 z "},"⅝":{"ha":1182,"x_min":68,"x_max":1091,"o":"m 167 686 l 82 707 l 115 979 l 440 979 l 440 890 l 203 890 l 188 774 q 226 787 201 780 q 283 795 252 795 q 381 774 340 795 q 445 713 422 753 q 467 619 467 674 q 445 529 467 571 q 379 462 423 488 q 267 437 335 437 q 172 455 217 437 q 99 507 127 473 q 68 591 71 542 l 173 591 q 202 540 176 556 q 267 524 228 524 q 338 551 317 524 q 359 621 359 579 q 333 689 359 663 q 257 715 307 715 q 201 706 220 715 q 167 686 182 696 m 856 847 l 374 75 l 303 120 l 785 892 l 856 847 m 1091 146 q 1065 61 1091 96 q 994 10 1039 27 q 891 -7 948 -7 q 789 10 834 -7 q 716 61 743 27 q 690 146 690 96 q 716 226 690 193 q 787 277 742 259 q 890 296 833 296 q 994 277 948 296 q 1065 226 1039 259 q 1091 146 1091 193 m 985 155 q 973 195 985 178 q 940 221 961 212 q 890 230 918 230 q 841 221 862 230 q 808 195 820 212 q 797 155 797 178 q 808 115 797 132 q 841 89 820 98 q 891 79 863 79 q 940 89 919 79 q 974 115 962 98 q 985 155 985 132 m 1078 393 q 1054 320 1078 351 q 988 271 1030 288 q 891 254 946 254 q 794 271 836 254 q 727 320 751 288 q 703 393 703 351 q 727 475 703 441 q 794 525 751 508 q 890 543 836 543 q 987 525 945 543 q 1054 475 1029 508 q 1078 393 1078 441 m 971 387 q 961 423 971 408 q 933 447 951 438 q 890 456 916 456 q 831 437 853 456 q 810 387 810 419 q 820 351 810 366 q 848 326 829 335 q 891 317 866 317 q 950 336 928 317 q 971 387 971 355 z "},"⅞":{"ha":1114,"x_min":61,"x_max":1040,"o":"m 481 979 l 481 918 l 243 444 l 131 444 l 368 892 l 61 892 l 61 979 l 481 979 m 789 847 l 307 75 l 236 120 l 718 892 l 789 847 m 1040 146 q 1014 61 1040 96 q 942 10 987 27 q 840 -7 897 -7 q 737 10 783 -7 q 665 61 692 27 q 638 146 638 96 q 664 226 638 193 q 736 277 690 259 q 839 296 781 296 q 942 277 897 296 q 1014 226 987 259 q 1040 146 1040 193 m 934 155 q 922 195 934 178 q 888 221 909 212 q 839 230 867 230 q 789 221 810 230 q 757 195 768 212 q 745 155 745 178 q 757 115 745 132 q 790 89 768 98 q 840 79 811 79 q 889 89 867 79 q 922 115 910 98 q 934 155 934 132 m 1027 393 q 1003 320 1027 351 q 937 271 979 288 q 840 254 895 254 q 742 271 785 254 q 676 320 700 288 q 652 393 652 351 q 676 475 652 441 q 742 525 700 508 q 839 543 785 543 q 936 525 893 543 q 1002 475 978 508 q 1027 393 1027 441 m 920 387 q 910 423 920 408 q 882 447 900 438 q 839 456 864 456 q 780 437 802 456 q 758 387 758 419 q 768 351 758 366 q 796 326 778 335 q 840 317 814 317 q 898 336 877 317 q 920 387 920 355 z "},"∂":{"ha":792,"x_min":72,"x_max":729,"o":"m 389 693 q 507 667 451 693 q 603 595 564 641 q 581 705 597 655 q 541 795 565 755 q 486 862 517 835 q 419 904 455 890 q 345 919 384 919 q 277 914 309 919 q 215 901 245 909 q 152 880 184 892 l 141 981 q 195 1003 166 993 q 263 1021 224 1014 q 356 1028 302 1028 q 490 1003 431 1028 q 595 929 550 977 q 669 811 640 880 q 714 656 699 743 q 729 467 729 569 l 729 427 q 715 285 729 352 q 673 164 701 218 q 605 69 645 109 q 513 7 565 29 q 399 -14 462 -14 q 261 13 322 -14 q 158 89 201 40 q 94 202 116 137 q 72 345 72 268 l 72 359 q 93 492 72 431 q 156 598 115 553 q 255 668 197 643 q 389 693 314 693 m 401 590 q 310 571 349 590 q 247 520 272 553 q 210 447 222 488 q 198 359 198 406 l 198 345 q 210 247 198 293 q 247 165 222 201 q 310 109 271 130 q 399 89 348 89 q 491 113 452 89 q 554 180 529 137 q 591 279 579 222 q 604 402 604 336 l 604 448 q 587 489 600 465 q 551 536 574 513 q 490 574 527 559 q 401 590 453 590 z "},"∏":{"ha":965,"x_min":115,"x_max":850,"o":"m 850 987 l 850 -144 l 724 -144 l 724 884 l 241 884 l 241 -144 l 115 -144 l 115 987 l 850 987 z "},"∑":{"ha":813,"x_min":47,"x_max":811,"o":"m 811 -80 l 811 -182 l 97 -182 l 97 -80 l 811 -80 m 759 987 l 759 885 l 74 885 l 74 987 l 759 987 m 593 408 l 593 391 l 114 -182 l 47 -182 l 47 -86 l 460 400 l 47 890 l 47 987 l 114 987 l 593 408 z "},"−":{"ha":794,"x_min":114,"x_max":680,"o":"m 680 545 l 680 441 l 114 441 l 114 545 l 680 545 z "},"√":{"ha":828,"x_min":43,"x_max":798,"o":"m 371 167 l 669 987 l 798 987 l 431 -1 l 347 -1 l 371 167 m 256 530 l 390 167 l 418 -1 l 335 -1 l 128 530 l 256 530 m 43 427 l 43 530 l 251 530 l 251 427 l 43 427 z "},"∞":{"ha":1428,"x_min":67,"x_max":1354,"o":"m 67 357 l 67 376 q 91 516 67 450 q 157 635 114 583 q 261 718 201 688 q 395 747 321 747 q 524 719 469 747 q 620 644 579 690 q 687 548 660 599 q 731 453 714 498 q 756 381 747 408 l 756 353 q 731 281 747 326 q 687 185 714 236 q 620 89 660 134 q 525 15 580 43 q 397 -14 469 -14 q 261 16 322 -14 q 157 98 201 45 q 91 217 114 150 q 67 357 67 283 m 193 376 l 193 357 q 206 254 193 302 q 245 168 219 205 q 309 110 271 131 q 397 89 347 89 q 483 110 445 89 q 549 165 520 132 q 596 235 577 198 q 627 303 616 271 q 643 353 639 335 l 643 381 q 627 430 639 398 q 596 498 616 461 q 549 568 577 534 q 482 623 520 602 q 395 644 444 644 q 309 623 347 644 q 245 564 271 602 q 206 478 219 527 q 193 376 193 430 m 1354 376 l 1354 357 q 1330 217 1354 283 q 1263 98 1306 150 q 1159 16 1219 45 q 1024 -14 1098 -14 q 896 15 951 -14 q 801 89 841 43 q 733 185 760 134 q 689 281 706 236 q 665 353 673 326 l 665 381 q 690 453 673 408 q 734 548 707 498 q 801 644 761 599 q 897 719 842 690 q 1025 747 952 747 q 1159 718 1099 747 q 1263 635 1219 688 q 1330 516 1307 583 q 1354 376 1354 450 m 1228 357 l 1228 376 q 1215 478 1228 430 q 1175 564 1201 527 q 1112 623 1149 602 q 1025 644 1074 644 q 939 623 977 644 q 872 568 901 602 q 824 498 844 534 q 793 430 804 461 q 777 381 781 398 l 777 353 q 793 303 781 335 q 824 235 804 271 q 872 165 844 198 q 938 110 900 132 q 1024 89 976 89 q 1111 110 1073 89 q 1175 168 1149 131 q 1215 254 1201 205 q 1228 357 1228 302 z "},"∫":{"ha":356,"x_min":-55,"x_max":444,"o":"m 243 -73 q 217 -198 243 -149 q 142 -272 191 -248 q 24 -296 93 -296 q -16 -293 3 -296 q -55 -283 -35 -290 l -42 -184 q -16 -190 -33 -187 q 12 -193 1 -193 q 68 -180 45 -193 q 104 -141 92 -168 q 117 -73 117 -114 l 117 812 q 144 946 117 892 q 224 1028 172 1000 q 347 1056 275 1056 q 395 1052 371 1056 q 444 1042 419 1048 l 428 945 q 401 951 416 949 q 366 953 386 953 q 298 936 326 953 q 257 888 271 920 q 243 812 243 857 l 243 -73 z "},"≈":{"ha":783,"x_min":68,"x_max":703,"o":"m 70 483 l 69 611 q 146 666 101 646 q 235 686 191 686 q 320 672 290 687 q 394 636 351 658 q 463 602 434 616 q 542 589 492 589 q 628 612 586 589 q 702 675 670 635 l 703 547 q 629 493 671 513 q 543 473 587 473 q 464 487 492 473 q 395 520 435 500 q 321 556 352 542 q 235 570 290 571 q 146 547 191 570 q 70 483 102 524 m 69 200 l 68 328 q 145 382 100 363 q 235 402 191 402 q 320 389 289 404 q 393 353 351 374 q 462 319 433 332 q 541 306 491 306 q 627 329 585 306 q 701 393 669 352 l 702 264 q 628 210 670 229 q 542 190 586 190 q 463 203 492 190 q 394 237 434 216 q 320 273 351 258 q 235 287 289 288 q 146 264 191 287 q 69 200 101 241 z "},"≠":{"ha":762,"x_min":103,"x_max":669,"o":"m 618 799 l 213 106 l 149 146 l 553 839 l 618 799 m 669 661 l 669 552 l 103 552 l 103 661 l 669 661 m 669 380 l 669 271 l 103 271 l 103 380 l 669 380 z "},"≤":{"ha":706,"x_min":41,"x_max":608,"o":"m 135 479 l 604 307 l 604 186 l 49 420 l 49 491 l 135 479 m 604 621 l 136 446 l 49 438 l 49 509 l 604 742 l 604 621 m 608 104 l 608 1 l 41 1 l 41 104 l 608 104 z "},"≥":{"ha":726,"x_min":90,"x_max":671,"o":"m 574 467 l 92 638 l 92 755 l 671 523 l 671 451 l 574 467 m 92 317 l 575 491 l 671 505 l 671 433 l 92 199 l 92 317 m 656 103 l 656 0 l 90 0 l 90 103 l 656 103 z "},"◊":{"ha":700,"x_min":30,"x_max":671,"o":"m 30 493 l 301 987 l 385 987 l 373 897 l 159 493 l 377 90 l 387 0 l 304 0 l 30 493 m 327 90 l 541 493 l 323 897 l 314 987 l 397 987 l 671 493 l 399 0 l 316 0 l 327 90 z "},"":{"ha":399,"x_min":123,"x_max":279,"o":"m 123 187 q 143 241 123 219 q 201 263 163 263 q 259 241 239 263 q 279 187 279 219 q 259 134 279 156 q 201 113 239 113 q 143 134 163 113 q 123 187 123 156 m 123 785 q 143 839 123 817 q 201 861 163 861 q 259 839 239 861 q 279 785 279 817 q 259 732 279 754 q 201 711 239 711 q 143 732 163 711 q 123 785 123 754 z "},"":{"ha":445,"x_min":75,"x_max":382,"o":"m 170 734 l 170 429 l 75 429 l 75 734 l 170 734 m 382 734 l 382 429 l 287 429 l 287 734 l 382 734 z "},"":{"ha":350,"x_min":63,"x_max":233,"o":"m 233 162 l 233 109 q 209 -7 233 55 q 134 -110 184 -68 l 63 -60 q 101 19 88 -22 q 113 107 113 60 l 113 162 l 233 162 z "},"ﬁ":{"ha":770,"x_min":22,"x_max":660,"o":"m 263 0 l 138 0 l 138 798 q 170 939 138 881 q 263 1026 203 996 q 406 1056 323 1056 q 502 1044 455 1056 q 598 1015 549 1032 l 577 909 q 505 932 546 921 q 415 943 464 943 q 299 907 334 943 q 263 798 263 871 l 263 0 m 413 734 l 413 637 l 22 637 l 22 734 l 413 734 m 660 734 l 660 0 l 534 0 l 534 734 l 660 734 z "},"ﬂ":{"ha":789,"x_min":41,"x_max":680,"o":"m 283 0 l 157 0 l 157 811 q 187 945 157 890 q 272 1028 216 1000 q 408 1056 328 1056 q 483 1050 438 1056 q 579 1034 528 1044 q 680 1015 631 1025 l 621 924 q 505 942 557 936 q 418 949 454 949 q 343 933 374 949 q 298 886 313 917 q 283 811 283 856 l 283 0 m 554 0 l 554 1015 l 680 1015 l 680 0 l 554 0 m 439 734 l 439 637 l 41 637 l 41 734 l 439 734 z "},"ﬃ":{"ha":1185,"x_min":41,"x_max":1076,"o":"m 283 0 l 157 0 l 157 811 q 186 945 157 890 q 269 1028 215 1000 q 398 1056 323 1056 q 442 1053 420 1056 q 485 1045 464 1050 l 478 943 q 446 947 464 946 q 410 949 428 949 q 341 933 370 949 q 298 886 313 917 q 283 811 283 856 l 283 0 m 446 734 l 446 637 l 41 637 l 41 734 l 446 734 m 680 0 l 554 0 l 554 798 q 586 939 554 881 q 679 1026 618 996 q 822 1056 739 1056 q 918 1044 871 1056 q 1015 1015 965 1032 l 993 909 q 921 932 962 921 q 831 943 880 943 q 715 907 751 943 q 680 798 680 871 l 680 0 m 829 734 l 829 637 l 438 637 l 438 734 l 829 734 m 1076 734 l 1076 0 l 951 0 l 951 734 l 1076 734 z "},"ﬄ":{"ha":1185,"x_min":41,"x_max":1076,"o":"m 283 0 l 157 0 l 157 811 q 186 945 157 890 q 269 1028 215 1000 q 398 1056 323 1056 q 442 1053 420 1056 q 485 1045 464 1050 l 478 943 q 446 947 464 946 q 410 949 428 949 q 341 933 370 949 q 298 886 313 917 q 283 811 283 856 l 283 0 m 446 734 l 446 637 l 41 637 l 41 734 l 446 734 m 680 0 l 554 0 l 554 811 q 584 945 554 890 q 669 1028 613 1000 q 805 1056 725 1056 q 880 1050 835 1056 q 976 1034 925 1044 q 1076 1015 1027 1025 l 1018 924 q 902 942 954 936 q 814 949 850 949 q 740 933 770 949 q 695 886 710 917 q 680 811 680 856 l 680 0 m 951 0 l 951 1015 l 1076 1015 l 1076 0 l 951 0 m 836 734 l 836 637 l 438 637 l 438 734 l 836 734 z "},"\uFEFF":{"ha":0,"x_min":0,"x_max":0,"o":""},"￼":{"ha":1424,"x_min":62,"x_max":1377,"o":"m 138 793 l 62 793 l 62 986 l 271 986 l 271 907 l 138 907 l 138 793 m 1301 907 l 1166 907 l 1166 986 l 1377 986 l 1377 793 l 1301 793 l 1301 907 m 271 -270 l 62 -270 l 62 -56 l 138 -56 l 138 -193 l 271 -193 l 271 -270 m 1377 -270 l 1166 -270 l 1166 -193 l 1301 -193 l 1301 -56 l 1377 -56 l 1377 -270 m 1084 -270 l 896 -270 l 896 -193 l 1084 -193 l 1084 -270 m 542 -270 l 355 -270 l 355 -193 l 542 -193 l 542 -270 m 542 907 l 355 907 l 355 986 l 542 986 l 542 907 m 1377 197 l 1377 28 l 1301 28 l 1301 197 l 1377 197 m 1377 708 l 1377 538 l 1301 538 l 1301 708 l 1377 708 m 813 -270 l 625 -270 l 625 -193 l 813 -193 l 813 -270 m 138 197 l 138 28 l 62 28 l 62 197 l 138 197 m 813 907 l 625 907 l 625 986 l 813 986 l 813 907 m 1084 907 l 896 907 l 896 986 l 1084 986 l 1084 907 m 138 453 l 138 282 l 62 282 l 62 453 l 138 453 m 138 708 l 138 538 l 62 538 l 62 708 l 138 708 m 1377 453 l 1377 282 l 1301 282 l 1301 453 l 1377 453 m 1144 288 l 1144 545 l 1206 545 l 1206 288 q 1170 203 1206 235 q 1080 172 1134 172 q 983 200 1020 172 q 946 283 946 227 l 1009 283 q 1028 237 1009 252 q 1080 222 1047 222 q 1126 240 1107 222 q 1144 288 1144 259 m 755 336 l 653 336 l 652 384 l 732 384 q 792 398 772 384 q 812 438 812 412 q 792 476 812 466 q 732 486 772 486 l 669 486 l 669 171 l 605 171 l 605 543 l 732 543 q 809 532 777 543 q 859 499 842 522 q 876 441 876 477 q 865 399 876 418 q 831 368 853 380 q 777 353 809 356 q 775 347 777 353 q 772 340 774 340 q 764 337 764 337 q 755 336 764 336 m 755 171 l 629 171 l 662 222 l 755 222 q 807 237 790 222 q 825 278 825 252 q 807 320 825 304 q 755 336 790 336 l 674 336 l 675 384 l 777 384 q 787 384 787 384 q 795 380 787 383 q 797 373 795 379 q 800 366 800 366 q 848 351 829 363 q 878 318 868 338 q 888 276 888 299 q 853 198 888 224 q 755 171 817 171 m 559 393 l 559 317 q 516 210 559 252 q 404 169 473 169 q 291 210 334 169 q 247 317 247 252 l 247 393 q 290 500 247 459 q 403 542 334 542 q 516 500 473 542 q 559 393 559 459 m 497 317 l 497 393 q 472 466 497 439 q 403 493 447 493 q 334 466 359 493 q 309 393 309 439 l 309 317 q 335 244 309 271 q 404 218 360 218 q 472 244 448 218 q 497 317 497 271 z "},"�":{"ha":1425,"x_min":62,"x_max":1361,"o":"m 62 436 l 711 1097 l 1361 436 l 711 -225 l 62 436 m 630 273 l 767 273 q 775 328 767 307 q 812 368 784 349 q 891 436 858 393 q 924 536 924 480 q 868 674 924 623 q 710 725 811 725 q 564 683 624 725 q 503 545 504 640 l 640 545 q 663 598 642 582 q 710 614 684 614 q 767 593 748 614 q 787 536 787 571 q 769 474 787 500 q 724 431 751 448 q 671 389 692 408 q 641 342 650 369 q 630 273 631 316 m 767 96 l 767 211 l 630 211 l 630 96 l 767 96 m 716 -376 l 716 -374 l 719 -374 l 719 -376 l 716 -376 m 715 1464 l 715 1467 l 718 1467 l 718 1464 l 715 1464 z "}," ":{"ha":345,"x_min":0,"x_max":0,"o":""},"­":{"ha":384,"x_min":26,"x_max":357,"o":"m 357 471 l 357 368 l 26 368 l 26 471 l 357 471 z "},"Đ":{"ha":932,"x_min":25,"x_max":850,"o":"m 402 0 l 196 0 l 197 106 l 402 106 q 578 151 508 106 q 685 276 649 195 q 720 464 720 356 l 720 524 q 700 675 720 609 q 640 787 680 741 q 544 857 601 833 q 414 880 488 880 l 192 880 l 192 987 l 414 987 q 591 955 511 987 q 729 862 671 923 q 819 716 787 802 q 850 523 850 630 l 850 464 q 819 271 850 357 q 729 125 787 185 q 588 32 670 64 q 402 0 505 0 m 266 987 l 266 0 l 135 0 l 135 987 l 266 987 m 457 554 l 457 451 l 25 451 l 25 554 l 457 554 z "},"Ð":{"ha":932,"x_min":25,"x_max":850,"o":"m 402 0 l 196 0 l 197 106 l 402 106 q 578 151 508 106 q 685 276 649 195 q 720 464 720 356 l 720 524 q 700 675 720 609 q 640 787 680 741 q 544 857 601 833 q 414 880 488 880 l 192 880 l 192 987 l 414 987 q 591 955 511 987 q 729 862 671 923 q 819 716 787 802 q 850 523 850 630 l 850 464 q 819 271 850 357 q 729 125 787 185 q 588 32 670 64 q 402 0 505 0 m 266 987 l 266 0 l 135 0 l 135 987 l 266 987 m 457 554 l 457 451 l 25 451 l 25 554 l 457 554 z "},"ħ":{"ha":785,"x_min":1,"x_max":693,"o":"m 241 1042 l 241 0 l 116 0 l 116 1042 l 241 1042 m 212 395 l 159 397 q 182 536 160 472 q 243 648 203 600 q 337 721 282 695 q 458 747 391 747 q 555 733 512 747 q 630 686 599 718 q 677 604 661 654 q 693 481 693 553 l 693 0 l 567 0 l 567 482 q 550 575 567 540 q 500 626 533 610 q 420 642 468 642 q 335 622 374 642 q 270 568 297 602 q 227 489 242 533 q 212 395 212 444 m 433 939 l 433 836 l 1 836 l 1 939 l 433 939 z "},"Ŧ":{"ha":829,"x_min":34,"x_max":797,"o":"m 479 987 l 479 0 l 351 0 l 351 987 l 479 987 m 797 987 l 797 880 l 34 880 l 34 987 l 797 987 m 637 661 l 637 557 l 205 557 l 205 661 l 637 661 z "},"ŧ":{"ha":454,"x_min":-8,"x_max":424,"o":"m 403 734 l 403 637 l 6 637 l 6 734 l 403 734 m 140 912 l 266 912 l 266 182 q 277 125 266 144 q 307 100 289 106 q 347 94 326 94 q 379 97 362 94 q 406 102 397 100 l 406 0 q 367 -9 391 -5 q 309 -14 343 -14 q 224 5 263 -14 q 163 66 186 23 q 140 182 140 109 l 140 912 m 424 511 l 424 408 l -8 408 l -8 511 l 424 511 z "},"À":{"ha":906,"x_min":20,"x_max":888,"o":"m 480 900 l 153 0 l 20 0 l 396 987 l 482 987 l 480 900 m 754 0 l 427 900 l 425 987 l 511 987 l 888 0 l 754 0 m 737 366 l 737 258 l 182 258 l 182 366 l 737 366 m 396 1253 l 527 1053 l 419 1053 l 244 1253 l 396 1253 z "},"Á":{"ha":906,"x_min":20,"x_max":888,"o":"m 480 900 l 153 0 l 20 0 l 396 987 l 482 987 l 480 900 m 754 0 l 427 900 l 425 987 l 511 987 l 888 0 l 754 0 m 737 366 l 737 258 l 182 258 l 182 366 l 737 366 m 387 1053 l 518 1253 l 669 1253 l 488 1053 l 387 1053 z "},"Â":{"ha":906,"x_min":20,"x_max":888,"o":"m 480 900 l 153 0 l 20 0 l 396 987 l 482 987 l 480 900 m 754 0 l 427 900 l 425 987 l 511 987 l 888 0 l 754 0 m 737 366 l 737 258 l 182 258 l 182 366 l 737 366 m 494 1253 l 662 1067 l 662 1061 l 557 1061 l 456 1175 l 355 1061 l 252 1061 l 252 1068 l 418 1253 l 494 1253 z "},"Ã":{"ha":906,"x_min":20,"x_max":888,"o":"m 480 900 l 153 0 l 20 0 l 396 987 l 482 987 l 480 900 m 754 0 l 427 900 l 425 987 l 511 987 l 888 0 l 754 0 m 737 366 l 737 258 l 182 258 l 182 366 l 737 366 m 612 1239 l 696 1232 q 677 1145 696 1182 q 624 1087 657 1107 q 550 1067 591 1067 q 493 1077 515 1067 q 453 1099 471 1086 q 416 1121 435 1112 q 368 1131 397 1131 q 320 1109 340 1131 q 301 1056 301 1088 l 216 1060 q 236 1147 216 1109 q 288 1206 255 1185 q 362 1227 321 1227 q 413 1218 391 1227 q 455 1195 435 1208 q 496 1173 475 1183 q 544 1163 517 1163 q 592 1185 572 1163 q 612 1239 612 1207 z "},"Ä":{"ha":906,"x_min":20,"x_max":888,"o":"m 480 900 l 153 0 l 20 0 l 396 987 l 482 987 l 480 900 m 754 0 l 427 900 l 425 987 l 511 987 l 888 0 l 754 0 m 737 366 l 737 258 l 182 258 l 182 366 l 737 366 m 237 1141 q 256 1192 237 1171 q 311 1213 275 1213 q 367 1192 348 1213 q 386 1141 386 1171 q 367 1091 386 1112 q 311 1070 348 1070 q 256 1091 275 1070 q 237 1141 237 1112 m 530 1139 q 548 1191 530 1170 q 604 1212 567 1212 q 659 1191 640 1212 q 678 1139 678 1170 q 659 1089 678 1110 q 604 1069 640 1069 q 548 1089 567 1069 q 530 1139 530 1110 z "},"Å":{"ha":906,"x_min":20,"x_max":888,"o":"m 480 900 l 153 0 l 20 0 l 396 987 l 482 987 l 480 900 m 754 0 l 427 900 l 425 987 l 511 987 l 888 0 l 754 0 m 737 366 l 737 258 l 182 258 l 182 366 l 737 366 m 310 1174 q 329 1245 310 1213 q 381 1296 349 1277 q 456 1315 414 1315 q 559 1274 517 1315 q 602 1174 602 1232 q 582 1103 602 1135 q 530 1054 563 1072 q 456 1036 497 1036 q 352 1075 394 1036 q 310 1174 310 1114 m 377 1174 q 399 1120 377 1144 q 456 1096 421 1096 q 512 1119 490 1096 q 534 1174 534 1143 q 512 1230 534 1206 q 456 1254 490 1254 q 399 1230 421 1254 q 377 1174 377 1206 z "},"Ǻ":{"ha":906,"x_min":20,"x_max":888,"o":"m 480 900 l 153 0 l 20 0 l 396 987 l 482 987 l 480 900 m 754 0 l 427 900 l 425 987 l 511 987 l 888 0 l 754 0 m 737 366 l 737 258 l 182 258 l 182 366 l 737 366 m 429 1192 l 528 1316 l 656 1316 l 507 1192 l 429 1192 m 342 1045 q 376 1127 342 1095 q 458 1158 410 1158 q 538 1127 505 1158 q 572 1045 572 1095 q 538 965 572 996 q 458 935 505 935 q 376 965 410 935 q 342 1045 342 996 m 399 1045 q 416 1005 399 1021 q 458 988 434 988 q 498 1005 481 988 q 515 1045 515 1021 q 498 1088 515 1071 q 458 1105 481 1105 q 416 1088 434 1105 q 399 1045 399 1071 z "},"Ç":{"ha":904,"x_min":81,"x_max":841,"o":"m 711 314 l 841 314 q 787 146 831 220 q 665 30 744 73 q 467 -14 585 -14 q 309 19 380 -14 q 187 112 238 52 q 109 256 136 172 q 81 444 81 340 l 81 543 q 109 731 81 646 q 188 876 136 815 q 313 968 240 936 q 478 1001 387 1001 q 667 959 590 1001 q 788 843 745 917 q 841 671 831 768 l 711 671 q 675 790 701 740 q 602 867 650 840 q 478 894 555 894 q 362 869 412 894 q 279 798 313 844 q 229 687 245 751 q 212 544 212 623 l 212 444 q 227 308 212 372 q 273 196 242 244 q 353 120 304 148 q 467 93 401 93 q 600 119 550 93 q 674 195 649 146 q 711 314 700 245 m 420 -7 l 510 -7 l 502 -43 q 573 -75 541 -50 q 606 -160 606 -101 q 592 -218 606 -192 q 553 -263 579 -244 q 489 -292 528 -281 q 400 -302 451 -302 l 395 -229 q 452 -222 427 -229 q 493 -201 477 -216 q 508 -162 508 -186 q 496 -127 508 -140 q 461 -107 485 -114 q 399 -98 437 -101 l 420 -7 z "},"È":{"ha":789,"x_min":115,"x_max":742,"o":"m 742 106 l 742 0 l 219 0 l 219 106 l 742 106 m 245 987 l 245 0 l 115 0 l 115 987 l 245 987 m 673 563 l 673 456 l 219 456 l 219 563 l 673 563 m 735 987 l 735 880 l 219 880 l 219 987 l 735 987 m 360 1260 l 491 1061 l 383 1061 l 208 1260 l 360 1260 z "},"É":{"ha":789,"x_min":115,"x_max":742,"o":"m 742 106 l 742 0 l 219 0 l 219 106 l 742 106 m 245 987 l 245 0 l 115 0 l 115 987 l 245 987 m 673 563 l 673 456 l 219 456 l 219 563 l 673 563 m 735 987 l 735 880 l 219 880 l 219 987 l 735 987 m 351 1061 l 482 1260 l 633 1260 l 452 1061 l 351 1061 z "},"Ê":{"ha":789,"x_min":115,"x_max":742,"o":"m 742 106 l 742 0 l 219 0 l 219 106 l 742 106 m 245 987 l 245 0 l 115 0 l 115 987 l 245 987 m 673 563 l 673 456 l 219 456 l 219 563 l 673 563 m 735 987 l 735 880 l 219 880 l 219 987 l 735 987 m 458 1260 l 626 1075 l 626 1068 l 522 1068 l 420 1183 l 319 1068 l 216 1068 l 216 1076 l 382 1260 l 458 1260 z "},"Ë":{"ha":789,"x_min":115,"x_max":742,"o":"m 742 106 l 742 0 l 219 0 l 219 106 l 742 106 m 245 987 l 245 0 l 115 0 l 115 987 l 245 987 m 673 563 l 673 456 l 219 456 l 219 563 l 673 563 m 735 987 l 735 880 l 219 880 l 219 987 l 735 987 m 201 1148 q 220 1200 201 1179 q 275 1221 239 1221 q 331 1200 312 1221 q 350 1148 350 1179 q 331 1098 350 1119 q 275 1078 312 1078 q 220 1098 239 1078 q 201 1148 201 1119 m 494 1147 q 512 1198 494 1177 q 568 1219 531 1219 q 623 1198 604 1219 q 642 1147 642 1177 q 623 1097 642 1118 q 568 1076 604 1076 q 512 1097 531 1076 q 494 1147 494 1118 z "},"Ì":{"ha":378,"x_min":-22,"x_max":260,"o":"m 255 987 l 255 0 l 124 0 l 124 987 l 255 987 m 130 1260 l 260 1061 l 153 1061 l -22 1260 l 130 1260 z "},"Í":{"ha":378,"x_min":120,"x_max":403,"o":"m 255 987 l 255 0 l 124 0 l 124 987 l 255 987 m 120 1061 l 252 1260 l 403 1260 l 221 1061 l 120 1061 z "},"Î":{"ha":378,"x_min":-15,"x_max":395,"o":"m 255 987 l 255 0 l 124 0 l 124 987 l 255 987 m 227 1260 l 395 1075 l 395 1068 l 291 1068 l 189 1183 l 88 1068 l -15 1068 l -15 1076 l 151 1260 l 227 1260 z "},"Ï":{"ha":378,"x_min":-29,"x_max":412,"o":"m 255 987 l 255 0 l 124 0 l 124 987 l 255 987 m -29 1148 q -10 1200 -29 1179 q 45 1221 9 1221 q 100 1200 81 1221 q 119 1148 119 1179 q 100 1098 119 1119 q 45 1078 81 1078 q -10 1098 9 1078 q -29 1148 -29 1119 m 263 1147 q 282 1198 263 1177 q 337 1219 300 1219 q 392 1198 373 1219 q 412 1147 412 1177 q 392 1097 412 1118 q 337 1076 373 1076 q 282 1097 300 1076 q 263 1147 263 1118 z "},"Ñ":{"ha":991,"x_min":115,"x_max":874,"o":"m 874 987 l 874 0 l 743 0 l 245 762 l 245 0 l 115 0 l 115 987 l 245 987 l 745 224 l 745 987 l 874 987 m 648 1239 l 733 1232 q 713 1145 733 1182 q 661 1087 694 1107 q 587 1067 628 1067 q 530 1077 552 1067 q 490 1099 507 1086 q 453 1121 472 1112 q 405 1131 433 1131 q 357 1109 376 1131 q 338 1056 338 1088 l 253 1060 q 272 1147 253 1109 q 325 1206 292 1185 q 399 1227 358 1227 q 450 1218 428 1227 q 492 1195 472 1208 q 532 1173 511 1183 q 581 1163 553 1163 q 629 1185 609 1163 q 648 1239 648 1207 z "},"Ò":{"ha":956,"x_min":81,"x_max":875,"o":"m 875 525 l 875 463 q 847 263 875 351 q 767 113 819 175 q 642 19 715 52 q 479 -14 569 -14 q 318 19 391 -14 q 192 113 245 52 q 110 263 139 175 q 81 463 81 351 l 81 525 q 110 724 81 636 q 191 874 138 812 q 317 968 244 936 q 477 1001 390 1001 q 641 968 568 1001 q 766 874 713 936 q 847 724 819 812 q 875 525 875 636 m 745 463 l 745 526 q 727 682 745 614 q 675 796 709 750 q 590 866 640 842 q 477 890 541 890 q 367 866 416 890 q 283 796 318 842 q 229 682 248 750 q 210 526 210 614 l 210 463 q 229 306 210 374 q 284 191 248 237 q 369 121 319 144 q 479 97 418 97 q 592 121 543 97 q 676 191 642 144 q 728 306 710 237 q 745 463 745 374 m 420 1254 l 551 1055 l 443 1055 l 268 1254 l 420 1254 z "},"Ó":{"ha":956,"x_min":81,"x_max":875,"o":"m 875 525 l 875 463 q 847 263 875 351 q 767 113 819 175 q 642 19 715 52 q 479 -14 569 -14 q 318 19 391 -14 q 192 113 245 52 q 110 263 139 175 q 81 463 81 351 l 81 525 q 110 724 81 636 q 191 874 138 812 q 317 968 244 936 q 477 1001 390 1001 q 641 968 568 1001 q 766 874 713 936 q 847 724 819 812 q 875 525 875 636 m 745 463 l 745 526 q 727 682 745 614 q 675 796 709 750 q 590 866 640 842 q 477 890 541 890 q 367 866 416 890 q 283 796 318 842 q 229 682 248 750 q 210 526 210 614 l 210 463 q 229 306 210 374 q 284 191 248 237 q 369 121 319 144 q 479 97 418 97 q 592 121 543 97 q 676 191 642 144 q 728 306 710 237 q 745 463 745 374 m 410 1055 l 542 1254 l 693 1254 l 511 1055 l 410 1055 z "},"Ô":{"ha":956,"x_min":81,"x_max":875,"o":"m 875 525 l 875 463 q 847 263 875 351 q 767 113 819 175 q 642 19 715 52 q 479 -14 569 -14 q 318 19 391 -14 q 192 113 245 52 q 110 263 139 175 q 81 463 81 351 l 81 525 q 110 724 81 636 q 191 874 138 812 q 317 968 244 936 q 477 1001 390 1001 q 641 968 568 1001 q 766 874 713 936 q 847 724 819 812 q 875 525 875 636 m 745 463 l 745 526 q 727 682 745 614 q 675 796 709 750 q 590 866 640 842 q 477 890 541 890 q 367 866 416 890 q 283 796 318 842 q 229 682 248 750 q 210 526 210 614 l 210 463 q 229 306 210 374 q 284 191 248 237 q 369 121 319 144 q 479 97 418 97 q 592 121 543 97 q 676 191 642 144 q 728 306 710 237 q 745 463 745 374 m 517 1254 l 686 1069 l 686 1062 l 581 1062 l 479 1177 l 378 1062 l 275 1062 l 275 1069 l 441 1254 l 517 1254 z "},"Õ":{"ha":956,"x_min":81,"x_max":875,"o":"m 875 525 l 875 463 q 847 263 875 351 q 767 113 819 175 q 642 19 715 52 q 479 -14 569 -14 q 318 19 391 -14 q 192 113 245 52 q 110 263 139 175 q 81 463 81 351 l 81 525 q 110 724 81 636 q 191 874 138 812 q 317 968 244 936 q 477 1001 390 1001 q 641 968 568 1001 q 766 874 713 936 q 847 724 819 812 q 875 525 875 636 m 745 463 l 745 526 q 727 682 745 614 q 675 796 709 750 q 590 866 640 842 q 477 890 541 890 q 367 866 416 890 q 283 796 318 842 q 229 682 248 750 q 210 526 210 614 l 210 463 q 229 306 210 374 q 284 191 248 237 q 369 121 319 144 q 479 97 418 97 q 592 121 543 97 q 676 191 642 144 q 728 306 710 237 q 745 463 745 374 m 635 1240 l 720 1233 q 701 1146 720 1183 q 648 1088 681 1109 q 574 1068 615 1068 q 517 1078 539 1068 q 477 1100 494 1088 q 440 1123 459 1113 q 392 1133 420 1133 q 344 1111 363 1133 q 325 1057 325 1089 l 240 1061 q 259 1148 240 1111 q 312 1207 279 1186 q 386 1229 345 1229 q 437 1219 415 1229 q 479 1197 459 1209 q 519 1174 498 1184 q 568 1164 541 1164 q 616 1186 596 1164 q 635 1240 635 1208 z "},"Ö":{"ha":956,"x_min":81,"x_max":875,"o":"m 875 525 l 875 463 q 847 263 875 351 q 767 113 819 175 q 642 19 715 52 q 479 -14 569 -14 q 318 19 391 -14 q 192 113 245 52 q 110 263 139 175 q 81 463 81 351 l 81 525 q 110 724 81 636 q 191 874 138 812 q 317 968 244 936 q 477 1001 390 1001 q 641 968 568 1001 q 766 874 713 936 q 847 724 819 812 q 875 525 875 636 m 745 463 l 745 526 q 727 682 745 614 q 675 796 709 750 q 590 866 640 842 q 477 890 541 890 q 367 866 416 890 q 283 796 318 842 q 229 682 248 750 q 210 526 210 614 l 210 463 q 229 306 210 374 q 284 191 248 237 q 369 121 319 144 q 479 97 418 97 q 592 121 543 97 q 676 191 642 144 q 728 306 710 237 q 745 463 745 374 m 261 1142 q 280 1194 261 1173 q 335 1215 299 1215 q 391 1194 372 1215 q 410 1142 410 1173 q 391 1092 410 1113 q 335 1072 372 1072 q 280 1092 299 1072 q 261 1142 261 1113 m 553 1141 q 572 1192 553 1171 q 627 1213 591 1213 q 683 1192 663 1213 q 702 1141 702 1171 q 683 1091 702 1112 q 627 1070 663 1070 q 572 1091 591 1070 q 553 1141 553 1112 z "},"Ù":{"ha":901,"x_min":95,"x_max":810,"o":"m 680 987 l 810 987 l 810 319 q 760 134 810 208 q 629 23 711 60 q 452 -14 547 -14 q 270 23 351 -14 q 142 134 189 60 q 95 319 95 208 l 95 987 l 224 987 l 224 319 q 253 192 224 242 q 333 117 281 142 q 452 93 384 93 q 571 117 520 93 q 651 192 623 142 q 680 319 680 242 l 680 987 m 393 1253 l 524 1053 l 416 1053 l 241 1253 l 393 1253 z "},"Ú":{"ha":901,"x_min":95,"x_max":810,"o":"m 680 987 l 810 987 l 810 319 q 760 134 810 208 q 629 23 711 60 q 452 -14 547 -14 q 270 23 351 -14 q 142 134 189 60 q 95 319 95 208 l 95 987 l 224 987 l 224 319 q 253 192 224 242 q 333 117 281 142 q 452 93 384 93 q 571 117 520 93 q 651 192 623 142 q 680 319 680 242 l 680 987 m 383 1053 l 515 1253 l 666 1253 l 484 1053 l 383 1053 z "},"Û":{"ha":901,"x_min":95,"x_max":810,"o":"m 680 987 l 810 987 l 810 319 q 760 134 810 208 q 629 23 711 60 q 452 -14 547 -14 q 270 23 351 -14 q 142 134 189 60 q 95 319 95 208 l 95 987 l 224 987 l 224 319 q 253 192 224 242 q 333 117 281 142 q 452 93 384 93 q 571 117 520 93 q 651 192 623 142 q 680 319 680 242 l 680 987 m 490 1253 l 659 1067 l 659 1061 l 554 1061 l 452 1175 l 351 1061 l 248 1061 l 248 1068 l 414 1253 l 490 1253 z "},"Ü":{"ha":901,"x_min":95,"x_max":810,"o":"m 680 987 l 810 987 l 810 319 q 760 134 810 208 q 629 23 711 60 q 452 -14 547 -14 q 270 23 351 -14 q 142 134 189 60 q 95 319 95 208 l 95 987 l 224 987 l 224 319 q 253 192 224 242 q 333 117 281 142 q 452 93 384 93 q 571 117 520 93 q 651 192 623 142 q 680 319 680 242 l 680 987 m 234 1141 q 253 1192 234 1171 q 308 1213 272 1213 q 363 1192 345 1213 q 382 1141 382 1171 q 363 1091 382 1112 q 308 1070 345 1070 q 253 1091 272 1070 q 234 1141 234 1112 m 526 1139 q 545 1191 526 1170 q 600 1212 564 1212 q 655 1191 636 1212 q 675 1139 675 1170 q 655 1089 675 1110 q 600 1069 636 1069 q 545 1089 564 1069 q 526 1139 526 1110 z "},"Ý":{"ha":834,"x_min":10,"x_max":822,"o":"m 160 987 l 416 492 l 673 987 l 822 987 l 481 369 l 481 0 l 351 0 l 351 369 l 10 987 l 160 987 m 350 1053 l 481 1252 l 633 1252 l 451 1053 l 350 1053 z "},"à":{"ha":755,"x_min":74,"x_max":680,"o":"m 528 125 l 528 503 q 511 579 528 547 q 459 629 494 611 q 374 646 425 646 q 291 630 326 646 q 235 587 255 614 q 215 530 215 561 l 90 530 q 110 608 90 570 q 169 679 130 647 q 261 729 207 710 q 381 747 315 747 q 523 720 461 747 q 619 638 584 693 q 654 502 654 584 l 654 160 q 660 82 654 123 q 680 11 667 41 l 680 0 l 549 0 q 534 58 539 22 q 528 125 528 94 m 550 445 l 551 357 l 425 357 q 329 348 371 357 q 258 323 287 340 q 215 280 230 306 q 200 221 200 255 q 216 158 200 186 q 263 113 231 130 q 340 96 294 96 q 442 121 398 96 q 512 180 486 145 q 541 249 538 216 l 594 189 q 568 125 589 160 q 512 59 547 91 q 430 7 477 28 q 322 -14 382 -14 q 192 16 248 -14 q 105 94 136 45 q 74 204 74 143 q 97 308 74 263 q 163 384 120 353 q 268 429 207 414 q 404 445 329 445 l 550 445 m 335 1042 l 466 842 l 358 842 l 183 1042 l 335 1042 z "},"á":{"ha":755,"x_min":74,"x_max":680,"o":"m 528 125 l 528 503 q 511 579 528 547 q 459 629 494 611 q 374 646 425 646 q 291 630 326 646 q 235 587 255 614 q 215 530 215 561 l 90 530 q 110 608 90 570 q 169 679 130 647 q 261 729 207 710 q 381 747 315 747 q 523 720 461 747 q 619 638 584 693 q 654 502 654 584 l 654 160 q 660 82 654 123 q 680 11 667 41 l 680 0 l 549 0 q 534 58 539 22 q 528 125 528 94 m 550 445 l 551 357 l 425 357 q 329 348 371 357 q 258 323 287 340 q 215 280 230 306 q 200 221 200 255 q 216 158 200 186 q 263 113 231 130 q 340 96 294 96 q 442 121 398 96 q 512 180 486 145 q 541 249 538 216 l 594 189 q 568 125 589 160 q 512 59 547 91 q 430 7 477 28 q 322 -14 382 -14 q 192 16 248 -14 q 105 94 136 45 q 74 204 74 143 q 97 308 74 263 q 163 384 120 353 q 268 429 207 414 q 404 445 329 445 l 550 445 m 326 842 l 457 1042 l 608 1042 l 427 842 l 326 842 z "},"â":{"ha":755,"x_min":74,"x_max":680,"o":"m 528 125 l 528 503 q 511 579 528 547 q 459 629 494 611 q 374 646 425 646 q 291 630 326 646 q 235 587 255 614 q 215 530 215 561 l 90 530 q 110 608 90 570 q 169 679 130 647 q 261 729 207 710 q 381 747 315 747 q 523 720 461 747 q 619 638 584 693 q 654 502 654 584 l 654 160 q 660 82 654 123 q 680 11 667 41 l 680 0 l 549 0 q 534 58 539 22 q 528 125 528 94 m 550 445 l 551 357 l 425 357 q 329 348 371 357 q 258 323 287 340 q 215 280 230 306 q 200 221 200 255 q 216 158 200 186 q 263 113 231 130 q 340 96 294 96 q 442 121 398 96 q 512 180 486 145 q 541 249 538 216 l 594 189 q 568 125 589 160 q 512 59 547 91 q 430 7 477 28 q 322 -14 382 -14 q 192 16 248 -14 q 105 94 136 45 q 74 204 74 143 q 97 308 74 263 q 163 384 120 353 q 268 429 207 414 q 404 445 329 445 l 550 445 m 433 1042 l 601 857 l 601 850 l 496 850 l 395 964 l 294 850 l 191 850 l 191 857 l 357 1042 l 433 1042 z "},"ã":{"ha":755,"x_min":74,"x_max":680,"o":"m 528 125 l 528 503 q 511 579 528 547 q 459 629 494 611 q 374 646 425 646 q 291 630 326 646 q 235 587 255 614 q 215 530 215 561 l 90 530 q 110 608 90 570 q 169 679 130 647 q 261 729 207 710 q 381 747 315 747 q 523 720 461 747 q 619 638 584 693 q 654 502 654 584 l 654 160 q 660 82 654 123 q 680 11 667 41 l 680 0 l 549 0 q 534 58 539 22 q 528 125 528 94 m 550 445 l 551 357 l 425 357 q 329 348 371 357 q 258 323 287 340 q 215 280 230 306 q 200 221 200 255 q 216 158 200 186 q 263 113 231 130 q 340 96 294 96 q 442 121 398 96 q 512 180 486 145 q 541 249 538 216 l 594 189 q 568 125 589 160 q 512 59 547 91 q 430 7 477 28 q 322 -14 382 -14 q 192 16 248 -14 q 105 94 136 45 q 74 204 74 143 q 97 308 74 263 q 163 384 120 353 q 268 429 207 414 q 404 445 329 445 l 550 445 m 551 1028 l 635 1021 q 616 934 635 971 q 563 876 596 897 q 489 856 530 856 q 432 866 454 856 q 392 888 410 876 q 355 910 374 901 q 307 920 336 920 q 259 899 279 920 q 240 845 240 877 l 155 849 q 175 936 155 899 q 227 995 194 974 q 301 1017 260 1017 q 352 1007 330 1017 q 394 984 374 997 q 435 962 414 972 q 483 952 456 952 q 531 974 511 952 q 551 1028 551 996 z "},"ä":{"ha":755,"x_min":74,"x_max":680,"o":"m 528 125 l 528 503 q 511 579 528 547 q 459 629 494 611 q 374 646 425 646 q 291 630 326 646 q 235 587 255 614 q 215 530 215 561 l 90 530 q 110 608 90 570 q 169 679 130 647 q 261 729 207 710 q 381 747 315 747 q 523 720 461 747 q 619 638 584 693 q 654 502 654 584 l 654 160 q 660 82 654 123 q 680 11 667 41 l 680 0 l 549 0 q 534 58 539 22 q 528 125 528 94 m 550 445 l 551 357 l 425 357 q 329 348 371 357 q 258 323 287 340 q 215 280 230 306 q 200 221 200 255 q 216 158 200 186 q 263 113 231 130 q 340 96 294 96 q 442 121 398 96 q 512 180 486 145 q 541 249 538 216 l 594 189 q 568 125 589 160 q 512 59 547 91 q 430 7 477 28 q 322 -14 382 -14 q 192 16 248 -14 q 105 94 136 45 q 74 204 74 143 q 97 308 74 263 q 163 384 120 353 q 268 429 207 414 q 404 445 329 445 l 550 445 m 176 930 q 195 981 176 960 q 250 1002 214 1002 q 306 981 287 1002 q 325 930 325 960 q 306 880 325 901 q 250 859 287 859 q 195 880 214 859 q 176 930 176 901 m 469 928 q 487 980 469 959 q 543 1001 506 1001 q 598 980 578 1001 q 617 928 617 959 q 598 879 617 899 q 543 858 578 858 q 487 879 506 858 q 469 928 469 899 z "},"å":{"ha":755,"x_min":74,"x_max":680,"o":"m 528 125 l 528 503 q 511 579 528 547 q 459 629 494 611 q 374 646 425 646 q 291 630 326 646 q 235 587 255 614 q 215 530 215 561 l 90 530 q 110 608 90 570 q 169 679 130 647 q 261 729 207 710 q 381 747 315 747 q 523 720 461 747 q 619 638 584 693 q 654 502 654 584 l 654 160 q 660 82 654 123 q 680 11 667 41 l 680 0 l 549 0 q 534 58 539 22 q 528 125 528 94 m 550 445 l 551 357 l 425 357 q 329 348 371 357 q 258 323 287 340 q 215 280 230 306 q 200 221 200 255 q 216 158 200 186 q 263 113 231 130 q 340 96 294 96 q 442 121 398 96 q 512 180 486 145 q 541 249 538 216 l 594 189 q 568 125 589 160 q 512 59 547 91 q 430 7 477 28 q 322 -14 382 -14 q 192 16 248 -14 q 105 94 136 45 q 74 204 74 143 q 97 308 74 263 q 163 384 120 353 q 268 429 207 414 q 404 445 329 445 l 550 445 m 249 963 q 268 1034 249 1002 q 320 1085 288 1066 q 395 1104 353 1104 q 498 1063 456 1104 q 541 963 541 1021 q 521 892 541 924 q 469 843 502 861 q 395 825 436 825 q 291 864 333 825 q 249 963 249 903 m 316 963 q 338 909 316 933 q 395 885 360 885 q 451 908 429 885 q 473 963 473 932 q 451 1019 473 995 q 395 1043 429 1043 q 338 1019 360 1043 q 316 963 316 995 z "},"ǻ":{"ha":755,"x_min":74,"x_max":680,"o":"m 528 125 l 528 503 q 511 579 528 547 q 459 629 494 611 q 374 646 425 646 q 291 630 326 646 q 235 587 255 614 q 215 530 215 561 l 90 530 q 110 608 90 570 q 169 679 130 647 q 261 729 207 710 q 381 747 315 747 q 523 720 461 747 q 619 638 584 693 q 654 502 654 584 l 654 160 q 660 82 654 123 q 680 11 667 41 l 680 0 l 549 0 q 534 58 539 22 q 528 125 528 94 m 550 445 l 551 357 l 425 357 q 329 348 371 357 q 258 323 287 340 q 215 280 230 306 q 200 221 200 255 q 216 158 200 186 q 263 113 231 130 q 340 96 294 96 q 442 121 398 96 q 512 180 486 145 q 541 249 538 216 l 594 189 q 568 125 589 160 q 512 59 547 91 q 430 7 477 28 q 322 -14 382 -14 q 192 16 248 -14 q 105 94 136 45 q 74 204 74 143 q 97 308 74 263 q 163 384 120 353 q 268 429 207 414 q 404 445 329 445 l 550 445 m 368 981 l 467 1105 l 595 1105 l 446 981 l 368 981 m 281 834 q 315 916 281 884 q 397 947 349 947 q 477 916 444 947 q 511 834 511 884 q 477 754 511 785 q 397 724 444 724 q 315 754 349 724 q 281 834 281 785 m 338 834 q 355 794 338 810 q 397 777 373 777 q 437 794 420 777 q 454 834 454 810 q 437 877 454 860 q 397 894 420 894 q 355 877 373 894 q 338 834 338 860 z "},"ç":{"ha":727,"x_min":63,"x_max":682,"o":"m 389 90 q 472 108 434 90 q 534 158 510 126 q 562 232 559 191 l 682 232 q 638 111 678 167 q 532 21 597 55 q 389 -14 467 -14 q 245 16 307 -14 q 143 96 184 45 q 83 213 103 146 q 63 353 63 279 l 63 381 q 83 521 63 455 q 143 638 103 587 q 245 718 184 689 q 389 747 307 747 q 540 712 475 747 q 641 617 604 677 q 682 481 678 557 l 562 481 q 537 564 559 527 q 477 622 515 600 q 389 644 439 644 q 293 622 332 644 q 231 561 254 599 q 198 476 208 522 q 189 381 189 429 l 189 353 q 198 258 189 304 q 230 173 208 211 q 292 112 253 135 q 389 90 331 90 m 320 -7 l 410 -7 l 402 -43 q 474 -75 441 -50 q 506 -160 506 -101 q 493 -218 506 -192 q 454 -263 479 -244 q 390 -292 428 -281 q 300 -302 351 -302 l 296 -229 q 352 -222 327 -229 q 393 -201 378 -216 q 408 -162 408 -186 q 397 -127 408 -140 q 361 -107 385 -114 q 299 -98 337 -101 l 320 -7 z "},"è":{"ha":736,"x_min":63,"x_max":686,"o":"m 400 -14 q 261 13 323 -14 q 155 86 199 39 q 87 199 111 134 q 63 341 63 264 l 63 370 q 90 529 63 459 q 161 648 116 600 q 264 722 207 697 q 384 747 322 747 q 520 720 463 747 q 614 645 577 693 q 668 531 650 596 q 686 388 686 465 l 686 332 l 138 332 l 138 434 l 560 434 l 560 444 q 540 538 557 492 q 486 614 523 585 q 384 644 448 644 q 305 626 341 644 q 243 573 269 608 q 203 487 218 538 q 189 370 189 436 l 189 341 q 204 243 189 289 q 247 163 218 197 q 315 109 275 128 q 407 89 355 89 q 519 116 473 89 q 600 189 566 143 l 676 128 q 616 60 652 92 q 526 7 579 27 q 400 -14 473 -14 m 323 1042 l 454 842 l 347 842 l 172 1042 l 323 1042 z "},"é":{"ha":736,"x_min":63,"x_max":686,"o":"m 400 -14 q 261 13 323 -14 q 155 86 199 39 q 87 199 111 134 q 63 341 63 264 l 63 370 q 90 529 63 459 q 161 648 116 600 q 264 722 207 697 q 384 747 322 747 q 520 720 463 747 q 614 645 577 693 q 668 531 650 596 q 686 388 686 465 l 686 332 l 138 332 l 138 434 l 560 434 l 560 444 q 540 538 557 492 q 486 614 523 585 q 384 644 448 644 q 305 626 341 644 q 243 573 269 608 q 203 487 218 538 q 189 370 189 436 l 189 341 q 204 243 189 289 q 247 163 218 197 q 315 109 275 128 q 407 89 355 89 q 519 116 473 89 q 600 189 566 143 l 676 128 q 616 60 652 92 q 526 7 579 27 q 400 -14 473 -14 m 314 842 l 446 1042 l 597 1042 l 415 842 l 314 842 z "},"ê":{"ha":736,"x_min":63,"x_max":686,"o":"m 400 -14 q 261 13 323 -14 q 155 86 199 39 q 87 199 111 134 q 63 341 63 264 l 63 370 q 90 529 63 459 q 161 648 116 600 q 264 722 207 697 q 384 747 322 747 q 520 720 463 747 q 614 645 577 693 q 668 531 650 596 q 686 388 686 465 l 686 332 l 138 332 l 138 434 l 560 434 l 560 444 q 540 538 557 492 q 486 614 523 585 q 384 644 448 644 q 305 626 341 644 q 243 573 269 608 q 203 487 218 538 q 189 370 189 436 l 189 341 q 204 243 189 289 q 247 163 218 197 q 315 109 275 128 q 407 89 355 89 q 519 116 473 89 q 600 189 566 143 l 676 128 q 616 60 652 92 q 526 7 579 27 q 400 -14 473 -14 m 421 1042 l 589 857 l 589 850 l 485 850 l 383 964 l 282 850 l 179 850 l 179 857 l 345 1042 l 421 1042 z "},"ë":{"ha":736,"x_min":63,"x_max":686,"o":"m 400 -14 q 261 13 323 -14 q 155 86 199 39 q 87 199 111 134 q 63 341 63 264 l 63 370 q 90 529 63 459 q 161 648 116 600 q 264 722 207 697 q 384 747 322 747 q 520 720 463 747 q 614 645 577 693 q 668 531 650 596 q 686 388 686 465 l 686 332 l 138 332 l 138 434 l 560 434 l 560 444 q 540 538 557 492 q 486 614 523 585 q 384 644 448 644 q 305 626 341 644 q 243 573 269 608 q 203 487 218 538 q 189 370 189 436 l 189 341 q 204 243 189 289 q 247 163 218 197 q 315 109 275 128 q 407 89 355 89 q 519 116 473 89 q 600 189 566 143 l 676 128 q 616 60 652 92 q 526 7 579 27 q 400 -14 473 -14 m 165 930 q 184 981 165 960 q 239 1002 203 1002 q 294 981 275 1002 q 313 930 313 960 q 294 880 313 901 q 239 859 275 859 q 184 880 203 859 q 165 930 165 901 m 457 928 q 476 980 457 959 q 531 1001 494 1001 q 586 980 567 1001 q 606 928 606 959 q 586 879 606 899 q 531 858 567 858 q 476 879 494 858 q 457 928 457 899 z "},"ì":{"ha":344,"x_min":-41,"x_max":242,"o":"m 231 734 l 231 0 l 106 0 l 106 734 l 231 734 m 111 1040 l 242 841 l 134 841 l -41 1040 l 111 1040 z "},"í":{"ha":344,"x_min":102,"x_max":385,"o":"m 231 734 l 231 0 l 106 0 l 106 734 l 231 734 m 102 841 l 233 1040 l 385 1040 l 203 841 l 102 841 z "},"î":{"ha":344,"x_min":-33,"x_max":377,"o":"m 231 734 l 231 0 l 106 0 l 106 734 l 231 734 m 209 1040 l 377 855 l 377 848 l 273 848 l 171 963 l 70 848 l -33 848 l -33 856 l 133 1040 l 209 1040 z "},"ï":{"ha":344,"x_min":-47,"x_max":393,"o":"m 231 734 l 231 0 l 106 0 l 106 734 l 231 734 m -47 928 q -28 980 -47 959 q 26 1001 -9 1001 q 82 980 63 1001 q 101 928 101 959 q 82 879 101 899 q 26 858 63 858 q -28 879 -9 858 q -47 928 -47 899 m 245 927 q 263 979 245 958 q 319 1000 282 1000 q 374 979 355 1000 q 393 927 393 958 q 374 877 393 898 q 319 857 355 857 q 263 877 282 857 q 245 927 245 898 z "},"ñ":{"ha":767,"x_min":96,"x_max":673,"o":"m 221 577 l 221 0 l 96 0 l 96 734 l 214 734 l 221 577 m 191 395 l 139 397 q 161 536 140 472 q 222 648 183 600 q 316 721 262 695 q 437 747 371 747 q 535 733 492 747 q 609 686 578 718 q 656 604 640 654 q 673 481 673 553 l 673 0 l 547 0 l 547 482 q 530 575 547 540 q 480 626 513 610 q 400 642 448 642 q 315 622 353 642 q 249 568 277 602 q 207 489 222 533 q 191 395 191 444 m 545 1028 l 629 1021 q 610 934 629 971 q 557 876 590 897 q 483 856 524 856 q 426 866 448 856 q 386 888 404 876 q 349 910 368 901 q 301 920 330 920 q 253 899 273 920 q 234 845 234 877 l 149 849 q 169 936 149 899 q 221 995 188 974 q 295 1017 254 1017 q 346 1007 324 1017 q 388 984 368 997 q 429 962 408 972 q 477 952 450 952 q 525 974 505 952 q 545 1028 545 996 z "},"ò":{"ha":792,"x_min":62,"x_max":730,"o":"m 62 359 l 62 374 q 85 522 62 454 q 152 641 109 590 q 257 719 195 691 q 395 747 319 747 q 535 719 473 747 q 641 641 597 691 q 707 522 684 590 q 730 374 730 454 l 730 359 q 707 212 730 279 q 641 93 684 144 q 535 15 597 43 q 397 -14 474 -14 q 258 15 319 -14 q 152 93 196 43 q 85 212 109 144 q 62 359 62 279 m 188 374 l 188 359 q 201 255 188 304 q 240 170 214 207 q 305 111 266 132 q 397 90 345 90 q 487 111 448 90 q 552 170 526 132 q 591 255 578 207 q 604 359 604 304 l 604 374 q 591 477 604 429 q 552 563 578 526 q 487 623 526 601 q 395 644 448 644 q 305 623 344 644 q 240 563 266 601 q 201 477 214 526 q 188 374 188 429 m 330 1042 l 461 842 l 353 842 l 178 1042 l 330 1042 z "},"ó":{"ha":792,"x_min":62,"x_max":730,"o":"m 62 359 l 62 374 q 85 522 62 454 q 152 641 109 590 q 257 719 195 691 q 395 747 319 747 q 535 719 473 747 q 641 641 597 691 q 707 522 684 590 q 730 374 730 454 l 730 359 q 707 212 730 279 q 641 93 684 144 q 535 15 597 43 q 397 -14 474 -14 q 258 15 319 -14 q 152 93 196 43 q 85 212 109 144 q 62 359 62 279 m 188 374 l 188 359 q 201 255 188 304 q 240 170 214 207 q 305 111 266 132 q 397 90 345 90 q 487 111 448 90 q 552 170 526 132 q 591 255 578 207 q 604 359 604 304 l 604 374 q 591 477 604 429 q 552 563 578 526 q 487 623 526 601 q 395 644 448 644 q 305 623 344 644 q 240 563 266 601 q 201 477 214 526 q 188 374 188 429 m 321 842 l 452 1042 l 604 1042 l 422 842 l 321 842 z "},"ô":{"ha":792,"x_min":62,"x_max":730,"o":"m 62 359 l 62 374 q 85 522 62 454 q 152 641 109 590 q 257 719 195 691 q 395 747 319 747 q 535 719 473 747 q 641 641 597 691 q 707 522 684 590 q 730 374 730 454 l 730 359 q 707 212 730 279 q 641 93 684 144 q 535 15 597 43 q 397 -14 474 -14 q 258 15 319 -14 q 152 93 196 43 q 85 212 109 144 q 62 359 62 279 m 188 374 l 188 359 q 201 255 188 304 q 240 170 214 207 q 305 111 266 132 q 397 90 345 90 q 487 111 448 90 q 552 170 526 132 q 591 255 578 207 q 604 359 604 304 l 604 374 q 591 477 604 429 q 552 563 578 526 q 487 623 526 601 q 395 644 448 644 q 305 623 344 644 q 240 563 266 601 q 201 477 214 526 q 188 374 188 429 m 428 1042 l 596 857 l 596 850 l 492 850 l 390 964 l 289 850 l 186 850 l 186 857 l 352 1042 l 428 1042 z "},"õ":{"ha":792,"x_min":62,"x_max":730,"o":"m 62 359 l 62 374 q 85 522 62 454 q 152 641 109 590 q 257 719 195 691 q 395 747 319 747 q 535 719 473 747 q 641 641 597 691 q 707 522 684 590 q 730 374 730 454 l 730 359 q 707 212 730 279 q 641 93 684 144 q 535 15 597 43 q 397 -14 474 -14 q 258 15 319 -14 q 152 93 196 43 q 85 212 109 144 q 62 359 62 279 m 188 374 l 188 359 q 201 255 188 304 q 240 170 214 207 q 305 111 266 132 q 397 90 345 90 q 487 111 448 90 q 552 170 526 132 q 591 255 578 207 q 604 359 604 304 l 604 374 q 591 477 604 429 q 552 563 578 526 q 487 623 526 601 q 395 644 448 644 q 305 623 344 644 q 240 563 266 601 q 201 477 214 526 q 188 374 188 429 m 546 1028 l 631 1021 q 611 934 631 971 q 558 876 591 897 q 484 856 526 856 q 427 866 450 856 q 387 888 405 876 q 350 910 370 901 q 302 920 331 920 q 255 899 274 920 q 235 845 235 877 l 151 849 q 170 936 151 899 q 222 995 189 974 q 296 1017 256 1017 q 348 1007 326 1017 q 389 984 370 997 q 430 962 409 972 q 478 952 451 952 q 526 974 507 952 q 546 1028 546 996 z "},"ö":{"ha":792,"x_min":62,"x_max":730,"o":"m 62 359 l 62 374 q 85 522 62 454 q 152 641 109 590 q 257 719 195 691 q 395 747 319 747 q 535 719 473 747 q 641 641 597 691 q 707 522 684 590 q 730 374 730 454 l 730 359 q 707 212 730 279 q 641 93 684 144 q 535 15 597 43 q 397 -14 474 -14 q 258 15 319 -14 q 152 93 196 43 q 85 212 109 144 q 62 359 62 279 m 188 374 l 188 359 q 201 255 188 304 q 240 170 214 207 q 305 111 266 132 q 397 90 345 90 q 487 111 448 90 q 552 170 526 132 q 591 255 578 207 q 604 359 604 304 l 604 374 q 591 477 604 429 q 552 563 578 526 q 487 623 526 601 q 395 644 448 644 q 305 623 344 644 q 240 563 266 601 q 201 477 214 526 q 188 374 188 429 m 172 930 q 191 981 172 960 q 245 1002 210 1002 q 301 981 282 1002 q 320 930 320 960 q 301 880 320 901 q 245 859 282 859 q 191 880 210 859 q 172 930 172 901 m 464 928 q 483 980 464 959 q 538 1001 501 1001 q 593 980 574 1001 q 612 928 612 959 q 593 879 612 899 q 538 858 574 858 q 483 879 501 858 q 464 928 464 899 z "},"ù":{"ha":766,"x_min":93,"x_max":671,"o":"m 545 170 l 545 734 l 671 734 l 671 0 l 551 0 l 545 170 m 568 324 l 621 326 q 605 190 621 252 q 556 83 590 128 q 467 12 522 37 q 334 -14 412 -14 q 236 2 280 -14 q 159 50 191 18 q 110 135 127 83 q 93 260 93 187 l 93 734 l 218 734 l 218 259 q 230 177 218 210 q 260 126 241 145 q 303 100 279 108 q 353 93 328 93 q 480 124 433 93 q 548 207 527 155 q 568 324 568 260 m 325 1042 l 456 842 l 348 842 l 173 1042 l 325 1042 z "},"ú":{"ha":766,"x_min":93,"x_max":671,"o":"m 545 170 l 545 734 l 671 734 l 671 0 l 551 0 l 545 170 m 568 324 l 621 326 q 605 190 621 252 q 556 83 590 128 q 467 12 522 37 q 334 -14 412 -14 q 236 2 280 -14 q 159 50 191 18 q 110 135 127 83 q 93 260 93 187 l 93 734 l 218 734 l 218 259 q 230 177 218 210 q 260 126 241 145 q 303 100 279 108 q 353 93 328 93 q 480 124 433 93 q 548 207 527 155 q 568 324 568 260 m 315 842 l 447 1042 l 598 1042 l 416 842 l 315 842 z "},"û":{"ha":766,"x_min":93,"x_max":671,"o":"m 545 170 l 545 734 l 671 734 l 671 0 l 551 0 l 545 170 m 568 324 l 621 326 q 605 190 621 252 q 556 83 590 128 q 467 12 522 37 q 334 -14 412 -14 q 236 2 280 -14 q 159 50 191 18 q 110 135 127 83 q 93 260 93 187 l 93 734 l 218 734 l 218 259 q 230 177 218 210 q 260 126 241 145 q 303 100 279 108 q 353 93 328 93 q 480 124 433 93 q 548 207 527 155 q 568 324 568 260 m 422 1042 l 591 857 l 591 850 l 486 850 l 385 964 l 283 850 l 180 850 l 180 857 l 347 1042 l 422 1042 z "},"ü":{"ha":766,"x_min":93,"x_max":671,"o":"m 545 170 l 545 734 l 671 734 l 671 0 l 551 0 l 545 170 m 568 324 l 621 326 q 605 190 621 252 q 556 83 590 128 q 467 12 522 37 q 334 -14 412 -14 q 236 2 280 -14 q 159 50 191 18 q 110 135 127 83 q 93 260 93 187 l 93 734 l 218 734 l 218 259 q 230 177 218 210 q 260 126 241 145 q 303 100 279 108 q 353 93 328 93 q 480 124 433 93 q 548 207 527 155 q 568 324 568 260 m 166 930 q 185 981 166 960 q 240 1002 204 1002 q 296 981 277 1002 q 315 930 315 960 q 296 880 315 901 q 240 859 277 859 q 185 880 204 859 q 166 930 166 901 m 458 928 q 477 980 458 959 q 532 1001 496 1001 q 588 980 568 1001 q 607 928 607 959 q 588 879 607 899 q 532 858 568 858 q 477 879 496 858 q 458 928 458 899 z "},"ý":{"ha":657,"x_min":15,"x_max":640,"o":"m 302 76 l 506 734 l 640 734 l 346 -113 q 319 -172 336 -140 q 277 -232 302 -203 q 215 -278 251 -260 q 128 -296 178 -296 q 90 -292 113 -296 q 58 -286 67 -288 l 57 -184 q 74 -185 62 -184 q 91 -186 86 -186 q 163 -175 134 -186 q 214 -138 193 -164 q 250 -66 235 -112 l 302 76 m 152 734 l 342 164 l 375 32 l 285 -14 l 15 734 l 152 734 m 275 842 l 407 1042 l 558 1042 l 376 842 l 275 842 z "},"ÿ":{"ha":657,"x_min":15,"x_max":640,"o":"m 302 76 l 506 734 l 640 734 l 346 -113 q 319 -172 336 -140 q 277 -232 302 -203 q 215 -278 251 -260 q 128 -296 178 -296 q 90 -292 113 -296 q 58 -286 67 -288 l 57 -184 q 74 -185 62 -184 q 91 -186 86 -186 q 163 -175 134 -186 q 214 -138 193 -164 q 250 -66 235 -112 l 302 76 m 152 734 l 342 164 l 375 32 l 285 -14 l 15 734 l 152 734 m 126 930 q 145 981 126 960 q 200 1002 164 1002 q 256 981 237 1002 q 275 930 275 960 q 256 880 275 901 q 200 859 237 859 q 145 880 164 859 q 126 930 126 901 m 418 928 q 437 980 418 959 q 492 1001 456 1001 q 548 980 528 1001 q 567 928 567 959 q 548 879 567 899 q 492 858 528 858 q 437 879 456 858 q 418 928 418 899 z "},"Ā":{"ha":906,"x_min":20,"x_max":888,"o":"m 480 900 l 153 0 l 20 0 l 396 987 l 482 987 l 480 900 m 754 0 l 427 900 l 425 987 l 511 987 l 888 0 l 754 0 m 737 366 l 737 258 l 182 258 l 182 366 l 737 366 m 687 1196 l 687 1100 l 232 1100 l 232 1196 l 687 1196 z "},"ā":{"ha":755,"x_min":74,"x_max":680,"o":"m 528 125 l 528 503 q 511 579 528 547 q 459 629 494 611 q 374 646 425 646 q 291 630 326 646 q 235 587 255 614 q 215 530 215 561 l 90 530 q 110 608 90 570 q 169 679 130 647 q 261 729 207 710 q 381 747 315 747 q 523 720 461 747 q 619 638 584 693 q 654 502 654 584 l 654 160 q 660 82 654 123 q 680 11 667 41 l 680 0 l 549 0 q 534 58 539 22 q 528 125 528 94 m 550 445 l 551 357 l 425 357 q 329 348 371 357 q 258 323 287 340 q 215 280 230 306 q 200 221 200 255 q 216 158 200 186 q 263 113 231 130 q 340 96 294 96 q 442 121 398 96 q 512 180 486 145 q 541 249 538 216 l 594 189 q 568 125 589 160 q 512 59 547 91 q 430 7 477 28 q 322 -14 382 -14 q 192 16 248 -14 q 105 94 136 45 q 74 204 74 143 q 97 308 74 263 q 163 384 120 353 q 268 429 207 414 q 404 445 329 445 l 550 445 m 626 985 l 626 889 l 171 889 l 171 985 l 626 985 z "},"Ă":{"ha":906,"x_min":20,"x_max":888,"o":"m 480 900 l 153 0 l 20 0 l 396 987 l 482 987 l 480 900 m 754 0 l 427 900 l 425 987 l 511 987 l 888 0 l 754 0 m 737 366 l 737 258 l 182 258 l 182 366 l 737 366 m 557 1225 l 659 1225 q 634 1131 659 1172 q 564 1067 610 1090 q 456 1044 519 1044 q 308 1094 362 1044 q 253 1225 253 1145 l 355 1225 q 378 1154 355 1185 q 456 1124 401 1124 q 534 1154 511 1124 q 557 1225 557 1185 z "},"ă":{"ha":755,"x_min":74,"x_max":680,"o":"m 528 125 l 528 503 q 511 579 528 547 q 459 629 494 611 q 374 646 425 646 q 291 630 326 646 q 235 587 255 614 q 215 530 215 561 l 90 530 q 110 608 90 570 q 169 679 130 647 q 261 729 207 710 q 381 747 315 747 q 523 720 461 747 q 619 638 584 693 q 654 502 654 584 l 654 160 q 660 82 654 123 q 680 11 667 41 l 680 0 l 549 0 q 534 58 539 22 q 528 125 528 94 m 550 445 l 551 357 l 425 357 q 329 348 371 357 q 258 323 287 340 q 215 280 230 306 q 200 221 200 255 q 216 158 200 186 q 263 113 231 130 q 340 96 294 96 q 442 121 398 96 q 512 180 486 145 q 541 249 538 216 l 594 189 q 568 125 589 160 q 512 59 547 91 q 430 7 477 28 q 322 -14 382 -14 q 192 16 248 -14 q 105 94 136 45 q 74 204 74 143 q 97 308 74 263 q 163 384 120 353 q 268 429 207 414 q 404 445 329 445 l 550 445 m 496 1014 l 597 1014 q 573 920 597 961 q 503 856 549 879 q 395 833 458 833 q 247 883 301 833 q 192 1014 192 934 l 294 1014 q 317 943 294 974 q 395 913 340 913 q 473 943 450 913 q 496 1014 496 974 z "},"Ą":{"ha":906,"x_min":20,"x_max":888,"o":"m 480 900 l 153 0 l 20 0 l 396 987 l 482 987 l 480 900 m 754 0 l 427 900 l 425 987 l 511 987 l 888 0 l 754 0 m 737 366 l 737 258 l 182 258 l 182 366 l 737 366 m 812 39 l 863 0 q 807 -45 833 -22 q 764 -95 781 -68 q 747 -151 747 -121 q 759 -186 747 -173 q 800 -200 770 -200 q 840 -194 822 -200 q 867 -182 857 -187 l 877 -264 q 834 -284 860 -275 q 768 -294 808 -294 q 675 -261 713 -294 q 637 -165 637 -229 q 655 -92 637 -128 q 712 -23 673 -56 q 812 39 751 10 z "},"ą":{"ha":755,"x_min":74,"x_max":680,"o":"m 528 125 l 528 503 q 511 579 528 547 q 459 629 494 611 q 374 646 425 646 q 291 630 326 646 q 235 587 255 614 q 215 530 215 561 l 90 530 q 110 608 90 570 q 169 679 130 647 q 261 729 207 710 q 381 747 315 747 q 523 720 461 747 q 619 638 584 693 q 654 502 654 584 l 654 160 q 660 82 654 123 q 680 11 667 41 l 680 0 l 549 0 q 534 58 539 22 q 528 125 528 94 m 550 445 l 551 357 l 425 357 q 329 348 371 357 q 258 323 287 340 q 215 280 230 306 q 200 221 200 255 q 216 158 200 186 q 263 113 231 130 q 340 96 294 96 q 442 121 398 96 q 512 180 486 145 q 541 249 538 216 l 594 189 q 568 125 589 160 q 512 59 547 91 q 430 7 477 28 q 322 -14 382 -14 q 192 16 248 -14 q 105 94 136 45 q 74 204 74 143 q 97 308 74 263 q 163 384 120 353 q 268 429 207 414 q 404 445 329 445 l 550 445 m 608 39 l 658 0 q 602 -45 629 -22 q 559 -95 576 -68 q 542 -151 542 -121 q 554 -186 542 -173 q 595 -200 566 -200 q 635 -194 617 -200 q 663 -182 652 -187 l 672 -264 q 629 -284 655 -275 q 563 -294 603 -294 q 470 -261 508 -294 q 433 -165 433 -229 q 451 -92 433 -128 q 507 -23 469 -56 q 608 39 546 10 z "},"Ć":{"ha":904,"x_min":81,"x_max":841,"o":"m 711 314 l 841 314 q 787 146 831 220 q 665 30 744 73 q 467 -14 585 -14 q 309 19 380 -14 q 187 112 238 52 q 109 256 136 172 q 81 444 81 340 l 81 543 q 109 731 81 646 q 188 876 136 815 q 313 968 240 936 q 478 1001 387 1001 q 667 959 590 1001 q 788 843 745 917 q 841 671 831 768 l 711 671 q 675 790 701 740 q 602 867 650 840 q 478 894 555 894 q 362 869 412 894 q 279 798 313 844 q 229 687 245 751 q 212 544 212 623 l 212 444 q 227 308 212 372 q 273 196 242 244 q 353 120 304 148 q 467 93 401 93 q 600 119 550 93 q 674 195 649 146 q 711 314 700 245 m 392 1075 l 524 1274 l 675 1274 l 493 1075 l 392 1075 z "},"ć":{"ha":727,"x_min":63,"x_max":682,"o":"m 389 90 q 472 108 434 90 q 534 158 510 126 q 562 232 559 191 l 682 232 q 638 111 678 167 q 532 21 597 55 q 389 -14 467 -14 q 245 16 307 -14 q 143 96 184 45 q 83 213 103 146 q 63 353 63 279 l 63 381 q 83 521 63 455 q 143 638 103 587 q 245 718 184 689 q 389 747 307 747 q 540 712 475 747 q 641 617 604 677 q 682 481 678 557 l 562 481 q 537 564 559 527 q 477 622 515 600 q 389 644 439 644 q 293 622 332 644 q 231 561 254 599 q 198 476 208 522 q 189 381 189 429 l 189 353 q 198 258 189 304 q 230 173 208 211 q 292 112 253 135 q 389 90 331 90 m 292 842 l 424 1042 l 575 1042 l 393 842 l 292 842 z "},"Ĉ":{"ha":904,"x_min":81,"x_max":841,"o":"m 711 314 l 841 314 q 787 146 831 220 q 665 30 744 73 q 467 -14 585 -14 q 309 19 380 -14 q 187 112 238 52 q 109 256 136 172 q 81 444 81 340 l 81 543 q 109 731 81 646 q 188 876 136 815 q 313 968 240 936 q 478 1001 387 1001 q 667 959 590 1001 q 788 843 745 917 q 841 671 831 768 l 711 671 q 675 790 701 740 q 602 867 650 840 q 478 894 555 894 q 362 869 412 894 q 279 798 313 844 q 229 687 245 751 q 212 544 212 623 l 212 444 q 227 308 212 372 q 273 196 242 244 q 353 120 304 148 q 467 93 401 93 q 600 119 550 93 q 674 195 649 146 q 711 314 700 245 m 499 1274 l 667 1089 l 667 1082 l 563 1082 l 461 1197 l 360 1082 l 257 1082 l 257 1090 l 423 1274 l 499 1274 z "},"ĉ":{"ha":727,"x_min":63,"x_max":682,"o":"m 389 90 q 472 108 434 90 q 534 158 510 126 q 562 232 559 191 l 682 232 q 638 111 678 167 q 532 21 597 55 q 389 -14 467 -14 q 245 16 307 -14 q 143 96 184 45 q 83 213 103 146 q 63 353 63 279 l 63 381 q 83 521 63 455 q 143 638 103 587 q 245 718 184 689 q 389 747 307 747 q 540 712 475 747 q 641 617 604 677 q 682 481 678 557 l 562 481 q 537 564 559 527 q 477 622 515 600 q 389 644 439 644 q 293 622 332 644 q 231 561 254 599 q 198 476 208 522 q 189 381 189 429 l 189 353 q 198 258 189 304 q 230 173 208 211 q 292 112 253 135 q 389 90 331 90 m 399 1042 l 568 857 l 568 850 l 463 850 l 361 964 l 260 850 l 157 850 l 157 857 l 323 1042 l 399 1042 z "},"Ċ":{"ha":904,"x_min":81,"x_max":841,"o":"m 711 314 l 841 314 q 787 146 831 220 q 665 30 744 73 q 467 -14 585 -14 q 309 19 380 -14 q 187 112 238 52 q 109 256 136 172 q 81 444 81 340 l 81 543 q 109 731 81 646 q 188 876 136 815 q 313 968 240 936 q 478 1001 387 1001 q 667 959 590 1001 q 788 843 745 917 q 841 671 831 768 l 711 671 q 675 790 701 740 q 602 867 650 840 q 478 894 555 894 q 362 869 412 894 q 279 798 313 844 q 229 687 245 751 q 212 544 212 623 l 212 444 q 227 308 212 372 q 273 196 242 244 q 353 120 304 148 q 467 93 401 93 q 600 119 550 93 q 674 195 649 146 q 711 314 700 245 m 387 1160 q 406 1211 387 1190 q 461 1232 425 1232 q 516 1211 497 1232 q 536 1160 536 1190 q 516 1110 536 1131 q 461 1089 497 1089 q 406 1110 425 1089 q 387 1160 387 1131 z "},"ċ":{"ha":727,"x_min":63,"x_max":682,"o":"m 389 90 q 472 108 434 90 q 534 158 510 126 q 562 232 559 191 l 682 232 q 638 111 678 167 q 532 21 597 55 q 389 -14 467 -14 q 245 16 307 -14 q 143 96 184 45 q 83 213 103 146 q 63 353 63 279 l 63 381 q 83 521 63 455 q 143 638 103 587 q 245 718 184 689 q 389 747 307 747 q 540 712 475 747 q 641 617 604 677 q 682 481 678 557 l 562 481 q 537 564 559 527 q 477 622 515 600 q 389 644 439 644 q 293 622 332 644 q 231 561 254 599 q 198 476 208 522 q 189 381 189 429 l 189 353 q 198 258 189 304 q 230 173 208 211 q 292 112 253 135 q 389 90 331 90 m 288 928 q 306 979 288 958 q 361 1000 325 1000 q 417 979 397 1000 q 436 928 436 958 q 417 877 436 898 q 361 857 397 857 q 306 877 325 857 q 288 928 288 898 z "},"Č":{"ha":904,"x_min":81,"x_max":841,"o":"m 711 314 l 841 314 q 787 146 831 220 q 665 30 744 73 q 467 -14 585 -14 q 309 19 380 -14 q 187 112 238 52 q 109 256 136 172 q 81 444 81 340 l 81 543 q 109 731 81 646 q 188 876 136 815 q 313 968 240 936 q 478 1001 387 1001 q 667 959 590 1001 q 788 843 745 917 q 841 671 831 768 l 711 671 q 675 790 701 740 q 602 867 650 840 q 478 894 555 894 q 362 869 412 894 q 279 798 313 844 q 229 687 245 751 q 212 544 212 623 l 212 444 q 227 308 212 372 q 273 196 242 244 q 353 120 304 148 q 467 93 401 93 q 600 119 550 93 q 674 195 649 146 q 711 314 700 245 m 358 1274 l 460 1158 l 563 1274 l 671 1274 l 671 1267 l 499 1081 l 422 1081 l 252 1267 l 252 1274 l 358 1274 z "},"č":{"ha":727,"x_min":63,"x_max":682,"o":"m 389 90 q 472 108 434 90 q 534 158 510 126 q 562 232 559 191 l 682 232 q 638 111 678 167 q 532 21 597 55 q 389 -14 467 -14 q 245 16 307 -14 q 143 96 184 45 q 83 213 103 146 q 63 353 63 279 l 63 381 q 83 521 63 455 q 143 638 103 587 q 245 718 184 689 q 389 747 307 747 q 540 712 475 747 q 641 617 604 677 q 682 481 678 557 l 562 481 q 537 564 559 527 q 477 622 515 600 q 389 644 439 644 q 293 622 332 644 q 231 561 254 599 q 198 476 208 522 q 189 381 189 429 l 189 353 q 198 258 189 304 q 230 173 208 211 q 292 112 253 135 q 389 90 331 90 m 258 1041 l 361 926 l 463 1041 l 572 1041 l 572 1034 l 399 848 l 322 848 l 153 1034 l 153 1041 l 258 1041 z "},"Ď":{"ha":911,"x_min":115,"x_max":829,"o":"m 382 0 l 176 0 l 177 106 l 382 106 q 558 151 488 106 q 664 276 629 195 q 700 464 700 356 l 700 524 q 680 675 700 609 q 620 787 659 741 q 524 857 581 833 q 394 880 467 880 l 172 880 l 172 987 l 394 987 q 571 955 491 987 q 709 862 651 923 q 798 716 767 802 q 829 523 829 630 l 829 464 q 798 271 829 357 q 708 125 767 185 q 567 32 650 64 q 382 0 485 0 m 245 987 l 245 0 l 115 0 l 115 987 l 245 987 m 310 1259 l 412 1144 l 515 1259 l 623 1259 l 623 1253 l 451 1067 l 374 1067 l 204 1253 l 204 1259 l 310 1259 z "},"ď":{"ha":885,"x_min":64,"x_max":898,"o":"m 558 142 l 558 1042 l 684 1042 l 684 0 l 569 0 l 558 142 m 64 359 l 64 373 q 85 526 64 457 q 144 644 106 595 q 236 721 182 694 q 355 747 289 747 q 476 723 424 747 q 564 653 528 699 q 621 543 600 608 q 650 397 642 479 l 650 335 q 622 190 643 254 q 564 80 600 125 q 475 11 528 35 q 353 -14 423 -14 q 236 14 289 -14 q 144 92 182 42 q 85 211 106 142 q 64 359 64 279 m 191 373 l 191 359 q 202 256 191 304 q 237 171 213 208 q 297 114 260 134 q 385 93 334 93 q 487 119 447 93 q 552 189 528 146 q 590 283 576 233 l 590 447 q 567 519 582 484 q 527 582 551 554 q 468 625 503 609 q 386 642 433 642 q 297 620 334 642 q 237 562 260 599 q 202 476 213 525 q 191 373 191 428 m 898 1043 l 898 989 q 874 874 898 936 q 800 771 850 812 l 728 821 q 766 900 753 859 q 779 988 779 941 l 779 1043 l 898 1043 z "},"Ē":{"ha":789,"x_min":115,"x_max":742,"o":"m 742 106 l 742 0 l 219 0 l 219 106 l 742 106 m 245 987 l 245 0 l 115 0 l 115 987 l 245 987 m 673 563 l 673 456 l 219 456 l 219 563 l 673 563 m 735 987 l 735 880 l 219 880 l 219 987 l 735 987 m 651 1204 l 651 1107 l 196 1107 l 196 1204 l 651 1204 z "},"ē":{"ha":736,"x_min":63,"x_max":686,"o":"m 400 -14 q 261 13 323 -14 q 155 86 199 39 q 87 199 111 134 q 63 341 63 264 l 63 370 q 90 529 63 459 q 161 648 116 600 q 264 722 207 697 q 384 747 322 747 q 520 720 463 747 q 614 645 577 693 q 668 531 650 596 q 686 388 686 465 l 686 332 l 138 332 l 138 434 l 560 434 l 560 444 q 540 538 557 492 q 486 614 523 585 q 384 644 448 644 q 305 626 341 644 q 243 573 269 608 q 203 487 218 538 q 189 370 189 436 l 189 341 q 204 243 189 289 q 247 163 218 197 q 315 109 275 128 q 407 89 355 89 q 519 116 473 89 q 600 189 566 143 l 676 128 q 616 60 652 92 q 526 7 579 27 q 400 -14 473 -14 m 614 985 l 614 889 l 159 889 l 159 985 l 614 985 z "},"Ĕ":{"ha":789,"x_min":115,"x_max":742,"o":"m 742 106 l 742 0 l 219 0 l 219 106 l 742 106 m 245 987 l 245 0 l 115 0 l 115 987 l 245 987 m 673 563 l 673 456 l 219 456 l 219 563 l 673 563 m 735 987 l 735 880 l 219 880 l 219 987 l 735 987 m 521 1232 l 623 1232 q 598 1138 623 1179 q 528 1074 574 1097 q 420 1051 483 1051 q 272 1102 326 1051 q 217 1232 217 1152 l 319 1232 q 342 1162 319 1192 q 420 1131 365 1131 q 498 1162 475 1131 q 521 1232 521 1192 z "},"ĕ":{"ha":736,"x_min":63,"x_max":686,"o":"m 400 -14 q 261 13 323 -14 q 155 86 199 39 q 87 199 111 134 q 63 341 63 264 l 63 370 q 90 529 63 459 q 161 648 116 600 q 264 722 207 697 q 384 747 322 747 q 520 720 463 747 q 614 645 577 693 q 668 531 650 596 q 686 388 686 465 l 686 332 l 138 332 l 138 434 l 560 434 l 560 444 q 540 538 557 492 q 486 614 523 585 q 384 644 448 644 q 305 626 341 644 q 243 573 269 608 q 203 487 218 538 q 189 370 189 436 l 189 341 q 204 243 189 289 q 247 163 218 197 q 315 109 275 128 q 407 89 355 89 q 519 116 473 89 q 600 189 566 143 l 676 128 q 616 60 652 92 q 526 7 579 27 q 400 -14 473 -14 m 484 1014 l 586 1014 q 562 920 586 961 q 492 856 537 879 q 384 833 446 833 q 235 883 290 833 q 180 1014 180 934 l 282 1014 q 305 943 282 974 q 384 913 328 913 q 461 943 438 913 q 484 1014 484 974 z "},"Ė":{"ha":789,"x_min":115,"x_max":742,"o":"m 742 106 l 742 0 l 219 0 l 219 106 l 742 106 m 245 987 l 245 0 l 115 0 l 115 987 l 245 987 m 673 563 l 673 456 l 219 456 l 219 563 l 673 563 m 735 987 l 735 880 l 219 880 l 219 987 l 735 987 m 346 1146 q 365 1197 346 1176 q 420 1218 383 1218 q 475 1197 456 1218 q 494 1146 494 1176 q 475 1096 494 1116 q 420 1075 456 1075 q 365 1096 383 1075 q 346 1146 346 1116 z "},"ė":{"ha":736,"x_min":63,"x_max":686,"o":"m 400 -14 q 261 13 323 -14 q 155 86 199 39 q 87 199 111 134 q 63 341 63 264 l 63 370 q 90 529 63 459 q 161 648 116 600 q 264 722 207 697 q 384 747 322 747 q 520 720 463 747 q 614 645 577 693 q 668 531 650 596 q 686 388 686 465 l 686 332 l 138 332 l 138 434 l 560 434 l 560 444 q 540 538 557 492 q 486 614 523 585 q 384 644 448 644 q 305 626 341 644 q 243 573 269 608 q 203 487 218 538 q 189 370 189 436 l 189 341 q 204 243 189 289 q 247 163 218 197 q 315 109 275 128 q 407 89 355 89 q 519 116 473 89 q 600 189 566 143 l 676 128 q 616 60 652 92 q 526 7 579 27 q 400 -14 473 -14 m 309 928 q 328 979 309 958 q 383 1000 347 1000 q 438 979 419 1000 q 458 928 458 958 q 438 877 458 898 q 383 857 419 857 q 328 877 347 857 q 309 928 309 898 z "},"Ę":{"ha":789,"x_min":115,"x_max":742,"o":"m 742 106 l 742 0 l 219 0 l 219 106 l 742 106 m 245 987 l 245 0 l 115 0 l 115 987 l 245 987 m 673 563 l 673 456 l 219 456 l 219 563 l 673 563 m 735 987 l 735 880 l 219 880 l 219 987 l 735 987 m 643 39 l 693 0 q 637 -45 664 -22 q 594 -95 611 -68 q 577 -151 577 -121 q 589 -186 577 -173 q 630 -200 601 -200 q 670 -194 652 -200 q 698 -182 688 -187 l 707 -264 q 664 -284 690 -275 q 598 -294 638 -294 q 506 -261 543 -294 q 468 -165 468 -229 q 486 -92 468 -128 q 543 -23 504 -56 q 643 39 581 10 z "},"ę":{"ha":736,"x_min":63,"x_max":686,"o":"m 400 -14 q 261 13 323 -14 q 155 86 199 39 q 87 199 111 134 q 63 341 63 264 l 63 370 q 90 529 63 459 q 161 648 116 600 q 264 722 207 697 q 384 747 322 747 q 520 720 463 747 q 614 645 577 693 q 668 531 650 596 q 686 388 686 465 l 686 332 l 138 332 l 138 434 l 560 434 l 560 444 q 540 538 557 492 q 486 614 523 585 q 384 644 448 644 q 305 626 341 644 q 243 573 269 608 q 203 487 218 538 q 189 370 189 436 l 189 341 q 204 243 189 289 q 247 163 218 197 q 315 109 275 128 q 407 89 355 89 q 519 116 473 89 q 600 189 566 143 l 676 128 q 616 60 652 92 q 526 7 579 27 q 400 -14 473 -14 m 500 56 l 551 18 q 495 -27 522 -4 q 452 -77 469 -51 q 435 -133 435 -103 q 447 -169 435 -155 q 488 -182 458 -182 q 528 -176 510 -182 q 555 -164 545 -170 l 565 -247 q 522 -267 548 -257 q 456 -277 496 -277 q 363 -244 401 -277 q 326 -147 326 -211 q 343 -75 326 -111 q 400 -5 361 -39 q 500 56 439 28 z "},"Ě":{"ha":789,"x_min":115,"x_max":742,"o":"m 742 106 l 742 0 l 219 0 l 219 106 l 742 106 m 245 987 l 245 0 l 115 0 l 115 987 l 245 987 m 673 563 l 673 456 l 219 456 l 219 563 l 673 563 m 735 987 l 735 880 l 219 880 l 219 987 l 735 987 m 317 1259 l 419 1144 l 522 1259 l 630 1259 l 630 1253 l 458 1067 l 380 1067 l 211 1253 l 211 1259 l 317 1259 z "},"ě":{"ha":736,"x_min":63,"x_max":686,"o":"m 400 -14 q 261 13 323 -14 q 155 86 199 39 q 87 199 111 134 q 63 341 63 264 l 63 370 q 90 529 63 459 q 161 648 116 600 q 264 722 207 697 q 384 747 322 747 q 520 720 463 747 q 614 645 577 693 q 668 531 650 596 q 686 388 686 465 l 686 332 l 138 332 l 138 434 l 560 434 l 560 444 q 540 538 557 492 q 486 614 523 585 q 384 644 448 644 q 305 626 341 644 q 243 573 269 608 q 203 487 218 538 q 189 370 189 436 l 189 341 q 204 243 189 289 q 247 163 218 197 q 315 109 275 128 q 407 89 355 89 q 519 116 473 89 q 600 189 566 143 l 676 128 q 616 60 652 92 q 526 7 579 27 q 400 -14 473 -14 m 280 1041 l 382 926 l 485 1041 l 593 1041 l 593 1034 l 421 848 l 344 848 l 174 1034 l 174 1041 l 280 1041 z "},"Ĝ":{"ha":946,"x_min":83,"x_max":844,"o":"m 844 492 l 844 130 q 786 70 826 103 q 676 11 746 36 q 495 -14 606 -14 q 329 18 405 -14 q 198 110 254 50 q 113 258 143 171 q 83 456 83 345 l 83 532 q 109 730 83 643 q 186 877 135 817 q 311 969 237 938 q 480 1001 385 1001 q 670 962 593 1001 q 789 854 746 923 q 844 699 832 786 l 713 699 q 679 796 705 752 q 604 867 652 840 q 480 894 556 894 q 361 869 412 894 q 279 797 311 844 q 230 684 246 750 q 214 534 214 617 l 214 456 q 234 303 214 370 q 292 189 254 236 q 381 117 329 142 q 496 93 433 93 q 609 105 566 93 q 677 133 652 117 q 714 165 701 150 l 714 386 l 486 386 l 486 492 l 844 492 m 494 1274 l 662 1089 l 662 1082 l 557 1082 l 456 1197 l 355 1082 l 252 1082 l 252 1090 l 418 1274 l 494 1274 z "},"ĝ":{"ha":780,"x_min":66,"x_max":685,"o":"m 571 734 l 685 734 l 685 16 q 646 -150 685 -81 q 536 -254 606 -218 q 374 -290 466 -290 q 285 -278 336 -290 q 185 -238 234 -266 q 102 -162 136 -210 l 168 -87 q 265 -165 214 -143 q 365 -186 315 -186 q 468 -164 425 -186 q 535 -98 511 -142 q 559 9 559 -54 l 559 572 l 571 734 m 66 359 l 66 373 q 86 526 66 457 q 143 644 106 595 q 235 721 181 694 q 355 747 288 747 q 476 723 425 747 q 565 653 528 699 q 622 543 601 608 q 651 397 643 479 l 651 335 q 622 190 644 254 q 565 80 601 125 q 476 11 528 35 q 354 -14 424 -14 q 235 14 288 -14 q 144 92 182 42 q 86 211 106 142 q 66 359 66 279 m 191 373 l 191 359 q 202 256 191 304 q 237 171 214 208 q 297 114 260 134 q 385 93 334 93 q 488 119 447 93 q 552 189 528 146 q 590 283 576 233 l 590 447 q 567 519 583 484 q 528 582 552 554 q 469 625 504 609 q 386 642 433 642 q 297 620 334 642 q 237 562 260 599 q 202 476 214 525 q 191 373 191 428 m 415 1042 l 583 857 l 583 850 l 479 850 l 377 964 l 276 850 l 173 850 l 173 857 l 339 1042 l 415 1042 z "},"Ğ":{"ha":946,"x_min":83,"x_max":844,"o":"m 844 492 l 844 130 q 786 70 826 103 q 676 11 746 36 q 495 -14 606 -14 q 329 18 405 -14 q 198 110 254 50 q 113 258 143 171 q 83 456 83 345 l 83 532 q 109 730 83 643 q 186 877 135 817 q 311 969 237 938 q 480 1001 385 1001 q 670 962 593 1001 q 789 854 746 923 q 844 699 832 786 l 713 699 q 679 796 705 752 q 604 867 652 840 q 480 894 556 894 q 361 869 412 894 q 279 797 311 844 q 230 684 246 750 q 214 534 214 617 l 214 456 q 234 303 214 370 q 292 189 254 236 q 381 117 329 142 q 496 93 433 93 q 609 105 566 93 q 677 133 652 117 q 714 165 701 150 l 714 386 l 486 386 l 486 492 l 844 492 m 557 1246 l 659 1246 q 634 1153 659 1194 q 564 1088 610 1112 q 456 1065 519 1065 q 308 1116 362 1065 q 253 1246 253 1166 l 355 1246 q 378 1176 355 1206 q 456 1145 401 1145 q 534 1176 511 1145 q 557 1246 557 1206 z "},"ğ":{"ha":780,"x_min":66,"x_max":685,"o":"m 571 734 l 685 734 l 685 16 q 646 -150 685 -81 q 536 -254 606 -218 q 374 -290 466 -290 q 285 -278 336 -290 q 185 -238 234 -266 q 102 -162 136 -210 l 168 -87 q 265 -165 214 -143 q 365 -186 315 -186 q 468 -164 425 -186 q 535 -98 511 -142 q 559 9 559 -54 l 559 572 l 571 734 m 66 359 l 66 373 q 86 526 66 457 q 143 644 106 595 q 235 721 181 694 q 355 747 288 747 q 476 723 425 747 q 565 653 528 699 q 622 543 601 608 q 651 397 643 479 l 651 335 q 622 190 644 254 q 565 80 601 125 q 476 11 528 35 q 354 -14 424 -14 q 235 14 288 -14 q 144 92 182 42 q 86 211 106 142 q 66 359 66 279 m 191 373 l 191 359 q 202 256 191 304 q 237 171 214 208 q 297 114 260 134 q 385 93 334 93 q 488 119 447 93 q 552 189 528 146 q 590 283 576 233 l 590 447 q 567 519 583 484 q 528 582 552 554 q 469 625 504 609 q 386 642 433 642 q 297 620 334 642 q 237 562 260 599 q 202 476 214 525 q 191 373 191 428 m 478 1014 l 580 1014 q 555 920 580 961 q 486 856 531 879 q 378 833 440 833 q 229 883 283 833 q 174 1014 174 934 l 276 1014 q 299 943 276 974 q 378 913 322 913 q 455 943 432 913 q 478 1014 478 974 z "},"Ġ":{"ha":946,"x_min":83,"x_max":844,"o":"m 844 492 l 844 130 q 786 70 826 103 q 676 11 746 36 q 495 -14 606 -14 q 329 18 405 -14 q 198 110 254 50 q 113 258 143 171 q 83 456 83 345 l 83 532 q 109 730 83 643 q 186 877 135 817 q 311 969 237 938 q 480 1001 385 1001 q 670 962 593 1001 q 789 854 746 923 q 844 699 832 786 l 713 699 q 679 796 705 752 q 604 867 652 840 q 480 894 556 894 q 361 869 412 894 q 279 797 311 844 q 230 684 246 750 q 214 534 214 617 l 214 456 q 234 303 214 370 q 292 189 254 236 q 381 117 329 142 q 496 93 433 93 q 609 105 566 93 q 677 133 652 117 q 714 165 701 150 l 714 386 l 486 386 l 486 492 l 844 492 m 382 1160 q 400 1211 382 1190 q 456 1232 419 1232 q 511 1211 492 1232 q 530 1160 530 1190 q 511 1110 530 1131 q 456 1089 492 1089 q 400 1110 419 1089 q 382 1160 382 1131 z "},"ġ":{"ha":780,"x_min":66,"x_max":685,"o":"m 571 734 l 685 734 l 685 16 q 646 -150 685 -81 q 536 -254 606 -218 q 374 -290 466 -290 q 285 -278 336 -290 q 185 -238 234 -266 q 102 -162 136 -210 l 168 -87 q 265 -165 214 -143 q 365 -186 315 -186 q 468 -164 425 -186 q 535 -98 511 -142 q 559 9 559 -54 l 559 572 l 571 734 m 66 359 l 66 373 q 86 526 66 457 q 143 644 106 595 q 235 721 181 694 q 355 747 288 747 q 476 723 425 747 q 565 653 528 699 q 622 543 601 608 q 651 397 643 479 l 651 335 q 622 190 644 254 q 565 80 601 125 q 476 11 528 35 q 354 -14 424 -14 q 235 14 288 -14 q 144 92 182 42 q 86 211 106 142 q 66 359 66 279 m 191 373 l 191 359 q 202 256 191 304 q 237 171 214 208 q 297 114 260 134 q 385 93 334 93 q 488 119 447 93 q 552 189 528 146 q 590 283 576 233 l 590 447 q 567 519 583 484 q 528 582 552 554 q 469 625 504 609 q 386 642 433 642 q 297 620 334 642 q 237 562 260 599 q 202 476 214 525 q 191 373 191 428 m 303 928 q 322 979 303 958 q 377 1000 340 1000 q 432 979 413 1000 q 452 928 452 958 q 432 877 452 898 q 377 857 413 857 q 322 877 340 857 q 303 928 303 898 z "},"Ģ":{"ha":946,"x_min":83,"x_max":844,"o":"m 844 492 l 844 130 q 786 70 826 103 q 676 11 746 36 q 495 -14 606 -14 q 329 18 405 -14 q 198 110 254 50 q 113 258 143 171 q 83 456 83 345 l 83 532 q 109 730 83 643 q 186 877 135 817 q 311 969 237 938 q 480 1001 385 1001 q 670 962 593 1001 q 789 854 746 923 q 844 699 832 786 l 713 699 q 679 796 705 752 q 604 867 652 840 q 480 894 556 894 q 361 869 412 894 q 279 797 311 844 q 230 684 246 750 q 214 534 214 617 l 214 456 q 234 303 214 370 q 292 189 254 236 q 381 117 329 142 q 496 93 433 93 q 609 105 566 93 q 677 133 652 117 q 714 165 701 150 l 714 386 l 486 386 l 486 492 l 844 492 m 554 -84 l 554 -138 q 530 -253 554 -191 q 456 -356 506 -315 l 385 -307 q 422 -227 410 -268 q 435 -139 435 -186 l 435 -84 l 554 -84 z "},"ģ":{"ha":780,"x_min":66,"x_max":685,"o":"m 571 734 l 685 734 l 685 16 q 646 -150 685 -81 q 536 -254 606 -218 q 374 -290 466 -290 q 285 -278 336 -290 q 185 -238 234 -266 q 102 -162 136 -210 l 168 -87 q 265 -165 214 -143 q 365 -186 315 -186 q 468 -164 425 -186 q 535 -98 511 -142 q 559 9 559 -54 l 559 572 l 571 734 m 66 359 l 66 373 q 86 526 66 457 q 143 644 106 595 q 235 721 181 694 q 355 747 288 747 q 476 723 425 747 q 565 653 528 699 q 622 543 601 608 q 651 397 643 479 l 651 335 q 622 190 644 254 q 565 80 601 125 q 476 11 528 35 q 354 -14 424 -14 q 235 14 288 -14 q 144 92 182 42 q 86 211 106 142 q 66 359 66 279 m 191 373 l 191 359 q 202 256 191 304 q 237 171 214 208 q 297 114 260 134 q 385 93 334 93 q 488 119 447 93 q 552 189 528 146 q 590 283 576 233 l 590 447 q 567 519 583 484 q 528 582 552 554 q 469 625 504 609 q 386 642 433 642 q 297 620 334 642 q 237 562 260 599 q 202 476 214 525 q 191 373 191 428 m 311 850 l 311 938 q 326 1018 311 978 q 362 1090 340 1057 q 406 1141 385 1122 l 478 1085 q 446 1009 455 1044 q 437 932 437 974 l 437 850 l 311 850 z "},"Ĥ":{"ha":991,"x_min":115,"x_max":873,"o":"m 760 563 l 760 456 l 225 456 l 225 563 l 760 563 m 245 987 l 245 0 l 115 0 l 115 987 l 245 987 m 873 987 l 873 0 l 743 0 l 743 987 l 873 987 m 521 1260 l 689 1075 l 689 1068 l 585 1068 l 483 1183 l 382 1068 l 279 1068 l 279 1076 l 445 1260 l 521 1260 z "},"ĥ":{"ha":765,"x_min":96,"x_max":673,"o":"m 221 1042 l 221 0 l 96 0 l 96 1042 l 221 1042 m 191 395 l 139 397 q 161 536 140 472 q 222 648 183 600 q 316 721 262 695 q 437 747 371 747 q 535 733 492 747 q 609 686 578 718 q 656 604 640 654 q 673 481 673 553 l 673 0 l 547 0 l 547 482 q 530 575 547 540 q 480 626 513 610 q 400 642 448 642 q 315 622 353 642 q 249 568 277 602 q 207 489 222 533 q 191 395 191 444 m 378 1259 l 546 1074 l 546 1067 l 441 1067 l 340 1182 l 239 1067 l 136 1067 l 136 1075 l 302 1259 l 378 1259 z "},"Ĩ":{"ha":378,"x_min":-50,"x_max":430,"o":"m 255 987 l 255 0 l 124 0 l 124 987 l 255 987 m 345 1246 l 430 1239 q 410 1152 430 1190 q 358 1095 391 1115 q 283 1074 325 1074 q 227 1084 249 1074 q 186 1106 204 1094 q 150 1129 169 1119 q 102 1139 130 1139 q 54 1117 73 1139 q 35 1063 35 1095 l -50 1067 q -31 1155 -50 1117 q 22 1214 -12 1192 q 96 1235 55 1235 q 147 1225 125 1235 q 189 1203 169 1215 q 229 1180 208 1190 q 277 1171 250 1171 q 326 1193 306 1171 q 345 1246 345 1215 z "},"ĩ":{"ha":344,"x_min":-68,"x_max":412,"o":"m 231 734 l 231 0 l 106 0 l 106 734 l 231 734 m 327 1027 l 412 1019 q 392 932 412 970 q 339 875 372 895 q 265 854 307 854 q 208 864 231 854 q 168 887 186 874 q 131 909 151 899 q 83 919 112 919 q 36 897 55 919 q 16 844 16 876 l -68 848 q -49 935 -68 897 q 3 994 -30 972 q 77 1015 37 1015 q 129 1005 106 1015 q 170 983 151 996 q 211 961 190 970 q 259 951 232 951 q 307 973 288 951 q 327 1027 327 995 z "},"Ī":{"ha":378,"x_min":-35,"x_max":420,"o":"m 255 987 l 255 0 l 124 0 l 124 987 l 255 987 m 420 1204 l 420 1107 l -35 1107 l -35 1204 l 420 1204 z "},"ī":{"ha":344,"x_min":-53,"x_max":402,"o":"m 231 734 l 231 0 l 106 0 l 106 734 l 231 734 m 402 984 l 402 888 l -53 888 l -53 984 l 402 984 z "},"Ĭ":{"ha":378,"x_min":-14,"x_max":392,"o":"m 255 987 l 255 0 l 124 0 l 124 987 l 255 987 m 290 1232 l 392 1232 q 368 1138 392 1179 q 298 1074 343 1097 q 190 1051 252 1051 q 41 1102 96 1051 q -14 1232 -14 1152 l 88 1232 q 111 1162 88 1192 q 190 1131 134 1131 q 267 1162 244 1131 q 290 1232 290 1192 z "},"ĭ":{"ha":344,"x_min":-32,"x_max":374,"o":"m 231 734 l 231 0 l 106 0 l 106 734 l 231 734 m 272 1013 l 374 1013 q 349 919 374 960 q 279 854 325 878 q 172 831 234 831 q 23 882 77 831 q -32 1013 -32 932 l 70 1013 q 93 942 70 972 q 172 911 116 911 q 249 942 226 911 q 272 1013 272 972 z "},"Į":{"ha":378,"x_min":16,"x_max":255,"o":"m 255 987 l 255 0 l 124 0 l 124 987 l 255 987 m 191 45 l 241 6 q 185 -39 212 -16 q 142 -89 159 -62 q 125 -144 125 -115 q 137 -180 125 -167 q 178 -194 149 -194 q 218 -188 200 -194 q 245 -176 235 -181 l 255 -258 q 212 -278 238 -269 q 146 -288 186 -288 q 53 -255 91 -288 q 16 -159 16 -222 q 34 -86 16 -122 q 90 -17 52 -50 q 191 45 129 16 z "},"į":{"ha":338,"x_min":-4,"x_max":245,"o":"m 232 734 l 232 0 l 106 0 l 106 734 l 232 734 m 96 928 q 115 980 96 959 q 170 1001 134 1001 q 225 980 206 1001 q 245 928 245 959 q 225 879 245 899 q 170 858 206 858 q 115 879 134 858 q 96 928 96 899 m 171 39 l 221 0 q 165 -45 192 -22 q 122 -95 139 -68 q 105 -151 105 -121 q 117 -186 105 -173 q 158 -200 129 -200 q 198 -194 180 -200 q 226 -182 216 -187 l 235 -264 q 192 -284 218 -275 q 126 -294 166 -294 q 34 -261 71 -294 q -4 -165 -4 -229 q 14 -92 -4 -128 q 71 -23 32 -56 q 171 39 109 10 z "},"İ":{"ha":378,"x_min":115,"x_max":264,"o":"m 255 987 l 255 0 l 124 0 l 124 987 l 255 987 m 115 1146 q 134 1197 115 1176 q 189 1218 153 1218 q 244 1197 225 1218 q 264 1146 264 1176 q 244 1096 264 1116 q 189 1075 225 1075 q 134 1096 153 1075 q 115 1146 115 1116 z "},"Ĳ":{"ha":1144,"x_min":124,"x_max":1037,"o":"m 255 987 l 255 0 l 124 0 l 124 987 l 255 987 m 907 288 l 907 987 l 1037 987 l 1037 288 q 997 123 1037 191 q 887 21 957 56 q 726 -14 817 -14 q 564 18 635 -14 q 454 113 494 49 q 414 273 414 176 l 545 273 q 568 171 545 211 q 632 112 591 131 q 726 93 673 93 q 818 115 777 93 q 883 181 859 137 q 907 288 907 224 z "},"ĳ":{"ha":670,"x_min":96,"x_max":572,"o":"m 232 734 l 232 0 l 106 0 l 106 734 l 232 734 m 96 928 q 115 980 96 959 q 170 1001 134 1001 q 225 980 206 1001 q 245 928 245 959 q 225 879 245 899 q 170 858 206 858 q 115 879 134 858 q 96 928 96 899 m 437 734 l 563 734 l 563 -87 q 542 -201 563 -155 q 478 -272 520 -248 q 371 -296 435 -296 q 331 -293 354 -296 q 293 -285 309 -290 l 294 -184 q 323 -188 307 -186 q 351 -190 339 -190 q 398 -180 379 -190 q 427 -147 417 -170 q 437 -87 437 -125 l 437 734 m 424 928 q 443 980 424 959 q 498 1001 462 1001 q 553 980 534 1001 q 572 928 572 959 q 553 879 572 899 q 498 858 534 858 q 443 879 462 858 q 424 928 424 899 z "},"Ĵ":{"ha":766,"x_min":36,"x_max":784,"o":"m 529 288 l 529 987 l 659 987 l 659 288 q 619 123 659 191 q 509 21 579 56 q 348 -14 439 -14 q 186 18 257 -14 q 76 113 116 49 q 36 273 36 176 l 167 273 q 190 171 167 211 q 254 112 213 131 q 348 93 295 93 q 440 115 399 93 q 505 181 481 137 q 529 288 529 224 m 616 1251 l 784 1066 l 784 1059 l 680 1059 l 578 1174 l 477 1059 l 374 1059 l 374 1067 l 540 1251 l 616 1251 z "},"ĵ":{"ha":350,"x_min":-52,"x_max":387,"o":"m 117 734 l 243 734 l 243 -60 q 217 -189 243 -136 q 142 -269 191 -242 q 24 -296 93 -296 q -14 -294 3 -296 q -52 -285 -32 -292 l -42 -184 q -8 -191 -32 -189 q 24 -193 15 -193 q 74 -177 54 -193 q 106 -132 95 -161 q 117 -60 117 -102 l 117 734 m 218 1014 l 387 829 l 387 822 l 282 822 l 180 937 l 79 822 l -24 822 l -24 829 l 142 1014 l 218 1014 z "},"Ķ":{"ha":871,"x_min":115,"x_max":871,"o":"m 245 987 l 245 0 l 115 0 l 115 987 l 245 987 m 842 987 l 431 527 l 201 288 l 179 427 l 353 618 l 684 987 l 842 987 m 715 0 l 350 481 l 428 585 l 871 0 l 715 0 m 507 -17 l 507 -71 q 483 -186 507 -124 q 408 -289 458 -248 l 337 -239 q 375 -160 362 -201 q 387 -72 387 -119 l 387 -17 l 507 -17 z "},"ķ":{"ha":704,"x_min":96,"x_max":703,"o":"m 222 1042 l 222 0 l 96 0 l 96 1042 l 222 1042 m 670 734 l 350 391 l 171 205 l 161 339 l 289 492 l 517 734 l 670 734 m 555 0 l 294 350 l 359 462 l 703 0 l 555 0 m 418 -30 l 418 -83 q 394 -199 418 -137 q 319 -302 370 -260 l 248 -252 q 286 -173 273 -214 q 298 -85 298 -132 l 298 -30 l 418 -30 z "},"Ĺ":{"ha":748,"x_min":110,"x_max":713,"o":"m 713 106 l 713 0 l 220 0 l 220 106 l 713 106 m 245 987 l 245 0 l 115 0 l 115 987 l 245 987 m 110 1050 l 241 1249 l 393 1249 l 211 1050 l 110 1050 z "},"ĺ":{"ha":338,"x_min":100,"x_max":382,"o":"m 232 1042 l 232 0 l 106 0 l 106 1042 l 232 1042 m 100 1118 l 231 1318 l 382 1318 l 201 1118 l 100 1118 z "},"Ļ":{"ha":748,"x_min":115,"x_max":713,"o":"m 713 106 l 713 0 l 220 0 l 220 106 l 713 106 m 245 987 l 245 0 l 115 0 l 115 987 l 245 987 m 479 -71 l 479 -125 q 455 -240 479 -178 q 381 -343 431 -302 l 310 -294 q 348 -214 335 -255 q 360 -126 360 -174 l 360 -71 l 479 -71 z "},"ļ":{"ha":338,"x_min":58,"x_max":232,"o":"m 232 1042 l 232 0 l 106 0 l 106 1042 l 232 1042 m 228 -71 l 228 -125 q 204 -240 228 -178 q 130 -343 180 -302 l 58 -294 q 96 -214 83 -255 q 109 -126 109 -174 l 109 -71 l 228 -71 z "},"Ľ":{"ha":748,"x_min":115,"x_max":713,"o":"m 713 106 l 713 0 l 220 0 l 220 106 l 713 106 m 245 987 l 245 0 l 115 0 l 115 987 l 245 987 m 551 988 l 551 935 q 527 819 551 881 q 453 716 503 758 l 382 766 q 419 845 407 804 q 432 933 432 886 l 432 988 l 551 988 z "},"ľ":{"ha":439,"x_min":106,"x_max":465,"o":"m 232 1042 l 232 0 l 106 0 l 106 1042 l 232 1042 m 465 1043 l 465 989 q 440 874 465 936 q 366 771 416 812 l 295 821 q 333 900 320 859 q 345 988 345 941 l 345 1043 l 465 1043 z "},"Ŀ":{"ha":748,"x_min":115,"x_max":713,"o":"m 713 106 l 713 0 l 220 0 l 220 106 l 713 106 m 245 987 l 245 0 l 115 0 l 115 987 l 245 987 m 397 540 q 416 591 397 570 q 471 612 435 612 q 527 591 507 612 q 546 540 546 570 q 527 489 546 510 q 471 469 507 469 q 416 489 435 469 q 397 540 397 510 z "},"ŀ":{"ha":487,"x_min":106,"x_max":457,"o":"m 232 1042 l 232 0 l 106 0 l 106 1042 l 232 1042 m 309 530 q 327 581 309 559 q 382 602 346 602 q 438 581 418 602 q 457 530 457 559 q 438 479 457 500 q 382 458 418 458 q 327 479 346 458 q 309 530 309 500 z "},"Ń":{"ha":991,"x_min":115,"x_max":874,"o":"m 874 987 l 874 0 l 743 0 l 245 762 l 245 0 l 115 0 l 115 987 l 245 987 l 745 224 l 745 987 l 874 987 m 423 1053 l 555 1253 l 706 1253 l 524 1053 l 423 1053 z "},"ń":{"ha":767,"x_min":96,"x_max":673,"o":"m 221 577 l 221 0 l 96 0 l 96 734 l 214 734 l 221 577 m 191 395 l 139 397 q 161 536 140 472 q 222 648 183 600 q 316 721 262 695 q 437 747 371 747 q 535 733 492 747 q 609 686 578 718 q 656 604 640 654 q 673 481 673 553 l 673 0 l 547 0 l 547 482 q 530 575 547 540 q 480 626 513 610 q 400 642 448 642 q 315 622 353 642 q 249 568 277 602 q 207 489 222 533 q 191 395 191 444 m 319 842 l 451 1042 l 602 1042 l 420 842 l 319 842 z "},"Ņ":{"ha":991,"x_min":115,"x_max":874,"o":"m 874 987 l 874 0 l 743 0 l 245 762 l 245 0 l 115 0 l 115 987 l 245 987 l 745 224 l 745 987 l 874 987 m 547 -71 l 547 -125 q 523 -240 547 -178 q 449 -343 499 -302 l 378 -294 q 415 -214 403 -255 q 428 -126 428 -174 l 428 -71 l 547 -71 z "},"ņ":{"ha":767,"x_min":96,"x_max":673,"o":"m 221 577 l 221 0 l 96 0 l 96 734 l 214 734 l 221 577 m 191 395 l 139 397 q 161 536 140 472 q 222 648 183 600 q 316 721 262 695 q 437 747 371 747 q 535 733 492 747 q 609 686 578 718 q 656 604 640 654 q 673 481 673 553 l 673 0 l 547 0 l 547 482 q 530 575 547 540 q 480 626 513 610 q 400 642 448 642 q 315 622 353 642 q 249 568 277 602 q 207 489 222 533 q 191 395 191 444 m 441 -71 l 441 -125 q 417 -240 441 -178 q 342 -343 393 -302 l 271 -294 q 309 -214 296 -255 q 321 -126 321 -174 l 321 -71 l 441 -71 z "},"Ň":{"ha":991,"x_min":115,"x_max":874,"o":"m 874 987 l 874 0 l 743 0 l 245 762 l 245 0 l 115 0 l 115 987 l 245 987 l 745 224 l 745 987 l 874 987 m 389 1252 l 492 1137 l 594 1252 l 703 1252 l 703 1245 l 530 1059 l 453 1059 l 283 1245 l 283 1252 l 389 1252 z "},"ň":{"ha":767,"x_min":96,"x_max":673,"o":"m 221 577 l 221 0 l 96 0 l 96 734 l 214 734 l 221 577 m 191 395 l 139 397 q 161 536 140 472 q 222 648 183 600 q 316 721 262 695 q 437 747 371 747 q 535 733 492 747 q 609 686 578 718 q 656 604 640 654 q 673 481 673 553 l 673 0 l 547 0 l 547 482 q 530 575 547 540 q 480 626 513 610 q 400 642 448 642 q 315 622 353 642 q 249 568 277 602 q 207 489 222 533 q 191 395 191 444 m 286 1041 l 388 926 l 490 1041 l 599 1041 l 599 1034 l 427 848 l 349 848 l 180 1034 l 180 1041 l 286 1041 z "},"ŉ":{"ha":767,"x_min":-47,"x_max":673,"o":"m 221 577 l 221 0 l 96 0 l 96 734 l 214 734 l 221 577 m 191 395 l 139 397 q 161 536 140 472 q 222 648 183 600 q 316 721 262 695 q 437 747 371 747 q 535 733 492 747 q 609 686 578 718 q 656 604 640 654 q 673 481 673 553 l 673 0 l 547 0 l 547 482 q 530 575 547 540 q 480 626 513 610 q 400 642 448 642 q 315 622 353 642 q 249 568 277 602 q 207 489 222 533 q 191 395 191 444 m 123 1045 l 123 991 q 99 876 123 938 q 24 773 75 814 l -47 823 q -9 902 -22 861 q 3 990 3 943 l 3 1045 l 123 1045 z "},"Ō":{"ha":956,"x_min":81,"x_max":875,"o":"m 875 525 l 875 463 q 847 263 875 351 q 767 113 819 175 q 642 19 715 52 q 479 -14 569 -14 q 318 19 391 -14 q 192 113 245 52 q 110 263 139 175 q 81 463 81 351 l 81 525 q 110 724 81 636 q 191 874 138 812 q 317 968 244 936 q 477 1001 390 1001 q 641 968 568 1001 q 766 874 713 936 q 847 724 819 812 q 875 525 875 636 m 745 463 l 745 526 q 727 682 745 614 q 675 796 709 750 q 590 866 640 842 q 477 890 541 890 q 367 866 416 890 q 283 796 318 842 q 229 682 248 750 q 210 526 210 614 l 210 463 q 229 306 210 374 q 284 191 248 237 q 369 121 319 144 q 479 97 418 97 q 592 121 543 97 q 676 191 642 144 q 728 306 710 237 q 745 463 745 374 m 711 1198 l 711 1101 l 256 1101 l 256 1198 l 711 1198 z "},"ō":{"ha":792,"x_min":62,"x_max":730,"o":"m 62 359 l 62 374 q 85 522 62 454 q 152 641 109 590 q 257 719 195 691 q 395 747 319 747 q 535 719 473 747 q 641 641 597 691 q 707 522 684 590 q 730 374 730 454 l 730 359 q 707 212 730 279 q 641 93 684 144 q 535 15 597 43 q 397 -14 474 -14 q 258 15 319 -14 q 152 93 196 43 q 85 212 109 144 q 62 359 62 279 m 188 374 l 188 359 q 201 255 188 304 q 240 170 214 207 q 305 111 266 132 q 397 90 345 90 q 487 111 448 90 q 552 170 526 132 q 591 255 578 207 q 604 359 604 304 l 604 374 q 591 477 604 429 q 552 563 578 526 q 487 623 526 601 q 395 644 448 644 q 305 623 344 644 q 240 563 266 601 q 201 477 214 526 q 188 374 188 429 m 621 985 l 621 889 l 166 889 l 166 985 l 621 985 z "},"Ŏ":{"ha":956,"x_min":81,"x_max":875,"o":"m 875 525 l 875 463 q 847 263 875 351 q 767 113 819 175 q 642 19 715 52 q 479 -14 569 -14 q 318 19 391 -14 q 192 113 245 52 q 110 263 139 175 q 81 463 81 351 l 81 525 q 110 724 81 636 q 191 874 138 812 q 317 968 244 936 q 477 1001 390 1001 q 641 968 568 1001 q 766 874 713 936 q 847 724 819 812 q 875 525 875 636 m 745 463 l 745 526 q 727 682 745 614 q 675 796 709 750 q 590 866 640 842 q 477 890 541 890 q 367 866 416 890 q 283 796 318 842 q 229 682 248 750 q 210 526 210 614 l 210 463 q 229 306 210 374 q 284 191 248 237 q 369 121 319 144 q 479 97 418 97 q 592 121 543 97 q 676 191 642 144 q 728 306 710 237 q 745 463 745 374 m 581 1226 l 682 1226 q 658 1132 682 1173 q 588 1068 633 1091 q 480 1045 543 1045 q 331 1096 386 1045 q 277 1226 277 1146 l 378 1226 q 401 1156 378 1186 q 480 1125 425 1125 q 557 1156 534 1125 q 581 1226 581 1186 z "},"ŏ":{"ha":792,"x_min":62,"x_max":730,"o":"m 62 359 l 62 374 q 85 522 62 454 q 152 641 109 590 q 257 719 195 691 q 395 747 319 747 q 535 719 473 747 q 641 641 597 691 q 707 522 684 590 q 730 374 730 454 l 730 359 q 707 212 730 279 q 641 93 684 144 q 535 15 597 43 q 397 -14 474 -14 q 258 15 319 -14 q 152 93 196 43 q 85 212 109 144 q 62 359 62 279 m 188 374 l 188 359 q 201 255 188 304 q 240 170 214 207 q 305 111 266 132 q 397 90 345 90 q 487 111 448 90 q 552 170 526 132 q 591 255 578 207 q 604 359 604 304 l 604 374 q 591 477 604 429 q 552 563 578 526 q 487 623 526 601 q 395 644 448 644 q 305 623 344 644 q 240 563 266 601 q 201 477 214 526 q 188 374 188 429 m 491 1014 l 593 1014 q 568 920 593 961 q 498 856 544 879 q 391 833 453 833 q 242 883 296 833 q 187 1014 187 934 l 289 1014 q 312 943 289 974 q 391 913 335 913 q 468 943 445 913 q 491 1014 491 974 z "},"Ő":{"ha":956,"x_min":81,"x_max":875,"o":"m 875 525 l 875 463 q 847 263 875 351 q 767 113 819 175 q 642 19 715 52 q 479 -14 569 -14 q 318 19 391 -14 q 192 113 245 52 q 110 263 139 175 q 81 463 81 351 l 81 525 q 110 724 81 636 q 191 874 138 812 q 317 968 244 936 q 477 1001 390 1001 q 641 968 568 1001 q 766 874 713 936 q 847 724 819 812 q 875 525 875 636 m 745 463 l 745 526 q 727 682 745 614 q 675 796 709 750 q 590 866 640 842 q 477 890 541 890 q 367 866 416 890 q 283 796 318 842 q 229 682 248 750 q 210 526 210 614 l 210 463 q 229 306 210 374 q 284 191 248 237 q 369 121 319 144 q 479 97 418 97 q 592 121 543 97 q 676 191 642 144 q 728 306 710 237 q 745 463 745 374 m 500 1048 l 656 1253 l 797 1253 l 615 1048 l 500 1048 m 311 1048 l 426 1253 l 560 1253 l 412 1048 l 311 1048 z "},"ő":{"ha":792,"x_min":62,"x_max":730,"o":"m 62 359 l 62 374 q 85 522 62 454 q 152 641 109 590 q 257 719 195 691 q 395 747 319 747 q 535 719 473 747 q 641 641 597 691 q 707 522 684 590 q 730 374 730 454 l 730 359 q 707 212 730 279 q 641 93 684 144 q 535 15 597 43 q 397 -14 474 -14 q 258 15 319 -14 q 152 93 196 43 q 85 212 109 144 q 62 359 62 279 m 188 374 l 188 359 q 201 255 188 304 q 240 170 214 207 q 305 111 266 132 q 397 90 345 90 q 487 111 448 90 q 552 170 526 132 q 591 255 578 207 q 604 359 604 304 l 604 374 q 591 477 604 429 q 552 563 578 526 q 487 623 526 601 q 395 644 448 644 q 305 623 344 644 q 240 563 266 601 q 201 477 214 526 q 188 374 188 429 m 411 836 l 567 1041 l 707 1041 l 526 836 l 411 836 m 221 836 l 336 1041 l 471 1041 l 323 836 l 221 836 z "},"Ŕ":{"ha":856,"x_min":115,"x_max":831,"o":"m 115 987 l 441 987 q 630 954 553 987 q 747 853 707 920 q 787 691 787 787 q 760 567 787 623 q 681 472 732 511 q 559 414 630 433 l 522 400 l 215 400 l 214 507 l 446 507 q 563 531 516 507 q 633 598 610 556 q 657 691 657 640 q 635 791 657 748 q 565 857 612 833 q 441 880 517 880 l 245 880 l 245 0 l 115 0 l 115 987 m 692 0 l 452 448 l 588 448 l 831 8 l 831 0 l 692 0 m 345 1053 l 476 1253 l 627 1253 l 446 1053 l 345 1053 z "},"ŕ":{"ha":471,"x_min":96,"x_max":490,"o":"m 221 618 l 221 0 l 96 0 l 96 734 l 218 734 l 221 618 m 450 738 l 450 621 q 420 626 434 625 q 389 627 406 627 q 312 613 345 627 q 256 575 279 600 q 219 517 233 551 q 202 444 206 484 l 167 423 q 180 548 167 490 q 221 651 193 606 q 292 722 249 696 q 395 747 335 747 q 426 744 408 747 q 450 738 444 741 m 208 842 l 339 1042 l 490 1042 l 309 842 l 208 842 z "},"Ŗ":{"ha":856,"x_min":115,"x_max":831,"o":"m 115 987 l 441 987 q 630 954 553 987 q 747 853 707 920 q 787 691 787 787 q 760 567 787 623 q 681 472 732 511 q 559 414 630 433 l 522 400 l 215 400 l 214 507 l 446 507 q 563 531 516 507 q 633 598 610 556 q 657 691 657 640 q 635 791 657 748 q 565 857 612 833 q 441 880 517 880 l 245 880 l 245 0 l 115 0 l 115 987 m 692 0 l 452 448 l 588 448 l 831 8 l 831 0 l 692 0 m 473 -71 l 473 -125 q 449 -240 473 -178 q 375 -343 425 -302 l 304 -294 q 341 -214 329 -255 q 354 -126 354 -174 l 354 -71 l 473 -71 z "},"ŗ":{"ha":471,"x_min":56,"x_max":450,"o":"m 221 618 l 221 0 l 96 0 l 96 734 l 218 734 l 221 618 m 450 738 l 450 621 q 420 626 434 625 q 389 627 406 627 q 312 613 345 627 q 256 575 279 600 q 219 517 233 551 q 202 444 206 484 l 167 423 q 180 548 167 490 q 221 651 193 606 q 292 722 249 696 q 395 747 335 747 q 426 744 408 747 q 450 738 444 741 m 226 -71 l 226 -124 q 202 -239 226 -178 q 127 -342 178 -301 l 56 -293 q 94 -214 81 -254 q 106 -125 106 -173 l 106 -71 l 226 -71 z "},"Ř":{"ha":856,"x_min":115,"x_max":831,"o":"m 115 987 l 441 987 q 630 954 553 987 q 747 853 707 920 q 787 691 787 787 q 760 567 787 623 q 681 472 732 511 q 559 414 630 433 l 522 400 l 215 400 l 214 507 l 446 507 q 563 531 516 507 q 633 598 610 556 q 657 691 657 640 q 635 791 657 748 q 565 857 612 833 q 441 880 517 880 l 245 880 l 245 0 l 115 0 l 115 987 m 692 0 l 452 448 l 588 448 l 831 8 l 831 0 l 692 0 m 311 1252 l 413 1137 l 515 1252 l 624 1252 l 624 1245 l 452 1059 l 374 1059 l 205 1245 l 205 1252 l 311 1252 z "},"ř":{"ha":471,"x_min":68,"x_max":487,"o":"m 221 618 l 221 0 l 96 0 l 96 734 l 218 734 l 221 618 m 450 738 l 450 621 q 420 626 434 625 q 389 627 406 627 q 312 613 345 627 q 256 575 279 600 q 219 517 233 551 q 202 444 206 484 l 167 423 q 180 548 167 490 q 221 651 193 606 q 292 722 249 696 q 395 747 335 747 q 426 744 408 747 q 450 738 444 741 m 174 1041 l 276 926 l 378 1041 l 487 1041 l 487 1034 l 315 848 l 237 848 l 68 1034 l 68 1041 l 174 1041 z "},"Ś":{"ha":825,"x_min":55,"x_max":772,"o":"m 641 250 q 630 311 641 284 q 594 359 620 338 q 522 401 568 381 q 406 441 476 420 q 274 489 333 463 q 173 551 215 516 q 109 630 131 585 q 86 732 86 675 q 110 839 86 790 q 178 924 134 888 q 284 981 222 960 q 422 1001 346 1001 q 611 959 533 1001 q 729 848 688 916 q 770 703 770 780 l 640 703 q 616 801 640 758 q 544 869 592 844 q 422 894 496 894 q 307 873 352 894 q 239 816 261 852 q 217 734 217 780 q 230 677 217 703 q 272 630 243 652 q 343 590 300 608 q 448 555 387 572 q 593 502 532 531 q 694 436 654 473 q 753 354 734 400 q 772 251 772 309 q 748 142 772 191 q 678 58 724 93 q 569 5 633 24 q 428 -14 506 -14 q 293 5 359 -14 q 173 62 227 24 q 87 156 119 100 q 55 286 55 212 l 185 286 q 205 199 185 235 q 259 139 224 163 q 337 104 293 115 q 428 93 380 93 q 544 112 496 93 q 616 166 591 131 q 641 250 641 201 m 353 1055 l 484 1254 l 635 1254 l 454 1055 l 353 1055 z "},"ś":{"ha":717,"x_min":64,"x_max":648,"o":"m 523 195 q 511 245 523 222 q 463 288 499 269 q 354 321 427 307 q 244 352 293 334 q 160 395 195 370 q 108 454 126 420 q 90 533 90 488 q 109 615 90 576 q 164 684 128 654 q 250 730 199 713 q 361 747 300 747 q 512 716 450 747 q 608 633 574 685 q 641 518 641 581 l 515 518 q 497 577 515 549 q 445 625 479 606 q 361 644 411 644 q 277 628 309 644 q 230 588 245 612 q 216 536 216 564 q 223 500 216 516 q 248 471 230 484 q 300 446 267 458 q 385 423 333 435 q 533 374 475 403 q 620 304 591 346 q 648 204 648 263 q 628 116 648 156 q 571 47 608 76 q 481 2 533 18 q 365 -14 429 -14 q 201 21 268 -14 q 99 111 134 56 q 64 227 64 165 l 191 227 q 220 145 193 175 q 287 102 248 115 q 365 90 326 90 q 451 103 416 90 q 505 140 486 117 q 523 195 523 164 m 312 842 l 444 1042 l 595 1042 l 413 842 l 312 842 z "},"Ŝ":{"ha":825,"x_min":55,"x_max":772,"o":"m 641 250 q 630 311 641 284 q 594 359 620 338 q 522 401 568 381 q 406 441 476 420 q 274 489 333 463 q 173 551 215 516 q 109 630 131 585 q 86 732 86 675 q 110 839 86 790 q 178 924 134 888 q 284 981 222 960 q 422 1001 346 1001 q 611 959 533 1001 q 729 848 688 916 q 770 703 770 780 l 640 703 q 616 801 640 758 q 544 869 592 844 q 422 894 496 894 q 307 873 352 894 q 239 816 261 852 q 217 734 217 780 q 230 677 217 703 q 272 630 243 652 q 343 590 300 608 q 448 555 387 572 q 593 502 532 531 q 694 436 654 473 q 753 354 734 400 q 772 251 772 309 q 748 142 772 191 q 678 58 724 93 q 569 5 633 24 q 428 -14 506 -14 q 293 5 359 -14 q 173 62 227 24 q 87 156 119 100 q 55 286 55 212 l 185 286 q 205 199 185 235 q 259 139 224 163 q 337 104 293 115 q 428 93 380 93 q 544 112 496 93 q 616 166 591 131 q 641 250 641 201 m 460 1254 l 628 1069 l 628 1062 l 524 1062 l 422 1177 l 321 1062 l 218 1062 l 218 1069 l 384 1254 l 460 1254 z "},"ŝ":{"ha":717,"x_min":64,"x_max":648,"o":"m 523 195 q 511 245 523 222 q 463 288 499 269 q 354 321 427 307 q 244 352 293 334 q 160 395 195 370 q 108 454 126 420 q 90 533 90 488 q 109 615 90 576 q 164 684 128 654 q 250 730 199 713 q 361 747 300 747 q 512 716 450 747 q 608 633 574 685 q 641 518 641 581 l 515 518 q 497 577 515 549 q 445 625 479 606 q 361 644 411 644 q 277 628 309 644 q 230 588 245 612 q 216 536 216 564 q 223 500 216 516 q 248 471 230 484 q 300 446 267 458 q 385 423 333 435 q 533 374 475 403 q 620 304 591 346 q 648 204 648 263 q 628 116 648 156 q 571 47 608 76 q 481 2 533 18 q 365 -14 429 -14 q 201 21 268 -14 q 99 111 134 56 q 64 227 64 165 l 191 227 q 220 145 193 175 q 287 102 248 115 q 365 90 326 90 q 451 103 416 90 q 505 140 486 117 q 523 195 523 164 m 419 1042 l 587 857 l 587 850 l 483 850 l 381 964 l 280 850 l 177 850 l 177 857 l 343 1042 l 419 1042 z "},"Ş":{"ha":825,"x_min":55,"x_max":772,"o":"m 641 250 q 630 311 641 284 q 594 359 620 338 q 522 401 568 381 q 406 441 476 420 q 274 489 333 463 q 173 551 215 516 q 109 630 131 585 q 86 732 86 675 q 110 839 86 790 q 178 924 134 888 q 284 981 222 960 q 422 1001 346 1001 q 611 959 533 1001 q 729 848 688 916 q 770 703 770 780 l 640 703 q 616 801 640 758 q 544 869 592 844 q 422 894 496 894 q 307 873 352 894 q 239 816 261 852 q 217 734 217 780 q 230 677 217 703 q 272 630 243 652 q 343 590 300 608 q 448 555 387 572 q 593 502 532 531 q 694 436 654 473 q 753 354 734 400 q 772 251 772 309 q 748 142 772 191 q 678 58 724 93 q 569 5 633 24 q 428 -14 506 -14 q 293 5 359 -14 q 173 62 227 24 q 87 156 119 100 q 55 286 55 212 l 185 286 q 205 199 185 235 q 259 139 224 163 q 337 104 293 115 q 428 93 380 93 q 544 112 496 93 q 616 166 591 131 q 641 250 641 201 m 385 -1 l 475 -1 l 467 -37 q 538 -69 506 -43 q 570 -154 570 -95 q 557 -212 570 -186 q 518 -257 544 -238 q 454 -286 492 -275 q 365 -296 416 -296 l 360 -223 q 417 -216 391 -223 q 457 -195 442 -210 q 473 -156 473 -180 q 461 -121 473 -134 q 426 -101 450 -108 q 363 -92 401 -95 l 385 -1 z "},"ş":{"ha":717,"x_min":64,"x_max":648,"o":"m 523 195 q 511 245 523 222 q 463 288 499 269 q 354 321 427 307 q 244 352 293 334 q 160 395 195 370 q 108 454 126 420 q 90 533 90 488 q 109 615 90 576 q 164 684 128 654 q 250 730 199 713 q 361 747 300 747 q 512 716 450 747 q 608 633 574 685 q 641 518 641 581 l 515 518 q 497 577 515 549 q 445 625 479 606 q 361 644 411 644 q 277 628 309 644 q 230 588 245 612 q 216 536 216 564 q 223 500 216 516 q 248 471 230 484 q 300 446 267 458 q 385 423 333 435 q 533 374 475 403 q 620 304 591 346 q 648 204 648 263 q 628 116 648 156 q 571 47 608 76 q 481 2 533 18 q 365 -14 429 -14 q 201 21 268 -14 q 99 111 134 56 q 64 227 64 165 l 191 227 q 220 145 193 175 q 287 102 248 115 q 365 90 326 90 q 451 103 416 90 q 505 140 486 117 q 523 195 523 164 m 340 -7 l 430 -7 l 422 -43 q 493 -75 461 -50 q 526 -160 526 -101 q 512 -218 526 -192 q 473 -263 499 -244 q 409 -292 448 -281 q 320 -302 371 -302 l 315 -229 q 372 -222 347 -229 q 413 -201 397 -216 q 428 -162 428 -186 q 416 -127 428 -140 q 381 -107 405 -114 q 319 -98 357 -101 l 340 -7 z "},"Ș":{"ha":825,"x_min":55,"x_max":772,"o":"m 641 250 q 630 311 641 284 q 594 359 620 338 q 522 401 568 381 q 406 441 476 420 q 274 489 333 463 q 173 551 215 516 q 109 630 131 585 q 86 732 86 675 q 110 839 86 790 q 178 924 134 888 q 284 981 222 960 q 422 1001 346 1001 q 611 959 533 1001 q 729 848 688 916 q 770 703 770 780 l 640 703 q 616 801 640 758 q 544 869 592 844 q 422 894 496 894 q 307 873 352 894 q 239 816 261 852 q 217 734 217 780 q 230 677 217 703 q 272 630 243 652 q 343 590 300 608 q 448 555 387 572 q 593 502 532 531 q 694 436 654 473 q 753 354 734 400 q 772 251 772 309 q 748 142 772 191 q 678 58 724 93 q 569 5 633 24 q 428 -14 506 -14 q 293 5 359 -14 q 173 62 227 24 q 87 156 119 100 q 55 286 55 212 l 185 286 q 205 199 185 235 q 259 139 224 163 q 337 104 293 115 q 428 93 380 93 q 544 112 496 93 q 616 166 591 131 q 641 250 641 201 m 485 -79 l 485 -132 q 461 -248 485 -186 q 387 -351 437 -309 l 315 -301 q 353 -222 340 -262 q 366 -134 366 -181 l 366 -79 l 485 -79 z "},"ș":{"ha":717,"x_min":64,"x_max":648,"o":"m 523 195 q 511 245 523 222 q 463 288 499 269 q 354 321 427 307 q 244 352 293 334 q 160 395 195 370 q 108 454 126 420 q 90 533 90 488 q 109 615 90 576 q 164 684 128 654 q 250 730 199 713 q 361 747 300 747 q 512 716 450 747 q 608 633 574 685 q 641 518 641 581 l 515 518 q 497 577 515 549 q 445 625 479 606 q 361 644 411 644 q 277 628 309 644 q 230 588 245 612 q 216 536 216 564 q 223 500 216 516 q 248 471 230 484 q 300 446 267 458 q 385 423 333 435 q 533 374 475 403 q 620 304 591 346 q 648 204 648 263 q 628 116 648 156 q 571 47 608 76 q 481 2 533 18 q 365 -14 429 -14 q 201 21 268 -14 q 99 111 134 56 q 64 227 64 165 l 191 227 q 220 145 193 175 q 287 102 248 115 q 365 90 326 90 q 451 103 416 90 q 505 140 486 117 q 523 195 523 164 m 440 -85 l 440 -138 q 416 -254 440 -192 q 342 -357 392 -315 l 271 -307 q 308 -228 296 -269 q 321 -140 321 -187 l 321 -85 l 440 -85 z "},"Š":{"ha":825,"x_min":55,"x_max":772,"o":"m 641 250 q 630 311 641 284 q 594 359 620 338 q 522 401 568 381 q 406 441 476 420 q 274 489 333 463 q 173 551 215 516 q 109 630 131 585 q 86 732 86 675 q 110 839 86 790 q 178 924 134 888 q 284 981 222 960 q 422 1001 346 1001 q 611 959 533 1001 q 729 848 688 916 q 770 703 770 780 l 640 703 q 616 801 640 758 q 544 869 592 844 q 422 894 496 894 q 307 873 352 894 q 239 816 261 852 q 217 734 217 780 q 230 677 217 703 q 272 630 243 652 q 343 590 300 608 q 448 555 387 572 q 593 502 532 531 q 694 436 654 473 q 753 354 734 400 q 772 251 772 309 q 748 142 772 191 q 678 58 724 93 q 569 5 633 24 q 428 -14 506 -14 q 293 5 359 -14 q 173 62 227 24 q 87 156 119 100 q 55 286 55 212 l 185 286 q 205 199 185 235 q 259 139 224 163 q 337 104 293 115 q 428 93 380 93 q 544 112 496 93 q 616 166 591 131 q 641 250 641 201 m 319 1253 l 421 1138 l 524 1253 l 632 1253 l 632 1246 l 460 1061 l 382 1061 l 213 1246 l 213 1253 l 319 1253 z "},"š":{"ha":717,"x_min":64,"x_max":648,"o":"m 523 195 q 511 245 523 222 q 463 288 499 269 q 354 321 427 307 q 244 352 293 334 q 160 395 195 370 q 108 454 126 420 q 90 533 90 488 q 109 615 90 576 q 164 684 128 654 q 250 730 199 713 q 361 747 300 747 q 512 716 450 747 q 608 633 574 685 q 641 518 641 581 l 515 518 q 497 577 515 549 q 445 625 479 606 q 361 644 411 644 q 277 628 309 644 q 230 588 245 612 q 216 536 216 564 q 223 500 216 516 q 248 471 230 484 q 300 446 267 458 q 385 423 333 435 q 533 374 475 403 q 620 304 591 346 q 648 204 648 263 q 628 116 648 156 q 571 47 608 76 q 481 2 533 18 q 365 -14 429 -14 q 201 21 268 -14 q 99 111 134 56 q 64 227 64 165 l 191 227 q 220 145 193 175 q 287 102 248 115 q 365 90 326 90 q 451 103 416 90 q 505 140 486 117 q 523 195 523 164 m 278 1041 l 380 926 l 483 1041 l 591 1041 l 591 1034 l 419 848 l 342 848 l 172 1034 l 172 1041 l 278 1041 z "},"Ț":{"ha":829,"x_min":34,"x_max":797,"o":"m 479 987 l 479 0 l 351 0 l 351 987 l 479 987 m 797 987 l 797 880 l 34 880 l 34 987 l 797 987 m 475 -78 l 475 -132 q 451 -247 475 -185 q 377 -350 427 -309 l 306 -300 q 343 -221 331 -262 q 356 -133 356 -180 l 356 -78 l 475 -78 z "},"ț":{"ha":454,"x_min":6,"x_max":406,"o":"m 403 734 l 403 637 l 6 637 l 6 734 l 403 734 m 140 912 l 266 912 l 266 182 q 277 125 266 144 q 307 100 289 106 q 347 94 326 94 q 379 97 362 94 q 406 102 397 100 l 406 0 q 367 -9 391 -5 q 309 -14 343 -14 q 224 5 263 -14 q 163 66 186 23 q 140 182 140 109 l 140 912 m 366 -78 l 366 -132 q 342 -247 366 -185 q 268 -350 318 -309 l 197 -300 q 234 -221 222 -262 q 247 -133 247 -180 l 247 -78 l 366 -78 z "},"Ţ":{"ha":829,"x_min":34,"x_max":797,"o":"m 479 987 l 479 0 l 351 0 l 351 987 l 479 987 m 797 987 l 797 880 l 34 880 l 34 987 l 797 987 m 375 0 l 465 0 l 457 -36 q 529 -68 496 -43 q 561 -153 561 -94 q 548 -211 561 -185 q 509 -256 534 -237 q 445 -285 483 -275 q 355 -295 406 -295 l 351 -222 q 407 -216 382 -222 q 448 -194 433 -209 q 463 -155 463 -179 q 452 -120 463 -133 q 416 -101 440 -107 q 354 -92 392 -94 l 375 0 z "},"ţ":{"ha":454,"x_min":6,"x_max":452,"o":"m 403 734 l 403 637 l 6 637 l 6 734 l 403 734 m 140 912 l 266 912 l 266 182 q 277 125 266 144 q 307 100 289 106 q 347 94 326 94 q 379 97 362 94 q 406 102 397 100 l 406 0 q 367 -9 391 -5 q 309 -14 343 -14 q 224 5 263 -14 q 163 66 186 23 q 140 182 140 109 l 140 912 m 266 0 l 356 0 l 348 -36 q 419 -68 387 -43 q 452 -153 452 -94 q 438 -211 452 -185 q 399 -256 425 -237 q 335 -285 374 -275 q 246 -295 297 -295 l 241 -222 q 298 -216 273 -222 q 339 -194 323 -209 q 354 -155 354 -179 q 342 -120 354 -133 q 307 -101 331 -107 q 245 -92 283 -94 l 266 0 z "},"Ť":{"ha":829,"x_min":34,"x_max":797,"o":"m 479 987 l 479 0 l 351 0 l 351 987 l 479 987 m 797 987 l 797 880 l 34 880 l 34 987 l 797 987 m 312 1251 l 414 1136 l 517 1251 l 625 1251 l 625 1244 l 453 1059 l 376 1059 l 206 1244 l 206 1251 l 312 1251 z "},"ť":{"ha":481,"x_min":6,"x_max":507,"o":"m 403 734 l 403 637 l 6 637 l 6 734 l 403 734 m 140 912 l 266 912 l 266 182 q 277 125 266 144 q 307 100 289 106 q 347 94 326 94 q 379 97 362 94 q 406 102 397 100 l 406 0 q 367 -9 391 -5 q 309 -14 343 -14 q 224 5 263 -14 q 163 66 186 23 q 140 182 140 109 l 140 912 m 507 1124 l 507 1071 q 483 956 507 1017 q 409 852 459 894 l 338 902 q 375 981 363 941 q 388 1069 388 1022 l 388 1124 l 507 1124 z "},"Ũ":{"ha":901,"x_min":95,"x_max":810,"o":"m 680 987 l 810 987 l 810 319 q 760 134 810 208 q 629 23 711 60 q 452 -14 547 -14 q 270 23 351 -14 q 142 134 189 60 q 95 319 95 208 l 95 987 l 224 987 l 224 319 q 253 192 224 242 q 333 117 281 142 q 452 93 384 93 q 571 117 520 93 q 651 192 623 142 q 680 319 680 242 l 680 987 m 608 1239 l 693 1232 q 673 1145 693 1182 q 621 1087 654 1107 q 547 1067 588 1067 q 490 1077 512 1067 q 450 1099 467 1086 q 413 1121 432 1112 q 365 1131 393 1131 q 317 1109 336 1131 q 298 1056 298 1088 l 213 1060 q 232 1147 213 1109 q 285 1206 252 1185 q 359 1227 318 1227 q 410 1218 388 1227 q 452 1195 432 1208 q 492 1173 471 1183 q 541 1163 513 1163 q 589 1185 569 1163 q 608 1239 608 1207 z "},"ũ":{"ha":766,"x_min":93,"x_max":671,"o":"m 545 170 l 545 734 l 671 734 l 671 0 l 551 0 l 545 170 m 568 324 l 621 326 q 605 190 621 252 q 556 83 590 128 q 467 12 522 37 q 334 -14 412 -14 q 236 2 280 -14 q 159 50 191 18 q 110 135 127 83 q 93 260 93 187 l 93 734 l 218 734 l 218 259 q 230 177 218 210 q 260 126 241 145 q 303 100 279 108 q 353 93 328 93 q 480 124 433 93 q 548 207 527 155 q 568 324 568 260 m 541 1028 l 625 1021 q 606 934 625 971 q 553 876 586 897 q 479 856 520 856 q 422 866 444 856 q 382 888 399 876 q 345 910 364 901 q 297 920 326 920 q 249 899 269 920 q 230 845 230 877 l 145 849 q 164 936 145 899 q 217 995 184 974 q 291 1017 250 1017 q 342 1007 320 1017 q 384 984 364 997 q 425 962 404 972 q 473 952 446 952 q 521 974 501 952 q 541 1028 541 996 z "},"Ū":{"ha":901,"x_min":95,"x_max":810,"o":"m 680 987 l 810 987 l 810 319 q 760 134 810 208 q 629 23 711 60 q 452 -14 547 -14 q 270 23 351 -14 q 142 134 189 60 q 95 319 95 208 l 95 987 l 224 987 l 224 319 q 253 192 224 242 q 333 117 281 142 q 452 93 384 93 q 571 117 520 93 q 651 192 623 142 q 680 319 680 242 l 680 987 m 684 1196 l 684 1100 l 229 1100 l 229 1196 l 684 1196 z "},"ū":{"ha":766,"x_min":93,"x_max":671,"o":"m 545 170 l 545 734 l 671 734 l 671 0 l 551 0 l 545 170 m 568 324 l 621 326 q 605 190 621 252 q 556 83 590 128 q 467 12 522 37 q 334 -14 412 -14 q 236 2 280 -14 q 159 50 191 18 q 110 135 127 83 q 93 260 93 187 l 93 734 l 218 734 l 218 259 q 230 177 218 210 q 260 126 241 145 q 303 100 279 108 q 353 93 328 93 q 480 124 433 93 q 548 207 527 155 q 568 324 568 260 m 616 985 l 616 889 l 161 889 l 161 985 l 616 985 z "},"Ŭ":{"ha":901,"x_min":95,"x_max":810,"o":"m 680 987 l 810 987 l 810 319 q 760 134 810 208 q 629 23 711 60 q 452 -14 547 -14 q 270 23 351 -14 q 142 134 189 60 q 95 319 95 208 l 95 987 l 224 987 l 224 319 q 253 192 224 242 q 333 117 281 142 q 452 93 384 93 q 571 117 520 93 q 651 192 623 142 q 680 319 680 242 l 680 987 m 553 1225 l 655 1225 q 631 1131 655 1172 q 561 1067 606 1090 q 453 1044 515 1044 q 304 1094 359 1044 q 250 1225 250 1145 l 351 1225 q 374 1154 351 1185 q 453 1124 397 1124 q 530 1154 507 1124 q 553 1225 553 1185 z "},"ŭ":{"ha":766,"x_min":93,"x_max":671,"o":"m 545 170 l 545 734 l 671 734 l 671 0 l 551 0 l 545 170 m 568 324 l 621 326 q 605 190 621 252 q 556 83 590 128 q 467 12 522 37 q 334 -14 412 -14 q 236 2 280 -14 q 159 50 191 18 q 110 135 127 83 q 93 260 93 187 l 93 734 l 218 734 l 218 259 q 230 177 218 210 q 260 126 241 145 q 303 100 279 108 q 353 93 328 93 q 480 124 433 93 q 548 207 527 155 q 568 324 568 260 m 486 1014 l 587 1014 q 563 920 587 961 q 493 856 538 879 q 385 833 448 833 q 236 883 291 833 q 182 1014 182 934 l 283 1014 q 307 943 283 974 q 385 913 330 913 q 463 943 439 913 q 486 1014 486 974 z "},"Ů":{"ha":901,"x_min":95,"x_max":810,"o":"m 680 987 l 810 987 l 810 319 q 760 134 810 208 q 629 23 711 60 q 452 -14 547 -14 q 270 23 351 -14 q 142 134 189 60 q 95 319 95 208 l 95 987 l 224 987 l 224 319 q 253 192 224 242 q 333 117 281 142 q 452 93 384 93 q 571 117 520 93 q 651 192 623 142 q 680 319 680 242 l 680 987 m 307 1174 q 326 1245 307 1213 q 378 1296 345 1277 q 452 1315 411 1315 q 556 1274 514 1315 q 598 1174 598 1232 q 579 1103 598 1135 q 527 1054 559 1072 q 452 1036 494 1036 q 349 1075 391 1036 q 307 1174 307 1114 m 374 1174 q 396 1120 374 1144 q 452 1096 418 1096 q 509 1119 487 1096 q 531 1174 531 1143 q 509 1230 531 1206 q 452 1254 487 1254 q 396 1230 418 1254 q 374 1174 374 1206 z "},"ů":{"ha":766,"x_min":93,"x_max":671,"o":"m 545 170 l 545 734 l 671 734 l 671 0 l 551 0 l 545 170 m 568 324 l 621 326 q 605 190 621 252 q 556 83 590 128 q 467 12 522 37 q 334 -14 412 -14 q 236 2 280 -14 q 159 50 191 18 q 110 135 127 83 q 93 260 93 187 l 93 734 l 218 734 l 218 259 q 230 177 218 210 q 260 126 241 145 q 303 100 279 108 q 353 93 328 93 q 480 124 433 93 q 548 207 527 155 q 568 324 568 260 m 239 963 q 258 1034 239 1002 q 310 1085 277 1066 q 385 1104 343 1104 q 488 1063 446 1104 q 530 963 530 1021 q 511 892 530 924 q 459 843 492 861 q 385 825 426 825 q 281 864 323 825 q 239 963 239 903 m 306 963 q 328 909 306 933 q 385 885 350 885 q 441 908 419 885 q 463 963 463 932 q 441 1019 463 995 q 385 1043 419 1043 q 328 1019 350 1043 q 306 963 306 995 z "},"Ű":{"ha":901,"x_min":95,"x_max":810,"o":"m 680 987 l 810 987 l 810 319 q 760 134 810 208 q 629 23 711 60 q 452 -14 547 -14 q 270 23 351 -14 q 142 134 189 60 q 95 319 95 208 l 95 987 l 224 987 l 224 319 q 253 192 224 242 q 333 117 281 142 q 452 93 384 93 q 571 117 520 93 q 651 192 623 142 q 680 319 680 242 l 680 987 m 473 1046 l 629 1252 l 770 1252 l 588 1046 l 473 1046 m 283 1046 l 399 1252 l 533 1252 l 385 1046 l 283 1046 z "},"ű":{"ha":766,"x_min":93,"x_max":702,"o":"m 545 170 l 545 734 l 671 734 l 671 0 l 551 0 l 545 170 m 568 324 l 621 326 q 605 190 621 252 q 556 83 590 128 q 467 12 522 37 q 334 -14 412 -14 q 236 2 280 -14 q 159 50 191 18 q 110 135 127 83 q 93 260 93 187 l 93 734 l 218 734 l 218 259 q 230 177 218 210 q 260 126 241 145 q 303 100 279 108 q 353 93 328 93 q 480 124 433 93 q 548 207 527 155 q 568 324 568 260 m 406 836 l 562 1041 l 702 1041 l 520 836 l 406 836 m 216 836 l 331 1041 l 465 1041 l 317 836 l 216 836 z "},"Ų":{"ha":901,"x_min":95,"x_max":810,"o":"m 680 987 l 810 987 l 810 319 q 760 134 810 208 q 629 23 711 60 q 452 -14 547 -14 q 270 23 351 -14 q 142 134 189 60 q 95 319 95 208 l 95 987 l 224 987 l 224 319 q 253 192 224 242 q 333 117 281 142 q 452 93 384 93 q 571 117 520 93 q 651 192 623 142 q 680 319 680 242 l 680 987 m 588 68 l 638 30 q 583 -15 609 8 q 539 -65 556 -39 q 522 -121 522 -91 q 534 -157 522 -143 q 575 -170 546 -170 q 615 -164 597 -170 q 643 -152 633 -157 l 652 -235 q 609 -255 635 -245 q 543 -264 583 -264 q 451 -232 488 -264 q 413 -135 413 -199 q 431 -62 413 -98 q 488 7 449 -26 q 588 68 526 40 z "},"ų":{"ha":766,"x_min":93,"x_max":678,"o":"m 545 170 l 545 734 l 671 734 l 671 0 l 551 0 l 545 170 m 568 324 l 621 326 q 605 190 621 252 q 556 83 590 128 q 467 12 522 37 q 334 -14 412 -14 q 236 2 280 -14 q 159 50 191 18 q 110 135 127 83 q 93 260 93 187 l 93 734 l 218 734 l 218 259 q 230 177 218 210 q 260 126 241 145 q 303 100 279 108 q 353 93 328 93 q 480 124 433 93 q 548 207 527 155 q 568 324 568 260 m 614 39 l 664 0 q 608 -45 635 -22 q 565 -95 582 -68 q 548 -151 548 -121 q 560 -186 548 -173 q 601 -200 572 -200 q 641 -194 623 -200 q 669 -182 659 -187 l 678 -264 q 635 -284 661 -275 q 569 -294 609 -294 q 476 -261 514 -294 q 439 -165 439 -229 q 457 -92 439 -128 q 513 -23 475 -56 q 614 39 552 10 z "},"Ŵ":{"ha":1232,"x_min":41,"x_max":1202,"o":"m 374 298 l 570 987 l 665 987 l 610 720 l 399 0 l 305 0 l 374 298 m 172 987 l 328 312 l 374 0 l 281 0 l 41 987 l 172 987 m 919 313 l 1072 987 l 1202 987 l 964 0 l 870 0 l 919 313 m 680 987 l 870 298 l 939 0 l 845 0 l 642 720 l 586 987 l 680 987 m 665 1253 l 833 1067 l 833 1061 l 728 1061 l 627 1175 l 526 1061 l 422 1061 l 422 1068 l 589 1253 l 665 1253 z "},"ŵ":{"ha":1044,"x_min":29,"x_max":1011,"o":"m 281 130 l 470 734 l 553 734 l 536 614 l 345 0 l 264 0 l 281 130 m 155 734 l 315 123 l 327 0 l 242 0 l 29 734 l 155 734 m 733 128 l 886 734 l 1011 734 l 798 0 l 714 0 l 733 128 m 571 734 l 755 140 l 777 0 l 696 0 l 499 615 l 483 734 l 571 734 m 555 1042 l 724 857 l 724 850 l 619 850 l 517 964 l 416 850 l 313 850 l 313 857 l 479 1042 l 555 1042 z "},"Ŷ":{"ha":834,"x_min":10,"x_max":822,"o":"m 160 987 l 416 492 l 673 987 l 822 987 l 481 369 l 481 0 l 351 0 l 351 369 l 10 987 l 160 987 m 457 1252 l 625 1067 l 625 1060 l 521 1060 l 419 1175 l 318 1060 l 215 1060 l 215 1067 l 381 1252 l 457 1252 z "},"ŷ":{"ha":657,"x_min":15,"x_max":640,"o":"m 302 76 l 506 734 l 640 734 l 346 -113 q 319 -172 336 -140 q 277 -232 302 -203 q 215 -278 251 -260 q 128 -296 178 -296 q 90 -292 113 -296 q 58 -286 67 -288 l 57 -184 q 74 -185 62 -184 q 91 -186 86 -186 q 163 -175 134 -186 q 214 -138 193 -164 q 250 -66 235 -112 l 302 76 m 152 734 l 342 164 l 375 32 l 285 -14 l 15 734 l 152 734 m 382 1042 l 551 857 l 551 850 l 446 850 l 345 964 l 243 850 l 140 850 l 140 857 l 307 1042 l 382 1042 z "},"Ÿ":{"ha":834,"x_min":10,"x_max":822,"o":"m 160 987 l 416 492 l 673 987 l 822 987 l 481 369 l 481 0 l 351 0 l 351 369 l 10 987 l 160 987 m 201 1140 q 220 1192 201 1171 q 275 1213 239 1213 q 330 1192 311 1213 q 349 1140 349 1171 q 330 1090 349 1111 q 275 1069 311 1069 q 220 1090 239 1069 q 201 1140 201 1111 m 493 1139 q 512 1190 493 1169 q 567 1211 530 1211 q 622 1190 603 1211 q 642 1139 642 1169 q 622 1089 642 1109 q 567 1068 603 1068 q 512 1089 530 1068 q 493 1139 493 1109 z "},"Ź":{"ha":832,"x_min":59,"x_max":777,"o":"m 777 106 l 777 0 l 109 0 l 109 106 l 777 106 m 755 892 l 140 0 l 59 0 l 59 98 l 674 987 l 755 987 l 755 892 m 700 987 l 700 880 l 68 880 l 68 987 l 700 987 m 349 1053 l 480 1253 l 631 1253 l 450 1053 l 349 1053 z "},"ź":{"ha":689,"x_min":60,"x_max":642,"o":"m 642 103 l 642 0 l 109 0 l 109 103 l 642 103 m 623 645 l 137 0 l 60 0 l 60 92 l 543 734 l 623 734 l 623 645 m 567 734 l 567 630 l 66 630 l 66 734 l 567 734 m 280 842 l 412 1042 l 563 1042 l 381 842 l 280 842 z "},"Ż":{"ha":832,"x_min":59,"x_max":777,"o":"m 777 106 l 777 0 l 109 0 l 109 106 l 777 106 m 755 892 l 140 0 l 59 0 l 59 98 l 674 987 l 755 987 l 755 892 m 700 987 l 700 880 l 68 880 l 68 987 l 700 987 m 344 1139 q 362 1190 344 1168 q 418 1211 381 1211 q 473 1190 454 1211 q 492 1139 492 1168 q 473 1088 492 1109 q 418 1067 454 1067 q 362 1088 381 1067 q 344 1139 344 1109 z "},"ż":{"ha":689,"x_min":60,"x_max":642,"o":"m 642 103 l 642 0 l 109 0 l 109 103 l 642 103 m 623 645 l 137 0 l 60 0 l 60 92 l 543 734 l 623 734 l 623 645 m 567 734 l 567 630 l 66 630 l 66 734 l 567 734 m 275 928 q 294 979 275 958 q 349 1000 313 1000 q 405 979 385 1000 q 424 928 424 958 q 405 877 424 898 q 349 857 385 857 q 294 877 313 857 q 275 928 275 898 z "},"Ž":{"ha":832,"x_min":59,"x_max":777,"o":"m 777 106 l 777 0 l 109 0 l 109 106 l 777 106 m 755 892 l 140 0 l 59 0 l 59 98 l 674 987 l 755 987 l 755 892 m 700 987 l 700 880 l 68 880 l 68 987 l 700 987 m 315 1252 l 417 1137 l 519 1252 l 628 1252 l 628 1245 l 456 1059 l 378 1059 l 209 1245 l 209 1252 l 315 1252 z "},"ž":{"ha":689,"x_min":60,"x_max":642,"o":"m 642 103 l 642 0 l 109 0 l 109 103 l 642 103 m 623 645 l 137 0 l 60 0 l 60 92 l 543 734 l 623 734 l 623 645 m 567 734 l 567 630 l 66 630 l 66 734 l 567 734 m 246 1041 l 349 926 l 451 1041 l 559 1041 l 559 1034 l 387 848 l 310 848 l 140 1034 l 140 1041 l 246 1041 z "},"Ǽ":{"ha":1298,"x_min":-10,"x_max":1275,"o":"m 658 886 l 144 0 l -10 0 l 587 987 l 668 987 l 658 886 m 756 358 l 756 239 l 252 239 l 252 358 l 756 358 m 1275 103 l 1275 0 l 778 0 l 778 103 l 1275 103 m 760 987 l 802 0 l 675 0 l 634 987 l 760 987 m 1178 566 l 1178 463 l 751 463 l 751 566 l 1178 566 m 1233 987 l 1233 884 l 736 884 l 736 987 l 1233 987 m 568 1061 l 699 1260 l 850 1260 l 669 1061 l 568 1061 z "},"ǽ":{"ha":1173,"x_min":54,"x_max":1126,"o":"m 508 124 l 508 488 q 491 572 508 537 q 442 626 475 607 q 363 644 410 644 q 275 627 313 644 q 218 580 238 609 q 197 515 197 551 l 73 528 q 94 615 73 575 q 153 685 115 655 q 244 731 191 715 q 363 747 298 747 q 503 718 443 747 q 596 631 563 689 q 630 487 630 574 l 630 148 l 508 124 m 536 431 l 536 336 l 359 336 q 260 318 300 336 q 199 269 220 299 q 179 203 179 239 q 194 145 179 171 q 240 103 210 119 q 319 88 271 88 q 394 102 355 88 q 464 138 432 116 q 516 184 496 160 q 537 230 536 209 l 602 132 q 544 65 584 99 q 443 8 505 31 q 294 -14 380 -14 q 163 13 217 -14 q 81 90 109 40 q 54 206 54 140 q 73 301 54 260 q 131 372 92 343 q 226 416 169 401 q 357 431 283 431 l 536 431 m 857 -14 q 709 13 773 -14 q 602 89 646 40 q 536 205 559 138 q 514 353 514 273 l 514 382 q 537 530 514 463 q 603 646 561 597 q 703 721 646 694 q 827 747 760 748 q 956 725 900 747 q 1050 659 1012 702 q 1107 555 1088 616 q 1126 418 1126 494 l 1126 338 l 581 338 l 581 434 l 1000 434 l 1000 455 q 983 549 1000 507 q 928 618 966 592 q 827 644 890 644 q 744 624 780 644 q 683 568 708 604 q 646 484 659 532 q 633 382 633 437 l 633 353 q 646 250 633 298 q 686 166 659 202 q 755 109 713 130 q 857 89 798 89 q 987 114 937 89 q 1070 161 1036 138 l 1114 69 q 1066 38 1099 58 q 981 2 1034 18 q 857 -14 929 -14 m 513 843 l 645 1042 l 796 1042 l 614 843 l 513 843 z "},"Ǿ":{"ha":956,"x_min":81,"x_max":888,"o":"m 888 1028 l 208 -63 l 111 -63 l 793 1028 l 888 1028 m 875 525 l 875 463 q 847 263 875 351 q 767 113 819 175 q 642 19 715 52 q 479 -14 569 -14 q 348 7 409 -14 q 238 69 287 28 q 153 167 189 109 q 99 299 118 225 q 81 463 81 374 l 81 525 q 110 724 81 636 q 191 874 138 812 q 317 968 244 936 q 477 1001 390 1001 q 611 980 549 1001 q 721 919 672 959 q 804 820 770 878 q 857 688 838 762 q 875 525 875 614 m 745 463 l 745 526 q 734 654 745 597 q 700 755 722 711 q 645 829 677 800 q 570 874 612 859 q 477 890 528 890 q 367 866 416 890 q 283 796 318 842 q 229 682 248 750 q 210 526 210 614 l 210 463 q 222 334 210 391 q 258 232 235 276 q 314 157 281 187 q 389 112 347 127 q 479 97 430 97 q 592 121 543 97 q 676 191 642 144 q 728 306 710 237 q 745 463 745 374 m 416 1103 l 547 1302 l 699 1302 l 517 1103 l 416 1103 z "},"ǿ":{"ha":787,"x_min":62,"x_max":730,"o":"m 667 820 l 217 -92 l 134 -92 l 583 820 l 667 820 m 62 359 l 62 374 q 85 522 62 454 q 152 641 109 590 q 257 719 195 691 q 395 747 319 747 q 535 719 473 747 q 640 641 597 691 q 707 522 684 590 q 730 374 730 454 l 730 359 q 707 212 730 279 q 640 93 684 144 q 535 15 597 43 q 397 -14 474 -14 q 258 15 319 -14 q 152 93 196 43 q 85 212 109 144 q 62 359 62 279 m 188 374 l 188 359 q 201 255 188 304 q 240 170 214 207 q 305 111 266 132 q 397 90 345 90 q 487 111 448 90 q 552 170 526 132 q 591 255 578 207 q 604 359 604 304 l 604 374 q 591 477 604 429 q 552 563 578 526 q 487 623 526 601 q 395 644 448 644 q 305 623 344 644 q 240 563 266 601 q 201 477 214 526 q 188 374 188 429 m 295 842 l 427 1041 l 578 1041 l 396 842 l 295 842 z "},"Ά":{"ha":906,"x_min":20,"x_max":888,"o":"m 480 900 l 153 0 l 20 0 l 396 987 l 482 987 l 480 900 m 754 0 l 427 900 l 425 987 l 511 987 l 888 0 l 754 0 m 737 366 l 737 258 l 182 258 l 182 366 l 737 366 m 127 856 l 163 1084 l 281 1084 l 203 856 l 127 856 z "},"Έ":{"ha":857,"x_min":-79,"x_max":810,"o":"m 810 106 l 810 0 l 287 0 l 287 106 l 810 106 m 313 987 l 313 0 l 182 0 l 182 987 l 313 987 m 741 563 l 741 456 l 287 456 l 287 563 l 741 563 m 803 987 l 803 880 l 287 880 l 287 987 l 803 987 m -79 857 l -42 1084 l 76 1084 l -3 857 l -79 857 z "},"Ή":{"ha":1059,"x_min":-69,"x_max":941,"o":"m 827 563 l 827 456 l 293 456 l 293 563 l 827 563 m 313 987 l 313 0 l 182 0 l 182 987 l 313 987 m 941 987 l 941 0 l 811 0 l 811 987 l 941 987 m -69 858 l -33 1086 l 85 1086 l 7 858 l -69 858 z "},"Ί":{"ha":446,"x_min":-65,"x_max":323,"o":"m 323 987 l 323 0 l 192 0 l 192 987 l 323 987 m -65 858 l -28 1086 l 90 1086 l 11 858 l -65 858 z "},"Ό":{"ha":969,"x_min":-4,"x_max":888,"o":"m 888 525 l 888 463 q 861 263 888 351 q 781 113 833 175 q 655 19 728 52 q 492 -14 583 -14 q 332 19 405 -14 q 206 113 259 52 q 123 263 153 175 q 94 463 94 351 l 94 525 q 123 724 94 636 q 205 874 152 812 q 331 968 258 936 q 491 1001 404 1001 q 654 968 581 1001 q 780 874 727 936 q 860 724 832 812 q 888 525 888 636 m 759 463 l 759 526 q 741 682 759 614 q 688 796 723 750 q 604 866 654 842 q 491 890 554 890 q 381 866 430 890 q 297 796 332 842 q 243 682 262 750 q 224 526 224 614 l 224 463 q 243 306 224 374 q 297 191 262 237 q 382 121 333 144 q 492 97 431 97 q 606 121 556 97 q 689 191 655 144 q 741 306 724 237 q 759 463 759 374 m -4 856 l 33 1084 l 151 1084 l 72 856 l -4 856 z "},"Ύ":{"ha":902,"x_min":-94,"x_max":890,"o":"m 228 987 l 484 492 l 741 987 l 890 987 l 549 369 l 549 0 l 418 0 l 418 369 l 78 987 l 228 987 m -94 856 l -57 1084 l 61 1084 l -18 856 l -94 856 z "},"Ώ":{"ha":937,"x_min":-3,"x_max":846,"o":"m 714 492 l 714 571 q 697 711 714 650 q 648 812 680 771 q 570 874 615 853 q 467 895 524 895 q 366 874 411 895 q 289 812 321 853 q 240 711 257 771 q 223 571 223 650 l 223 492 q 238 338 223 406 q 279 223 252 271 q 344 148 307 176 q 427 111 382 119 l 427 15 q 293 67 354 24 q 186 177 231 110 q 116 325 141 243 q 91 492 91 406 l 91 570 q 118 745 91 666 q 195 881 145 824 q 314 970 245 939 q 467 1001 383 1001 q 622 970 552 1001 q 741 881 691 939 q 819 745 791 824 q 846 570 846 666 l 846 492 q 822 326 846 407 q 752 177 797 244 q 647 67 707 111 q 514 15 586 24 l 514 111 q 596 148 559 120 q 659 224 633 176 q 700 339 686 272 q 714 492 714 406 m 514 0 l 514 106 l 842 106 l 842 0 l 514 0 m 94 0 l 94 106 l 427 106 l 427 0 l 94 0 m -3 856 l 34 1084 l 152 1084 l 73 856 l -3 856 z "},"ΐ":{"ha":450,"x_min":-68,"x_max":464,"o":"m 132 734 l 258 734 l 258 187 q 270 131 258 150 q 300 105 281 112 q 339 99 318 99 q 372 102 355 99 q 398 107 389 105 l 399 5 q 360 -4 384 1 q 302 -9 336 -9 q 217 10 256 -9 q 155 72 178 28 q 132 188 132 115 l 132 734 m 148 941 l 180 1120 l 308 1120 l 240 941 l 148 941 m -68 916 q -50 967 -68 946 q 5 988 -31 988 q 61 967 41 988 q 80 916 80 946 q 61 866 80 886 q 5 845 41 845 q -50 866 -31 845 q -68 916 -68 886 m 315 914 q 334 966 315 945 q 389 987 353 987 q 445 966 426 987 q 464 914 464 945 q 445 864 464 885 q 389 844 426 844 q 334 864 353 844 q 315 914 315 885 z "},"Α":{"ha":906,"x_min":20,"x_max":888,"o":"m 480 900 l 153 0 l 20 0 l 396 987 l 482 987 l 480 900 m 754 0 l 427 900 l 425 987 l 511 987 l 888 0 l 754 0 m 737 366 l 737 258 l 182 258 l 182 366 l 737 366 z "},"Β":{"ha":865,"x_min":115,"x_max":787,"o":"m 467 462 l 216 462 l 215 567 l 442 567 q 541 586 498 567 q 606 641 583 605 q 629 726 629 676 q 609 814 629 780 q 546 864 588 848 q 438 880 503 880 l 245 880 l 245 0 l 115 0 l 115 987 l 438 987 q 574 972 514 987 q 675 925 633 957 q 739 843 717 892 q 760 724 760 793 q 729 614 760 663 q 643 534 698 565 q 513 494 587 503 l 467 462 m 460 0 l 165 0 l 239 106 l 460 106 q 567 128 523 106 q 633 190 610 150 q 656 283 656 229 q 637 378 656 338 q 575 440 617 418 q 467 462 533 462 l 280 462 l 281 567 l 536 567 l 564 529 q 685 489 635 523 q 761 401 734 454 q 787 285 787 349 q 746 129 787 193 q 633 33 706 66 q 460 0 559 0 z "},"Ε":{"ha":789,"x_min":115,"x_max":742,"o":"m 742 106 l 742 0 l 219 0 l 219 106 l 742 106 m 245 987 l 245 0 l 115 0 l 115 987 l 245 987 m 673 563 l 673 456 l 219 456 l 219 563 l 673 563 m 735 987 l 735 880 l 219 880 l 219 987 l 735 987 z "},"Ζ":{"ha":832,"x_min":59,"x_max":777,"o":"m 777 106 l 777 0 l 109 0 l 109 106 l 777 106 m 755 892 l 140 0 l 59 0 l 59 98 l 674 987 l 755 987 l 755 892 m 700 987 l 700 880 l 68 880 l 68 987 l 700 987 z "},"Η":{"ha":991,"x_min":115,"x_max":873,"o":"m 760 563 l 760 456 l 225 456 l 225 563 l 760 563 m 245 987 l 245 0 l 115 0 l 115 987 l 245 987 m 873 987 l 873 0 l 743 0 l 743 987 l 873 987 z "},"Ι":{"ha":378,"x_min":124,"x_max":255,"o":"m 255 987 l 255 0 l 124 0 l 124 987 l 255 987 z "},"Κ":{"ha":871,"x_min":115,"x_max":871,"o":"m 245 987 l 245 0 l 115 0 l 115 987 l 245 987 m 842 987 l 431 527 l 201 288 l 179 427 l 353 618 l 684 987 l 842 987 m 715 0 l 350 481 l 428 585 l 871 0 l 715 0 z "},"Μ":{"ha":1213,"x_min":115,"x_max":1097,"o":"m 156 987 l 283 987 l 606 182 l 929 987 l 1057 987 l 655 0 l 556 0 l 156 987 m 115 987 l 227 987 l 245 385 l 245 0 l 115 0 l 115 987 m 985 987 l 1097 987 l 1097 0 l 967 0 l 967 385 l 985 987 z "},"Ν":{"ha":991,"x_min":115,"x_max":874,"o":"m 874 987 l 874 0 l 743 0 l 245 762 l 245 0 l 115 0 l 115 987 l 245 987 l 745 224 l 745 987 l 874 987 z "},"Ο":{"ha":956,"x_min":81,"x_max":875,"o":"m 875 525 l 875 463 q 847 263 875 351 q 767 113 819 175 q 642 19 715 52 q 479 -14 569 -14 q 318 19 391 -14 q 192 113 245 52 q 110 263 139 175 q 81 463 81 351 l 81 525 q 110 724 81 636 q 191 874 138 812 q 317 968 244 936 q 477 1001 390 1001 q 641 968 568 1001 q 766 874 713 936 q 847 724 819 812 q 875 525 875 636 m 745 463 l 745 526 q 727 682 745 614 q 675 796 709 750 q 590 866 640 842 q 477 890 541 890 q 367 866 416 890 q 283 796 318 842 q 229 682 248 750 q 210 526 210 614 l 210 463 q 229 306 210 374 q 284 191 248 237 q 369 121 319 144 q 479 97 418 97 q 592 121 543 97 q 676 191 642 144 q 728 306 710 237 q 745 463 745 374 z "},"Ρ":{"ha":876,"x_min":115,"x_max":825,"o":"m 479 387 l 215 387 l 215 494 l 479 494 q 603 518 555 494 q 672 586 650 543 q 694 685 694 629 q 672 781 694 736 q 603 853 650 825 q 479 880 555 880 l 245 880 l 245 0 l 115 0 l 115 987 l 479 987 q 668 949 591 987 q 785 842 745 910 q 825 686 825 774 q 785 524 825 591 q 668 422 745 457 q 479 387 591 387 z "},"Τ":{"ha":829,"x_min":34,"x_max":797,"o":"m 479 987 l 479 0 l 351 0 l 351 987 l 479 987 m 797 987 l 797 880 l 34 880 l 34 987 l 797 987 z "},"Υ":{"ha":834,"x_min":10,"x_max":822,"o":"m 160 987 l 416 492 l 673 987 l 822 987 l 481 369 l 481 0 l 351 0 l 351 369 l 10 987 l 160 987 z "},"Χ":{"ha":871,"x_min":39,"x_max":834,"o":"m 199 987 l 437 609 l 674 987 l 827 987 l 515 498 l 834 0 l 680 0 l 437 386 l 193 0 l 39 0 l 359 498 l 47 987 l 199 987 z "},"Ϊ":{"ha":378,"x_min":-29,"x_max":412,"o":"m 255 987 l 255 0 l 124 0 l 124 987 l 255 987 m -29 1148 q -10 1200 -29 1179 q 45 1221 9 1221 q 100 1200 81 1221 q 119 1148 119 1179 q 100 1098 119 1119 q 45 1078 81 1078 q -10 1098 9 1078 q -29 1148 -29 1119 m 263 1147 q 282 1198 263 1177 q 337 1219 300 1219 q 392 1198 373 1219 q 412 1147 412 1177 q 392 1097 412 1118 q 337 1076 373 1076 q 282 1097 300 1076 q 263 1147 263 1118 z "},"Ϋ":{"ha":834,"x_min":10,"x_max":822,"o":"m 160 987 l 416 492 l 673 987 l 822 987 l 481 369 l 481 0 l 351 0 l 351 369 l 10 987 l 160 987 m 201 1140 q 220 1192 201 1171 q 275 1213 239 1213 q 330 1192 311 1213 q 349 1140 349 1171 q 330 1090 349 1111 q 275 1069 311 1069 q 220 1090 239 1069 q 201 1140 201 1111 m 493 1139 q 512 1190 493 1169 q 567 1211 530 1211 q 622 1190 603 1211 q 642 1139 642 1169 q 622 1089 642 1109 q 567 1068 603 1068 q 512 1089 530 1068 q 493 1139 493 1109 z "},"ά":{"ha":785,"x_min":68,"x_max":776,"o":"m 68 340 l 68 354 q 87 513 68 441 q 142 637 106 585 q 232 719 178 690 q 355 747 286 747 q 450 732 408 747 q 525 686 492 716 q 581 613 557 656 q 618 515 604 570 q 638 394 632 460 l 638 338 q 610 192 631 256 q 555 81 590 127 q 471 10 521 35 q 353 -14 420 -14 q 232 12 286 -14 q 142 85 179 38 q 87 198 106 133 q 68 340 68 262 m 194 354 l 194 340 q 205 242 194 288 q 238 162 216 197 q 297 108 261 127 q 385 89 334 89 q 469 109 434 89 q 529 164 505 130 q 569 244 553 199 q 595 337 585 289 l 595 382 q 572 478 587 431 q 532 563 557 525 q 471 622 507 600 q 386 644 435 644 q 298 621 334 644 q 239 558 262 598 q 205 466 216 518 q 194 354 194 413 m 576 734 l 683 734 l 683 200 q 687 149 683 169 q 699 118 691 130 q 716 103 707 107 q 737 98 726 98 q 750 100 744 98 q 760 102 755 101 l 776 9 q 734 -10 755 -6 q 692 -14 714 -14 q 635 -2 661 -14 q 593 35 610 9 q 566 101 575 60 q 557 200 557 142 l 557 574 l 576 734 m 378 852 l 414 1080 l 532 1080 l 454 852 l 378 852 z "},"έ":{"ha":749,"x_min":68,"x_max":681,"o":"m 356 398 l 505 398 l 505 325 l 366 325 q 272 312 310 325 q 214 274 233 300 q 194 206 194 248 q 206 161 194 182 q 241 123 218 140 q 298 98 264 107 q 374 88 332 88 q 470 106 429 88 q 533 154 511 125 q 556 217 556 184 l 681 217 q 654 114 681 157 q 584 42 628 70 q 485 0 540 14 q 374 -14 431 -14 q 252 1 308 -14 q 155 45 196 16 q 91 114 113 73 q 68 207 68 155 q 87 289 68 253 q 143 349 106 324 q 234 386 180 373 q 356 398 288 398 m 505 351 l 356 351 q 243 365 294 351 q 156 405 192 379 q 100 463 119 430 q 81 534 81 496 q 101 626 81 586 q 161 692 122 665 q 254 733 199 719 q 374 747 308 747 q 488 732 435 747 q 582 688 541 717 q 646 620 623 660 q 669 530 669 580 l 544 530 q 521 588 544 562 q 460 630 498 614 q 374 645 422 645 q 279 629 317 645 q 224 588 242 613 q 206 534 206 562 q 215 490 206 510 q 243 455 224 470 q 293 433 262 441 q 366 425 323 425 l 505 425 l 505 351 m 328 851 l 364 1079 l 482 1079 l 404 851 l 328 851 z "},"ή":{"ha":787,"x_min":99,"x_max":684,"o":"m 224 577 l 224 0 l 99 0 l 99 734 l 212 734 l 224 577 m 199 391 l 146 389 q 165 533 146 467 q 223 646 185 598 q 314 721 260 694 q 436 747 368 747 q 539 734 493 747 q 617 688 585 720 q 667 603 650 656 q 684 471 684 550 l 684 -281 l 559 -281 l 559 469 q 548 553 559 519 q 517 607 538 587 q 467 635 496 627 q 399 644 437 644 q 307 624 345 644 q 245 569 269 604 q 210 488 221 534 q 199 391 199 442 m 346 852 l 382 1080 l 500 1080 l 422 852 l 346 852 z "},"ί":{"ha":450,"x_min":132,"x_max":399,"o":"m 132 734 l 258 734 l 258 187 q 270 131 258 150 q 300 105 281 112 q 339 99 318 99 q 372 102 355 99 q 398 107 389 105 l 399 5 q 360 -4 384 1 q 302 -9 336 -9 q 217 10 256 -9 q 155 72 178 28 q 132 188 132 115 l 132 734 m 153 838 l 190 1065 l 308 1065 l 229 838 l 153 838 z "},"ΰ":{"ha":758,"x_min":98,"x_max":688,"o":"m 98 734 l 223 734 l 223 289 q 233 196 223 235 q 262 134 243 158 q 306 100 281 111 q 360 89 331 89 q 448 114 410 89 q 511 182 486 140 q 549 277 536 225 q 562 381 562 329 q 537 562 561 473 q 479 734 513 650 l 611 734 q 649 639 631 692 q 677 522 667 586 q 688 382 688 458 q 669 232 688 304 q 610 105 650 161 q 509 18 570 50 q 366 -14 449 -14 q 255 4 304 -14 q 170 59 205 22 q 116 153 135 96 q 98 290 98 211 l 98 734 m 317 941 l 349 1120 l 477 1120 l 409 941 l 317 941 m 100 916 q 119 967 100 946 q 174 988 138 988 q 230 967 210 988 q 249 916 249 946 q 230 866 249 886 q 174 845 210 845 q 119 866 138 845 q 100 916 100 886 m 484 914 q 503 966 484 945 q 558 987 522 987 q 614 966 595 987 q 633 914 633 945 q 614 864 633 885 q 558 844 595 844 q 503 864 522 844 q 484 914 484 885 z "},"κ":{"ha":773,"x_min":105,"x_max":738,"o":"m 231 734 l 231 0 l 105 0 l 105 734 l 231 734 m 713 734 l 351 313 l 189 313 l 170 423 l 293 423 l 562 734 l 713 734 m 579 0 l 287 332 l 368 423 l 738 0 l 579 0 z "},"ο":{"ha":792,"x_min":62,"x_max":730,"o":"m 62 359 l 62 374 q 85 522 62 454 q 152 641 109 590 q 257 719 195 691 q 395 747 319 747 q 535 719 473 747 q 641 641 597 691 q 707 522 684 590 q 730 374 730 454 l 730 359 q 707 212 730 279 q 641 93 684 144 q 535 15 597 43 q 397 -14 474 -14 q 258 15 319 -14 q 152 93 196 43 q 85 212 109 144 q 62 359 62 279 m 188 374 l 188 359 q 201 255 188 304 q 240 170 214 207 q 305 111 266 132 q 397 90 345 90 q 487 111 448 90 q 552 170 526 132 q 591 255 578 207 q 604 359 604 304 l 604 374 q 591 477 604 429 q 552 563 578 526 q 487 623 526 601 q 395 644 448 644 q 305 623 344 644 q 240 563 266 601 q 201 477 214 526 q 188 374 188 429 z "},"μ":{"ha":787,"x_min":105,"x_max":682,"o":"m 557 734 l 682 734 l 682 0 l 569 0 l 557 170 l 557 734 m 579 341 l 626 342 q 612 200 626 265 q 569 87 598 135 q 494 12 540 39 q 385 -14 449 -14 q 293 -1 334 -14 q 224 41 253 12 q 176 116 195 70 l 151 312 l 230 312 q 241 198 230 242 q 274 130 253 154 q 321 98 294 106 q 380 89 349 89 q 479 107 440 89 q 540 160 518 126 q 570 240 562 194 q 579 341 579 286 m 105 734 l 230 734 l 230 -282 l 105 -282 l 105 734 z "},"ν":{"ha":673,"x_min":22,"x_max":648,"o":"m 319 113 l 519 734 l 648 734 l 384 0 l 300 0 l 319 113 m 151 734 l 358 110 l 372 0 l 288 0 l 22 734 l 151 734 z "},"χ":{"ha":770,"x_min":61,"x_max":774,"o":"m 710 734 l 215 -282 l 81 -282 l 583 734 l 710 734 m 132 744 q 214 726 181 744 q 270 680 248 708 q 307 621 292 652 q 333 563 321 589 l 614 -80 q 642 -132 627 -109 q 673 -169 656 -155 q 711 -182 690 -182 q 742 -181 722 -182 q 774 -178 763 -180 l 741 -286 q 722 -293 734 -291 q 700 -296 709 -296 q 632 -284 661 -296 q 581 -249 603 -272 q 541 -192 559 -226 q 503 -113 522 -157 l 230 513 q 200 573 217 545 q 161 619 184 602 q 108 637 139 637 q 85 635 100 637 q 62 633 71 634 l 61 734 q 94 741 73 738 q 132 744 115 744 z "},"ϊ":{"ha":450,"x_min":-19,"x_max":422,"o":"m 132 734 l 258 734 l 258 187 q 270 131 258 150 q 300 105 281 112 q 339 99 318 99 q 372 102 355 99 q 398 107 389 105 l 399 5 q 360 -4 384 1 q 302 -9 336 -9 q 217 10 256 -9 q 155 72 178 28 q 132 188 132 115 l 132 734 m -19 916 q 0 967 -19 946 q 55 988 19 988 q 111 967 92 988 q 130 916 130 946 q 111 866 130 886 q 55 845 92 845 q 0 866 19 845 q -19 916 -19 886 m 273 914 q 292 966 273 945 q 347 987 311 987 q 402 966 383 987 q 422 914 422 945 q 402 864 422 885 q 347 844 383 844 q 292 864 311 844 q 273 914 273 885 z "},"ϋ":{"ha":758,"x_min":98,"x_max":688,"o":"m 98 734 l 223 734 l 223 289 q 233 196 223 235 q 262 134 243 158 q 306 100 281 111 q 360 89 331 89 q 448 114 410 89 q 511 182 486 140 q 549 277 536 225 q 562 381 562 329 q 537 562 561 473 q 479 734 513 650 l 611 734 q 649 639 631 692 q 677 522 667 586 q 688 382 688 458 q 669 232 688 304 q 610 105 650 161 q 509 18 570 50 q 366 -14 449 -14 q 255 4 304 -14 q 170 59 205 22 q 116 153 135 96 q 98 290 98 211 l 98 734 m 150 916 q 169 967 150 946 q 224 988 188 988 q 279 967 260 988 q 298 916 298 946 q 279 866 298 886 q 224 845 260 845 q 169 866 188 845 q 150 916 150 886 m 442 914 q 461 966 442 945 q 516 987 479 987 q 571 966 552 987 q 591 914 591 945 q 571 864 591 885 q 516 844 552 844 q 461 864 479 844 q 442 914 442 885 z "},"ό":{"ha":792,"x_min":62,"x_max":730,"o":"m 62 359 l 62 374 q 85 522 62 454 q 152 641 109 590 q 257 719 195 691 q 395 747 319 747 q 535 719 473 747 q 641 641 597 691 q 707 522 684 590 q 730 374 730 454 l 730 359 q 707 212 730 279 q 641 93 684 144 q 535 15 597 43 q 397 -14 474 -14 q 258 15 319 -14 q 152 93 196 43 q 85 212 109 144 q 62 359 62 279 m 188 374 l 188 359 q 201 255 188 304 q 240 170 214 207 q 305 111 266 132 q 397 90 345 90 q 487 111 448 90 q 552 170 526 132 q 591 255 578 207 q 604 359 604 304 l 604 374 q 591 477 604 429 q 552 563 578 526 q 487 623 526 601 q 395 644 448 644 q 305 623 344 644 q 240 563 266 601 q 201 477 214 526 q 188 374 188 429 m 344 852 l 380 1080 l 498 1080 l 420 852 l 344 852 z "},"ύ":{"ha":758,"x_min":98,"x_max":688,"o":"m 98 734 l 223 734 l 223 289 q 233 196 223 235 q 262 134 243 158 q 306 100 281 111 q 360 89 331 89 q 448 114 410 89 q 511 182 486 140 q 549 277 536 225 q 562 381 562 329 q 537 562 561 473 q 479 734 513 650 l 611 734 q 649 639 631 692 q 677 522 667 586 q 688 382 688 458 q 669 232 688 304 q 610 105 650 161 q 509 18 570 50 q 366 -14 449 -14 q 255 4 304 -14 q 170 59 205 22 q 116 153 135 96 q 98 290 98 211 l 98 734 m 322 838 l 359 1065 l 477 1065 l 398 838 l 322 838 z "},"ώ":{"ha":1144,"x_min":83,"x_max":1059,"o":"m 836 734 l 967 734 q 1013 638 991 691 q 1046 521 1034 585 q 1059 380 1059 457 q 1045 231 1059 302 q 999 105 1030 160 q 916 18 967 50 q 791 -14 864 -14 q 687 8 732 -14 q 610 73 642 30 q 562 178 578 115 q 546 321 546 240 l 546 522 l 634 522 l 634 319 q 645 213 634 256 q 677 141 656 169 q 725 101 697 114 q 784 89 752 89 q 853 112 825 89 q 899 175 882 135 q 925 268 917 216 q 933 380 933 321 q 904 561 931 473 q 836 734 876 650 m 175 734 l 307 734 q 238 561 266 650 q 209 380 211 473 q 214 290 209 333 q 230 210 219 246 q 258 146 241 174 q 300 104 275 119 q 357 89 325 89 q 417 101 390 89 q 465 141 445 114 q 497 213 486 169 q 508 319 508 256 l 508 522 l 596 522 l 596 321 q 580 178 596 240 q 532 73 564 115 q 455 8 500 30 q 351 -14 410 -14 q 248 6 292 -14 q 172 64 203 27 q 121 152 140 102 q 92 260 101 201 q 83 380 83 318 q 96 521 83 457 q 130 638 109 585 q 175 734 151 691 m 529 836 l 566 1063 l 684 1063 l 605 836 l 529 836 z "},"Ё":{"ha":789,"x_min":115,"x_max":742,"o":"m 742 106 l 742 0 l 219 0 l 219 106 l 742 106 m 245 987 l 245 0 l 115 0 l 115 987 l 245 987 m 673 563 l 673 456 l 219 456 l 219 563 l 673 563 m 735 987 l 735 880 l 219 880 l 219 987 l 735 987 m 201 1148 q 220 1200 201 1179 q 275 1221 239 1221 q 331 1200 312 1221 q 350 1148 350 1179 q 331 1098 350 1119 q 275 1078 312 1078 q 220 1098 239 1078 q 201 1148 201 1119 m 494 1147 q 512 1198 494 1177 q 568 1219 531 1219 q 623 1198 604 1219 q 642 1147 642 1177 q 623 1097 642 1118 q 568 1076 604 1076 q 512 1097 531 1076 q 494 1147 494 1118 z "},"Ѓ":{"ha":772,"x_min":121,"x_max":727,"o":"m 727 987 l 727 880 l 251 880 l 251 0 l 121 0 l 121 987 l 727 987 m 355 1061 l 486 1260 l 637 1260 l 456 1061 l 355 1061 z "},"Ѕ":{"ha":825,"x_min":55,"x_max":772,"o":"m 641 250 q 630 311 641 284 q 594 359 620 338 q 522 401 568 381 q 406 441 476 420 q 274 489 333 463 q 173 551 215 516 q 109 630 131 585 q 86 732 86 675 q 110 839 86 790 q 178 924 134 888 q 284 981 222 960 q 422 1001 346 1001 q 611 959 533 1001 q 729 848 688 916 q 770 703 770 780 l 640 703 q 616 801 640 758 q 544 869 592 844 q 422 894 496 894 q 307 873 352 894 q 239 816 261 852 q 217 734 217 780 q 230 677 217 703 q 272 630 243 652 q 343 590 300 608 q 448 555 387 572 q 593 502 532 531 q 694 436 654 473 q 753 354 734 400 q 772 251 772 309 q 748 142 772 191 q 678 58 724 93 q 569 5 633 24 q 428 -14 506 -14 q 293 5 359 -14 q 173 62 227 24 q 87 156 119 100 q 55 286 55 212 l 185 286 q 205 199 185 235 q 259 139 224 163 q 337 104 293 115 q 428 93 380 93 q 544 112 496 93 q 616 166 591 131 q 641 250 641 201 z "},"І":{"ha":378,"x_min":124,"x_max":255,"o":"m 255 987 l 255 0 l 124 0 l 124 987 l 255 987 z "},"Ї":{"ha":378,"x_min":-29,"x_max":412,"o":"m 255 987 l 255 0 l 124 0 l 124 987 l 255 987 m -29 1148 q -10 1200 -29 1179 q 45 1221 9 1221 q 100 1200 81 1221 q 119 1148 119 1179 q 100 1098 119 1119 q 45 1078 81 1078 q -10 1098 9 1078 q -29 1148 -29 1119 m 263 1147 q 282 1198 263 1177 q 337 1219 300 1219 q 392 1198 373 1219 q 412 1147 412 1177 q 392 1097 412 1118 q 337 1076 373 1076 q 282 1097 300 1076 q 263 1147 263 1118 z "},"Ј":{"ha":766,"x_min":36,"x_max":659,"o":"m 529 288 l 529 987 l 659 987 l 659 288 q 619 123 659 191 q 509 21 579 56 q 348 -14 439 -14 q 186 18 257 -14 q 76 113 116 49 q 36 273 36 176 l 167 273 q 190 171 167 211 q 254 112 213 131 q 348 93 295 93 q 440 115 399 93 q 505 181 481 137 q 529 288 529 224 z "},"К":{"ha":892,"x_min":121,"x_max":888,"o":"m 252 987 l 252 0 l 121 0 l 121 987 l 252 987 m 860 987 l 431 444 l 199 444 l 179 553 l 353 553 l 698 987 l 860 987 m 728 0 l 357 461 l 431 576 l 888 0 l 728 0 z "},"Ќ":{"ha":871,"x_min":115,"x_max":871,"o":"m 245 987 l 245 0 l 115 0 l 115 987 l 245 987 m 842 987 l 431 527 l 201 288 l 179 427 l 353 618 l 684 987 l 842 987 m 715 0 l 350 481 l 428 585 l 871 0 l 715 0 m 341 1049 l 473 1249 l 624 1249 l 442 1049 l 341 1049 z "},"Ў":{"ha":873,"x_min":52,"x_max":832,"o":"m 420 328 l 682 987 l 832 987 l 483 165 q 450 98 468 130 q 405 41 431 66 q 339 1 378 16 q 243 -14 300 -14 q 204 -13 227 -14 q 175 -9 182 -11 l 179 96 q 208 93 186 94 q 240 92 230 92 q 301 108 279 92 q 337 148 323 123 q 363 197 351 172 l 420 328 m 199 987 l 473 372 l 506 251 l 396 243 l 52 987 l 199 987 m 539 1232 l 641 1232 q 616 1138 641 1179 q 547 1074 592 1097 q 439 1051 501 1051 q 290 1102 345 1051 q 235 1232 235 1152 l 337 1232 q 360 1162 337 1192 q 439 1131 383 1131 q 516 1162 493 1131 q 539 1232 539 1192 z "},"А":{"ha":906,"x_min":20,"x_max":888,"o":"m 480 900 l 153 0 l 20 0 l 396 987 l 482 987 l 480 900 m 754 0 l 427 900 l 425 987 l 511 987 l 888 0 l 754 0 m 737 366 l 737 258 l 182 258 l 182 366 l 737 366 z "},"В":{"ha":865,"x_min":115,"x_max":787,"o":"m 467 462 l 216 462 l 215 567 l 442 567 q 541 586 498 567 q 606 641 583 605 q 629 726 629 676 q 609 814 629 780 q 546 864 588 848 q 438 880 503 880 l 245 880 l 245 0 l 115 0 l 115 987 l 438 987 q 574 972 514 987 q 675 925 633 957 q 739 843 717 892 q 760 724 760 793 q 729 614 760 663 q 643 534 698 565 q 513 494 587 503 l 467 462 m 460 0 l 165 0 l 239 106 l 460 106 q 567 128 523 106 q 633 190 610 150 q 656 283 656 229 q 637 378 656 338 q 575 440 617 418 q 467 462 533 462 l 280 462 l 281 567 l 536 567 l 564 529 q 685 489 635 523 q 761 401 734 454 q 787 285 787 349 q 746 129 787 193 q 633 33 706 66 q 460 0 559 0 z "},"Г":{"ha":772,"x_min":121,"x_max":727,"o":"m 727 987 l 727 880 l 251 880 l 251 0 l 121 0 l 121 987 l 727 987 z "},"Е":{"ha":789,"x_min":115,"x_max":742,"o":"m 742 106 l 742 0 l 219 0 l 219 106 l 742 106 m 245 987 l 245 0 l 115 0 l 115 987 l 245 987 m 673 563 l 673 456 l 219 456 l 219 563 l 673 563 m 735 987 l 735 880 l 219 880 l 219 987 l 735 987 z "},"Й":{"ha":991,"x_min":121,"x_max":868,"o":"m 251 227 l 737 987 l 868 987 l 868 0 l 737 0 l 737 762 l 251 0 l 121 0 l 121 987 l 251 987 l 251 227 m 598 1232 l 700 1232 q 675 1138 700 1179 q 606 1074 651 1097 q 498 1051 560 1051 q 349 1102 404 1051 q 294 1232 294 1152 l 396 1232 q 419 1162 396 1192 q 498 1131 442 1131 q 575 1162 552 1131 q 598 1232 598 1192 z "},"М":{"ha":1213,"x_min":115,"x_max":1097,"o":"m 156 987 l 283 987 l 606 182 l 929 987 l 1057 987 l 655 0 l 556 0 l 156 987 m 115 987 l 227 987 l 245 385 l 245 0 l 115 0 l 115 987 m 985 987 l 1097 987 l 1097 0 l 967 0 l 967 385 l 985 987 z "},"Н":{"ha":991,"x_min":115,"x_max":873,"o":"m 760 563 l 760 456 l 225 456 l 225 563 l 760 563 m 245 987 l 245 0 l 115 0 l 115 987 l 245 987 m 873 987 l 873 0 l 743 0 l 743 987 l 873 987 z "},"О":{"ha":956,"x_min":81,"x_max":875,"o":"m 875 525 l 875 463 q 847 263 875 351 q 767 113 819 175 q 642 19 715 52 q 479 -14 569 -14 q 318 19 391 -14 q 192 113 245 52 q 110 263 139 175 q 81 463 81 351 l 81 525 q 110 724 81 636 q 191 874 138 812 q 317 968 244 936 q 477 1001 390 1001 q 641 968 568 1001 q 766 874 713 936 q 847 724 819 812 q 875 525 875 636 m 745 463 l 745 526 q 727 682 745 614 q 675 796 709 750 q 590 866 640 842 q 477 890 541 890 q 367 866 416 890 q 283 796 318 842 q 229 682 248 750 q 210 526 210 614 l 210 463 q 229 306 210 374 q 284 191 248 237 q 369 121 319 144 q 479 97 418 97 q 592 121 543 97 q 676 191 642 144 q 728 306 710 237 q 745 463 745 374 z "},"П":{"ha":991,"x_min":121,"x_max":869,"o":"m 869 987 l 869 0 l 739 0 l 739 880 l 252 880 l 252 0 l 121 0 l 121 987 l 869 987 z "},"Р":{"ha":876,"x_min":115,"x_max":825,"o":"m 479 387 l 215 387 l 215 494 l 479 494 q 603 518 555 494 q 672 586 650 543 q 694 685 694 629 q 672 781 694 736 q 603 853 650 825 q 479 880 555 880 l 245 880 l 245 0 l 115 0 l 115 987 l 479 987 q 668 949 591 987 q 785 842 745 910 q 825 686 825 774 q 785 524 825 591 q 668 422 745 457 q 479 387 591 387 z "},"С":{"ha":904,"x_min":81,"x_max":841,"o":"m 711 314 l 841 314 q 787 146 831 220 q 665 30 744 73 q 467 -14 585 -14 q 309 19 380 -14 q 187 112 238 52 q 109 256 136 172 q 81 444 81 340 l 81 543 q 109 731 81 646 q 188 876 136 815 q 313 968 240 936 q 478 1001 387 1001 q 667 959 590 1001 q 788 843 745 917 q 841 671 831 768 l 711 671 q 675 790 701 740 q 602 867 650 840 q 478 894 555 894 q 362 869 412 894 q 279 798 313 844 q 229 687 245 751 q 212 544 212 623 l 212 444 q 227 308 212 372 q 273 196 242 244 q 353 120 304 148 q 467 93 401 93 q 600 119 550 93 q 674 195 649 146 q 711 314 700 245 z "},"Т":{"ha":829,"x_min":34,"x_max":797,"o":"m 479 987 l 479 0 l 351 0 l 351 987 l 479 987 m 797 987 l 797 880 l 34 880 l 34 987 l 797 987 z "},"Х":{"ha":871,"x_min":39,"x_max":834,"o":"m 199 987 l 437 609 l 674 987 l 827 987 l 515 498 l 834 0 l 680 0 l 437 386 l 193 0 l 39 0 l 359 498 l 47 987 l 199 987 z "},"а":{"ha":755,"x_min":74,"x_max":680,"o":"m 528 125 l 528 503 q 511 579 528 547 q 459 629 494 611 q 374 646 425 646 q 291 630 326 646 q 235 587 255 614 q 215 530 215 561 l 90 530 q 110 608 90 570 q 169 679 130 647 q 261 729 207 710 q 381 747 315 747 q 523 720 461 747 q 619 638 584 693 q 654 502 654 584 l 654 160 q 660 82 654 123 q 680 11 667 41 l 680 0 l 549 0 q 534 58 539 22 q 528 125 528 94 m 550 445 l 551 357 l 425 357 q 329 348 371 357 q 258 323 287 340 q 215 280 230 306 q 200 221 200 255 q 216 158 200 186 q 263 113 231 130 q 340 96 294 96 q 442 121 398 96 q 512 180 486 145 q 541 249 538 216 l 594 189 q 568 125 589 160 q 512 59 547 91 q 430 7 477 28 q 322 -14 382 -14 q 192 16 248 -14 q 105 94 136 45 q 74 204 74 143 q 97 308 74 263 q 163 384 120 353 q 268 429 207 414 q 404 445 329 445 l 550 445 z "},"е":{"ha":736,"x_min":63,"x_max":686,"o":"m 400 -14 q 261 13 323 -14 q 155 86 199 39 q 87 199 111 134 q 63 341 63 264 l 63 370 q 90 529 63 459 q 161 648 116 600 q 264 722 207 697 q 384 747 322 747 q 520 720 463 747 q 614 645 577 693 q 668 531 650 596 q 686 388 686 465 l 686 332 l 138 332 l 138 434 l 560 434 l 560 444 q 540 538 557 492 q 486 614 523 585 q 384 644 448 644 q 305 626 341 644 q 243 573 269 608 q 203 487 218 538 q 189 370 189 436 l 189 341 q 204 243 189 289 q 247 163 218 197 q 315 109 275 128 q 407 89 355 89 q 519 116 473 89 q 600 189 566 143 l 676 128 q 616 60 652 92 q 526 7 579 27 q 400 -14 473 -14 z "},"й":{"ha":802,"x_min":106,"x_max":696,"o":"m 231 199 l 570 734 l 696 734 l 696 0 l 570 0 l 570 535 l 231 0 l 106 0 l 106 734 l 231 734 l 231 199 m 501 1000 l 603 1000 q 578 906 603 947 q 509 842 554 865 q 401 819 463 819 q 252 869 307 819 q 197 1000 197 920 l 299 1000 q 322 929 299 960 q 401 899 345 899 q 478 929 455 899 q 501 1000 501 960 z "},"о":{"ha":792,"x_min":62,"x_max":730,"o":"m 62 359 l 62 374 q 85 522 62 454 q 152 641 109 590 q 257 719 195 691 q 395 747 319 747 q 535 719 473 747 q 641 641 597 691 q 707 522 684 590 q 730 374 730 454 l 730 359 q 707 212 730 279 q 641 93 684 144 q 535 15 597 43 q 397 -14 474 -14 q 258 15 319 -14 q 152 93 196 43 q 85 212 109 144 q 62 359 62 279 m 188 374 l 188 359 q 201 255 188 304 q 240 170 214 207 q 305 111 266 132 q 397 90 345 90 q 487 111 448 90 q 552 170 526 132 q 591 255 578 207 q 604 359 604 304 l 604 374 q 591 477 604 429 q 552 563 578 526 q 487 623 526 601 q 395 644 448 644 q 305 623 344 644 q 240 563 266 601 q 201 477 214 526 q 188 374 188 429 z "},"р":{"ha":780,"x_min":95,"x_max":715,"o":"m 221 593 l 221 -282 l 95 -282 l 95 734 l 210 734 l 221 593 m 715 373 l 715 359 q 696 211 715 279 q 641 92 677 142 q 552 14 605 42 q 431 -14 499 -14 q 307 9 361 -14 q 216 77 254 33 q 157 182 179 121 q 127 321 135 244 l 127 397 q 157 543 135 479 q 217 653 180 608 q 307 723 254 699 q 429 747 359 747 q 551 721 498 747 q 642 644 605 694 q 697 526 678 595 q 715 373 715 457 m 589 359 l 589 373 q 578 476 589 428 q 542 562 566 525 q 481 620 518 599 q 392 642 444 642 q 310 625 345 642 q 250 582 275 609 q 211 519 226 554 q 188 447 195 484 l 188 271 q 226 182 201 224 q 291 115 250 140 q 393 90 332 90 q 481 111 444 90 q 542 170 518 132 q 578 255 566 207 q 589 359 589 304 z "},"с":{"ha":727,"x_min":63,"x_max":682,"o":"m 389 90 q 472 108 434 90 q 534 158 510 126 q 562 232 559 191 l 682 232 q 638 111 678 167 q 532 21 597 55 q 389 -14 467 -14 q 245 16 307 -14 q 143 96 184 45 q 83 213 103 146 q 63 353 63 279 l 63 381 q 83 521 63 455 q 143 638 103 587 q 245 718 184 689 q 389 747 307 747 q 540 712 475 747 q 641 617 604 677 q 682 481 678 557 l 562 481 q 537 564 559 527 q 477 622 515 600 q 389 644 439 644 q 293 622 332 644 q 231 561 254 599 q 198 476 208 522 q 189 381 189 429 l 189 353 q 198 258 189 304 q 230 173 208 211 q 292 112 253 135 q 389 90 331 90 z "},"у":{"ha":657,"x_min":15,"x_max":640,"o":"m 302 76 l 506 734 l 640 734 l 346 -113 q 319 -172 336 -140 q 277 -232 302 -203 q 215 -278 251 -260 q 128 -296 178 -296 q 90 -292 113 -296 q 58 -286 67 -288 l 57 -184 q 74 -185 62 -184 q 91 -186 86 -186 q 163 -175 134 -186 q 214 -138 193 -164 q 250 -66 235 -112 l 302 76 m 152 734 l 342 164 l 375 32 l 285 -14 l 15 734 l 152 734 z "},"х":{"ha":689,"x_min":28,"x_max":659,"o":"m 180 734 l 341 467 l 504 734 l 651 734 l 411 372 l 659 0 l 513 0 l 344 275 l 174 0 l 28 0 l 275 372 l 36 734 l 180 734 z "},"ё":{"ha":736,"x_min":63,"x_max":686,"o":"m 400 -14 q 261 13 323 -14 q 155 86 199 39 q 87 199 111 134 q 63 341 63 264 l 63 370 q 90 529 63 459 q 161 648 116 600 q 264 722 207 697 q 384 747 322 747 q 520 720 463 747 q 614 645 577 693 q 668 531 650 596 q 686 388 686 465 l 686 332 l 138 332 l 138 434 l 560 434 l 560 444 q 540 538 557 492 q 486 614 523 585 q 384 644 448 644 q 305 626 341 644 q 243 573 269 608 q 203 487 218 538 q 189 370 189 436 l 189 341 q 204 243 189 289 q 247 163 218 197 q 315 109 275 128 q 407 89 355 89 q 519 116 473 89 q 600 189 566 143 l 676 128 q 616 60 652 92 q 526 7 579 27 q 400 -14 473 -14 m 165 930 q 184 981 165 960 q 239 1002 203 1002 q 294 981 275 1002 q 313 930 313 960 q 294 880 313 901 q 239 859 275 859 q 184 880 203 859 q 165 930 165 901 m 457 928 q 476 980 457 959 q 531 1001 494 1001 q 586 980 567 1001 q 606 928 606 959 q 586 879 606 899 q 531 858 567 858 q 476 879 494 858 q 457 928 457 899 z "},"ѓ":{"ha":583,"x_min":105,"x_max":570,"o":"m 570 734 l 570 630 l 231 630 l 231 0 l 105 0 l 105 734 l 570 734 m 223 828 l 355 1027 l 506 1027 l 324 828 l 223 828 z "},"ѕ":{"ha":717,"x_min":64,"x_max":648,"o":"m 523 195 q 511 245 523 222 q 463 288 499 269 q 354 321 427 307 q 244 352 293 334 q 160 395 195 370 q 108 454 126 420 q 90 533 90 488 q 109 615 90 576 q 164 684 128 654 q 250 730 199 713 q 361 747 300 747 q 512 716 450 747 q 608 633 574 685 q 641 518 641 581 l 515 518 q 497 577 515 549 q 445 625 479 606 q 361 644 411 644 q 277 628 309 644 q 230 588 245 612 q 216 536 216 564 q 223 500 216 516 q 248 471 230 484 q 300 446 267 458 q 385 423 333 435 q 533 374 475 403 q 620 304 591 346 q 648 204 648 263 q 628 116 648 156 q 571 47 608 76 q 481 2 533 18 q 365 -14 429 -14 q 201 21 268 -14 q 99 111 134 56 q 64 227 64 165 l 191 227 q 220 145 193 175 q 287 102 248 115 q 365 90 326 90 q 451 103 416 90 q 505 140 486 117 q 523 195 523 164 z "},"і":{"ha":338,"x_min":96,"x_max":245,"o":"m 232 734 l 232 0 l 106 0 l 106 734 l 232 734 m 96 928 q 115 980 96 959 q 170 1001 134 1001 q 225 980 206 1001 q 245 928 245 959 q 225 879 245 899 q 170 858 206 858 q 115 879 134 858 q 96 928 96 899 z "},"ї":{"ha":344,"x_min":-47,"x_max":393,"o":"m 231 734 l 231 0 l 106 0 l 106 734 l 231 734 m -47 928 q -28 980 -47 959 q 26 1001 -9 1001 q 82 980 63 1001 q 101 928 101 959 q 82 879 101 899 q 26 858 63 858 q -28 879 -9 858 q -47 928 -47 899 m 245 927 q 263 979 245 958 q 319 1000 282 1000 q 374 979 355 1000 q 393 927 393 958 q 374 877 393 898 q 319 857 355 857 q 263 877 282 857 q 245 927 245 898 z "},"ј":{"ha":332,"x_min":-45,"x_max":235,"o":"m 99 734 l 225 734 l 225 -87 q 204 -201 225 -155 q 140 -272 182 -248 q 33 -296 98 -296 q -6 -293 16 -296 q -45 -285 -29 -290 l -44 -184 q -15 -188 -31 -186 q 14 -190 1 -190 q 60 -180 41 -190 q 89 -147 79 -170 q 99 -87 99 -125 l 99 734 m 86 928 q 105 980 86 959 q 160 1001 124 1001 q 216 980 197 1001 q 235 928 235 959 q 216 879 235 899 q 160 858 197 858 q 105 879 124 858 q 86 928 86 899 z "},"ќ":{"ha":751,"x_min":106,"x_max":738,"o":"m 232 734 l 232 0 l 106 0 l 106 734 l 232 734 m 713 734 l 366 313 l 190 313 l 171 423 l 315 423 l 561 734 l 713 734 m 578 0 l 309 332 l 389 423 l 738 0 l 578 0 m 298 827 l 429 1027 l 581 1027 l 399 827 l 298 827 z "},"ў":{"ha":657,"x_min":15,"x_max":640,"o":"m 302 76 l 506 734 l 640 734 l 346 -113 q 319 -172 336 -140 q 277 -232 302 -203 q 215 -278 251 -260 q 128 -296 178 -296 q 90 -292 113 -296 q 58 -286 67 -288 l 57 -184 q 74 -185 62 -184 q 91 -186 86 -186 q 163 -175 134 -186 q 214 -138 193 -164 q 250 -66 235 -112 l 302 76 m 152 734 l 342 164 l 375 32 l 285 -14 l 15 734 l 152 734 m 446 1014 l 547 1014 q 523 920 547 961 q 453 856 498 879 q 345 833 408 833 q 196 883 251 833 q 142 1014 142 934 l 243 1014 q 267 943 243 974 q 345 913 290 913 q 422 943 399 913 q 446 1014 446 974 z "},"Ẁ":{"ha":1232,"x_min":41,"x_max":1202,"o":"m 374 298 l 570 987 l 665 987 l 610 720 l 399 0 l 305 0 l 374 298 m 172 987 l 328 312 l 374 0 l 281 0 l 41 987 l 172 987 m 919 313 l 1072 987 l 1202 987 l 964 0 l 870 0 l 919 313 m 680 987 l 870 298 l 939 0 l 845 0 l 642 720 l 586 987 l 680 987 m 567 1253 l 698 1053 l 590 1053 l 415 1253 l 567 1253 z "},"ẁ":{"ha":1044,"x_min":29,"x_max":1011,"o":"m 281 130 l 470 734 l 553 734 l 536 614 l 345 0 l 264 0 l 281 130 m 155 734 l 315 123 l 327 0 l 242 0 l 29 734 l 155 734 m 733 128 l 886 734 l 1011 734 l 798 0 l 714 0 l 733 128 m 571 734 l 755 140 l 777 0 l 696 0 l 499 615 l 483 734 l 571 734 m 458 1042 l 589 842 l 481 842 l 306 1042 l 458 1042 z "},"Ẃ":{"ha":1232,"x_min":41,"x_max":1202,"o":"m 374 298 l 570 987 l 665 987 l 610 720 l 399 0 l 305 0 l 374 298 m 172 987 l 328 312 l 374 0 l 281 0 l 41 987 l 172 987 m 919 313 l 1072 987 l 1202 987 l 964 0 l 870 0 l 919 313 m 680 987 l 870 298 l 939 0 l 845 0 l 642 720 l 586 987 l 680 987 m 557 1053 l 689 1253 l 840 1253 l 659 1053 l 557 1053 z "},"ẃ":{"ha":1044,"x_min":29,"x_max":1011,"o":"m 281 130 l 470 734 l 553 734 l 536 614 l 345 0 l 264 0 l 281 130 m 155 734 l 315 123 l 327 0 l 242 0 l 29 734 l 155 734 m 733 128 l 886 734 l 1011 734 l 798 0 l 714 0 l 733 128 m 571 734 l 755 140 l 777 0 l 696 0 l 499 615 l 483 734 l 571 734 m 448 842 l 580 1042 l 731 1042 l 549 842 l 448 842 z "},"Ẅ":{"ha":1232,"x_min":41,"x_max":1202,"o":"m 374 298 l 570 987 l 665 987 l 610 720 l 399 0 l 305 0 l 374 298 m 172 987 l 328 312 l 374 0 l 281 0 l 41 987 l 172 987 m 919 313 l 1072 987 l 1202 987 l 964 0 l 870 0 l 919 313 m 680 987 l 870 298 l 939 0 l 845 0 l 642 720 l 586 987 l 680 987 m 408 1141 q 427 1192 408 1171 q 482 1213 446 1213 q 538 1192 519 1213 q 557 1141 557 1171 q 538 1091 557 1112 q 482 1070 519 1070 q 427 1091 446 1070 q 408 1141 408 1112 m 701 1139 q 719 1191 701 1170 q 774 1212 738 1212 q 830 1191 810 1212 q 849 1139 849 1170 q 830 1089 849 1110 q 774 1069 810 1069 q 719 1089 738 1069 q 701 1139 701 1110 z "},"ẅ":{"ha":1044,"x_min":29,"x_max":1011,"o":"m 281 130 l 470 734 l 553 734 l 536 614 l 345 0 l 264 0 l 281 130 m 155 734 l 315 123 l 327 0 l 242 0 l 29 734 l 155 734 m 733 128 l 886 734 l 1011 734 l 798 0 l 714 0 l 733 128 m 571 734 l 755 140 l 777 0 l 696 0 l 499 615 l 483 734 l 571 734 m 299 930 q 318 981 299 960 q 373 1002 337 1002 q 429 981 410 1002 q 448 930 448 960 q 429 880 448 901 q 373 859 410 859 q 318 880 337 859 q 299 930 299 901 m 591 928 q 610 980 591 959 q 665 1001 629 1001 q 721 980 701 1001 q 740 928 740 959 q 721 879 740 899 q 665 858 701 858 q 610 879 629 858 q 591 928 591 899 z "},"Ỳ":{"ha":834,"x_min":10,"x_max":822,"o":"m 160 987 l 416 492 l 673 987 l 822 987 l 481 369 l 481 0 l 351 0 l 351 369 l 10 987 l 160 987 m 359 1252 l 490 1053 l 382 1053 l 208 1252 l 359 1252 z "},"ỳ":{"ha":657,"x_min":15,"x_max":640,"o":"m 302 76 l 506 734 l 640 734 l 346 -113 q 319 -172 336 -140 q 277 -232 302 -203 q 215 -278 251 -260 q 128 -296 178 -296 q 90 -292 113 -296 q 58 -286 67 -288 l 57 -184 q 74 -185 62 -184 q 91 -186 86 -186 q 163 -175 134 -186 q 214 -138 193 -164 q 250 -66 235 -112 l 302 76 m 152 734 l 342 164 l 375 32 l 285 -14 l 15 734 l 152 734 m 285 1042 l 416 842 l 308 842 l 133 1042 l 285 1042 z "},"′":{"ha":243,"x_min":71,"x_max":172,"o":"m 172 1042 l 172 967 l 158 718 l 71 718 l 71 956 l 71 1042 l 172 1042 z "},"″":{"ha":445,"x_min":93,"x_max":372,"o":"m 189 1042 l 189 949 l 168 707 l 93 707 l 93 943 l 93 1042 l 189 1042 m 372 1042 l 372 949 l 351 707 l 276 707 l 276 948 l 276 1042 l 372 1042 z "},"‼":{"ha":716,"x_min":109,"x_max":616,"o":"m 245 987 l 236 279 l 123 279 l 113 987 l 245 987 m 109 63 q 128 115 109 94 q 183 136 146 136 q 238 115 219 136 q 258 63 258 94 q 238 13 258 34 q 183 -8 219 -8 q 128 13 146 -8 q 109 63 109 34 m 603 987 l 594 279 l 481 279 l 471 987 l 603 987 m 467 63 q 486 115 467 94 q 541 136 505 136 q 596 115 577 136 q 616 63 616 94 q 596 13 616 34 q 541 -8 577 -8 q 486 13 505 -8 q 467 63 467 34 z "},"ǰ":{"ha":350,"x_min":-52,"x_max":391,"o":"m 117 734 l 243 734 l 243 -60 q 217 -189 243 -136 q 142 -269 191 -242 q 24 -296 93 -296 q -14 -294 3 -296 q -52 -285 -32 -292 l -42 -184 q -8 -191 -32 -189 q 24 -193 15 -193 q 74 -177 54 -193 q 106 -132 95 -161 q 117 -60 117 -102 l 117 734 m 77 1013 l 180 898 l 282 1013 l 391 1013 l 391 1006 l 218 821 l 141 821 l -28 1006 l -28 1013 l 77 1013 z "},"ʼ":{"ha":278,"x_min":33,"x_max":222,"o":"m 222 1042 l 222 955 q 209 869 222 914 q 168 782 195 824 q 104 709 142 741 l 33 759 q 81 851 64 804 q 98 953 98 898 l 98 1042 l 222 1042 z "},"Ḿ":{"ha":1213,"x_min":115,"x_max":1097,"o":"m 156 987 l 283 987 l 606 182 l 929 987 l 1057 987 l 655 0 l 556 0 l 156 987 m 115 987 l 227 987 l 245 385 l 245 0 l 115 0 l 115 987 m 985 987 l 1097 987 l 1097 0 l 967 0 l 967 385 l 985 987 m 534 1053 l 666 1253 l 817 1253 l 635 1053 l 534 1053 z "},"ḿ":{"ha":1218,"x_min":94,"x_max":1124,"o":"m 220 588 l 220 0 l 94 0 l 94 734 l 214 734 l 220 588 m 195 395 l 136 397 q 156 536 137 472 q 212 648 175 600 q 305 721 250 695 q 434 747 361 747 q 529 733 486 747 q 604 687 572 718 q 654 607 636 656 q 671 489 671 558 l 671 0 l 546 0 l 546 483 q 527 575 546 541 q 472 626 507 610 q 389 642 437 642 q 296 622 334 642 q 237 568 259 602 q 204 489 214 533 q 195 395 195 444 m 670 464 l 586 438 q 606 554 587 498 q 662 653 625 610 q 753 722 699 696 q 878 747 808 747 q 982 732 937 747 q 1060 684 1028 716 q 1107 602 1091 652 q 1124 482 1124 551 l 1124 0 l 998 0 l 998 484 q 978 579 998 545 q 924 628 959 614 q 841 642 889 642 q 768 627 800 642 q 714 588 736 613 q 681 532 692 564 q 670 464 670 500 m 549 842 l 680 1042 l 831 1042 l 650 842 l 549 842 z "},"Ḁ":{"ha":906,"x_min":20,"x_max":888,"o":"m 480 900 l 153 0 l 20 0 l 396 987 l 482 987 l 480 900 m 754 0 l 427 900 l 425 987 l 511 987 l 888 0 l 754 0 m 737 366 l 737 258 l 182 258 l 182 366 l 737 366 m 347 -164 q 381 -83 347 -115 q 465 -51 416 -51 q 545 -83 511 -51 q 579 -164 579 -115 q 545 -244 579 -214 q 465 -275 511 -275 q 381 -244 416 -275 q 347 -164 347 -214 m 406 -164 q 423 -204 406 -187 q 465 -220 440 -220 q 504 -204 488 -220 q 521 -164 521 -188 q 504 -122 521 -139 q 465 -105 488 -105 q 423 -122 440 -105 q 406 -164 406 -139 z "},"ḁ":{"ha":755,"x_min":74,"x_max":680,"o":"m 528 125 l 528 503 q 511 579 528 547 q 459 629 494 611 q 374 646 425 646 q 291 630 326 646 q 235 587 255 614 q 215 530 215 561 l 90 530 q 110 608 90 570 q 169 679 130 647 q 261 729 207 710 q 381 747 315 747 q 523 720 461 747 q 619 638 584 693 q 654 502 654 584 l 654 160 q 660 82 654 123 q 680 11 667 41 l 680 0 l 549 0 q 534 58 539 22 q 528 125 528 94 m 550 445 l 551 357 l 425 357 q 329 348 371 357 q 258 323 287 340 q 215 280 230 306 q 200 221 200 255 q 216 158 200 186 q 263 113 231 130 q 340 96 294 96 q 442 121 398 96 q 512 180 486 145 q 541 249 538 216 l 594 189 q 568 125 589 160 q 512 59 547 91 q 430 7 477 28 q 322 -14 382 -14 q 192 16 248 -14 q 105 94 136 45 q 74 204 74 143 q 97 308 74 263 q 163 384 120 353 q 268 429 207 414 q 404 445 329 445 l 550 445 m 222 -164 q 257 -83 222 -115 q 340 -51 292 -51 q 420 -83 387 -51 q 454 -164 454 -115 q 420 -244 454 -214 q 340 -275 387 -275 q 257 -244 292 -275 q 222 -164 222 -214 m 281 -164 q 298 -204 281 -187 q 340 -220 315 -220 q 379 -204 363 -220 q 396 -164 396 -188 q 379 -122 396 -139 q 340 -105 363 -105 q 298 -122 315 -105 q 281 -164 281 -139 z "},"Ѐ":{"ha":789,"x_min":115,"x_max":742,"o":"m 742 106 l 742 0 l 219 0 l 219 106 l 742 106 m 245 987 l 245 0 l 115 0 l 115 987 l 245 987 m 673 563 l 673 456 l 219 456 l 219 563 l 673 563 m 735 987 l 735 880 l 219 880 l 219 987 l 735 987 m 360 1260 l 491 1061 l 383 1061 l 208 1260 l 360 1260 z "},"Ѝ":{"ha":991,"x_min":121,"x_max":868,"o":"m 251 227 l 737 987 l 868 987 l 868 0 l 737 0 l 737 762 l 251 0 l 121 0 l 121 987 l 251 987 l 251 227 m 437 1260 l 568 1061 l 460 1061 l 286 1260 l 437 1260 z "},"ѐ":{"ha":736,"x_min":63,"x_max":686,"o":"m 400 -14 q 261 13 323 -14 q 155 86 199 39 q 87 199 111 134 q 63 341 63 264 l 63 370 q 90 529 63 459 q 161 648 116 600 q 264 722 207 697 q 384 747 322 747 q 520 720 463 747 q 614 645 577 693 q 668 531 650 596 q 686 388 686 465 l 686 332 l 138 332 l 138 434 l 560 434 l 560 444 q 540 538 557 492 q 486 614 523 585 q 384 644 448 644 q 305 626 341 644 q 243 573 269 608 q 203 487 218 538 q 189 370 189 436 l 189 341 q 204 243 189 289 q 247 163 218 197 q 315 109 275 128 q 407 89 355 89 q 519 116 473 89 q 600 189 566 143 l 676 128 q 616 60 652 92 q 526 7 579 27 q 400 -14 473 -14 m 323 1042 l 454 842 l 347 842 l 172 1042 l 323 1042 z "},"ѝ":{"ha":802,"x_min":106,"x_max":696,"o":"m 231 199 l 570 734 l 696 734 l 696 0 l 570 0 l 570 535 l 231 0 l 106 0 l 106 734 l 231 734 l 231 199 m 340 1027 l 471 828 l 363 828 l 189 1027 l 340 1027 z "},"Ѱ":{"ha":961,"x_min":61,"x_max":891,"o":"m 760 987 l 891 987 l 891 631 q 838 420 891 507 q 692 289 785 334 q 480 243 599 243 l 460 243 q 301 269 374 243 q 174 344 228 294 q 91 466 121 393 q 61 631 61 538 l 61 987 l 191 987 l 191 631 q 211 511 191 564 q 267 423 231 459 q 353 369 303 387 q 461 351 402 351 l 481 351 q 627 383 564 351 q 725 478 690 416 q 760 631 760 541 l 760 987 m 536 987 l 536 0 l 406 0 l 406 987 l 536 987 z "},"ѱ":{"ha":972,"x_min":65,"x_max":913,"o":"m 65 734 l 191 734 l 191 403 q 212 257 191 317 q 273 160 234 197 q 364 106 312 123 q 477 89 416 89 q 624 115 564 89 q 720 184 684 140 q 772 280 755 227 q 788 385 788 332 q 762 564 786 476 q 702 734 738 651 l 834 734 q 873 640 855 692 q 902 524 891 587 q 913 385 913 460 q 891 234 913 306 q 818 106 868 162 q 685 18 768 50 q 484 -14 603 -14 q 311 10 388 -14 q 178 85 233 35 q 94 216 123 136 q 65 404 65 295 l 65 734 m 415 734 l 541 734 l 541 -321 l 415 -321 l 415 734 z "},"Ѷ":{"ha":876,"x_min":15,"x_max":844,"o":"m 439 254 l 614 802 q 663 917 636 873 q 727 980 690 960 q 813 1000 763 1000 l 844 1000 l 844 884 l 836 884 q 795 875 812 884 q 764 845 778 866 q 736 787 750 824 l 473 0 l 372 0 l 439 254 m 157 987 l 393 254 l 459 0 l 358 0 l 15 987 l 157 987 m 387 1018 l 273 1018 l 66 1198 l 218 1198 l 387 1018 m 564 1018 l 463 1018 l 296 1198 l 436 1198 l 564 1018 z "},"ѷ":{"ha":697,"x_min":-3,"x_max":703,"o":"m 355 214 l 462 583 q 507 678 481 642 q 565 731 533 714 q 630 747 596 747 q 668 745 650 747 q 703 730 686 742 l 688 630 q 677 634 685 632 q 659 635 669 635 q 632 628 646 635 q 606 607 618 621 q 587 573 595 593 l 385 0 l 302 0 l 355 214 m 160 734 l 323 214 l 373 0 l 290 0 l 32 734 l 160 734 m 318 817 l 203 817 l -3 998 l 149 998 l 318 817 m 495 817 l 393 817 l 227 998 l 367 998 l 495 817 z "},"ѹ":{"ha":1449,"x_min":62,"x_max":1432,"o":"m 62 359 l 62 374 q 85 522 62 454 q 152 641 109 590 q 257 719 195 691 q 395 747 319 747 q 535 719 473 747 q 641 641 597 691 q 707 522 684 590 q 730 374 730 454 l 730 359 q 707 212 730 279 q 641 93 684 144 q 535 15 597 43 q 397 -14 474 -14 q 258 15 319 -14 q 152 93 196 43 q 85 212 109 144 q 62 359 62 279 m 188 374 l 188 359 q 201 255 188 304 q 240 170 214 207 q 305 111 266 132 q 397 90 345 90 q 487 111 448 90 q 552 170 526 132 q 591 255 578 207 q 604 359 604 304 l 604 374 q 591 477 604 429 q 552 563 578 526 q 487 623 526 601 q 395 644 448 644 q 305 623 344 644 q 240 563 266 601 q 201 477 214 526 q 188 374 188 429 m 1094 76 l 1298 734 l 1432 734 l 1138 -113 q 1111 -172 1128 -140 q 1069 -232 1095 -203 q 1007 -278 1043 -260 q 920 -296 970 -296 q 882 -292 905 -296 q 850 -286 859 -288 l 849 -184 q 866 -185 854 -184 q 883 -186 878 -186 q 956 -175 926 -186 q 1006 -138 985 -164 q 1042 -66 1027 -112 l 1094 76 m 944 734 l 1135 164 l 1167 32 l 1077 -14 l 807 734 l 944 734 z "},"Ѹ":{"ha":1613,"x_min":81,"x_max":1596,"o":"m 875 525 l 875 463 q 847 263 875 351 q 767 113 819 175 q 642 19 715 52 q 479 -14 569 -14 q 318 19 391 -14 q 192 113 245 52 q 110 263 139 175 q 81 463 81 351 l 81 525 q 110 724 81 636 q 191 874 138 812 q 317 968 244 936 q 477 1001 390 1001 q 641 968 568 1001 q 766 874 713 936 q 847 724 819 812 q 875 525 875 636 m 745 463 l 745 526 q 727 682 745 614 q 675 796 709 750 q 590 866 640 842 q 477 890 541 890 q 367 866 416 890 q 283 796 318 842 q 229 682 248 750 q 210 526 210 614 l 210 463 q 229 306 210 374 q 284 191 248 237 q 369 121 319 144 q 479 97 418 97 q 592 121 543 97 q 676 191 642 144 q 728 306 710 237 q 745 463 745 374 m 1257 76 l 1461 734 l 1596 734 l 1301 -113 q 1275 -172 1291 -140 q 1232 -232 1258 -203 q 1170 -278 1206 -260 q 1084 -296 1134 -296 q 1046 -292 1069 -296 q 1013 -286 1023 -288 l 1013 -184 q 1030 -185 1018 -184 q 1046 -186 1042 -186 q 1119 -175 1089 -186 q 1170 -138 1149 -164 q 1205 -66 1190 -112 l 1257 76 m 1107 734 l 1298 164 l 1331 32 l 1240 -14 l 970 734 l 1107 734 z "},"Ҙ":{"ha":825,"x_min":54,"x_max":767,"o":"m 417 474 l 300 474 l 300 557 l 412 557 q 533 578 487 557 q 600 637 579 600 q 621 723 621 674 q 598 809 621 770 q 527 871 575 848 q 403 895 479 895 q 300 873 346 895 q 227 814 254 852 q 199 728 199 777 l 68 728 q 95 841 68 791 q 168 927 121 892 q 274 982 214 963 q 403 1001 335 1001 q 547 983 482 1001 q 657 930 611 965 q 728 842 703 895 q 752 721 752 790 q 728 625 752 670 q 661 547 705 581 q 555 493 616 513 q 417 474 493 474 m 300 532 l 417 532 q 566 515 500 532 q 675 465 631 498 q 744 385 720 433 q 767 275 767 337 q 740 153 767 206 q 665 62 713 99 q 549 5 616 24 q 403 -14 482 -14 q 277 3 339 -14 q 165 55 215 20 q 84 144 115 90 q 54 274 54 198 l 185 274 q 213 183 185 224 q 289 117 240 142 q 403 92 338 92 q 529 116 477 92 q 609 180 581 139 q 636 273 636 221 q 622 352 636 318 q 579 407 607 385 q 509 439 551 429 q 412 450 467 450 l 300 450 l 300 532 m 475 54 l 475 -294 l 349 -294 l 349 54 l 475 54 z "},"ҙ":{"ha":705,"x_min":60,"x_max":638,"o":"m 370 351 l 235 351 l 235 428 l 359 428 q 442 441 412 428 q 486 478 473 454 q 498 534 498 502 q 484 588 498 562 q 437 629 469 613 q 352 645 406 645 q 273 630 309 645 q 217 588 238 614 q 197 530 197 562 l 71 530 q 110 645 71 597 q 212 720 148 694 q 352 747 276 747 q 466 733 416 747 q 552 692 517 719 q 606 626 587 665 q 625 534 625 586 q 607 463 625 496 q 556 405 589 430 q 476 365 523 379 q 370 351 429 351 m 235 398 l 370 398 q 486 386 435 398 q 570 349 536 373 q 621 289 604 324 q 638 207 638 253 q 617 114 638 155 q 559 45 597 73 q 468 1 521 16 q 352 -14 416 -14 q 214 11 281 -14 q 103 86 146 35 q 60 217 60 138 l 185 217 q 206 154 185 184 q 265 106 227 124 q 352 87 302 87 q 440 104 405 87 q 493 147 475 120 q 511 206 511 174 q 495 273 511 248 q 445 310 479 298 q 359 321 412 321 l 235 321 l 235 398 m 415 55 l 415 -293 l 290 -293 l 290 55 l 415 55 z "},"Ҫ":{"ha":904,"x_min":81,"x_max":841,"o":"m 711 314 l 841 314 q 787 146 831 220 q 665 30 744 73 q 467 -14 585 -14 q 309 19 380 -14 q 187 112 238 52 q 109 256 136 172 q 81 444 81 340 l 81 543 q 109 731 81 646 q 188 876 136 815 q 313 968 240 936 q 478 1001 387 1001 q 667 959 590 1001 q 788 843 745 917 q 841 671 831 768 l 711 671 q 675 790 701 740 q 602 867 650 840 q 478 894 555 894 q 362 869 412 894 q 279 798 313 844 q 229 687 245 751 q 212 544 212 623 l 212 444 q 227 308 212 372 q 273 196 242 244 q 353 120 304 148 q 467 93 401 93 q 600 119 550 93 q 674 195 649 146 q 711 314 700 245 m 525 54 l 525 -294 l 399 -294 l 399 54 l 525 54 z "},"ҫ":{"ha":727,"x_min":63,"x_max":682,"o":"m 389 90 q 472 108 434 90 q 534 158 510 126 q 562 232 559 191 l 682 232 q 638 111 678 167 q 532 21 597 55 q 389 -14 467 -14 q 245 16 307 -14 q 143 96 184 45 q 83 213 103 146 q 63 353 63 279 l 63 381 q 83 521 63 455 q 143 638 103 587 q 245 718 184 689 q 389 747 307 747 q 540 712 475 747 q 641 617 604 677 q 682 481 678 557 l 562 481 q 537 564 559 527 q 477 622 515 600 q 389 644 439 644 q 293 622 332 644 q 231 561 254 599 q 198 476 208 522 q 189 381 189 429 l 189 353 q 198 258 189 304 q 230 173 208 211 q 292 112 253 135 q 389 90 331 90 m 425 54 l 425 -294 l 300 -294 l 300 54 l 425 54 z "},"Ү":{"ha":834,"x_min":10,"x_max":822,"o":"m 160 987 l 416 492 l 673 987 l 822 987 l 481 369 l 481 0 l 351 0 l 351 369 l 10 987 l 160 987 z "},"ү":{"ha":696,"x_min":32,"x_max":673,"o":"m 415 90 l 415 -283 l 290 -283 l 290 90 l 415 90 m 349 170 l 544 734 l 673 734 l 401 0 l 317 0 l 349 170 m 160 734 l 361 170 l 389 0 l 305 0 l 32 734 l 160 734 z "},"Ӏ":{"ha":378,"x_min":124,"x_max":255,"o":"m 255 987 l 255 0 l 124 0 l 124 987 l 255 987 z "},"Ӂ":{"ha":1261,"x_min":18,"x_max":1252,"o":"m 397 451 l 45 987 l 198 987 l 460 559 l 646 559 l 625 451 l 397 451 m 468 461 l 181 0 l 18 0 l 385 574 l 468 461 m 703 987 l 703 0 l 573 0 l 573 987 l 703 987 m 1226 987 l 872 451 l 651 451 l 631 559 l 810 559 l 1072 987 l 1226 987 m 1089 0 l 803 461 l 886 574 l 1252 0 l 1089 0 m 734 1232 l 836 1232 q 811 1138 836 1179 q 741 1074 787 1097 q 633 1051 696 1051 q 485 1102 539 1051 q 430 1232 430 1152 l 532 1232 q 555 1162 532 1192 q 633 1131 578 1131 q 711 1162 688 1131 q 734 1232 734 1192 z "},"ӂ":{"ha":1064,"x_min":15,"x_max":1044,"o":"m 318 319 l 40 734 l 191 734 l 381 430 l 528 430 l 509 319 l 318 319 m 387 332 l 174 0 l 15 0 l 307 423 l 387 332 m 592 734 l 592 0 l 467 0 l 467 734 l 592 734 m 1020 734 l 742 319 l 551 319 l 531 430 l 678 430 l 868 734 l 1020 734 m 886 0 l 672 332 l 753 423 l 1044 0 l 886 0 m 630 1000 l 732 1000 q 707 906 732 947 q 637 842 683 865 q 530 819 592 819 q 381 869 435 819 q 326 1000 326 920 l 428 1000 q 451 929 428 960 q 530 899 474 899 q 607 929 584 899 q 630 1000 630 960 z "},"ӏ":{"ha":378,"x_min":124,"x_max":255,"o":"m 255 987 l 255 0 l 124 0 l 124 987 l 255 987 z "},"Ӑ":{"ha":906,"x_min":20,"x_max":888,"o":"m 480 900 l 153 0 l 20 0 l 396 987 l 482 987 l 480 900 m 754 0 l 427 900 l 425 987 l 511 987 l 888 0 l 754 0 m 737 366 l 737 258 l 182 258 l 182 366 l 737 366 m 557 1225 l 659 1225 q 634 1131 659 1172 q 564 1067 610 1090 q 456 1044 519 1044 q 308 1094 362 1044 q 253 1225 253 1145 l 355 1225 q 378 1154 355 1185 q 456 1124 401 1124 q 534 1154 511 1124 q 557 1225 557 1185 z "},"ӑ":{"ha":755,"x_min":74,"x_max":680,"o":"m 528 125 l 528 503 q 511 579 528 547 q 459 629 494 611 q 374 646 425 646 q 291 630 326 646 q 235 587 255 614 q 215 530 215 561 l 90 530 q 110 608 90 570 q 169 679 130 647 q 261 729 207 710 q 381 747 315 747 q 523 720 461 747 q 619 638 584 693 q 654 502 654 584 l 654 160 q 660 82 654 123 q 680 11 667 41 l 680 0 l 549 0 q 534 58 539 22 q 528 125 528 94 m 550 445 l 551 357 l 425 357 q 329 348 371 357 q 258 323 287 340 q 215 280 230 306 q 200 221 200 255 q 216 158 200 186 q 263 113 231 130 q 340 96 294 96 q 442 121 398 96 q 512 180 486 145 q 541 249 538 216 l 594 189 q 568 125 589 160 q 512 59 547 91 q 430 7 477 28 q 322 -14 382 -14 q 192 16 248 -14 q 105 94 136 45 q 74 204 74 143 q 97 308 74 263 q 163 384 120 353 q 268 429 207 414 q 404 445 329 445 l 550 445 m 496 1014 l 597 1014 q 573 920 597 961 q 503 856 549 879 q 395 833 458 833 q 247 883 301 833 q 192 1014 192 934 l 294 1014 q 317 943 294 974 q 395 913 340 913 q 473 943 450 913 q 496 1014 496 974 z "},"Ӓ":{"ha":906,"x_min":20,"x_max":888,"o":"m 480 900 l 153 0 l 20 0 l 396 987 l 482 987 l 480 900 m 754 0 l 427 900 l 425 987 l 511 987 l 888 0 l 754 0 m 737 366 l 737 258 l 182 258 l 182 366 l 737 366 m 237 1141 q 256 1192 237 1171 q 311 1213 275 1213 q 367 1192 348 1213 q 386 1141 386 1171 q 367 1091 386 1112 q 311 1070 348 1070 q 256 1091 275 1070 q 237 1141 237 1112 m 530 1139 q 548 1191 530 1170 q 604 1212 567 1212 q 659 1191 640 1212 q 678 1139 678 1170 q 659 1089 678 1110 q 604 1069 640 1069 q 548 1089 567 1069 q 530 1139 530 1110 z "},"ӓ":{"ha":755,"x_min":74,"x_max":680,"o":"m 528 125 l 528 503 q 511 579 528 547 q 459 629 494 611 q 374 646 425 646 q 291 630 326 646 q 235 587 255 614 q 215 530 215 561 l 90 530 q 110 608 90 570 q 169 679 130 647 q 261 729 207 710 q 381 747 315 747 q 523 720 461 747 q 619 638 584 693 q 654 502 654 584 l 654 160 q 660 82 654 123 q 680 11 667 41 l 680 0 l 549 0 q 534 58 539 22 q 528 125 528 94 m 550 445 l 551 357 l 425 357 q 329 348 371 357 q 258 323 287 340 q 215 280 230 306 q 200 221 200 255 q 216 158 200 186 q 263 113 231 130 q 340 96 294 96 q 442 121 398 96 q 512 180 486 145 q 541 249 538 216 l 594 189 q 568 125 589 160 q 512 59 547 91 q 430 7 477 28 q 322 -14 382 -14 q 192 16 248 -14 q 105 94 136 45 q 74 204 74 143 q 97 308 74 263 q 163 384 120 353 q 268 429 207 414 q 404 445 329 445 l 550 445 m 176 930 q 195 981 176 960 q 250 1002 214 1002 q 306 981 287 1002 q 325 930 325 960 q 306 880 325 901 q 250 859 287 859 q 195 880 214 859 q 176 930 176 901 m 469 928 q 487 980 469 959 q 543 1001 506 1001 q 598 980 578 1001 q 617 928 617 959 q 598 879 617 899 q 543 858 578 858 q 487 879 506 858 q 469 928 469 899 z "},"Ӕ":{"ha":1298,"x_min":-10,"x_max":1275,"o":"m 658 886 l 144 0 l -10 0 l 587 987 l 668 987 l 658 886 m 756 358 l 756 239 l 252 239 l 252 358 l 756 358 m 1275 103 l 1275 0 l 778 0 l 778 103 l 1275 103 m 760 987 l 802 0 l 675 0 l 634 987 l 760 987 m 1178 566 l 1178 463 l 751 463 l 751 566 l 1178 566 m 1233 987 l 1233 884 l 736 884 l 736 987 l 1233 987 z "},"ӕ":{"ha":1173,"x_min":54,"x_max":1126,"o":"m 508 124 l 508 488 q 491 572 508 537 q 442 626 475 607 q 363 644 410 644 q 275 627 313 644 q 218 580 238 609 q 197 515 197 551 l 73 528 q 94 615 73 575 q 153 685 115 655 q 244 731 191 715 q 363 747 298 747 q 503 718 443 747 q 596 631 563 689 q 630 487 630 574 l 630 148 l 508 124 m 536 431 l 536 336 l 359 336 q 260 318 300 336 q 199 269 220 299 q 179 203 179 239 q 194 145 179 171 q 240 103 210 119 q 319 88 271 88 q 394 102 355 88 q 464 138 432 116 q 516 184 496 160 q 537 230 536 209 l 602 132 q 544 65 584 99 q 443 8 505 31 q 294 -14 380 -14 q 163 13 217 -14 q 81 90 109 40 q 54 206 54 140 q 73 301 54 260 q 131 372 92 343 q 226 416 169 401 q 357 431 283 431 l 536 431 m 857 -14 q 709 13 773 -14 q 602 89 646 40 q 536 205 559 138 q 514 353 514 273 l 514 382 q 537 530 514 463 q 603 646 561 597 q 703 721 646 694 q 827 747 760 748 q 956 725 900 747 q 1050 659 1012 702 q 1107 555 1088 616 q 1126 418 1126 494 l 1126 338 l 581 338 l 581 434 l 1000 434 l 1000 455 q 983 549 1000 507 q 928 618 966 592 q 827 644 890 644 q 744 624 780 644 q 683 568 708 604 q 646 484 659 532 q 633 382 633 437 l 633 353 q 646 250 633 298 q 686 166 659 202 q 755 109 713 130 q 857 89 798 89 q 987 114 937 89 q 1070 161 1036 138 l 1114 69 q 1066 38 1099 58 q 981 2 1034 18 q 857 -14 929 -14 z "},"Ӗ":{"ha":789,"x_min":115,"x_max":742,"o":"m 742 106 l 742 0 l 219 0 l 219 106 l 742 106 m 245 987 l 245 0 l 115 0 l 115 987 l 245 987 m 673 563 l 673 456 l 219 456 l 219 563 l 673 563 m 735 987 l 735 880 l 219 880 l 219 987 l 735 987 m 521 1232 l 623 1232 q 598 1138 623 1179 q 528 1074 574 1097 q 420 1051 483 1051 q 272 1102 326 1051 q 217 1232 217 1152 l 319 1232 q 342 1162 319 1192 q 420 1131 365 1131 q 498 1162 475 1131 q 521 1232 521 1192 z "},"ӗ":{"ha":736,"x_min":63,"x_max":686,"o":"m 400 -14 q 261 13 323 -14 q 155 86 199 39 q 87 199 111 134 q 63 341 63 264 l 63 370 q 90 529 63 459 q 161 648 116 600 q 264 722 207 697 q 384 747 322 747 q 520 720 463 747 q 614 645 577 693 q 668 531 650 596 q 686 388 686 465 l 686 332 l 138 332 l 138 434 l 560 434 l 560 444 q 540 538 557 492 q 486 614 523 585 q 384 644 448 644 q 305 626 341 644 q 243 573 269 608 q 203 487 218 538 q 189 370 189 436 l 189 341 q 204 243 189 289 q 247 163 218 197 q 315 109 275 128 q 407 89 355 89 q 519 116 473 89 q 600 189 566 143 l 676 128 q 616 60 652 92 q 526 7 579 27 q 400 -14 473 -14 m 484 1014 l 586 1014 q 562 920 586 961 q 492 856 537 879 q 384 833 446 833 q 235 883 290 833 q 180 1014 180 934 l 282 1014 q 305 943 282 974 q 384 913 328 913 q 461 943 438 913 q 484 1014 484 974 z "},"Ӛ":{"ha":960,"x_min":64,"x_max":880,"o":"m 435 1001 q 626 966 543 1001 q 765 868 709 931 q 851 717 822 804 q 880 525 880 630 l 880 461 q 849 269 880 356 q 761 118 817 181 q 631 20 705 55 q 473 -14 557 -14 q 296 18 372 -14 q 168 108 219 49 q 90 250 116 167 q 64 436 64 333 l 64 520 l 800 520 l 800 419 l 195 419 l 195 396 q 209 278 195 333 q 256 182 224 223 q 342 118 289 141 q 473 94 395 94 q 591 123 539 94 q 678 202 642 151 q 732 319 713 252 q 750 461 750 385 l 750 525 q 732 668 750 602 q 676 785 714 734 q 578 864 638 836 q 435 892 519 892 q 287 873 347 892 q 187 836 227 854 l 155 932 q 208 960 172 943 q 300 988 243 976 q 435 1001 357 1001 m 212 1117 q 231 1168 212 1147 q 286 1190 250 1190 q 342 1168 323 1190 q 361 1117 361 1147 q 342 1067 361 1088 q 286 1046 323 1046 q 231 1067 250 1046 q 212 1117 212 1088 m 505 1116 q 523 1167 505 1146 q 578 1188 542 1188 q 634 1167 614 1188 q 653 1116 653 1146 q 634 1066 653 1086 q 578 1045 614 1045 q 523 1066 542 1045 q 505 1116 505 1086 z "},"ә":{"ha":732,"x_min":67,"x_max":680,"o":"m 347 749 q 485 722 423 749 q 589 645 546 694 q 656 529 633 596 q 680 382 680 462 l 680 352 q 654 205 680 272 q 585 89 629 138 q 484 13 541 40 q 366 -13 428 -14 q 234 11 290 -13 q 141 79 178 35 q 85 182 104 123 q 67 314 67 242 l 67 397 l 605 397 l 605 294 l 193 294 l 193 277 q 211 185 193 228 q 268 116 229 142 q 366 90 307 90 q 441 110 407 90 q 500 166 475 130 q 539 250 526 202 q 553 352 553 298 l 553 382 q 540 484 553 436 q 501 568 527 532 q 437 625 475 604 q 347 646 398 646 q 222 624 273 646 q 138 572 172 603 l 88 658 q 185 720 122 690 q 347 749 248 749 z "},"ӛ":{"ha":732,"x_min":67,"x_max":680,"o":"m 347 749 q 485 722 423 749 q 589 645 546 694 q 656 529 633 596 q 680 382 680 462 l 680 352 q 654 205 680 272 q 585 89 629 138 q 484 13 541 40 q 366 -13 428 -14 q 234 11 290 -13 q 141 79 178 35 q 85 182 104 123 q 67 314 67 242 l 67 397 l 605 397 l 605 294 l 193 294 l 193 277 q 211 185 193 228 q 268 116 229 142 q 366 90 307 90 q 441 110 407 90 q 500 166 475 130 q 539 250 526 202 q 553 352 553 298 l 553 382 q 540 484 553 436 q 501 568 527 532 q 437 625 475 604 q 347 646 398 646 q 222 624 273 646 q 138 572 172 603 l 88 658 q 185 720 122 690 q 347 749 248 749 m 161 930 q 180 982 161 961 q 235 1003 199 1003 q 290 982 271 1003 q 309 930 309 961 q 290 881 309 901 q 235 860 271 860 q 180 881 199 860 q 161 930 161 901 m 453 929 q 472 981 453 960 q 527 1002 490 1002 q 582 981 563 1002 q 602 929 602 960 q 582 879 602 900 q 527 859 563 859 q 472 879 490 859 q 453 929 453 900 z "},"Ӝ":{"ha":1261,"x_min":18,"x_max":1252,"o":"m 397 451 l 45 987 l 198 987 l 460 559 l 646 559 l 625 451 l 397 451 m 468 461 l 181 0 l 18 0 l 385 574 l 468 461 m 703 987 l 703 0 l 573 0 l 573 987 l 703 987 m 1226 987 l 872 451 l 651 451 l 631 559 l 810 559 l 1072 987 l 1226 987 m 1089 0 l 803 461 l 886 574 l 1252 0 l 1089 0 m 414 1148 q 433 1200 414 1179 q 488 1221 452 1221 q 544 1200 525 1221 q 563 1148 563 1179 q 544 1098 563 1119 q 488 1078 525 1078 q 433 1098 452 1078 q 414 1148 414 1119 m 707 1147 q 725 1198 707 1177 q 781 1219 744 1219 q 836 1198 817 1219 q 855 1147 855 1177 q 836 1097 855 1118 q 781 1076 817 1076 q 725 1097 744 1076 q 707 1147 707 1118 z "},"ӝ":{"ha":1064,"x_min":15,"x_max":1044,"o":"m 318 319 l 40 734 l 191 734 l 381 430 l 528 430 l 509 319 l 318 319 m 387 332 l 174 0 l 15 0 l 307 423 l 387 332 m 592 734 l 592 0 l 467 0 l 467 734 l 592 734 m 1020 734 l 742 319 l 551 319 l 531 430 l 678 430 l 868 734 l 1020 734 m 886 0 l 672 332 l 753 423 l 1044 0 l 886 0 m 311 916 q 330 967 311 946 q 385 988 349 988 q 440 967 421 988 q 459 916 459 946 q 440 866 459 886 q 385 845 421 845 q 330 866 349 845 q 311 916 311 886 m 603 914 q 622 966 603 945 q 677 987 640 987 q 732 966 713 987 q 751 914 751 945 q 732 864 751 885 q 677 844 713 844 q 622 864 640 844 q 603 914 603 885 z "},"Ӟ":{"ha":825,"x_min":54,"x_max":767,"o":"m 417 474 l 300 474 l 300 557 l 412 557 q 533 578 487 557 q 600 637 579 600 q 621 723 621 674 q 598 809 621 770 q 527 871 575 848 q 403 895 479 895 q 300 873 346 895 q 227 814 254 852 q 199 728 199 777 l 68 728 q 95 841 68 791 q 168 927 121 892 q 274 982 214 963 q 403 1001 335 1001 q 547 983 482 1001 q 657 930 611 965 q 728 842 703 895 q 752 721 752 790 q 728 625 752 670 q 661 547 705 581 q 555 493 616 513 q 417 474 493 474 m 300 532 l 417 532 q 566 515 500 532 q 675 465 631 498 q 744 385 720 433 q 767 275 767 337 q 740 153 767 206 q 665 62 713 99 q 549 5 616 24 q 403 -14 482 -14 q 277 3 339 -14 q 165 55 215 20 q 84 144 115 90 q 54 274 54 198 l 185 274 q 213 183 185 224 q 289 117 240 142 q 403 92 338 92 q 529 116 477 92 q 609 180 581 139 q 636 273 636 221 q 622 352 636 318 q 579 407 607 385 q 509 439 551 429 q 412 450 467 450 l 300 450 l 300 532 m 193 1162 q 212 1214 193 1193 q 267 1235 231 1235 q 322 1214 303 1235 q 341 1162 341 1193 q 322 1113 341 1133 q 267 1092 303 1092 q 212 1113 231 1092 q 193 1162 193 1133 m 485 1161 q 504 1213 485 1192 q 559 1234 522 1234 q 614 1213 595 1234 q 633 1161 633 1192 q 614 1111 633 1132 q 559 1090 595 1090 q 504 1111 522 1090 q 485 1161 485 1132 z "},"ӟ":{"ha":705,"x_min":60,"x_max":638,"o":"m 370 351 l 235 351 l 235 428 l 359 428 q 442 441 412 428 q 486 478 473 454 q 498 534 498 502 q 484 588 498 562 q 437 629 469 613 q 352 645 406 645 q 273 630 309 645 q 217 588 238 614 q 197 530 197 562 l 71 530 q 110 645 71 597 q 212 720 148 694 q 352 747 276 747 q 466 733 416 747 q 552 692 517 719 q 606 626 587 665 q 625 534 625 586 q 607 463 625 496 q 556 405 589 430 q 476 365 523 379 q 370 351 429 351 m 235 398 l 370 398 q 486 386 435 398 q 570 349 536 373 q 621 289 604 324 q 638 207 638 253 q 617 114 638 155 q 559 45 597 73 q 468 1 521 16 q 352 -14 416 -14 q 214 11 281 -14 q 103 86 146 35 q 60 217 60 138 l 185 217 q 206 154 185 184 q 265 106 227 124 q 352 87 302 87 q 440 104 405 87 q 493 147 475 120 q 511 206 511 174 q 495 273 511 248 q 445 310 479 298 q 359 321 412 321 l 235 321 l 235 398 m 133 929 q 152 981 133 960 q 207 1002 171 1002 q 262 981 243 1002 q 281 929 281 960 q 262 879 281 900 q 207 859 243 859 q 152 879 171 859 q 133 929 133 900 m 425 928 q 444 979 425 958 q 499 1000 463 1000 q 554 979 535 1000 q 574 928 574 958 q 554 878 574 899 q 499 857 535 857 q 444 878 463 857 q 425 928 425 899 z "},"Ӣ":{"ha":991,"x_min":121,"x_max":868,"o":"m 251 227 l 737 987 l 868 987 l 868 0 l 737 0 l 737 762 l 251 0 l 121 0 l 121 987 l 251 987 l 251 227 m 728 1204 l 728 1107 l 273 1107 l 273 1204 l 728 1204 z "},"ӣ":{"ha":802,"x_min":106,"x_max":696,"o":"m 231 199 l 570 734 l 696 734 l 696 0 l 570 0 l 570 535 l 231 0 l 106 0 l 106 734 l 231 734 l 231 199 m 631 971 l 631 875 l 176 875 l 176 971 l 631 971 z "},"Ӥ":{"ha":991,"x_min":121,"x_max":868,"o":"m 251 227 l 737 987 l 868 987 l 868 0 l 737 0 l 737 762 l 251 0 l 121 0 l 121 987 l 251 987 l 251 227 m 279 1148 q 298 1200 279 1179 q 353 1221 317 1221 q 408 1200 389 1221 q 427 1148 427 1179 q 408 1098 427 1119 q 353 1078 389 1078 q 298 1098 317 1078 q 279 1148 279 1119 m 571 1147 q 590 1198 571 1177 q 645 1219 608 1219 q 700 1198 681 1219 q 720 1147 720 1177 q 700 1097 720 1118 q 645 1076 681 1076 q 590 1097 608 1076 q 571 1147 571 1118 z "},"ӥ":{"ha":802,"x_min":106,"x_max":696,"o":"m 231 199 l 570 734 l 696 734 l 696 0 l 570 0 l 570 535 l 231 0 l 106 0 l 106 734 l 231 734 l 231 199 m 182 916 q 201 967 182 946 q 256 988 220 988 q 311 967 292 988 q 330 916 330 946 q 311 866 330 886 q 256 845 292 845 q 201 866 220 845 q 182 916 182 886 m 474 914 q 493 966 474 945 q 548 987 511 987 q 603 966 584 987 q 623 914 623 945 q 603 864 623 885 q 548 844 584 844 q 493 864 511 844 q 474 914 474 885 z "},"Ӧ":{"ha":956,"x_min":81,"x_max":875,"o":"m 875 525 l 875 463 q 847 263 875 351 q 767 113 819 175 q 642 19 715 52 q 479 -14 569 -14 q 318 19 391 -14 q 192 113 245 52 q 110 263 139 175 q 81 463 81 351 l 81 525 q 110 724 81 636 q 191 874 138 812 q 317 968 244 936 q 477 1001 390 1001 q 641 968 568 1001 q 766 874 713 936 q 847 724 819 812 q 875 525 875 636 m 745 463 l 745 526 q 727 682 745 614 q 675 796 709 750 q 590 866 640 842 q 477 890 541 890 q 367 866 416 890 q 283 796 318 842 q 229 682 248 750 q 210 526 210 614 l 210 463 q 229 306 210 374 q 284 191 248 237 q 369 121 319 144 q 479 97 418 97 q 592 121 543 97 q 676 191 642 144 q 728 306 710 237 q 745 463 745 374 m 261 1142 q 280 1194 261 1173 q 335 1215 299 1215 q 391 1194 372 1215 q 410 1142 410 1173 q 391 1092 410 1113 q 335 1072 372 1072 q 280 1092 299 1072 q 261 1142 261 1113 m 553 1141 q 572 1192 553 1171 q 627 1213 591 1213 q 683 1192 663 1213 q 702 1141 702 1171 q 683 1091 702 1112 q 627 1070 663 1070 q 572 1091 591 1070 q 553 1141 553 1112 z "},"ӧ":{"ha":792,"x_min":62,"x_max":730,"o":"m 62 359 l 62 374 q 85 522 62 454 q 152 641 109 590 q 257 719 195 691 q 395 747 319 747 q 535 719 473 747 q 641 641 597 691 q 707 522 684 590 q 730 374 730 454 l 730 359 q 707 212 730 279 q 641 93 684 144 q 535 15 597 43 q 397 -14 474 -14 q 258 15 319 -14 q 152 93 196 43 q 85 212 109 144 q 62 359 62 279 m 188 374 l 188 359 q 201 255 188 304 q 240 170 214 207 q 305 111 266 132 q 397 90 345 90 q 487 111 448 90 q 552 170 526 132 q 591 255 578 207 q 604 359 604 304 l 604 374 q 591 477 604 429 q 552 563 578 526 q 487 623 526 601 q 395 644 448 644 q 305 623 344 644 q 240 563 266 601 q 201 477 214 526 q 188 374 188 429 m 172 930 q 191 981 172 960 q 245 1002 210 1002 q 301 981 282 1002 q 320 930 320 960 q 301 880 320 901 q 245 859 282 859 q 191 880 210 859 q 172 930 172 901 m 464 928 q 483 980 464 959 q 538 1001 501 1001 q 593 980 574 1001 q 612 928 612 959 q 593 879 612 899 q 538 858 574 858 q 483 879 501 858 q 464 928 464 899 z "},"Ө":{"ha":945,"x_min":70,"x_max":864,"o":"m 467 1001 q 600 980 538 1001 q 710 919 662 959 q 793 820 759 878 q 846 688 828 762 q 864 525 864 614 l 864 463 q 836 263 864 351 q 756 113 808 175 q 631 19 704 52 q 468 -14 558 -14 q 337 7 398 -14 q 227 69 276 28 q 142 167 178 109 q 89 299 107 225 q 70 463 70 374 l 70 525 q 99 724 70 636 q 180 874 127 812 q 306 968 233 936 q 467 1001 379 1001 m 467 890 q 366 870 412 890 q 285 812 319 850 q 229 716 251 773 q 201 586 208 660 q 200 563 201 575 q 199 539 199 551 l 734 539 q 734 562 734 551 q 732 585 734 574 q 706 716 726 659 q 651 811 686 772 q 571 870 617 850 q 467 890 524 890 m 468 97 q 573 117 526 97 q 653 176 620 137 q 707 274 687 216 q 732 407 727 332 q 733 421 733 414 q 734 436 734 429 l 200 436 q 201 415 201 425 q 203 395 202 405 q 231 267 210 323 q 288 174 253 212 q 368 116 322 136 q 468 97 414 97 z "},"ө":{"ha":789,"x_min":62,"x_max":730,"o":"m 395 747 q 535 719 473 747 q 640 641 597 691 q 707 522 684 590 q 730 374 730 454 l 730 359 q 707 212 730 279 q 640 93 684 144 q 535 15 597 43 q 397 -14 474 -14 q 258 15 319 -14 q 152 93 196 43 q 85 212 109 144 q 62 359 62 279 l 62 374 q 85 522 62 454 q 152 641 109 590 q 257 719 195 691 q 395 747 319 747 m 395 644 q 313 627 349 644 q 252 579 277 610 q 211 508 227 549 q 191 422 196 468 l 602 422 q 581 508 597 468 q 540 579 566 549 q 478 627 514 610 q 395 644 441 644 m 397 90 q 480 107 444 90 q 542 156 516 125 q 583 230 568 188 q 602 319 598 271 l 190 319 q 209 230 194 271 q 250 156 224 188 q 313 107 276 125 q 397 90 349 90 z "},"Ӫ":{"ha":945,"x_min":70,"x_max":864,"o":"m 467 1001 q 600 980 538 1001 q 710 919 662 959 q 793 820 759 878 q 846 688 828 762 q 864 525 864 614 l 864 463 q 836 263 864 351 q 756 113 808 175 q 631 19 704 52 q 468 -14 558 -14 q 337 7 398 -14 q 227 69 276 28 q 142 167 178 109 q 89 299 107 225 q 70 463 70 374 l 70 525 q 99 724 70 636 q 180 874 127 812 q 306 968 233 936 q 467 1001 379 1001 m 467 890 q 366 870 412 890 q 285 812 319 850 q 229 716 251 773 q 201 586 208 660 q 200 563 201 575 q 199 539 199 551 l 734 539 q 734 562 734 551 q 732 585 734 574 q 706 716 726 659 q 651 811 686 772 q 571 870 617 850 q 467 890 524 890 m 468 97 q 573 117 526 97 q 653 176 620 137 q 707 274 687 216 q 732 407 727 332 q 733 421 733 414 q 734 436 734 429 l 200 436 q 201 415 201 425 q 203 395 202 405 q 231 267 210 323 q 288 174 253 212 q 368 116 322 136 q 468 97 414 97 m 269 1145 q 288 1196 269 1175 q 343 1217 307 1217 q 399 1196 380 1217 q 418 1145 418 1175 q 399 1095 418 1116 q 343 1074 380 1074 q 288 1095 307 1074 q 269 1145 269 1116 m 562 1143 q 580 1195 562 1174 q 635 1216 599 1216 q 691 1195 671 1216 q 710 1143 710 1174 q 691 1094 710 1114 q 635 1073 671 1073 q 580 1094 599 1073 q 562 1143 562 1114 z "},"ӫ":{"ha":789,"x_min":62,"x_max":730,"o":"m 395 747 q 535 719 473 747 q 640 641 597 691 q 707 522 684 590 q 730 374 730 454 l 730 359 q 707 212 730 279 q 640 93 684 144 q 535 15 597 43 q 397 -14 474 -14 q 258 15 319 -14 q 152 93 196 43 q 85 212 109 144 q 62 359 62 279 l 62 374 q 85 522 62 454 q 152 641 109 590 q 257 719 195 691 q 395 747 319 747 m 395 644 q 313 627 349 644 q 252 579 277 610 q 211 508 227 549 q 191 422 196 468 l 602 422 q 581 508 597 468 q 540 579 566 549 q 478 627 514 610 q 395 644 441 644 m 397 90 q 480 107 444 90 q 542 156 516 125 q 583 230 568 188 q 602 319 598 271 l 190 319 q 209 230 194 271 q 250 156 224 188 q 313 107 276 125 q 397 90 349 90 m 161 931 q 180 983 161 962 q 235 1004 199 1004 q 290 983 271 1004 q 309 931 309 962 q 290 881 309 902 q 235 861 271 861 q 180 881 199 861 q 161 931 161 902 m 453 930 q 472 981 453 960 q 527 1002 490 1002 q 582 981 563 1002 q 602 930 602 960 q 582 880 602 901 q 527 859 563 859 q 472 880 490 859 q 453 930 453 901 z "},"Ӭ":{"ha":937,"x_min":100,"x_max":860,"o":"m 746 546 l 746 439 l 341 439 l 341 546 l 746 546 m 100 314 l 231 314 q 267 195 241 244 q 342 119 292 145 q 475 93 391 93 q 589 120 541 93 q 668 196 637 148 q 714 308 699 244 q 730 444 730 372 l 730 543 q 719 660 730 606 q 686 757 708 714 q 632 831 665 800 q 558 878 600 861 q 463 894 515 894 q 339 867 387 894 q 266 790 292 840 q 231 671 241 740 l 100 671 q 154 843 111 768 q 274 959 197 917 q 463 1001 351 1001 q 628 968 555 1001 q 753 876 701 936 q 832 730 805 815 q 860 542 860 646 l 860 444 q 832 256 860 340 q 754 112 805 172 q 632 19 703 52 q 475 -14 562 -14 q 277 30 356 -14 q 154 146 197 73 q 100 314 111 220 m 251 1163 q 270 1215 251 1194 q 325 1236 289 1236 q 380 1215 361 1236 q 399 1163 399 1194 q 380 1113 399 1134 q 325 1093 361 1093 q 270 1113 289 1093 q 251 1163 251 1134 m 543 1162 q 562 1213 543 1192 q 617 1234 581 1234 q 672 1213 653 1234 q 692 1162 692 1192 q 672 1112 692 1133 q 617 1091 653 1091 q 562 1112 581 1091 q 543 1162 543 1133 z "},"ӭ":{"ha":747,"x_min":68,"x_max":673,"o":"m 353 644 q 274 626 311 644 q 212 575 236 608 q 188 501 188 543 l 68 501 q 109 623 68 567 q 214 713 149 679 q 353 747 279 747 q 490 718 430 747 q 590 638 549 689 q 652 521 631 587 q 673 381 673 455 l 673 353 q 652 213 673 279 q 590 95 631 146 q 489 15 549 44 q 353 -14 430 -14 q 207 21 271 -14 q 105 116 142 56 q 68 252 68 176 l 188 252 q 210 169 188 206 q 269 111 232 132 q 353 89 307 89 q 441 112 404 89 q 502 173 478 135 q 537 258 526 211 q 548 353 548 305 l 548 381 q 537 476 548 429 q 502 561 526 523 q 442 622 479 599 q 353 644 405 644 m 609 425 l 609 323 l 271 323 l 271 425 l 609 425 m 153 930 q 172 981 153 960 q 227 1002 191 1002 q 282 981 263 1002 q 301 930 301 960 q 282 880 301 901 q 227 859 263 859 q 172 880 191 859 q 153 930 153 901 m 445 928 q 464 980 445 959 q 519 1001 482 1001 q 574 980 555 1001 q 593 928 593 959 q 574 879 593 899 q 519 858 555 858 q 464 879 482 858 q 445 928 445 899 z "},"Ӯ":{"ha":873,"x_min":52,"x_max":832,"o":"m 420 328 l 682 987 l 832 987 l 483 165 q 450 98 468 130 q 405 41 431 66 q 339 1 378 16 q 243 -14 300 -14 q 204 -13 227 -14 q 175 -9 182 -11 l 179 96 q 208 93 186 94 q 240 92 230 92 q 301 108 279 92 q 337 148 323 123 q 363 197 351 172 l 420 328 m 199 987 l 473 372 l 506 251 l 396 243 l 52 987 l 199 987 m 669 1204 l 669 1107 l 214 1107 l 214 1204 l 669 1204 z "},"ӯ":{"ha":657,"x_min":15,"x_max":640,"o":"m 302 76 l 506 734 l 640 734 l 346 -113 q 319 -172 336 -140 q 277 -232 302 -203 q 215 -278 251 -260 q 128 -296 178 -296 q 90 -292 113 -296 q 58 -286 67 -288 l 57 -184 q 74 -185 62 -184 q 91 -186 86 -186 q 163 -175 134 -186 q 214 -138 193 -164 q 250 -66 235 -112 l 302 76 m 152 734 l 342 164 l 375 32 l 285 -14 l 15 734 l 152 734 m 576 985 l 576 889 l 121 889 l 121 985 l 576 985 z "},"Ӱ":{"ha":873,"x_min":52,"x_max":832,"o":"m 420 328 l 682 987 l 832 987 l 483 165 q 450 98 468 130 q 405 41 431 66 q 339 1 378 16 q 243 -14 300 -14 q 204 -13 227 -14 q 175 -9 182 -11 l 179 96 q 208 93 186 94 q 240 92 230 92 q 301 108 279 92 q 337 148 323 123 q 363 197 351 172 l 420 328 m 199 987 l 473 372 l 506 251 l 396 243 l 52 987 l 199 987 m 220 1148 q 239 1200 220 1179 q 294 1221 258 1221 q 349 1200 330 1221 q 368 1148 368 1179 q 349 1098 368 1119 q 294 1078 330 1078 q 239 1098 258 1078 q 220 1148 220 1119 m 512 1147 q 531 1198 512 1177 q 586 1219 549 1219 q 641 1198 622 1219 q 661 1147 661 1177 q 641 1097 661 1118 q 586 1076 622 1076 q 531 1097 549 1076 q 512 1147 512 1118 z "},"ӱ":{"ha":657,"x_min":15,"x_max":640,"o":"m 302 76 l 506 734 l 640 734 l 346 -113 q 319 -172 336 -140 q 277 -232 302 -203 q 215 -278 251 -260 q 128 -296 178 -296 q 90 -292 113 -296 q 58 -286 67 -288 l 57 -184 q 74 -185 62 -184 q 91 -186 86 -186 q 163 -175 134 -186 q 214 -138 193 -164 q 250 -66 235 -112 l 302 76 m 152 734 l 342 164 l 375 32 l 285 -14 l 15 734 l 152 734 m 126 930 q 145 981 126 960 q 200 1002 164 1002 q 256 981 237 1002 q 275 930 275 960 q 256 880 275 901 q 200 859 237 859 q 145 880 164 859 q 126 930 126 901 m 418 928 q 437 980 418 959 q 492 1001 456 1001 q 548 980 528 1001 q 567 928 567 959 q 548 879 567 899 q 492 858 528 858 q 437 879 456 858 q 418 928 418 899 z "},"Ӳ":{"ha":873,"x_min":52,"x_max":832,"o":"m 420 328 l 682 987 l 832 987 l 483 165 q 450 98 468 130 q 405 41 431 66 q 339 1 378 16 q 243 -14 300 -14 q 204 -13 227 -14 q 175 -9 182 -11 l 179 96 q 208 93 186 94 q 240 92 230 92 q 301 108 279 92 q 337 148 323 123 q 363 197 351 172 l 420 328 m 199 987 l 473 372 l 506 251 l 396 243 l 52 987 l 199 987 m 459 1054 l 615 1259 l 755 1259 l 574 1054 l 459 1054 m 269 1054 l 385 1259 l 519 1259 l 371 1054 l 269 1054 z "},"ӳ":{"ha":657,"x_min":15,"x_max":662,"o":"m 302 76 l 506 734 l 640 734 l 346 -113 q 319 -172 336 -140 q 277 -232 302 -203 q 215 -278 251 -260 q 128 -296 178 -296 q 90 -292 113 -296 q 58 -286 67 -288 l 57 -184 q 74 -185 62 -184 q 91 -186 86 -186 q 163 -175 134 -186 q 214 -138 193 -164 q 250 -66 235 -112 l 302 76 m 152 734 l 342 164 l 375 32 l 285 -14 l 15 734 l 152 734 m 366 836 l 522 1041 l 662 1041 l 480 836 l 366 836 m 176 836 l 291 1041 l 425 1041 l 277 836 l 176 836 z "},"Ӵ":{"ha":951,"x_min":102,"x_max":831,"o":"m 102 987 l 233 987 l 233 679 q 256 559 233 602 q 323 498 278 515 q 437 480 369 480 q 516 484 477 480 q 591 493 554 487 q 663 508 627 499 q 733 527 699 517 l 733 420 q 667 401 700 410 q 599 386 634 392 q 525 376 564 380 q 437 373 485 373 q 257 403 332 373 q 142 500 182 433 q 102 679 102 568 l 102 987 m 700 987 l 831 987 l 831 0 l 700 0 l 700 987 m 248 1148 q 267 1200 248 1179 q 322 1221 286 1221 q 378 1200 359 1221 q 397 1148 397 1179 q 378 1098 397 1119 q 322 1078 359 1078 q 267 1098 286 1078 q 248 1148 248 1119 m 541 1147 q 559 1198 541 1177 q 614 1219 578 1219 q 670 1198 650 1219 q 689 1147 689 1177 q 670 1097 689 1118 q 614 1076 650 1076 q 559 1097 578 1076 q 541 1147 541 1118 z "},"ӵ":{"ha":755,"x_min":71,"x_max":649,"o":"m 649 734 l 649 0 l 524 0 l 524 734 l 649 734 m 606 397 l 606 294 q 529 268 568 279 q 447 251 490 257 q 354 244 404 244 q 203 274 267 244 q 105 366 140 304 q 71 521 71 427 l 71 735 l 196 735 l 196 521 q 214 422 196 460 q 268 366 233 384 q 354 348 303 348 q 446 354 403 348 q 529 372 489 361 q 606 397 568 382 m 137 916 q 156 967 137 946 q 211 988 175 988 q 267 967 248 988 q 286 916 286 946 q 267 866 286 886 q 211 845 248 845 q 156 866 175 845 q 137 916 137 886 m 429 914 q 448 966 429 945 q 503 987 467 987 q 558 966 539 987 q 578 914 578 945 q 558 864 578 885 q 503 844 539 844 q 448 864 467 844 q 429 914 429 885 z "},"Ӹ":{"ha":1201,"x_min":121,"x_max":1075,"o":"m 220 585 l 490 585 q 673 549 598 585 q 786 448 747 513 q 825 295 825 382 q 803 176 825 230 q 739 82 781 122 q 633 21 696 43 q 490 0 571 0 l 121 0 l 121 987 l 252 987 l 252 106 l 490 106 q 607 133 562 106 q 673 203 652 160 q 694 296 694 247 q 673 387 694 346 q 607 453 652 429 q 490 478 562 478 l 220 478 l 220 585 m 1075 987 l 1075 0 l 944 0 l 944 987 l 1075 987 m 385 1148 q 404 1200 385 1179 q 459 1221 423 1221 q 515 1200 496 1221 q 534 1148 534 1179 q 515 1098 534 1119 q 459 1078 496 1078 q 404 1098 423 1078 q 385 1148 385 1119 m 677 1147 q 696 1198 677 1177 q 751 1219 715 1219 q 807 1198 787 1219 q 826 1147 826 1177 q 807 1097 826 1118 q 751 1076 787 1076 q 696 1097 715 1076 q 677 1147 677 1118 z "},"ӹ":{"ha":1078,"x_min":107,"x_max":954,"o":"m 199 481 l 419 481 q 569 451 508 481 q 662 366 630 420 q 693 243 693 312 q 675 148 693 193 q 623 71 658 104 q 537 19 588 37 q 419 0 486 0 l 107 0 l 107 734 l 233 734 l 233 103 l 419 103 q 506 123 473 103 q 553 174 538 142 q 567 239 567 205 q 553 304 567 272 q 506 357 538 336 q 419 378 473 378 l 199 378 l 199 481 m 954 734 l 954 0 l 829 0 l 829 734 l 954 734 m 316 916 q 335 967 316 946 q 390 988 354 988 q 446 967 427 988 q 465 916 465 946 q 446 866 465 886 q 390 845 427 845 q 335 866 354 845 q 316 916 316 886 m 608 914 q 627 966 608 945 q 682 987 646 987 q 738 966 718 987 q 757 914 757 945 q 738 864 757 885 q 682 844 718 844 q 627 864 646 844 q 608 914 608 885 z "},"ԁ":{"ha":783,"x_min":64,"x_max":684,"o":"m 558 142 l 558 1042 l 684 1042 l 684 0 l 569 0 l 558 142 m 64 359 l 64 373 q 85 526 64 457 q 144 644 106 595 q 236 721 182 694 q 355 747 289 747 q 476 723 424 747 q 564 653 528 699 q 621 543 600 608 q 650 397 642 479 l 650 335 q 622 190 643 254 q 564 80 600 125 q 475 11 528 35 q 353 -14 423 -14 q 236 14 289 -14 q 144 92 182 42 q 85 211 106 142 q 64 359 64 279 m 191 373 l 191 359 q 202 256 191 304 q 237 171 213 208 q 297 114 260 134 q 385 93 334 93 q 487 119 447 93 q 552 189 528 146 q 590 283 576 233 l 590 447 q 567 519 582 484 q 527 582 551 554 q 468 625 503 609 q 386 642 433 642 q 297 620 334 642 q 237 562 260 599 q 202 476 213 525 q 191 373 191 428 z "},"Ạ":{"ha":906,"x_min":20,"x_max":888,"o":"m 480 900 l 153 0 l 20 0 l 396 987 l 482 987 l 480 900 m 754 0 l 427 900 l 425 987 l 511 987 l 888 0 l 754 0 m 737 366 l 737 258 l 182 258 l 182 366 l 737 366 m 387 -167 q 406 -115 387 -136 q 461 -94 425 -94 q 516 -115 497 -94 q 536 -167 536 -136 q 516 -217 536 -196 q 461 -237 497 -237 q 406 -217 425 -237 q 387 -167 387 -196 z "},"ạ":{"ha":755,"x_min":74,"x_max":680,"o":"m 528 125 l 528 503 q 511 579 528 547 q 459 629 494 611 q 374 646 425 646 q 291 630 326 646 q 235 587 255 614 q 215 530 215 561 l 90 530 q 110 608 90 570 q 169 679 130 647 q 261 729 207 710 q 381 747 315 747 q 523 720 461 747 q 619 638 584 693 q 654 502 654 584 l 654 160 q 660 82 654 123 q 680 11 667 41 l 680 0 l 549 0 q 534 58 539 22 q 528 125 528 94 m 550 445 l 551 357 l 425 357 q 329 348 371 357 q 258 323 287 340 q 215 280 230 306 q 200 221 200 255 q 216 158 200 186 q 263 113 231 130 q 340 96 294 96 q 442 121 398 96 q 512 180 486 145 q 541 249 538 216 l 594 189 q 568 125 589 160 q 512 59 547 91 q 430 7 477 28 q 322 -14 382 -14 q 192 16 248 -14 q 105 94 136 45 q 74 204 74 143 q 97 308 74 263 q 163 384 120 353 q 268 429 207 414 q 404 445 329 445 l 550 445 m 262 -167 q 281 -115 262 -136 q 336 -94 300 -94 q 392 -115 372 -94 q 411 -167 411 -136 q 392 -217 411 -196 q 336 -237 372 -237 q 281 -217 300 -237 q 262 -167 262 -196 z "},"Ả":{"ha":906,"x_min":20,"x_max":888,"o":"m 480 900 l 153 0 l 20 0 l 396 987 l 482 987 l 480 900 m 754 0 l 427 900 l 425 987 l 511 987 l 888 0 l 754 0 m 737 366 l 737 258 l 182 258 l 182 366 l 737 366 m 503 1064 l 413 1064 l 412 1167 q 469 1174 447 1169 q 500 1190 490 1179 q 511 1218 511 1200 q 502 1242 511 1232 q 477 1258 493 1252 q 441 1267 462 1265 q 398 1270 421 1270 l 403 1342 q 491 1333 453 1342 q 556 1308 530 1324 q 595 1267 582 1291 q 608 1215 608 1244 q 576 1140 608 1164 q 504 1112 543 1117 l 503 1064 z "},"ả":{"ha":755,"x_min":74,"x_max":680,"o":"m 528 125 l 528 503 q 511 579 528 547 q 459 629 494 611 q 374 646 425 646 q 291 630 326 646 q 235 587 255 614 q 215 530 215 561 l 90 530 q 110 608 90 570 q 169 679 130 647 q 261 729 207 710 q 381 747 315 747 q 523 720 461 747 q 619 638 584 693 q 654 502 654 584 l 654 160 q 660 82 654 123 q 680 11 667 41 l 680 0 l 549 0 q 534 58 539 22 q 528 125 528 94 m 550 445 l 551 357 l 425 357 q 329 348 371 357 q 258 323 287 340 q 215 280 230 306 q 200 221 200 255 q 216 158 200 186 q 263 113 231 130 q 340 96 294 96 q 442 121 398 96 q 512 180 486 145 q 541 249 538 216 l 594 189 q 568 125 589 160 q 512 59 547 91 q 430 7 477 28 q 322 -14 382 -14 q 192 16 248 -14 q 105 94 136 45 q 74 204 74 143 q 97 308 74 263 q 163 384 120 353 q 268 429 207 414 q 404 445 329 445 l 550 445 m 442 853 l 352 853 l 351 956 q 408 963 386 958 q 439 979 429 968 q 450 1007 450 989 q 441 1031 450 1021 q 416 1047 432 1041 q 380 1057 401 1054 q 337 1059 360 1059 l 342 1131 q 430 1122 392 1131 q 495 1097 469 1114 q 534 1056 521 1080 q 547 1004 547 1033 q 515 929 547 953 q 443 901 482 906 l 442 853 z "},"Ấ":{"ha":906,"x_min":20,"x_max":888,"o":"m 480 900 l 153 0 l 20 0 l 396 987 l 482 987 l 480 900 m 754 0 l 427 900 l 425 987 l 511 987 l 888 0 l 754 0 m 737 366 l 737 258 l 182 258 l 182 366 l 737 366 m 207 1053 l 404 1231 l 507 1231 l 705 1053 l 571 1053 l 456 1160 l 340 1053 l 207 1053 m 654 1173 l 750 1348 l 886 1348 l 749 1173 l 654 1173 z "},"ấ":{"ha":755,"x_min":74,"x_max":825,"o":"m 528 125 l 528 503 q 511 579 528 547 q 459 629 494 611 q 374 646 425 646 q 291 630 326 646 q 235 587 255 614 q 215 530 215 561 l 90 530 q 110 608 90 570 q 169 679 130 647 q 261 729 207 710 q 381 747 315 747 q 523 720 461 747 q 619 638 584 693 q 654 502 654 584 l 654 160 q 660 82 654 123 q 680 11 667 41 l 680 0 l 549 0 q 534 58 539 22 q 528 125 528 94 m 550 445 l 551 357 l 425 357 q 329 348 371 357 q 258 323 287 340 q 215 280 230 306 q 200 221 200 255 q 216 158 200 186 q 263 113 231 130 q 340 96 294 96 q 442 121 398 96 q 512 180 486 145 q 541 249 538 216 l 594 189 q 568 125 589 160 q 512 59 547 91 q 430 7 477 28 q 322 -14 382 -14 q 192 16 248 -14 q 105 94 136 45 q 74 204 74 143 q 97 308 74 263 q 163 384 120 353 q 268 429 207 414 q 404 445 329 445 l 550 445 m 146 842 l 343 1020 l 446 1020 l 644 842 l 510 842 l 395 949 l 279 842 l 146 842 m 593 962 l 689 1137 l 825 1137 l 688 962 l 593 962 z "},"Ầ":{"ha":906,"x_min":20,"x_max":888,"o":"m 480 900 l 153 0 l 20 0 l 396 987 l 482 987 l 480 900 m 754 0 l 427 900 l 425 987 l 511 987 l 888 0 l 754 0 m 737 366 l 737 258 l 182 258 l 182 366 l 737 366 m 505 1228 l 703 1050 l 569 1050 l 454 1158 l 339 1050 l 205 1050 l 402 1228 l 505 1228 m 159 1345 l 256 1171 l 160 1171 l 24 1345 l 159 1345 z "},"ầ":{"ha":755,"x_min":-37,"x_max":680,"o":"m 528 125 l 528 503 q 511 579 528 547 q 459 629 494 611 q 374 646 425 646 q 291 630 326 646 q 235 587 255 614 q 215 530 215 561 l 90 530 q 110 608 90 570 q 169 679 130 647 q 261 729 207 710 q 381 747 315 747 q 523 720 461 747 q 619 638 584 693 q 654 502 654 584 l 654 160 q 660 82 654 123 q 680 11 667 41 l 680 0 l 549 0 q 534 58 539 22 q 528 125 528 94 m 550 445 l 551 357 l 425 357 q 329 348 371 357 q 258 323 287 340 q 215 280 230 306 q 200 221 200 255 q 216 158 200 186 q 263 113 231 130 q 340 96 294 96 q 442 121 398 96 q 512 180 486 145 q 541 249 538 216 l 594 189 q 568 125 589 160 q 512 59 547 91 q 430 7 477 28 q 322 -14 382 -14 q 192 16 248 -14 q 105 94 136 45 q 74 204 74 143 q 97 308 74 263 q 163 384 120 353 q 268 429 207 414 q 404 445 329 445 l 550 445 m 444 1017 l 642 839 l 508 839 l 393 947 l 278 839 l 144 839 l 341 1017 l 444 1017 m 98 1135 l 195 960 l 99 960 l -37 1135 l 98 1135 z "},"Ẩ":{"ha":906,"x_min":20,"x_max":888,"o":"m 480 900 l 153 0 l 20 0 l 396 987 l 482 987 l 480 900 m 754 0 l 427 900 l 425 987 l 511 987 l 888 0 l 754 0 m 737 366 l 737 258 l 182 258 l 182 366 l 737 366 m 518 1220 l 704 1042 l 588 1042 l 454 1168 l 321 1042 l 206 1042 l 391 1220 l 518 1220 m 725 1135 l 647 1135 l 646 1225 q 694 1231 676 1227 q 722 1243 713 1235 q 730 1267 730 1252 q 718 1294 730 1284 q 683 1308 705 1303 q 635 1312 661 1312 l 639 1375 q 715 1368 682 1375 q 771 1345 748 1360 q 805 1311 793 1331 q 817 1265 817 1291 q 788 1201 817 1221 q 726 1177 760 1181 l 725 1135 z "},"ẩ":{"ha":755,"x_min":74,"x_max":755,"o":"m 528 125 l 528 503 q 511 579 528 547 q 459 629 494 611 q 374 646 425 646 q 291 630 326 646 q 235 587 255 614 q 215 530 215 561 l 90 530 q 110 608 90 570 q 169 679 130 647 q 261 729 207 710 q 381 747 315 747 q 523 720 461 747 q 619 638 584 693 q 654 502 654 584 l 654 160 q 660 82 654 123 q 680 11 667 41 l 680 0 l 549 0 q 534 58 539 22 q 528 125 528 94 m 550 445 l 551 357 l 425 357 q 329 348 371 357 q 258 323 287 340 q 215 280 230 306 q 200 221 200 255 q 216 158 200 186 q 263 113 231 130 q 340 96 294 96 q 442 121 398 96 q 512 180 486 145 q 541 249 538 216 l 594 189 q 568 125 589 160 q 512 59 547 91 q 430 7 477 28 q 322 -14 382 -14 q 192 16 248 -14 q 105 94 136 45 q 74 204 74 143 q 97 308 74 263 q 163 384 120 353 q 268 429 207 414 q 404 445 329 445 l 550 445 m 457 1009 l 643 831 l 527 831 l 393 957 l 260 831 l 145 831 l 330 1009 l 457 1009 m 664 924 l 586 924 l 585 1014 q 633 1020 615 1016 q 661 1033 652 1024 q 669 1056 669 1041 q 656 1083 669 1073 q 622 1097 644 1093 q 574 1101 600 1101 l 578 1164 q 654 1157 621 1164 q 710 1134 687 1149 q 744 1100 732 1120 q 755 1055 755 1080 q 727 990 755 1010 q 665 966 699 970 l 664 924 z "},"Ẫ":{"ha":906,"x_min":20,"x_max":888,"o":"m 480 900 l 153 0 l 20 0 l 396 987 l 482 987 l 480 900 m 754 0 l 427 900 l 425 987 l 511 987 l 888 0 l 754 0 m 737 366 l 737 258 l 182 258 l 182 366 l 737 366 m 499 1192 l 704 1027 l 588 1027 l 454 1134 l 321 1027 l 206 1027 l 410 1192 l 499 1192 m 579 1363 l 631 1348 q 617 1297 631 1321 q 578 1257 602 1272 q 523 1242 553 1242 q 469 1254 489 1242 q 430 1278 448 1266 q 385 1291 412 1291 q 346 1275 363 1291 q 328 1240 328 1259 l 276 1253 q 291 1304 276 1280 q 330 1345 305 1329 q 385 1361 355 1361 q 434 1349 413 1361 q 476 1325 455 1337 q 523 1314 496 1314 q 562 1329 544 1314 q 579 1363 579 1344 z "},"ẫ":{"ha":755,"x_min":74,"x_max":680,"o":"m 528 125 l 528 503 q 511 579 528 547 q 459 629 494 611 q 374 646 425 646 q 291 630 326 646 q 235 587 255 614 q 215 530 215 561 l 90 530 q 110 608 90 570 q 169 679 130 647 q 261 729 207 710 q 381 747 315 747 q 523 720 461 747 q 619 638 584 693 q 654 502 654 584 l 654 160 q 660 82 654 123 q 680 11 667 41 l 680 0 l 549 0 q 534 58 539 22 q 528 125 528 94 m 550 445 l 551 357 l 425 357 q 329 348 371 357 q 258 323 287 340 q 215 280 230 306 q 200 221 200 255 q 216 158 200 186 q 263 113 231 130 q 340 96 294 96 q 442 121 398 96 q 512 180 486 145 q 541 249 538 216 l 594 189 q 568 125 589 160 q 512 59 547 91 q 430 7 477 28 q 322 -14 382 -14 q 192 16 248 -14 q 105 94 136 45 q 74 204 74 143 q 97 308 74 263 q 163 384 120 353 q 268 429 207 414 q 404 445 329 445 l 550 445 m 438 981 l 643 816 l 527 816 l 393 923 l 260 816 l 145 816 l 349 981 l 438 981 m 518 1152 l 570 1137 q 556 1086 570 1110 q 517 1046 541 1061 q 462 1031 492 1031 q 408 1043 428 1031 q 369 1067 387 1055 q 323 1080 351 1080 q 285 1064 302 1080 q 267 1029 267 1048 l 215 1042 q 230 1094 215 1069 q 269 1134 244 1118 q 323 1150 294 1150 q 373 1138 352 1150 q 415 1115 394 1126 q 462 1103 435 1103 q 500 1118 483 1103 q 518 1152 518 1133 z "},"Ậ":{"ha":906,"x_min":20,"x_max":888,"o":"m 480 900 l 153 0 l 20 0 l 396 987 l 482 987 l 480 900 m 754 0 l 427 900 l 425 987 l 511 987 l 888 0 l 754 0 m 737 366 l 737 258 l 182 258 l 182 366 l 737 366 m 494 1253 l 662 1067 l 662 1061 l 557 1061 l 456 1175 l 355 1061 l 252 1061 l 252 1068 l 418 1253 l 494 1253 m 387 -167 q 406 -115 387 -136 q 461 -94 425 -94 q 516 -115 497 -94 q 536 -167 536 -136 q 516 -217 536 -196 q 461 -237 497 -237 q 406 -217 425 -237 q 387 -167 387 -196 z "},"ậ":{"ha":755,"x_min":74,"x_max":680,"o":"m 528 125 l 528 503 q 511 579 528 547 q 459 629 494 611 q 374 646 425 646 q 291 630 326 646 q 235 587 255 614 q 215 530 215 561 l 90 530 q 110 608 90 570 q 169 679 130 647 q 261 729 207 710 q 381 747 315 747 q 523 720 461 747 q 619 638 584 693 q 654 502 654 584 l 654 160 q 660 82 654 123 q 680 11 667 41 l 680 0 l 549 0 q 534 58 539 22 q 528 125 528 94 m 550 445 l 551 357 l 425 357 q 329 348 371 357 q 258 323 287 340 q 215 280 230 306 q 200 221 200 255 q 216 158 200 186 q 263 113 231 130 q 340 96 294 96 q 442 121 398 96 q 512 180 486 145 q 541 249 538 216 l 594 189 q 568 125 589 160 q 512 59 547 91 q 430 7 477 28 q 322 -14 382 -14 q 192 16 248 -14 q 105 94 136 45 q 74 204 74 143 q 97 308 74 263 q 163 384 120 353 q 268 429 207 414 q 404 445 329 445 l 550 445 m 433 1042 l 601 857 l 601 850 l 496 850 l 395 964 l 294 850 l 191 850 l 191 857 l 357 1042 l 433 1042 m 262 -167 q 281 -115 262 -136 q 336 -94 300 -94 q 392 -115 372 -94 q 411 -167 411 -136 q 392 -217 411 -196 q 336 -237 372 -237 q 281 -217 300 -237 q 262 -167 262 -196 z "},"Ắ":{"ha":906,"x_min":20,"x_max":888,"o":"m 480 900 l 153 0 l 20 0 l 396 987 l 482 987 l 480 900 m 754 0 l 427 900 l 425 987 l 511 987 l 888 0 l 754 0 m 737 366 l 737 258 l 182 258 l 182 366 l 737 366 m 554 1192 l 658 1192 q 633 1118 658 1150 q 562 1068 608 1086 q 453 1050 516 1050 q 343 1068 389 1050 q 272 1118 297 1086 q 247 1192 247 1150 l 350 1192 q 373 1137 350 1160 q 453 1114 396 1114 q 531 1137 507 1114 q 554 1192 554 1160 m 413 1205 l 490 1340 l 593 1340 l 482 1205 l 413 1205 z "},"ắ":{"ha":755,"x_min":74,"x_max":680,"o":"m 528 125 l 528 503 q 511 579 528 547 q 459 629 494 611 q 374 646 425 646 q 291 630 326 646 q 235 587 255 614 q 215 530 215 561 l 90 530 q 110 608 90 570 q 169 679 130 647 q 261 729 207 710 q 381 747 315 747 q 523 720 461 747 q 619 638 584 693 q 654 502 654 584 l 654 160 q 660 82 654 123 q 680 11 667 41 l 680 0 l 549 0 q 534 58 539 22 q 528 125 528 94 m 550 445 l 551 357 l 425 357 q 329 348 371 357 q 258 323 287 340 q 215 280 230 306 q 200 221 200 255 q 216 158 200 186 q 263 113 231 130 q 340 96 294 96 q 442 121 398 96 q 512 180 486 145 q 541 249 538 216 l 594 189 q 568 125 589 160 q 512 59 547 91 q 430 7 477 28 q 322 -14 382 -14 q 192 16 248 -14 q 105 94 136 45 q 74 204 74 143 q 97 308 74 263 q 163 384 120 353 q 268 429 207 414 q 404 445 329 445 l 550 445 m 493 981 l 597 981 q 572 907 597 939 q 501 857 547 876 q 392 839 455 839 q 282 857 328 839 q 211 907 236 876 q 186 981 186 939 l 289 981 q 312 926 289 949 q 392 903 335 903 q 470 926 446 903 q 493 981 493 949 m 352 994 l 429 1129 l 532 1129 l 421 994 l 352 994 z "},"Ằ":{"ha":906,"x_min":20,"x_max":888,"o":"m 480 900 l 153 0 l 20 0 l 396 987 l 482 987 l 480 900 m 754 0 l 427 900 l 425 987 l 511 987 l 888 0 l 754 0 m 737 366 l 737 258 l 182 258 l 182 366 l 737 366 m 554 1192 l 658 1192 q 633 1118 658 1150 q 562 1068 608 1086 q 453 1050 516 1050 q 343 1068 389 1050 q 272 1118 297 1086 q 247 1192 247 1150 l 350 1192 q 373 1137 350 1160 q 453 1114 396 1114 q 531 1137 507 1114 q 554 1192 554 1160 m 431 1205 l 320 1340 l 424 1340 l 500 1205 l 431 1205 z "},"ằ":{"ha":755,"x_min":74,"x_max":680,"o":"m 528 125 l 528 503 q 511 579 528 547 q 459 629 494 611 q 374 646 425 646 q 291 630 326 646 q 235 587 255 614 q 215 530 215 561 l 90 530 q 110 608 90 570 q 169 679 130 647 q 261 729 207 710 q 381 747 315 747 q 523 720 461 747 q 619 638 584 693 q 654 502 654 584 l 654 160 q 660 82 654 123 q 680 11 667 41 l 680 0 l 549 0 q 534 58 539 22 q 528 125 528 94 m 550 445 l 551 357 l 425 357 q 329 348 371 357 q 258 323 287 340 q 215 280 230 306 q 200 221 200 255 q 216 158 200 186 q 263 113 231 130 q 340 96 294 96 q 442 121 398 96 q 512 180 486 145 q 541 249 538 216 l 594 189 q 568 125 589 160 q 512 59 547 91 q 430 7 477 28 q 322 -14 382 -14 q 192 16 248 -14 q 105 94 136 45 q 74 204 74 143 q 97 308 74 263 q 163 384 120 353 q 268 429 207 414 q 404 445 329 445 l 550 445 m 493 981 l 597 981 q 572 907 597 939 q 501 857 547 876 q 392 839 455 839 q 282 857 328 839 q 211 907 236 876 q 186 981 186 939 l 289 981 q 312 926 289 949 q 392 903 335 903 q 470 926 446 903 q 493 981 493 949 m 370 994 l 259 1129 l 363 1129 l 439 994 l 370 994 z "},"Ẳ":{"ha":906,"x_min":20,"x_max":888,"o":"m 480 900 l 153 0 l 20 0 l 396 987 l 482 987 l 480 900 m 754 0 l 427 900 l 425 987 l 511 987 l 888 0 l 754 0 m 737 366 l 737 258 l 182 258 l 182 366 l 737 366 m 547 1203 l 646 1203 q 622 1130 646 1162 q 554 1080 598 1098 q 448 1062 510 1062 q 342 1080 387 1062 q 274 1130 298 1098 q 250 1203 250 1162 l 349 1203 q 372 1148 349 1172 q 448 1125 395 1125 q 524 1148 501 1125 q 547 1203 547 1172 m 497 1215 l 410 1215 l 410 1299 q 464 1305 443 1301 q 494 1317 484 1309 q 505 1338 505 1324 q 496 1357 505 1349 q 473 1369 488 1364 q 438 1376 458 1374 q 395 1378 418 1378 l 400 1434 q 486 1427 449 1434 q 548 1407 524 1419 q 586 1376 573 1394 q 599 1336 599 1358 q 584 1293 599 1310 q 547 1269 570 1277 q 498 1257 524 1261 l 497 1215 z "},"ẳ":{"ha":755,"x_min":74,"x_max":680,"o":"m 528 125 l 528 503 q 511 579 528 547 q 459 629 494 611 q 374 646 425 646 q 291 630 326 646 q 235 587 255 614 q 215 530 215 561 l 90 530 q 110 608 90 570 q 169 679 130 647 q 261 729 207 710 q 381 747 315 747 q 523 720 461 747 q 619 638 584 693 q 654 502 654 584 l 654 160 q 660 82 654 123 q 680 11 667 41 l 680 0 l 549 0 q 534 58 539 22 q 528 125 528 94 m 550 445 l 551 357 l 425 357 q 329 348 371 357 q 258 323 287 340 q 215 280 230 306 q 200 221 200 255 q 216 158 200 186 q 263 113 231 130 q 340 96 294 96 q 442 121 398 96 q 512 180 486 145 q 541 249 538 216 l 594 189 q 568 125 589 160 q 512 59 547 91 q 430 7 477 28 q 322 -14 382 -14 q 192 16 248 -14 q 105 94 136 45 q 74 204 74 143 q 97 308 74 263 q 163 384 120 353 q 268 429 207 414 q 404 445 329 445 l 550 445 m 486 992 l 585 992 q 561 919 585 951 q 493 869 537 887 q 387 851 449 851 q 281 869 326 851 q 213 919 237 887 q 189 992 189 951 l 288 992 q 311 938 288 961 q 387 914 334 914 q 463 938 440 914 q 486 992 486 961 m 436 1004 l 349 1004 l 349 1088 q 402 1094 382 1090 q 433 1106 423 1098 q 444 1127 444 1114 q 435 1146 444 1138 q 412 1158 427 1154 q 377 1165 397 1163 q 334 1167 357 1167 l 339 1223 q 425 1216 388 1223 q 487 1196 463 1208 q 525 1165 512 1183 q 538 1125 538 1147 q 523 1082 538 1099 q 486 1058 509 1066 q 437 1046 463 1050 l 436 1004 z "},"Ẵ":{"ha":906,"x_min":20,"x_max":888,"o":"m 480 900 l 153 0 l 20 0 l 396 987 l 482 987 l 480 900 m 754 0 l 427 900 l 425 987 l 511 987 l 888 0 l 754 0 m 737 366 l 737 258 l 182 258 l 182 366 l 737 366 m 550 1207 l 652 1207 q 627 1132 652 1165 q 558 1081 603 1099 q 451 1063 513 1063 q 345 1081 389 1063 q 275 1132 300 1099 q 251 1207 251 1165 l 352 1207 q 374 1152 352 1176 q 451 1127 397 1127 q 528 1152 505 1127 q 550 1207 550 1176 m 589 1404 l 646 1388 q 631 1327 646 1355 q 591 1283 616 1299 q 533 1266 566 1266 q 474 1279 496 1266 q 433 1305 452 1292 q 383 1318 413 1318 q 344 1300 360 1318 q 328 1257 328 1283 l 271 1272 q 285 1332 271 1304 q 325 1378 299 1360 q 383 1395 350 1395 q 437 1382 414 1395 q 482 1357 460 1369 q 533 1344 504 1344 q 572 1361 555 1344 q 589 1404 589 1379 z "},"ẵ":{"ha":755,"x_min":74,"x_max":680,"o":"m 528 125 l 528 503 q 511 579 528 547 q 459 629 494 611 q 374 646 425 646 q 291 630 326 646 q 235 587 255 614 q 215 530 215 561 l 90 530 q 110 608 90 570 q 169 679 130 647 q 261 729 207 710 q 381 747 315 747 q 523 720 461 747 q 619 638 584 693 q 654 502 654 584 l 654 160 q 660 82 654 123 q 680 11 667 41 l 680 0 l 549 0 q 534 58 539 22 q 528 125 528 94 m 550 445 l 551 357 l 425 357 q 329 348 371 357 q 258 323 287 340 q 215 280 230 306 q 200 221 200 255 q 216 158 200 186 q 263 113 231 130 q 340 96 294 96 q 442 121 398 96 q 512 180 486 145 q 541 249 538 216 l 594 189 q 568 125 589 160 q 512 59 547 91 q 430 7 477 28 q 322 -14 382 -14 q 192 16 248 -14 q 105 94 136 45 q 74 204 74 143 q 97 308 74 263 q 163 384 120 353 q 268 429 207 414 q 404 445 329 445 l 550 445 m 489 996 l 591 996 q 566 921 591 954 q 497 870 542 888 q 390 852 452 852 q 283 870 328 852 q 214 921 239 888 q 190 996 190 954 l 291 996 q 313 941 291 965 q 390 916 336 916 q 467 941 444 916 q 489 996 489 965 m 528 1193 l 585 1177 q 570 1116 585 1144 q 530 1072 555 1088 q 472 1055 505 1055 q 413 1068 435 1055 q 372 1094 391 1081 q 322 1107 352 1107 q 283 1089 299 1107 q 267 1046 267 1072 l 210 1061 q 224 1121 210 1093 q 263 1167 238 1149 q 322 1184 289 1184 q 376 1171 353 1184 q 421 1146 399 1158 q 472 1133 443 1133 q 511 1151 494 1133 q 528 1193 528 1168 z "},"Ặ":{"ha":906,"x_min":20,"x_max":888,"o":"m 480 900 l 153 0 l 20 0 l 396 987 l 482 987 l 480 900 m 754 0 l 427 900 l 425 987 l 511 987 l 888 0 l 754 0 m 737 366 l 737 258 l 182 258 l 182 366 l 737 366 m 557 1225 l 659 1225 q 634 1131 659 1172 q 564 1067 610 1090 q 456 1044 519 1044 q 308 1094 362 1044 q 253 1225 253 1145 l 355 1225 q 378 1154 355 1185 q 456 1124 401 1124 q 534 1154 511 1124 q 557 1225 557 1185 m 387 -167 q 406 -115 387 -136 q 461 -94 425 -94 q 516 -115 497 -94 q 536 -167 536 -136 q 516 -217 536 -196 q 461 -237 497 -237 q 406 -217 425 -237 q 387 -167 387 -196 z "},"ặ":{"ha":755,"x_min":74,"x_max":680,"o":"m 528 125 l 528 503 q 511 579 528 547 q 459 629 494 611 q 374 646 425 646 q 291 630 326 646 q 235 587 255 614 q 215 530 215 561 l 90 530 q 110 608 90 570 q 169 679 130 647 q 261 729 207 710 q 381 747 315 747 q 523 720 461 747 q 619 638 584 693 q 654 502 654 584 l 654 160 q 660 82 654 123 q 680 11 667 41 l 680 0 l 549 0 q 534 58 539 22 q 528 125 528 94 m 550 445 l 551 357 l 425 357 q 329 348 371 357 q 258 323 287 340 q 215 280 230 306 q 200 221 200 255 q 216 158 200 186 q 263 113 231 130 q 340 96 294 96 q 442 121 398 96 q 512 180 486 145 q 541 249 538 216 l 594 189 q 568 125 589 160 q 512 59 547 91 q 430 7 477 28 q 322 -14 382 -14 q 192 16 248 -14 q 105 94 136 45 q 74 204 74 143 q 97 308 74 263 q 163 384 120 353 q 268 429 207 414 q 404 445 329 445 l 550 445 m 496 1014 l 597 1014 q 573 920 597 961 q 503 856 549 879 q 395 833 458 833 q 247 883 301 833 q 192 1014 192 934 l 294 1014 q 317 943 294 974 q 395 913 340 913 q 473 943 450 913 q 496 1014 496 974 m 262 -167 q 281 -115 262 -136 q 336 -94 300 -94 q 392 -115 372 -94 q 411 -167 411 -136 q 392 -217 411 -196 q 336 -237 372 -237 q 281 -217 300 -237 q 262 -167 262 -196 z "},"Ẹ":{"ha":789,"x_min":115,"x_max":742,"o":"m 742 106 l 742 0 l 219 0 l 219 106 l 742 106 m 245 987 l 245 0 l 115 0 l 115 987 l 245 987 m 673 563 l 673 456 l 219 456 l 219 563 l 673 563 m 735 987 l 735 880 l 219 880 l 219 987 l 735 987 m 342 -160 q 360 -109 342 -130 q 416 -87 379 -87 q 471 -109 452 -87 q 490 -160 490 -130 q 471 -210 490 -189 q 416 -231 452 -231 q 360 -210 379 -231 q 342 -160 342 -189 z "},"ẹ":{"ha":736,"x_min":63,"x_max":686,"o":"m 400 -14 q 261 13 323 -14 q 155 86 199 39 q 87 199 111 134 q 63 341 63 264 l 63 370 q 90 529 63 459 q 161 648 116 600 q 264 722 207 697 q 384 747 322 747 q 520 720 463 747 q 614 645 577 693 q 668 531 650 596 q 686 388 686 465 l 686 332 l 138 332 l 138 434 l 560 434 l 560 444 q 540 538 557 492 q 486 614 523 585 q 384 644 448 644 q 305 626 341 644 q 243 573 269 608 q 203 487 218 538 q 189 370 189 436 l 189 341 q 204 243 189 289 q 247 163 218 197 q 315 109 275 128 q 407 89 355 89 q 519 116 473 89 q 600 189 566 143 l 676 128 q 616 60 652 92 q 526 7 579 27 q 400 -14 473 -14 m 307 -167 q 326 -115 307 -136 q 381 -94 345 -94 q 436 -115 417 -94 q 456 -167 456 -136 q 436 -217 456 -196 q 381 -237 417 -237 q 326 -217 345 -237 q 307 -167 307 -196 z "},"Ẻ":{"ha":789,"x_min":115,"x_max":742,"o":"m 742 106 l 742 0 l 219 0 l 219 106 l 742 106 m 245 987 l 245 0 l 115 0 l 115 987 l 245 987 m 673 563 l 673 456 l 219 456 l 219 563 l 673 563 m 735 987 l 735 880 l 219 880 l 219 987 l 735 987 m 467 1072 l 377 1072 l 376 1175 q 433 1182 411 1177 q 465 1197 454 1187 q 475 1225 475 1208 q 466 1250 475 1240 q 441 1266 457 1259 q 406 1275 426 1272 q 362 1278 385 1278 l 367 1350 q 455 1341 417 1350 q 520 1315 494 1332 q 559 1275 546 1298 q 572 1223 572 1251 q 540 1148 572 1171 q 468 1119 507 1124 l 467 1072 z "},"ẻ":{"ha":736,"x_min":63,"x_max":686,"o":"m 400 -14 q 261 13 323 -14 q 155 86 199 39 q 87 199 111 134 q 63 341 63 264 l 63 370 q 90 529 63 459 q 161 648 116 600 q 264 722 207 697 q 384 747 322 747 q 520 720 463 747 q 614 645 577 693 q 668 531 650 596 q 686 388 686 465 l 686 332 l 138 332 l 138 434 l 560 434 l 560 444 q 540 538 557 492 q 486 614 523 585 q 384 644 448 644 q 305 626 341 644 q 243 573 269 608 q 203 487 218 538 q 189 370 189 436 l 189 341 q 204 243 189 289 q 247 163 218 197 q 315 109 275 128 q 407 89 355 89 q 519 116 473 89 q 600 189 566 143 l 676 128 q 616 60 652 92 q 526 7 579 27 q 400 -14 473 -14 m 431 853 l 340 853 l 340 956 q 396 963 374 958 q 428 979 418 968 q 438 1007 438 989 q 429 1031 438 1021 q 405 1047 420 1041 q 369 1057 389 1054 q 326 1059 349 1059 l 330 1131 q 419 1122 380 1131 q 483 1097 457 1114 q 523 1056 509 1080 q 536 1004 536 1033 q 503 929 536 953 q 431 901 471 906 l 431 853 z "},"Ẽ":{"ha":789,"x_min":115,"x_max":742,"o":"m 742 106 l 742 0 l 219 0 l 219 106 l 742 106 m 245 987 l 245 0 l 115 0 l 115 987 l 245 987 m 673 563 l 673 456 l 219 456 l 219 563 l 673 563 m 735 987 l 735 880 l 219 880 l 219 987 l 735 987 m 576 1246 l 661 1239 q 641 1152 661 1190 q 588 1095 621 1115 q 514 1074 555 1074 q 457 1084 479 1074 q 417 1106 435 1094 q 380 1129 399 1119 q 332 1139 361 1139 q 284 1117 304 1139 q 265 1063 265 1095 l 180 1067 q 200 1155 180 1117 q 252 1214 219 1192 q 326 1235 286 1235 q 377 1225 355 1235 q 419 1203 399 1215 q 460 1180 439 1190 q 508 1171 481 1171 q 556 1193 536 1171 q 576 1246 576 1215 z "},"ẽ":{"ha":736,"x_min":63,"x_max":686,"o":"m 400 -14 q 261 13 323 -14 q 155 86 199 39 q 87 199 111 134 q 63 341 63 264 l 63 370 q 90 529 63 459 q 161 648 116 600 q 264 722 207 697 q 384 747 322 747 q 520 720 463 747 q 614 645 577 693 q 668 531 650 596 q 686 388 686 465 l 686 332 l 138 332 l 138 434 l 560 434 l 560 444 q 540 538 557 492 q 486 614 523 585 q 384 644 448 644 q 305 626 341 644 q 243 573 269 608 q 203 487 218 538 q 189 370 189 436 l 189 341 q 204 243 189 289 q 247 163 218 197 q 315 109 275 128 q 407 89 355 89 q 519 116 473 89 q 600 189 566 143 l 676 128 q 616 60 652 92 q 526 7 579 27 q 400 -14 473 -14 m 539 1028 l 624 1021 q 604 934 624 971 q 552 876 585 897 q 477 856 519 856 q 420 866 443 856 q 380 888 398 876 q 343 910 363 901 q 296 920 324 920 q 248 899 267 920 q 229 845 229 877 l 144 849 q 163 936 144 899 q 216 995 182 974 q 290 1017 249 1017 q 341 1007 319 1017 q 382 984 363 997 q 423 962 402 972 q 471 952 444 952 q 519 974 500 952 q 539 1028 539 996 z "},"Ế":{"ha":789,"x_min":115,"x_max":850,"o":"m 742 106 l 742 0 l 219 0 l 219 106 l 742 106 m 245 987 l 245 0 l 115 0 l 115 987 l 245 987 m 673 563 l 673 456 l 219 456 l 219 563 l 673 563 m 735 987 l 735 880 l 219 880 l 219 987 l 735 987 m 171 1061 l 368 1238 l 471 1238 l 669 1061 l 535 1061 l 420 1168 l 304 1061 l 171 1061 m 618 1181 l 714 1356 l 850 1356 l 713 1181 l 618 1181 z "},"ế":{"ha":736,"x_min":63,"x_max":813,"o":"m 400 -14 q 261 13 323 -14 q 155 86 199 39 q 87 199 111 134 q 63 341 63 264 l 63 370 q 90 529 63 459 q 161 648 116 600 q 264 722 207 697 q 384 747 322 747 q 520 720 463 747 q 614 645 577 693 q 668 531 650 596 q 686 388 686 465 l 686 332 l 138 332 l 138 434 l 560 434 l 560 444 q 540 538 557 492 q 486 614 523 585 q 384 644 448 644 q 305 626 341 644 q 243 573 269 608 q 203 487 218 538 q 189 370 189 436 l 189 341 q 204 243 189 289 q 247 163 218 197 q 315 109 275 128 q 407 89 355 89 q 519 116 473 89 q 600 189 566 143 l 676 128 q 616 60 652 92 q 526 7 579 27 q 400 -14 473 -14 m 134 842 l 332 1020 l 435 1020 l 632 842 l 498 842 l 383 949 l 268 842 l 134 842 m 582 962 l 677 1137 l 813 1137 l 677 962 l 582 962 z "},"Ề":{"ha":789,"x_min":-12,"x_max":742,"o":"m 742 106 l 742 0 l 219 0 l 219 106 l 742 106 m 245 987 l 245 0 l 115 0 l 115 987 l 245 987 m 673 563 l 673 456 l 219 456 l 219 563 l 673 563 m 735 987 l 735 880 l 219 880 l 219 987 l 735 987 m 469 1236 l 667 1057 l 533 1057 l 418 1165 l 303 1057 l 170 1057 l 366 1236 l 469 1236 m 123 1353 l 220 1178 l 124 1178 l -12 1353 l 123 1353 z "},"ề":{"ha":736,"x_min":-49,"x_max":686,"o":"m 400 -14 q 261 13 323 -14 q 155 86 199 39 q 87 199 111 134 q 63 341 63 264 l 63 370 q 90 529 63 459 q 161 648 116 600 q 264 722 207 697 q 384 747 322 747 q 520 720 463 747 q 614 645 577 693 q 668 531 650 596 q 686 388 686 465 l 686 332 l 138 332 l 138 434 l 560 434 l 560 444 q 540 538 557 492 q 486 614 523 585 q 384 644 448 644 q 305 626 341 644 q 243 573 269 608 q 203 487 218 538 q 189 370 189 436 l 189 341 q 204 243 189 289 q 247 163 218 197 q 315 109 275 128 q 407 89 355 89 q 519 116 473 89 q 600 189 566 143 l 676 128 q 616 60 652 92 q 526 7 579 27 q 400 -14 473 -14 m 433 1017 l 631 839 l 496 839 l 381 947 l 267 839 l 133 839 l 330 1017 l 433 1017 m 87 1135 l 183 960 l 87 960 l -49 1135 l 87 1135 z "},"Ể":{"ha":789,"x_min":115,"x_max":781,"o":"m 742 106 l 742 0 l 219 0 l 219 106 l 742 106 m 245 987 l 245 0 l 115 0 l 115 987 l 245 987 m 673 563 l 673 456 l 219 456 l 219 563 l 673 563 m 735 987 l 735 880 l 219 880 l 219 987 l 735 987 m 482 1227 l 668 1049 l 552 1049 l 418 1175 l 286 1049 l 170 1049 l 355 1227 l 482 1227 m 689 1143 l 611 1143 l 610 1232 q 659 1238 640 1234 q 686 1251 677 1242 q 694 1274 694 1259 q 682 1301 694 1291 q 647 1315 669 1311 q 599 1320 625 1320 l 603 1383 q 679 1375 646 1383 q 735 1353 712 1367 q 769 1318 758 1338 q 781 1273 781 1298 q 752 1209 781 1229 q 690 1184 724 1189 l 689 1143 z "},"ể":{"ha":736,"x_min":63,"x_max":744,"o":"m 400 -14 q 261 13 323 -14 q 155 86 199 39 q 87 199 111 134 q 63 341 63 264 l 63 370 q 90 529 63 459 q 161 648 116 600 q 264 722 207 697 q 384 747 322 747 q 520 720 463 747 q 614 645 577 693 q 668 531 650 596 q 686 388 686 465 l 686 332 l 138 332 l 138 434 l 560 434 l 560 444 q 540 538 557 492 q 486 614 523 585 q 384 644 448 644 q 305 626 341 644 q 243 573 269 608 q 203 487 218 538 q 189 370 189 436 l 189 341 q 204 243 189 289 q 247 163 218 197 q 315 109 275 128 q 407 89 355 89 q 519 116 473 89 q 600 189 566 143 l 676 128 q 616 60 652 92 q 526 7 579 27 q 400 -14 473 -14 m 446 1009 l 631 831 l 515 831 l 382 957 l 249 831 l 134 831 l 318 1009 l 446 1009 m 652 924 l 574 924 l 574 1014 q 622 1020 604 1016 q 649 1033 640 1024 q 658 1056 658 1041 q 645 1083 658 1073 q 610 1097 632 1093 q 562 1101 589 1101 l 566 1164 q 643 1157 610 1164 q 698 1134 675 1149 q 732 1100 721 1120 q 744 1055 744 1080 q 716 990 744 1010 q 653 966 688 970 l 652 924 z "},"Ễ":{"ha":789,"x_min":115,"x_max":742,"o":"m 742 106 l 742 0 l 219 0 l 219 106 l 742 106 m 245 987 l 245 0 l 115 0 l 115 987 l 245 987 m 673 563 l 673 456 l 219 456 l 219 563 l 673 563 m 735 987 l 735 880 l 219 880 l 219 987 l 735 987 m 463 1200 l 668 1034 l 552 1034 l 418 1141 l 286 1034 l 170 1034 l 374 1200 l 463 1200 m 543 1371 l 595 1356 q 581 1304 595 1329 q 542 1264 566 1280 q 487 1249 517 1249 q 433 1261 453 1249 q 394 1286 412 1274 q 349 1298 376 1298 q 310 1282 328 1298 q 292 1247 292 1266 l 240 1260 q 255 1312 240 1287 q 294 1353 269 1337 q 349 1369 319 1369 q 398 1357 377 1369 q 440 1333 419 1345 q 487 1321 460 1321 q 526 1336 508 1321 q 543 1371 543 1352 z "},"ễ":{"ha":736,"x_min":63,"x_max":686,"o":"m 400 -14 q 261 13 323 -14 q 155 86 199 39 q 87 199 111 134 q 63 341 63 264 l 63 370 q 90 529 63 459 q 161 648 116 600 q 264 722 207 697 q 384 747 322 747 q 520 720 463 747 q 614 645 577 693 q 668 531 650 596 q 686 388 686 465 l 686 332 l 138 332 l 138 434 l 560 434 l 560 444 q 540 538 557 492 q 486 614 523 585 q 384 644 448 644 q 305 626 341 644 q 243 573 269 608 q 203 487 218 538 q 189 370 189 436 l 189 341 q 204 243 189 289 q 247 163 218 197 q 315 109 275 128 q 407 89 355 89 q 519 116 473 89 q 600 189 566 143 l 676 128 q 616 60 652 92 q 526 7 579 27 q 400 -14 473 -14 m 427 981 l 631 816 l 515 816 l 382 923 l 249 816 l 134 816 l 338 981 l 427 981 m 507 1152 l 559 1137 q 544 1086 559 1110 q 505 1046 530 1061 q 450 1031 481 1031 q 396 1043 416 1031 q 358 1067 376 1055 q 312 1080 340 1080 q 273 1064 291 1080 q 256 1029 256 1048 l 203 1042 q 218 1094 203 1069 q 257 1134 233 1118 q 312 1150 282 1150 q 361 1138 340 1150 q 403 1115 382 1126 q 450 1103 424 1103 q 489 1118 471 1103 q 507 1152 507 1133 z "},"Ệ":{"ha":789,"x_min":115,"x_max":742,"o":"m 742 106 l 742 0 l 219 0 l 219 106 l 742 106 m 245 987 l 245 0 l 115 0 l 115 987 l 245 987 m 673 563 l 673 456 l 219 456 l 219 563 l 673 563 m 735 987 l 735 880 l 219 880 l 219 987 l 735 987 m 458 1260 l 626 1075 l 626 1068 l 522 1068 l 420 1183 l 319 1068 l 216 1068 l 216 1076 l 382 1260 l 458 1260 m 342 -160 q 360 -109 342 -130 q 416 -87 379 -87 q 471 -109 452 -87 q 490 -160 490 -130 q 471 -210 490 -189 q 416 -231 452 -231 q 360 -210 379 -231 q 342 -160 342 -189 z "},"ệ":{"ha":736,"x_min":63,"x_max":686,"o":"m 400 -14 q 261 13 323 -14 q 155 86 199 39 q 87 199 111 134 q 63 341 63 264 l 63 370 q 90 529 63 459 q 161 648 116 600 q 264 722 207 697 q 384 747 322 747 q 520 720 463 747 q 614 645 577 693 q 668 531 650 596 q 686 388 686 465 l 686 332 l 138 332 l 138 434 l 560 434 l 560 444 q 540 538 557 492 q 486 614 523 585 q 384 644 448 644 q 305 626 341 644 q 243 573 269 608 q 203 487 218 538 q 189 370 189 436 l 189 341 q 204 243 189 289 q 247 163 218 197 q 315 109 275 128 q 407 89 355 89 q 519 116 473 89 q 600 189 566 143 l 676 128 q 616 60 652 92 q 526 7 579 27 q 400 -14 473 -14 m 421 1042 l 589 857 l 589 850 l 485 850 l 383 964 l 282 850 l 179 850 l 179 857 l 345 1042 l 421 1042 m 307 -167 q 326 -115 307 -136 q 381 -94 345 -94 q 436 -115 417 -94 q 456 -167 456 -136 q 436 -217 456 -196 q 381 -237 417 -237 q 326 -217 345 -237 q 307 -167 307 -196 z "},"Ỉ":{"ha":378,"x_min":124,"x_max":342,"o":"m 255 987 l 255 0 l 124 0 l 124 987 l 255 987 m 237 1072 l 146 1072 l 146 1175 q 202 1182 180 1177 q 234 1197 224 1187 q 244 1225 244 1208 q 235 1250 244 1240 q 211 1266 227 1259 q 175 1275 195 1272 q 132 1278 155 1278 l 136 1350 q 225 1341 186 1350 q 289 1315 263 1332 q 329 1275 315 1298 q 342 1223 342 1251 q 309 1148 342 1171 q 237 1119 277 1124 l 237 1072 z "},"ỉ":{"ha":344,"x_min":106,"x_max":323,"o":"m 231 734 l 231 0 l 106 0 l 106 734 l 231 734 m 218 852 l 128 852 l 127 955 q 184 962 162 957 q 216 978 205 967 q 226 1006 226 988 q 217 1030 226 1020 q 193 1046 208 1040 q 157 1055 177 1053 q 113 1058 136 1058 l 118 1130 q 207 1121 168 1130 q 271 1095 245 1112 q 310 1055 297 1078 q 323 1003 323 1031 q 291 928 323 951 q 219 899 258 905 l 218 852 z "},"Ị":{"ha":378,"x_min":111,"x_max":260,"o":"m 255 987 l 255 0 l 124 0 l 124 987 l 255 987 m 111 -161 q 130 -109 111 -130 q 185 -88 149 -88 q 240 -109 221 -88 q 260 -161 260 -130 q 240 -211 260 -190 q 185 -231 221 -231 q 130 -211 149 -231 q 111 -161 111 -190 z "},"ị":{"ha":338,"x_min":91,"x_max":245,"o":"m 232 734 l 232 0 l 106 0 l 106 734 l 232 734 m 96 928 q 115 980 96 959 q 170 1001 134 1001 q 225 980 206 1001 q 245 928 245 959 q 225 879 245 899 q 170 858 206 858 q 115 879 134 858 q 96 928 96 899 m 91 -160 q 110 -109 91 -130 q 165 -87 128 -87 q 220 -109 201 -87 q 239 -160 239 -130 q 220 -210 239 -189 q 165 -231 201 -231 q 110 -210 128 -231 q 91 -160 91 -189 z "},"Ọ":{"ha":956,"x_min":81,"x_max":875,"o":"m 875 525 l 875 463 q 847 263 875 351 q 767 113 819 175 q 642 19 715 52 q 479 -14 569 -14 q 318 19 391 -14 q 192 113 245 52 q 110 263 139 175 q 81 463 81 351 l 81 525 q 110 724 81 636 q 191 874 138 812 q 317 968 244 936 q 477 1001 390 1001 q 641 968 568 1001 q 766 874 713 936 q 847 724 819 812 q 875 525 875 636 m 745 463 l 745 526 q 727 682 745 614 q 675 796 709 750 q 590 866 640 842 q 477 890 541 890 q 367 866 416 890 q 283 796 318 842 q 229 682 248 750 q 210 526 210 614 l 210 463 q 229 306 210 374 q 284 191 248 237 q 369 121 319 144 q 479 97 418 97 q 592 121 543 97 q 676 191 642 144 q 728 306 710 237 q 745 463 745 374 m 401 -167 q 420 -115 401 -136 q 475 -94 439 -94 q 531 -115 511 -94 q 550 -167 550 -136 q 531 -217 550 -196 q 475 -237 511 -237 q 420 -217 439 -237 q 401 -167 401 -196 z "},"ọ":{"ha":792,"x_min":62,"x_max":730,"o":"m 62 359 l 62 374 q 85 522 62 454 q 152 641 109 590 q 257 719 195 691 q 395 747 319 747 q 535 719 473 747 q 641 641 597 691 q 707 522 684 590 q 730 374 730 454 l 730 359 q 707 212 730 279 q 641 93 684 144 q 535 15 597 43 q 397 -14 474 -14 q 258 15 319 -14 q 152 93 196 43 q 85 212 109 144 q 62 359 62 279 m 188 374 l 188 359 q 201 255 188 304 q 240 170 214 207 q 305 111 266 132 q 397 90 345 90 q 487 111 448 90 q 552 170 526 132 q 591 255 578 207 q 604 359 604 304 l 604 374 q 591 477 604 429 q 552 563 578 526 q 487 623 526 601 q 395 644 448 644 q 305 623 344 644 q 240 563 266 601 q 201 477 214 526 q 188 374 188 429 m 318 -168 q 337 -116 318 -137 q 392 -95 355 -95 q 447 -116 428 -95 q 467 -168 467 -137 q 447 -217 467 -197 q 392 -238 428 -238 q 337 -217 355 -238 q 318 -168 318 -197 z "},"Ỏ":{"ha":956,"x_min":81,"x_max":875,"o":"m 875 525 l 875 463 q 847 263 875 351 q 767 113 819 175 q 642 19 715 52 q 479 -14 569 -14 q 318 19 391 -14 q 192 113 245 52 q 110 263 139 175 q 81 463 81 351 l 81 525 q 110 724 81 636 q 191 874 138 812 q 317 968 244 936 q 477 1001 390 1001 q 641 968 568 1001 q 766 874 713 936 q 847 724 819 812 q 875 525 875 636 m 745 463 l 745 526 q 727 682 745 614 q 675 796 709 750 q 590 866 640 842 q 477 890 541 890 q 367 866 416 890 q 283 796 318 842 q 229 682 248 750 q 210 526 210 614 l 210 463 q 229 306 210 374 q 284 191 248 237 q 369 121 319 144 q 479 97 418 97 q 592 121 543 97 q 676 191 642 144 q 728 306 710 237 q 745 463 745 374 m 527 1065 l 437 1065 l 436 1168 q 492 1176 471 1171 q 524 1191 514 1181 q 534 1219 534 1202 q 526 1243 534 1234 q 501 1260 517 1253 q 465 1269 486 1266 q 422 1272 445 1272 l 427 1343 q 515 1335 477 1343 q 579 1309 553 1326 q 619 1269 606 1292 q 632 1217 632 1245 q 600 1142 632 1165 q 528 1113 567 1118 l 527 1065 z "},"ỏ":{"ha":792,"x_min":62,"x_max":730,"o":"m 62 359 l 62 374 q 85 522 62 454 q 152 641 109 590 q 257 719 195 691 q 395 747 319 747 q 535 719 473 747 q 641 641 597 691 q 707 522 684 590 q 730 374 730 454 l 730 359 q 707 212 730 279 q 641 93 684 144 q 535 15 597 43 q 397 -14 474 -14 q 258 15 319 -14 q 152 93 196 43 q 85 212 109 144 q 62 359 62 279 m 188 374 l 188 359 q 201 255 188 304 q 240 170 214 207 q 305 111 266 132 q 397 90 345 90 q 487 111 448 90 q 552 170 526 132 q 591 255 578 207 q 604 359 604 304 l 604 374 q 591 477 604 429 q 552 563 578 526 q 487 623 526 601 q 395 644 448 644 q 305 623 344 644 q 240 563 266 601 q 201 477 214 526 q 188 374 188 429 m 437 853 l 347 853 l 347 956 q 403 963 381 958 q 435 979 425 968 q 445 1007 445 989 q 436 1031 445 1021 q 412 1047 427 1041 q 376 1057 396 1054 q 332 1059 355 1059 l 337 1131 q 426 1122 387 1131 q 490 1097 464 1114 q 529 1056 516 1080 q 543 1004 543 1033 q 510 929 543 953 q 438 901 477 906 l 437 853 z "},"Ố":{"ha":956,"x_min":81,"x_max":909,"o":"m 875 525 l 875 463 q 847 263 875 351 q 767 113 819 175 q 642 19 715 52 q 479 -14 569 -14 q 318 19 391 -14 q 192 113 245 52 q 110 263 139 175 q 81 463 81 351 l 81 525 q 110 724 81 636 q 191 874 138 812 q 317 968 244 936 q 477 1001 390 1001 q 641 968 568 1001 q 766 874 713 936 q 847 724 819 812 q 875 525 875 636 m 745 463 l 745 526 q 727 682 745 614 q 675 796 709 750 q 590 866 640 842 q 477 890 541 890 q 367 866 416 890 q 283 796 318 842 q 229 682 248 750 q 210 526 210 614 l 210 463 q 229 306 210 374 q 284 191 248 237 q 369 121 319 144 q 479 97 418 97 q 592 121 543 97 q 676 191 642 144 q 728 306 710 237 q 745 463 745 374 m 231 1055 l 428 1232 l 531 1232 l 728 1055 l 595 1055 l 479 1162 l 364 1055 l 231 1055 m 678 1175 l 774 1350 l 909 1350 l 773 1175 l 678 1175 z "},"ố":{"ha":792,"x_min":62,"x_max":820,"o":"m 62 359 l 62 374 q 85 522 62 454 q 152 641 109 590 q 257 719 195 691 q 395 747 319 747 q 535 719 473 747 q 641 641 597 691 q 707 522 684 590 q 730 374 730 454 l 730 359 q 707 212 730 279 q 641 93 684 144 q 535 15 597 43 q 397 -14 474 -14 q 258 15 319 -14 q 152 93 196 43 q 85 212 109 144 q 62 359 62 279 m 188 374 l 188 359 q 201 255 188 304 q 240 170 214 207 q 305 111 266 132 q 397 90 345 90 q 487 111 448 90 q 552 170 526 132 q 591 255 578 207 q 604 359 604 304 l 604 374 q 591 477 604 429 q 552 563 578 526 q 487 623 526 601 q 395 644 448 644 q 305 623 344 644 q 240 563 266 601 q 201 477 214 526 q 188 374 188 429 m 141 842 l 338 1020 l 441 1020 l 639 842 l 505 842 l 390 949 l 275 842 l 141 842 m 589 962 l 684 1137 l 820 1137 l 684 962 l 589 962 z "},"Ồ":{"ha":956,"x_min":47,"x_max":875,"o":"m 875 525 l 875 463 q 847 263 875 351 q 767 113 819 175 q 642 19 715 52 q 479 -14 569 -14 q 318 19 391 -14 q 192 113 245 52 q 110 263 139 175 q 81 463 81 351 l 81 525 q 110 724 81 636 q 191 874 138 812 q 317 968 244 936 q 477 1001 390 1001 q 641 968 568 1001 q 766 874 713 936 q 847 724 819 812 q 875 525 875 636 m 745 463 l 745 526 q 727 682 745 614 q 675 796 709 750 q 590 866 640 842 q 477 890 541 890 q 367 866 416 890 q 283 796 318 842 q 229 682 248 750 q 210 526 210 614 l 210 463 q 229 306 210 374 q 284 191 248 237 q 369 121 319 144 q 479 97 418 97 q 592 121 543 97 q 676 191 642 144 q 728 306 710 237 q 745 463 745 374 m 529 1230 l 727 1051 l 593 1051 l 477 1159 l 363 1051 l 229 1051 l 426 1230 l 529 1230 m 183 1347 l 279 1172 l 184 1172 l 47 1347 l 183 1347 z "},"ồ":{"ha":792,"x_min":-42,"x_max":730,"o":"m 62 359 l 62 374 q 85 522 62 454 q 152 641 109 590 q 257 719 195 691 q 395 747 319 747 q 535 719 473 747 q 641 641 597 691 q 707 522 684 590 q 730 374 730 454 l 730 359 q 707 212 730 279 q 641 93 684 144 q 535 15 597 43 q 397 -14 474 -14 q 258 15 319 -14 q 152 93 196 43 q 85 212 109 144 q 62 359 62 279 m 188 374 l 188 359 q 201 255 188 304 q 240 170 214 207 q 305 111 266 132 q 397 90 345 90 q 487 111 448 90 q 552 170 526 132 q 591 255 578 207 q 604 359 604 304 l 604 374 q 591 477 604 429 q 552 563 578 526 q 487 623 526 601 q 395 644 448 644 q 305 623 344 644 q 240 563 266 601 q 201 477 214 526 q 188 374 188 429 m 439 1017 l 637 839 l 503 839 l 388 947 l 273 839 l 140 839 l 336 1017 l 439 1017 m 94 1135 l 190 960 l 94 960 l -42 1135 l 94 1135 z "},"Ổ":{"ha":956,"x_min":81,"x_max":875,"o":"m 875 525 l 875 463 q 847 263 875 351 q 767 113 819 175 q 642 19 715 52 q 479 -14 569 -14 q 318 19 391 -14 q 192 113 245 52 q 110 263 139 175 q 81 463 81 351 l 81 525 q 110 724 81 636 q 191 874 138 812 q 317 968 244 936 q 477 1001 390 1001 q 641 968 568 1001 q 766 874 713 936 q 847 724 819 812 q 875 525 875 636 m 745 463 l 745 526 q 727 682 745 614 q 675 796 709 750 q 590 866 640 842 q 477 890 541 890 q 367 866 416 890 q 283 796 318 842 q 229 682 248 750 q 210 526 210 614 l 210 463 q 229 306 210 374 q 284 191 248 237 q 369 121 319 144 q 479 97 418 97 q 592 121 543 97 q 676 191 642 144 q 728 306 710 237 q 745 463 745 374 m 542 1221 l 728 1043 l 612 1043 l 478 1169 l 345 1043 l 230 1043 l 414 1221 l 542 1221 m 749 1137 l 671 1137 l 670 1226 q 718 1232 700 1228 q 745 1245 736 1236 q 754 1268 754 1253 q 741 1295 754 1285 q 707 1309 728 1305 q 659 1314 685 1314 l 663 1377 q 739 1369 706 1377 q 794 1347 772 1361 q 829 1312 817 1332 q 840 1267 840 1292 q 812 1203 840 1223 q 749 1178 784 1183 l 749 1137 z "},"ổ":{"ha":792,"x_min":62,"x_max":751,"o":"m 62 359 l 62 374 q 85 522 62 454 q 152 641 109 590 q 257 719 195 691 q 395 747 319 747 q 535 719 473 747 q 641 641 597 691 q 707 522 684 590 q 730 374 730 454 l 730 359 q 707 212 730 279 q 641 93 684 144 q 535 15 597 43 q 397 -14 474 -14 q 258 15 319 -14 q 152 93 196 43 q 85 212 109 144 q 62 359 62 279 m 188 374 l 188 359 q 201 255 188 304 q 240 170 214 207 q 305 111 266 132 q 397 90 345 90 q 487 111 448 90 q 552 170 526 132 q 591 255 578 207 q 604 359 604 304 l 604 374 q 591 477 604 429 q 552 563 578 526 q 487 623 526 601 q 395 644 448 644 q 305 623 344 644 q 240 563 266 601 q 201 477 214 526 q 188 374 188 429 m 452 1009 l 638 831 l 522 831 l 389 957 l 256 831 l 140 831 l 325 1009 l 452 1009 m 659 924 l 581 924 l 581 1014 q 629 1020 610 1016 q 656 1033 647 1024 q 665 1056 665 1041 q 652 1083 665 1073 q 617 1097 639 1093 q 569 1101 595 1101 l 573 1164 q 649 1157 616 1164 q 705 1134 682 1149 q 739 1100 728 1120 q 751 1055 751 1080 q 723 990 751 1010 q 660 966 694 970 l 659 924 z "},"Ỗ":{"ha":956,"x_min":81,"x_max":875,"o":"m 875 525 l 875 463 q 847 263 875 351 q 767 113 819 175 q 642 19 715 52 q 479 -14 569 -14 q 318 19 391 -14 q 192 113 245 52 q 110 263 139 175 q 81 463 81 351 l 81 525 q 110 724 81 636 q 191 874 138 812 q 317 968 244 936 q 477 1001 390 1001 q 641 968 568 1001 q 766 874 713 936 q 847 724 819 812 q 875 525 875 636 m 745 463 l 745 526 q 727 682 745 614 q 675 796 709 750 q 590 866 640 842 q 477 890 541 890 q 367 866 416 890 q 283 796 318 842 q 229 682 248 750 q 210 526 210 614 l 210 463 q 229 306 210 374 q 284 191 248 237 q 369 121 319 144 q 479 97 418 97 q 592 121 543 97 q 676 191 642 144 q 728 306 710 237 q 745 463 745 374 m 523 1194 l 728 1028 l 612 1028 l 478 1135 l 345 1028 l 230 1028 l 434 1194 l 523 1194 m 603 1364 l 655 1350 q 641 1298 655 1322 q 602 1258 626 1274 q 547 1243 577 1243 q 492 1255 513 1243 q 454 1280 472 1267 q 408 1292 436 1292 q 370 1276 387 1292 q 352 1241 352 1260 l 300 1254 q 314 1306 300 1281 q 354 1347 329 1331 q 408 1362 378 1362 q 458 1351 437 1362 q 499 1327 479 1339 q 547 1315 520 1315 q 585 1330 568 1315 q 603 1364 603 1345 z "},"ỗ":{"ha":792,"x_min":62,"x_max":730,"o":"m 62 359 l 62 374 q 85 522 62 454 q 152 641 109 590 q 257 719 195 691 q 395 747 319 747 q 535 719 473 747 q 641 641 597 691 q 707 522 684 590 q 730 374 730 454 l 730 359 q 707 212 730 279 q 641 93 684 144 q 535 15 597 43 q 397 -14 474 -14 q 258 15 319 -14 q 152 93 196 43 q 85 212 109 144 q 62 359 62 279 m 188 374 l 188 359 q 201 255 188 304 q 240 170 214 207 q 305 111 266 132 q 397 90 345 90 q 487 111 448 90 q 552 170 526 132 q 591 255 578 207 q 604 359 604 304 l 604 374 q 591 477 604 429 q 552 563 578 526 q 487 623 526 601 q 395 644 448 644 q 305 623 344 644 q 240 563 266 601 q 201 477 214 526 q 188 374 188 429 m 433 981 l 638 816 l 522 816 l 389 923 l 256 816 l 140 816 l 345 981 l 433 981 m 513 1152 l 566 1137 q 551 1086 566 1110 q 512 1046 536 1061 q 457 1031 488 1031 q 403 1043 423 1031 q 365 1067 382 1055 q 319 1080 347 1080 q 280 1064 298 1080 q 262 1029 262 1048 l 210 1042 q 225 1094 210 1069 q 264 1134 239 1118 q 319 1150 289 1150 q 368 1138 347 1150 q 410 1115 389 1126 q 457 1103 431 1103 q 496 1118 478 1103 q 513 1152 513 1133 z "},"Ộ":{"ha":956,"x_min":81,"x_max":875,"o":"m 875 525 l 875 463 q 847 263 875 351 q 767 113 819 175 q 642 19 715 52 q 479 -14 569 -14 q 318 19 391 -14 q 192 113 245 52 q 110 263 139 175 q 81 463 81 351 l 81 525 q 110 724 81 636 q 191 874 138 812 q 317 968 244 936 q 477 1001 390 1001 q 641 968 568 1001 q 766 874 713 936 q 847 724 819 812 q 875 525 875 636 m 745 463 l 745 526 q 727 682 745 614 q 675 796 709 750 q 590 866 640 842 q 477 890 541 890 q 367 866 416 890 q 283 796 318 842 q 229 682 248 750 q 210 526 210 614 l 210 463 q 229 306 210 374 q 284 191 248 237 q 369 121 319 144 q 479 97 418 97 q 592 121 543 97 q 676 191 642 144 q 728 306 710 237 q 745 463 745 374 m 517 1254 l 686 1069 l 686 1062 l 581 1062 l 479 1177 l 378 1062 l 275 1062 l 275 1069 l 441 1254 l 517 1254 m 401 -167 q 420 -115 401 -136 q 475 -94 439 -94 q 531 -115 511 -94 q 550 -167 550 -136 q 531 -217 550 -196 q 475 -237 511 -237 q 420 -217 439 -237 q 401 -167 401 -196 z "},"ộ":{"ha":792,"x_min":62,"x_max":730,"o":"m 62 359 l 62 374 q 85 522 62 454 q 152 641 109 590 q 257 719 195 691 q 395 747 319 747 q 535 719 473 747 q 641 641 597 691 q 707 522 684 590 q 730 374 730 454 l 730 359 q 707 212 730 279 q 641 93 684 144 q 535 15 597 43 q 397 -14 474 -14 q 258 15 319 -14 q 152 93 196 43 q 85 212 109 144 q 62 359 62 279 m 188 374 l 188 359 q 201 255 188 304 q 240 170 214 207 q 305 111 266 132 q 397 90 345 90 q 487 111 448 90 q 552 170 526 132 q 591 255 578 207 q 604 359 604 304 l 604 374 q 591 477 604 429 q 552 563 578 526 q 487 623 526 601 q 395 644 448 644 q 305 623 344 644 q 240 563 266 601 q 201 477 214 526 q 188 374 188 429 m 428 1042 l 596 857 l 596 850 l 492 850 l 390 964 l 289 850 l 186 850 l 186 857 l 352 1042 l 428 1042 m 318 -168 q 337 -116 318 -137 q 392 -95 355 -95 q 447 -116 428 -95 q 467 -168 467 -137 q 447 -217 467 -197 q 392 -238 428 -238 q 337 -217 355 -238 q 318 -168 318 -197 z "},"Ớ":{"ha":954,"x_min":69,"x_max":975,"o":"m 861 1080 l 975 1080 q 946 930 975 992 q 860 837 918 869 q 717 804 803 804 l 717 896 q 802 918 770 896 q 847 981 833 939 q 861 1080 861 1022 m 863 525 l 863 463 q 836 263 863 351 q 755 113 808 175 q 630 19 703 52 q 467 -14 557 -14 q 336 7 397 -14 q 226 69 275 28 q 142 167 177 109 q 88 299 106 225 q 69 463 69 374 l 69 525 q 98 724 69 636 q 180 874 127 812 q 306 968 233 936 q 466 1001 378 1001 q 600 980 538 1001 q 710 919 661 959 q 793 820 758 878 q 845 688 827 762 q 863 525 863 614 m 734 463 l 734 526 q 722 654 734 597 q 688 755 711 711 q 633 829 666 800 q 559 874 601 859 q 466 890 517 890 q 356 866 406 890 q 272 796 307 842 q 218 682 237 750 q 199 526 199 614 l 199 463 q 211 334 199 391 q 247 232 223 276 q 303 157 270 187 q 377 112 336 127 q 467 97 419 97 q 581 121 531 97 q 664 191 630 144 q 716 306 699 237 q 734 463 734 374 m 408 1049 l 539 1249 l 690 1249 l 509 1049 l 408 1049 z "},"ớ":{"ha":794,"x_min":62,"x_max":821,"o":"m 720 814 l 821 814 q 800 686 821 740 q 732 603 780 632 q 604 574 685 574 l 604 652 q 679 673 654 652 q 712 730 704 693 q 720 814 720 766 m 62 359 l 62 374 q 85 522 62 454 q 152 641 109 590 q 257 719 195 691 q 395 747 319 747 q 535 719 473 747 q 640 641 597 691 q 707 522 684 590 q 730 374 730 454 l 730 359 q 707 212 730 279 q 640 93 684 144 q 535 15 597 43 q 397 -14 474 -14 q 258 15 319 -14 q 152 93 196 43 q 85 212 109 144 q 62 359 62 279 m 188 374 l 188 359 q 201 255 188 304 q 240 170 214 207 q 305 111 266 132 q 397 90 345 90 q 487 111 448 90 q 552 170 526 132 q 591 255 578 207 q 604 359 604 304 l 604 374 q 591 477 604 429 q 552 563 578 526 q 487 623 526 601 q 395 644 448 644 q 305 623 344 644 q 240 563 266 601 q 201 477 214 526 q 188 374 188 429 m 326 842 l 457 1042 l 608 1042 l 427 842 l 326 842 z "},"Ờ":{"ha":954,"x_min":69,"x_max":975,"o":"m 861 1080 l 975 1080 q 946 930 975 992 q 860 837 918 869 q 717 804 803 804 l 717 896 q 802 918 770 896 q 847 981 833 939 q 861 1080 861 1022 m 863 525 l 863 463 q 836 263 863 351 q 755 113 808 175 q 630 19 703 52 q 467 -14 557 -14 q 336 7 397 -14 q 226 69 275 28 q 142 167 177 109 q 88 299 106 225 q 69 463 69 374 l 69 525 q 98 724 69 636 q 180 874 127 812 q 306 968 233 936 q 466 1001 378 1001 q 600 980 538 1001 q 710 919 661 959 q 793 820 758 878 q 845 688 827 762 q 863 525 863 614 m 734 463 l 734 526 q 722 654 734 597 q 688 755 711 711 q 633 829 666 800 q 559 874 601 859 q 466 890 517 890 q 356 866 406 890 q 272 796 307 842 q 218 682 237 750 q 199 526 199 614 l 199 463 q 211 334 199 391 q 247 232 223 276 q 303 157 270 187 q 377 112 336 127 q 467 97 419 97 q 581 121 531 97 q 664 191 630 144 q 716 306 699 237 q 734 463 734 374 m 417 1249 l 548 1049 l 440 1049 l 265 1249 l 417 1249 z "},"ờ":{"ha":794,"x_min":62,"x_max":821,"o":"m 720 814 l 821 814 q 800 686 821 740 q 732 603 780 632 q 604 574 685 574 l 604 652 q 679 673 654 652 q 712 730 704 693 q 720 814 720 766 m 62 359 l 62 374 q 85 522 62 454 q 152 641 109 590 q 257 719 195 691 q 395 747 319 747 q 535 719 473 747 q 640 641 597 691 q 707 522 684 590 q 730 374 730 454 l 730 359 q 707 212 730 279 q 640 93 684 144 q 535 15 597 43 q 397 -14 474 -14 q 258 15 319 -14 q 152 93 196 43 q 85 212 109 144 q 62 359 62 279 m 188 374 l 188 359 q 201 255 188 304 q 240 170 214 207 q 305 111 266 132 q 397 90 345 90 q 487 111 448 90 q 552 170 526 132 q 591 255 578 207 q 604 359 604 304 l 604 374 q 591 477 604 429 q 552 563 578 526 q 487 623 526 601 q 395 644 448 644 q 305 623 344 644 q 240 563 266 601 q 201 477 214 526 q 188 374 188 429 m 335 1042 l 466 842 l 358 842 l 183 1042 l 335 1042 z "},"Ở":{"ha":954,"x_min":69,"x_max":975,"o":"m 861 1080 l 975 1080 q 946 930 975 992 q 860 837 918 869 q 717 804 803 804 l 717 896 q 802 918 770 896 q 847 981 833 939 q 861 1080 861 1022 m 863 525 l 863 463 q 836 263 863 351 q 755 113 808 175 q 630 19 703 52 q 467 -14 557 -14 q 336 7 397 -14 q 226 69 275 28 q 142 167 177 109 q 88 299 106 225 q 69 463 69 374 l 69 525 q 98 724 69 636 q 180 874 127 812 q 306 968 233 936 q 466 1001 378 1001 q 600 980 538 1001 q 710 919 661 959 q 793 820 758 878 q 845 688 827 762 q 863 525 863 614 m 734 463 l 734 526 q 722 654 734 597 q 688 755 711 711 q 633 829 666 800 q 559 874 601 859 q 466 890 517 890 q 356 866 406 890 q 272 796 307 842 q 218 682 237 750 q 199 526 199 614 l 199 463 q 211 334 199 391 q 247 232 223 276 q 303 157 270 187 q 377 112 336 127 q 467 97 419 97 q 581 121 531 97 q 664 191 630 144 q 716 306 699 237 q 734 463 734 374 m 524 1060 l 434 1060 l 433 1163 q 490 1170 468 1165 q 522 1186 511 1175 q 532 1214 532 1196 q 523 1238 532 1228 q 498 1254 514 1248 q 463 1263 483 1261 q 419 1266 442 1266 l 424 1338 q 512 1329 474 1338 q 577 1303 551 1320 q 616 1263 603 1286 q 629 1211 629 1240 q 597 1136 629 1160 q 525 1107 564 1113 l 524 1060 z "},"ở":{"ha":794,"x_min":62,"x_max":821,"o":"m 720 814 l 821 814 q 800 686 821 740 q 732 603 780 632 q 604 574 685 574 l 604 652 q 679 673 654 652 q 712 730 704 693 q 720 814 720 766 m 62 359 l 62 374 q 85 522 62 454 q 152 641 109 590 q 257 719 195 691 q 395 747 319 747 q 535 719 473 747 q 640 641 597 691 q 707 522 684 590 q 730 374 730 454 l 730 359 q 707 212 730 279 q 640 93 684 144 q 535 15 597 43 q 397 -14 474 -14 q 258 15 319 -14 q 152 93 196 43 q 85 212 109 144 q 62 359 62 279 m 188 374 l 188 359 q 201 255 188 304 q 240 170 214 207 q 305 111 266 132 q 397 90 345 90 q 487 111 448 90 q 552 170 526 132 q 591 255 578 207 q 604 359 604 304 l 604 374 q 591 477 604 429 q 552 563 578 526 q 487 623 526 601 q 395 644 448 644 q 305 623 344 644 q 240 563 266 601 q 201 477 214 526 q 188 374 188 429 m 442 853 l 352 853 l 351 956 q 408 963 386 958 q 439 979 429 968 q 450 1007 450 989 q 441 1031 450 1021 q 416 1047 432 1041 q 380 1057 401 1054 q 337 1059 360 1059 l 342 1131 q 430 1122 392 1131 q 495 1097 469 1114 q 534 1056 521 1080 q 547 1004 547 1033 q 515 929 547 953 q 443 901 482 906 l 442 853 z "},"Ỡ":{"ha":954,"x_min":69,"x_max":975,"o":"m 861 1080 l 975 1080 q 946 930 975 992 q 860 837 918 869 q 717 804 803 804 l 717 896 q 802 918 770 896 q 847 981 833 939 q 861 1080 861 1022 m 863 525 l 863 463 q 836 263 863 351 q 755 113 808 175 q 630 19 703 52 q 467 -14 557 -14 q 336 7 397 -14 q 226 69 275 28 q 142 167 177 109 q 88 299 106 225 q 69 463 69 374 l 69 525 q 98 724 69 636 q 180 874 127 812 q 306 968 233 936 q 466 1001 378 1001 q 600 980 538 1001 q 710 919 661 959 q 793 820 758 878 q 845 688 827 762 q 863 525 863 614 m 734 463 l 734 526 q 722 654 734 597 q 688 755 711 711 q 633 829 666 800 q 559 874 601 859 q 466 890 517 890 q 356 866 406 890 q 272 796 307 842 q 218 682 237 750 q 199 526 199 614 l 199 463 q 211 334 199 391 q 247 232 223 276 q 303 157 270 187 q 377 112 336 127 q 467 97 419 97 q 581 121 531 97 q 664 191 630 144 q 716 306 699 237 q 734 463 734 374 m 633 1235 l 718 1227 q 698 1141 718 1178 q 645 1083 678 1103 q 571 1063 612 1063 q 514 1073 536 1063 q 474 1095 492 1082 q 437 1117 456 1107 q 389 1127 418 1127 q 341 1105 361 1127 q 322 1052 322 1084 l 237 1056 q 257 1143 237 1105 q 309 1202 276 1181 q 383 1223 342 1223 q 434 1214 412 1223 q 476 1191 456 1204 q 517 1169 496 1179 q 565 1159 538 1159 q 613 1181 593 1159 q 633 1235 633 1203 z "},"ỡ":{"ha":794,"x_min":62,"x_max":821,"o":"m 720 814 l 821 814 q 800 686 821 740 q 732 603 780 632 q 604 574 685 574 l 604 652 q 679 673 654 652 q 712 730 704 693 q 720 814 720 766 m 62 359 l 62 374 q 85 522 62 454 q 152 641 109 590 q 257 719 195 691 q 395 747 319 747 q 535 719 473 747 q 640 641 597 691 q 707 522 684 590 q 730 374 730 454 l 730 359 q 707 212 730 279 q 640 93 684 144 q 535 15 597 43 q 397 -14 474 -14 q 258 15 319 -14 q 152 93 196 43 q 85 212 109 144 q 62 359 62 279 m 188 374 l 188 359 q 201 255 188 304 q 240 170 214 207 q 305 111 266 132 q 397 90 345 90 q 487 111 448 90 q 552 170 526 132 q 591 255 578 207 q 604 359 604 304 l 604 374 q 591 477 604 429 q 552 563 578 526 q 487 623 526 601 q 395 644 448 644 q 305 623 344 644 q 240 563 266 601 q 201 477 214 526 q 188 374 188 429 m 551 1028 l 635 1021 q 616 934 635 971 q 563 876 596 897 q 489 856 530 856 q 432 866 454 856 q 392 888 410 876 q 355 910 374 901 q 307 920 336 920 q 259 899 279 920 q 240 845 240 877 l 155 849 q 175 936 155 899 q 227 995 194 974 q 301 1017 260 1017 q 352 1007 330 1017 q 394 984 374 997 q 435 962 414 972 q 483 952 456 952 q 531 974 511 952 q 551 1028 551 996 z "},"Ợ":{"ha":954,"x_min":69,"x_max":975,"o":"m 861 1080 l 975 1080 q 946 930 975 992 q 860 837 918 869 q 717 804 803 804 l 717 896 q 802 918 770 896 q 847 981 833 939 q 861 1080 861 1022 m 863 525 l 863 463 q 836 263 863 351 q 755 113 808 175 q 630 19 703 52 q 467 -14 557 -14 q 336 7 397 -14 q 226 69 275 28 q 142 167 177 109 q 88 299 106 225 q 69 463 69 374 l 69 525 q 98 724 69 636 q 180 874 127 812 q 306 968 233 936 q 466 1001 378 1001 q 600 980 538 1001 q 710 919 661 959 q 793 820 758 878 q 845 688 827 762 q 863 525 863 614 m 734 463 l 734 526 q 722 654 734 597 q 688 755 711 711 q 633 829 666 800 q 559 874 601 859 q 466 890 517 890 q 356 866 406 890 q 272 796 307 842 q 218 682 237 750 q 199 526 199 614 l 199 463 q 211 334 199 391 q 247 232 223 276 q 303 157 270 187 q 377 112 336 127 q 467 97 419 97 q 581 121 531 97 q 664 191 630 144 q 716 306 699 237 q 734 463 734 374 m 391 -167 q 410 -115 391 -136 q 465 -94 429 -94 q 520 -115 501 -94 q 540 -167 540 -136 q 520 -217 540 -196 q 465 -237 501 -237 q 410 -217 429 -237 q 391 -167 391 -196 z "},"ợ":{"ha":794,"x_min":62,"x_max":821,"o":"m 720 814 l 821 814 q 800 686 821 740 q 732 603 780 632 q 604 574 685 574 l 604 652 q 679 673 654 652 q 712 730 704 693 q 720 814 720 766 m 62 359 l 62 374 q 85 522 62 454 q 152 641 109 590 q 257 719 195 691 q 395 747 319 747 q 535 719 473 747 q 640 641 597 691 q 707 522 684 590 q 730 374 730 454 l 730 359 q 707 212 730 279 q 640 93 684 144 q 535 15 597 43 q 397 -14 474 -14 q 258 15 319 -14 q 152 93 196 43 q 85 212 109 144 q 62 359 62 279 m 188 374 l 188 359 q 201 255 188 304 q 240 170 214 207 q 305 111 266 132 q 397 90 345 90 q 487 111 448 90 q 552 170 526 132 q 591 255 578 207 q 604 359 604 304 l 604 374 q 591 477 604 429 q 552 563 578 526 q 487 623 526 601 q 395 644 448 644 q 305 623 344 644 q 240 563 266 601 q 201 477 214 526 q 188 374 188 429 m 317 -174 q 335 -122 317 -143 q 391 -101 354 -101 q 446 -122 427 -101 q 465 -174 465 -143 q 446 -223 465 -203 q 391 -244 427 -244 q 335 -223 354 -244 q 317 -174 317 -203 z "},"Ụ":{"ha":901,"x_min":95,"x_max":810,"o":"m 680 987 l 810 987 l 810 319 q 760 134 810 208 q 629 23 711 60 q 452 -14 547 -14 q 270 23 351 -14 q 142 134 189 60 q 95 319 95 208 l 95 987 l 224 987 l 224 319 q 253 192 224 242 q 333 117 281 142 q 452 93 384 93 q 571 117 520 93 q 651 192 623 142 q 680 319 680 242 l 680 987 m 374 -167 q 392 -115 374 -136 q 448 -94 411 -94 q 503 -115 484 -94 q 522 -167 522 -136 q 503 -217 522 -196 q 448 -237 484 -237 q 392 -217 411 -237 q 374 -167 374 -196 z "},"ụ":{"ha":766,"x_min":93,"x_max":671,"o":"m 545 170 l 545 734 l 671 734 l 671 0 l 551 0 l 545 170 m 568 324 l 621 326 q 605 190 621 252 q 556 83 590 128 q 467 12 522 37 q 334 -14 412 -14 q 236 2 280 -14 q 159 50 191 18 q 110 135 127 83 q 93 260 93 187 l 93 734 l 218 734 l 218 259 q 230 177 218 210 q 260 126 241 145 q 303 100 279 108 q 353 93 328 93 q 480 124 433 93 q 548 207 527 155 q 568 324 568 260 m 267 -167 q 286 -115 267 -136 q 341 -94 304 -94 q 396 -115 377 -94 q 416 -167 416 -136 q 396 -217 416 -196 q 341 -237 377 -237 q 286 -217 304 -237 q 267 -167 267 -196 z "},"Ủ":{"ha":901,"x_min":95,"x_max":810,"o":"m 680 987 l 810 987 l 810 319 q 760 134 810 208 q 629 23 711 60 q 452 -14 547 -14 q 270 23 351 -14 q 142 134 189 60 q 95 319 95 208 l 95 987 l 224 987 l 224 319 q 253 192 224 242 q 333 117 281 142 q 452 93 384 93 q 571 117 520 93 q 651 192 623 142 q 680 319 680 242 l 680 987 m 500 1064 l 410 1064 l 409 1167 q 465 1174 444 1169 q 497 1190 487 1179 q 507 1218 507 1200 q 498 1242 507 1232 q 474 1258 490 1252 q 438 1267 458 1265 q 395 1270 418 1270 l 399 1342 q 488 1333 450 1342 q 552 1308 526 1324 q 592 1267 578 1291 q 605 1215 605 1244 q 572 1140 605 1164 q 500 1112 540 1117 l 500 1064 z "},"ủ":{"ha":766,"x_min":93,"x_max":671,"o":"m 545 170 l 545 734 l 671 734 l 671 0 l 551 0 l 545 170 m 568 324 l 621 326 q 605 190 621 252 q 556 83 590 128 q 467 12 522 37 q 334 -14 412 -14 q 236 2 280 -14 q 159 50 191 18 q 110 135 127 83 q 93 260 93 187 l 93 734 l 218 734 l 218 259 q 230 177 218 210 q 260 126 241 145 q 303 100 279 108 q 353 93 328 93 q 480 124 433 93 q 548 207 527 155 q 568 324 568 260 m 432 853 l 342 853 l 341 956 q 397 963 376 958 q 429 979 419 968 q 439 1007 439 989 q 431 1031 439 1021 q 406 1047 422 1041 q 370 1057 391 1054 q 327 1059 350 1059 l 332 1131 q 420 1122 382 1131 q 485 1097 458 1114 q 524 1056 511 1080 q 537 1004 537 1033 q 505 929 537 953 q 433 901 472 906 l 432 853 z "},"Ứ":{"ha":966,"x_min":95,"x_max":1061,"o":"m 954 1043 l 1061 1043 q 1033 882 1061 947 q 943 784 1005 817 q 779 751 881 751 l 779 842 q 886 865 848 842 q 939 932 924 888 q 954 1043 954 977 m 680 987 l 810 987 l 810 319 q 760 134 810 208 q 629 23 711 60 q 452 -14 547 -14 q 270 23 351 -14 q 142 134 189 60 q 95 319 95 208 l 95 987 l 224 987 l 224 319 q 253 192 224 242 q 333 117 281 142 q 452 93 384 93 q 571 117 520 93 q 651 192 623 142 q 680 319 680 242 l 680 987 m 401 1061 l 533 1260 l 684 1260 l 503 1061 l 401 1061 z "},"ứ":{"ha":859,"x_min":93,"x_max":879,"o":"m 783 793 l 879 793 q 860 669 879 719 q 792 593 840 618 q 656 568 744 568 l 656 646 q 744 661 718 646 q 777 709 770 676 q 783 793 783 741 m 545 170 l 545 734 l 671 734 l 671 0 l 551 0 l 545 170 m 568 324 l 621 326 q 605 190 621 252 q 556 83 590 128 q 467 12 522 37 q 334 -14 412 -14 q 236 2 280 -14 q 159 50 191 18 q 110 135 127 83 q 93 260 93 187 l 93 734 l 218 734 l 218 259 q 230 177 218 210 q 260 126 241 145 q 303 100 279 108 q 353 93 328 93 q 480 124 433 93 q 548 207 527 155 q 568 324 568 260 m 324 828 l 456 1027 l 607 1027 l 425 828 l 324 828 z "},"Ừ":{"ha":966,"x_min":95,"x_max":1061,"o":"m 954 1043 l 1061 1043 q 1033 882 1061 947 q 943 784 1005 817 q 779 751 881 751 l 779 842 q 886 865 848 842 q 939 932 924 888 q 954 1043 954 977 m 680 987 l 810 987 l 810 319 q 760 134 810 208 q 629 23 711 60 q 452 -14 547 -14 q 270 23 351 -14 q 142 134 189 60 q 95 319 95 208 l 95 987 l 224 987 l 224 319 q 253 192 224 242 q 333 117 281 142 q 452 93 384 93 q 571 117 520 93 q 651 192 623 142 q 680 319 680 242 l 680 987 m 411 1260 l 542 1061 l 434 1061 l 259 1260 l 411 1260 z "},"ừ":{"ha":859,"x_min":93,"x_max":879,"o":"m 783 793 l 879 793 q 860 669 879 719 q 792 593 840 618 q 656 568 744 568 l 656 646 q 744 661 718 646 q 777 709 770 676 q 783 793 783 741 m 545 170 l 545 734 l 671 734 l 671 0 l 551 0 l 545 170 m 568 324 l 621 326 q 605 190 621 252 q 556 83 590 128 q 467 12 522 37 q 334 -14 412 -14 q 236 2 280 -14 q 159 50 191 18 q 110 135 127 83 q 93 260 93 187 l 93 734 l 218 734 l 218 259 q 230 177 218 210 q 260 126 241 145 q 303 100 279 108 q 353 93 328 93 q 480 124 433 93 q 548 207 527 155 q 568 324 568 260 m 334 1027 l 465 828 l 357 828 l 182 1027 l 334 1027 z "},"Ử":{"ha":966,"x_min":95,"x_max":1061,"o":"m 954 1043 l 1061 1043 q 1033 882 1061 947 q 943 784 1005 817 q 779 751 881 751 l 779 842 q 886 865 848 842 q 939 932 924 888 q 954 1043 954 977 m 680 987 l 810 987 l 810 319 q 760 134 810 208 q 629 23 711 60 q 452 -14 547 -14 q 270 23 351 -14 q 142 134 189 60 q 95 319 95 208 l 95 987 l 224 987 l 224 319 q 253 192 224 242 q 333 117 281 142 q 452 93 384 93 q 571 117 520 93 q 651 192 623 142 q 680 319 680 242 l 680 987 m 518 1072 l 428 1072 l 427 1175 q 484 1182 462 1177 q 515 1197 505 1187 q 526 1225 526 1208 q 517 1250 526 1240 q 492 1266 508 1259 q 456 1275 477 1272 q 413 1278 436 1278 l 418 1350 q 506 1341 468 1350 q 571 1315 545 1332 q 610 1275 597 1298 q 623 1223 623 1251 q 591 1148 623 1171 q 519 1119 558 1124 l 518 1072 z "},"ử":{"ha":859,"x_min":93,"x_max":879,"o":"m 783 793 l 879 793 q 860 669 879 719 q 792 593 840 618 q 656 568 744 568 l 656 646 q 744 661 718 646 q 777 709 770 676 q 783 793 783 741 m 545 170 l 545 734 l 671 734 l 671 0 l 551 0 l 545 170 m 568 324 l 621 326 q 605 190 621 252 q 556 83 590 128 q 467 12 522 37 q 334 -14 412 -14 q 236 2 280 -14 q 159 50 191 18 q 110 135 127 83 q 93 260 93 187 l 93 734 l 218 734 l 218 259 q 230 177 218 210 q 260 126 241 145 q 303 100 279 108 q 353 93 328 93 q 480 124 433 93 q 548 207 527 155 q 568 324 568 260 m 441 839 l 351 839 l 350 942 q 406 949 385 944 q 438 965 428 954 q 448 993 448 975 q 439 1017 448 1007 q 415 1033 431 1027 q 379 1042 399 1040 q 336 1045 359 1045 l 340 1117 q 429 1108 391 1117 q 493 1082 467 1099 q 533 1042 519 1065 q 546 990 546 1019 q 513 915 546 939 q 441 886 481 892 l 441 839 z "},"Ữ":{"ha":966,"x_min":95,"x_max":1061,"o":"m 954 1043 l 1061 1043 q 1033 882 1061 947 q 943 784 1005 817 q 779 751 881 751 l 779 842 q 886 865 848 842 q 939 932 924 888 q 954 1043 954 977 m 680 987 l 810 987 l 810 319 q 760 134 810 208 q 629 23 711 60 q 452 -14 547 -14 q 270 23 351 -14 q 142 134 189 60 q 95 319 95 208 l 95 987 l 224 987 l 224 319 q 253 192 224 242 q 333 117 281 142 q 452 93 384 93 q 571 117 520 93 q 651 192 623 142 q 680 319 680 242 l 680 987 m 627 1246 l 711 1239 q 692 1152 711 1190 q 639 1095 672 1115 q 565 1074 606 1074 q 508 1084 530 1074 q 468 1106 486 1094 q 431 1129 450 1119 q 383 1139 412 1139 q 335 1117 355 1139 q 316 1063 316 1095 l 231 1067 q 251 1155 231 1117 q 303 1214 270 1192 q 377 1235 336 1235 q 428 1225 406 1235 q 470 1203 450 1215 q 511 1180 490 1190 q 559 1171 532 1171 q 607 1193 587 1171 q 627 1246 627 1215 z "},"ữ":{"ha":859,"x_min":93,"x_max":879,"o":"m 783 793 l 879 793 q 860 669 879 719 q 792 593 840 618 q 656 568 744 568 l 656 646 q 744 661 718 646 q 777 709 770 676 q 783 793 783 741 m 545 170 l 545 734 l 671 734 l 671 0 l 551 0 l 545 170 m 568 324 l 621 326 q 605 190 621 252 q 556 83 590 128 q 467 12 522 37 q 334 -14 412 -14 q 236 2 280 -14 q 159 50 191 18 q 110 135 127 83 q 93 260 93 187 l 93 734 l 218 734 l 218 259 q 230 177 218 210 q 260 126 241 145 q 303 100 279 108 q 353 93 328 93 q 480 124 433 93 q 548 207 527 155 q 568 324 568 260 m 549 1014 l 634 1006 q 614 920 634 957 q 562 862 595 882 q 488 842 529 842 q 431 851 453 842 q 391 874 408 861 q 354 896 373 886 q 306 906 334 906 q 258 884 277 906 q 239 831 239 863 l 154 835 q 173 922 154 884 q 226 981 193 960 q 300 1002 259 1002 q 351 992 329 1002 q 393 970 373 983 q 433 948 412 958 q 481 938 454 938 q 530 960 510 938 q 549 1014 549 982 z "},"Ự":{"ha":966,"x_min":95,"x_max":1061,"o":"m 954 1043 l 1061 1043 q 1033 882 1061 947 q 943 784 1005 817 q 779 751 881 751 l 779 842 q 886 865 848 842 q 939 932 924 888 q 954 1043 954 977 m 680 987 l 810 987 l 810 319 q 760 134 810 208 q 629 23 711 60 q 452 -14 547 -14 q 270 23 351 -14 q 142 134 189 60 q 95 319 95 208 l 95 987 l 224 987 l 224 319 q 253 192 224 242 q 333 117 281 142 q 452 93 384 93 q 571 117 520 93 q 651 192 623 142 q 680 319 680 242 l 680 987 m 391 -173 q 410 -121 391 -142 q 465 -100 429 -100 q 520 -121 501 -100 q 540 -173 540 -142 q 520 -223 540 -202 q 465 -243 501 -243 q 410 -223 429 -243 q 391 -173 391 -202 z "},"ự":{"ha":859,"x_min":93,"x_max":879,"o":"m 783 793 l 879 793 q 860 669 879 719 q 792 593 840 618 q 656 568 744 568 l 656 646 q 744 661 718 646 q 777 709 770 676 q 783 793 783 741 m 545 170 l 545 734 l 671 734 l 671 0 l 551 0 l 545 170 m 568 324 l 621 326 q 605 190 621 252 q 556 83 590 128 q 467 12 522 37 q 334 -14 412 -14 q 236 2 280 -14 q 159 50 191 18 q 110 135 127 83 q 93 260 93 187 l 93 734 l 218 734 l 218 259 q 230 177 218 210 q 260 126 241 145 q 303 100 279 108 q 353 93 328 93 q 480 124 433 93 q 548 207 527 155 q 568 324 568 260 m 304 -167 q 322 -115 304 -136 q 378 -94 341 -94 q 433 -115 414 -94 q 452 -167 452 -136 q 433 -217 452 -196 q 378 -237 414 -237 q 322 -217 341 -237 q 304 -167 304 -196 z "},"Ỵ":{"ha":834,"x_min":10,"x_max":822,"o":"m 160 987 l 416 492 l 673 987 l 822 987 l 481 369 l 481 0 l 351 0 l 351 369 l 10 987 l 160 987 m 339 -166 q 358 -115 339 -136 q 413 -94 376 -94 q 468 -115 449 -94 q 488 -166 488 -136 q 468 -216 488 -195 q 413 -237 449 -237 q 358 -216 376 -237 q 339 -166 339 -195 z "},"ỵ":{"ha":657,"x_min":15,"x_max":640,"o":"m 302 76 l 506 734 l 640 734 l 346 -113 q 319 -172 336 -140 q 277 -232 302 -203 q 215 -278 251 -260 q 128 -296 178 -296 q 90 -292 113 -296 q 58 -286 67 -288 l 57 -184 q 74 -185 62 -184 q 91 -186 86 -186 q 163 -175 134 -186 q 214 -138 193 -164 q 250 -66 235 -112 l 302 76 m 152 734 l 342 164 l 375 32 l 285 -14 l 15 734 l 152 734 m 405 -274 q 424 -222 405 -243 q 479 -201 442 -201 q 534 -222 515 -201 q 553 -274 553 -243 q 534 -324 553 -303 q 479 -345 515 -345 q 424 -324 442 -345 q 405 -274 405 -303 z "},"Ỷ":{"ha":834,"x_min":10,"x_max":822,"o":"m 160 987 l 416 492 l 673 987 l 822 987 l 481 369 l 481 0 l 351 0 l 351 369 l 10 987 l 160 987 m 467 1063 l 376 1063 l 376 1166 q 432 1174 410 1168 q 464 1189 454 1179 q 474 1217 474 1200 q 465 1241 474 1232 q 441 1258 456 1251 q 405 1267 425 1264 q 361 1270 385 1270 l 366 1341 q 455 1333 416 1341 q 519 1307 493 1324 q 558 1266 545 1290 q 572 1215 572 1243 q 539 1140 572 1163 q 467 1111 507 1116 l 467 1063 z "},"ỷ":{"ha":657,"x_min":15,"x_max":640,"o":"m 302 76 l 506 734 l 640 734 l 346 -113 q 319 -172 336 -140 q 277 -232 302 -203 q 215 -278 251 -260 q 128 -296 178 -296 q 90 -292 113 -296 q 58 -286 67 -288 l 57 -184 q 74 -185 62 -184 q 91 -186 86 -186 q 163 -175 134 -186 q 214 -138 193 -164 q 250 -66 235 -112 l 302 76 m 152 734 l 342 164 l 375 32 l 285 -14 l 15 734 l 152 734 m 392 853 l 302 853 l 301 956 q 357 963 336 958 q 389 979 379 968 q 399 1007 399 989 q 391 1031 399 1021 q 366 1047 382 1041 q 330 1057 351 1054 q 287 1059 310 1059 l 292 1131 q 380 1122 342 1131 q 445 1097 418 1114 q 484 1056 471 1080 q 497 1004 497 1033 q 465 929 497 953 q 393 901 432 906 l 392 853 z "},"Ỹ":{"ha":834,"x_min":10,"x_max":822,"o":"m 160 987 l 416 492 l 673 987 l 822 987 l 481 369 l 481 0 l 351 0 l 351 369 l 10 987 l 160 987 m 575 1238 l 660 1231 q 640 1144 660 1181 q 588 1086 621 1107 q 513 1066 555 1066 q 456 1076 479 1066 q 416 1098 434 1086 q 379 1121 399 1111 q 332 1131 360 1131 q 284 1109 303 1131 q 264 1055 264 1087 l 180 1059 q 199 1146 180 1109 q 252 1205 218 1184 q 326 1227 285 1227 q 377 1217 355 1227 q 418 1195 399 1207 q 459 1172 438 1182 q 507 1162 480 1162 q 555 1184 536 1162 q 575 1238 575 1206 z "},"ỹ":{"ha":657,"x_min":15,"x_max":640,"o":"m 302 76 l 506 734 l 640 734 l 346 -113 q 319 -172 336 -140 q 277 -232 302 -203 q 215 -278 251 -260 q 128 -296 178 -296 q 90 -292 113 -296 q 58 -286 67 -288 l 57 -184 q 74 -185 62 -184 q 91 -186 86 -186 q 163 -175 134 -186 q 214 -138 193 -164 q 250 -66 235 -112 l 302 76 m 152 734 l 342 164 l 375 32 l 285 -14 l 15 734 l 152 734 m 500 1028 l 585 1021 q 566 934 585 971 q 513 876 546 897 q 439 856 480 856 q 382 866 404 856 q 342 888 359 876 q 305 910 324 901 q 257 920 286 920 q 209 899 229 920 q 190 845 190 877 l 105 849 q 124 936 105 899 q 177 995 144 974 q 251 1017 210 1017 q 302 1007 280 1017 q 344 984 324 997 q 385 962 363 972 q 433 952 406 952 q 481 974 461 952 q 500 1028 500 996 z "},"₫":{"ha":804,"x_min":64,"x_max":812,"o":"m 558 142 l 558 1042 l 684 1042 l 684 0 l 569 0 l 558 142 m 64 359 l 64 373 q 85 526 64 457 q 144 644 106 595 q 236 721 182 694 q 355 747 289 747 q 476 723 424 747 q 564 653 528 699 q 621 543 600 608 q 650 397 642 479 l 650 335 q 622 190 643 254 q 564 80 600 125 q 475 11 528 35 q 353 -14 423 -14 q 236 14 289 -14 q 144 92 182 42 q 85 211 106 142 q 64 359 64 279 m 191 373 l 191 359 q 202 256 191 304 q 237 171 213 208 q 297 114 260 134 q 385 93 334 93 q 487 119 447 93 q 552 189 528 146 q 590 283 576 233 l 590 447 q 567 519 582 484 q 527 582 551 554 q 468 625 503 609 q 386 642 433 642 q 297 620 334 642 q 237 562 260 599 q 202 476 213 525 q 191 373 191 428 m 812 939 l 812 836 l 380 836 l 380 939 l 812 939 m 732 -106 l 732 -210 l 111 -210 l 111 -106 l 732 -106 z "},"Ҭ":{"ha":829,"x_min":34,"x_max":797,"o":"m 479 987 l 479 0 l 351 0 l 351 987 l 479 987 m 797 987 l 797 880 l 34 880 l 34 987 l 797 987 m 587 104 l 587 -243 l 461 -243 l 461 104 l 587 104 z "},"ҭ":{"ha":668,"x_min":27,"x_max":641,"o":"m 395 734 l 395 0 l 269 0 l 269 734 l 395 734 m 641 734 l 641 632 l 27 632 l 27 734 l 641 734 m 505 104 l 505 -243 l 379 -243 l 379 104 l 505 104 z "},"Ӌ":{"ha":951,"x_min":102,"x_max":831,"o":"m 102 987 l 233 987 l 233 679 q 256 559 233 602 q 323 498 278 515 q 437 480 369 480 q 516 484 477 480 q 591 493 554 487 q 663 508 627 499 q 733 527 699 517 l 733 420 q 667 401 700 410 q 599 386 634 392 q 525 376 564 380 q 437 373 485 373 q 257 403 332 373 q 142 500 182 433 q 102 679 102 568 l 102 987 m 700 987 l 831 987 l 831 0 l 700 0 l 700 987 m 715 104 l 715 -243 l 590 -243 l 590 104 l 715 104 z "},"ӌ":{"ha":755,"x_min":71,"x_max":649,"o":"m 649 734 l 649 0 l 524 0 l 524 734 l 649 734 m 606 397 l 606 294 q 529 268 568 279 q 447 251 490 257 q 354 244 404 244 q 203 274 267 244 q 105 366 140 304 q 71 521 71 427 l 71 735 l 196 735 l 196 521 q 214 422 196 460 q 268 366 233 384 q 354 348 303 348 q 446 354 403 348 q 529 372 489 361 q 606 397 568 382 m 536 104 l 536 -243 l 411 -243 l 411 104 l 536 104 z "},"Ӷ":{"ha":772,"x_min":121,"x_max":727,"o":"m 727 987 l 727 880 l 251 880 l 251 0 l 121 0 l 121 987 l 727 987 m 359 104 l 359 -243 l 233 -243 l 233 104 l 359 104 z "},"ӷ":{"ha":583,"x_min":105,"x_max":570,"o":"m 570 734 l 570 630 l 231 630 l 231 0 l 105 0 l 105 734 l 570 734 m 340 104 l 340 -243 l 215 -243 l 215 104 l 340 104 z "},"Ҿ":{"ha":1074,"x_min":43,"x_max":997,"o":"m 43 733 l 146 733 q 163 647 146 684 q 218 589 181 610 q 314 568 256 568 l 314 473 q 164 505 225 473 q 73 596 104 537 q 43 733 43 654 m 679 -16 q 500 16 578 -16 q 368 104 422 47 q 287 238 315 161 q 260 409 260 316 l 260 578 q 288 748 260 671 q 367 883 317 826 q 485 970 418 939 q 629 1000 551 1001 q 788 969 720 1000 q 904 878 857 937 q 974 736 950 819 q 997 549 997 652 l 997 473 l 339 473 l 339 567 l 866 567 l 866 589 q 853 707 866 652 q 813 804 841 762 q 740 868 785 845 q 629 892 694 892 q 527 867 572 892 q 452 800 483 843 q 406 700 422 756 q 390 578 390 643 l 390 409 q 406 286 390 343 q 457 185 422 229 q 547 117 492 142 q 679 92 602 92 q 819 111 763 92 q 913 149 876 130 l 945 52 q 895 25 929 41 q 808 -3 861 9 q 679 -16 754 -16 m 721 57 l 721 -291 l 595 -291 l 595 57 l 721 57 z "},"ҿ":{"ha":823,"x_min":-24,"x_max":762,"o":"m -24 581 l 77 581 q 111 475 77 515 q 218 435 144 435 l 218 343 q 85 372 139 343 q 4 454 31 401 q -24 581 -24 508 m 476 -14 q 337 13 399 -14 q 231 86 275 39 q 163 199 186 134 q 139 341 139 264 l 139 370 q 165 529 139 459 q 237 648 192 600 q 340 722 283 697 q 460 747 398 747 q 596 720 539 747 q 690 645 653 693 q 745 531 727 596 q 762 388 762 465 l 762 332 l 214 332 l 214 434 l 636 434 l 636 444 q 624 516 634 480 q 594 581 614 551 q 541 627 574 610 q 460 644 508 644 q 381 626 417 644 q 319 573 345 608 q 279 487 294 538 q 265 370 265 436 l 265 341 q 280 243 265 289 q 322 163 294 197 q 391 109 351 128 q 483 89 431 89 q 595 116 549 89 q 676 189 642 143 l 753 128 q 692 60 729 92 q 602 7 655 27 q 476 -14 549 -14 m 543 59 l 543 -289 l 418 -289 l 418 59 l 543 59 z "},"һ":{"ha":765,"x_min":96,"x_max":673,"o":"m 221 1042 l 221 0 l 96 0 l 96 1042 l 221 1042 m 191 395 l 139 397 q 161 536 140 472 q 222 648 183 600 q 316 721 262 695 q 437 747 371 747 q 535 733 492 747 q 609 686 578 718 q 656 604 640 654 q 673 481 673 553 l 673 0 l 547 0 l 547 482 q 530 575 547 540 q 480 626 513 610 q 400 642 448 642 q 315 622 353 642 q 249 568 277 602 q 207 489 222 533 q 191 395 191 444 z "},"Ҍ":{"ha":871,"x_min":-30,"x_max":814,"o":"m 210 585 l 479 585 q 663 549 588 585 q 776 448 737 513 q 814 295 814 382 q 793 176 814 230 q 728 82 771 122 q 623 21 686 43 q 479 0 561 0 l 111 0 l 111 987 l 241 987 l 241 106 l 479 106 q 597 133 552 106 q 663 203 642 160 q 684 296 684 247 q 663 387 684 346 q 597 453 642 429 q 479 478 552 478 l 210 478 l 210 585 m 402 851 l 402 748 l -30 748 l -30 851 l 402 851 z "},"Ѣ":{"ha":871,"x_min":-30,"x_max":814,"o":"m 210 585 l 479 585 q 663 549 588 585 q 776 448 737 513 q 814 295 814 382 q 793 176 814 230 q 728 82 771 122 q 623 21 686 43 q 479 0 561 0 l 111 0 l 111 987 l 241 987 l 241 106 l 479 106 q 597 133 552 106 q 663 203 642 160 q 684 296 684 247 q 663 387 684 346 q 597 453 642 429 q 479 478 552 478 l 210 478 l 210 585 m 402 851 l 402 748 l -30 748 l -30 851 l 402 851 z "},"Ғ":{"ha":772,"x_min":2,"x_max":727,"o":"m 727 987 l 727 880 l 251 880 l 251 0 l 121 0 l 121 987 l 727 987 m 434 566 l 434 463 l 2 463 l 2 566 l 434 566 z "},"ғ":{"ha":583,"x_min":-2,"x_max":570,"o":"m 570 734 l 570 630 l 231 630 l 231 0 l 105 0 l 105 734 l 570 734 m 430 427 l 430 324 l -2 324 l -2 427 l 430 427 z "},"Ҟ":{"ha":906,"x_min":7,"x_max":902,"o":"m 265 987 l 265 0 l 134 0 l 134 987 l 265 987 m 873 987 l 445 444 l 213 444 l 193 553 l 367 553 l 711 987 l 873 987 m 742 0 l 371 461 l 444 576 l 902 0 l 742 0 m 439 834 l 439 731 l 7 731 l 7 834 l 439 834 z "},"ҟ":{"ha":722,"x_min":-31,"x_max":722,"o":"m 239 1042 l 239 0 l 113 0 l 113 1042 l 239 1042 m 687 734 l 385 340 l 194 340 l 179 444 l 324 444 l 538 734 l 687 734 m 573 0 l 321 349 l 387 460 l 722 0 l 573 0 m 401 928 l 401 825 l -31 825 l -31 928 l 401 928 z "},"Ұ":{"ha":834,"x_min":10,"x_max":822,"o":"m 160 987 l 416 492 l 673 987 l 822 987 l 481 369 l 481 0 l 351 0 l 351 369 l 10 987 l 160 987 m 635 456 l 635 353 l 203 353 l 203 456 l 635 456 z "},"ұ":{"ha":696,"x_min":32,"x_max":673,"o":"m 415 90 l 415 -283 l 290 -283 l 290 90 l 415 90 m 349 170 l 544 734 l 673 734 l 401 0 l 317 0 l 349 170 m 160 734 l 361 170 l 389 0 l 305 0 l 32 734 l 160 734 m 572 95 l 572 -8 l 140 -8 l 140 95 l 572 95 z "},"Ӿ":{"ha":871,"x_min":39,"x_max":834,"o":"m 199 987 l 437 609 l 674 987 l 827 987 l 515 498 l 834 0 l 680 0 l 437 386 l 193 0 l 39 0 l 359 498 l 47 987 l 199 987 m 655 557 l 655 454 l 223 454 l 223 557 l 655 557 z "},"ӿ":{"ha":689,"x_min":28,"x_max":659,"o":"m 180 734 l 341 467 l 504 734 l 651 734 l 411 372 l 659 0 l 513 0 l 344 275 l 174 0 l 28 0 l 275 372 l 36 734 l 180 734 m 562 429 l 562 326 l 130 326 l 130 429 l 562 429 z "},"ԑ":{"ha":749,"x_min":68,"x_max":681,"o":"m 356 398 l 505 398 l 505 325 l 366 325 q 272 312 310 325 q 214 274 233 300 q 194 206 194 248 q 206 161 194 182 q 241 123 218 140 q 298 98 264 107 q 374 88 332 88 q 470 106 429 88 q 533 154 511 125 q 556 217 556 184 l 681 217 q 654 114 681 157 q 584 42 628 70 q 485 0 540 14 q 374 -14 431 -14 q 252 1 308 -14 q 155 45 196 16 q 91 114 113 73 q 68 207 68 155 q 87 289 68 253 q 143 349 106 324 q 234 386 180 373 q 356 398 288 398 m 505 351 l 356 351 q 243 365 294 351 q 156 405 192 379 q 100 463 119 430 q 81 534 81 496 q 101 626 81 586 q 161 692 122 665 q 254 733 199 719 q 374 747 308 747 q 488 732 435 747 q 582 688 541 717 q 646 620 623 660 q 669 530 669 580 l 544 530 q 521 588 544 562 q 460 630 498 614 q 374 645 422 645 q 279 629 317 645 q 224 588 242 613 q 206 534 206 562 q 215 490 206 510 q 243 455 224 470 q 293 433 262 441 q 366 425 323 425 l 505 425 l 505 351 z "},"₣":{"ha":768,"x_min":12,"x_max":726,"o":"m 245 987 l 245 0 l 115 0 l 115 987 l 245 987 m 659 543 l 659 436 l 217 436 l 217 543 l 659 543 m 726 987 l 726 880 l 217 880 l 217 987 l 726 987 m 444 282 l 444 179 l 12 179 l 12 282 l 444 282 z "},"―":{"ha":1084,"x_min":98,"x_max":1004,"o":"m 1004 545 l 1004 441 l 98 441 l 98 545 l 1004 545 z "},"Ὅ":{"ha":1003,"x_min":-266,"x_max":922,"o":"m 922 525 l 922 463 q 895 263 922 351 q 814 113 867 175 q 689 19 762 52 q 526 -14 616 -14 q 366 19 439 -14 q 240 113 293 52 q 157 263 186 175 q 128 463 128 351 l 128 525 q 157 724 128 636 q 239 874 186 812 q 365 968 292 936 q 525 1001 437 1001 q 688 968 615 1001 q 813 874 761 936 q 894 724 866 812 q 922 525 922 636 m 793 463 l 793 526 q 775 682 793 614 q 722 796 757 750 q 638 866 688 842 q 525 890 588 890 q 415 866 464 890 q 331 796 366 842 q 277 682 296 750 q 258 526 258 614 l 258 463 q 277 306 258 374 q 331 191 296 237 q 416 121 367 144 q 526 97 465 97 q 640 121 590 97 q 723 191 689 144 q 775 306 758 237 q 793 463 793 374 m -69 783 l -69 795 l 9 1013 l 142 1013 l 142 999 l -9 783 l -69 783 m -266 956 l -266 1013 l -153 1013 l -153 960 q -138 876 -153 911 q -96 810 -124 840 l -145 770 q -235 849 -203 801 q -266 956 -266 898 z "}}');
const familyName = "Roboto";
const ascender = 1289;
const descender = -339;
const underlinePosition = -102;
const underlineThickness = 68;
const boundingBox = { "yMin": -376, "xMin": -1024, "yMax": 1467, "xMax": 1596 };
const resolution = 1e3;
const original_font_information = { "format": 0, "copyright": "Copyright 2011 The Roboto Project Authors (https://github.com/googlefonts/roboto-classic)", "fontFamily": "Roboto", "fontSubfamily": "Regular", "uniqueID": "3.009;GOOG;Roboto-Regular", "fullName": "Roboto Regular", "version": "Version 3.009; 2024", "postScriptName": "Roboto-Regular", "trademark": "Roboto is a trademark of Google.", "manufacturer": "Google", "designer": "Christian Robertson", "manufacturerURL": "Google.com", "designerURL": "Google.com", "licence": "This Font Software is licensed under the SIL Open Font License, Version 1.1. This license is available with a FAQ at: https://openfontlicense.org", "licenceURL": "https://openfontlicense.org", "unknown1": "Roboto", "unknown2": "Weight", "unknown3": "Width", "unknown4": "Italic", "unknown5": "Thin", "unknown6": "ExtraLight", "unknown7": "Light", "unknown8": "Regular", "unknown9": "Medium", "unknown10": "SemiBold", "unknown11": "Bold", "unknown12": "ExtraBold", "unknown13": "Black", "unknown14": "Condensed Thin", "unknown15": "Condensed ExtraLight", "unknown16": "Condensed Light", "unknown17": "Condensed Regular", "unknown18": "Condensed Medium", "unknown19": "Condensed SemiBold", "unknown20": "Condensed Bold", "unknown21": "Condensed ExtraBold", "unknown22": "Condensed Black", "unknown23": "Condensed", "unknown24": "Normal", "unknown25": "Roman", "unknown26": "Roboto-Thin", "unknown27": "Roboto-ExtraLight", "unknown28": "Roboto-Light", "unknown29": "Roboto-Regular", "unknown30": "Roboto-Medium", "unknown31": "Roboto-SemiBold", "unknown32": "Roboto-Bold", "unknown33": "Roboto-ExtraBold", "unknown34": "Roboto-Black", "unknown35": "Roboto-CondensedThin", "unknown36": "Roboto-CondensedExtraLight", "unknown37": "Roboto-CondensedLight", "unknown38": "Roboto-CondensedRegular", "unknown39": "Roboto-CondensedMedium", "unknown40": "Roboto-CondensedSemiBold", "unknown41": "Roboto-CondensedBold", "unknown42": "Roboto-CondensedExtraBold", "unknown43": "Roboto-CondensedBlack" };
const cssFontWeight = "normal";
const cssFontStyle = "normal";
const robotoRegular = {
  glyphs,
  familyName,
  ascender,
  descender,
  underlinePosition,
  underlineThickness,
  boundingBox,
  resolution,
  original_font_information,
  cssFontWeight,
  cssFontStyle
};
class TextShape extends Shape2 {
  constructor(text, size = 8) {
    const color2 = Colors.ELEMENT_TEXT;
    const loader = new FontLoader();
    var font = loader.parse(robotoRegular);
    var textGeometry = new TextGeometry(text, {
      font,
      size,
      depth: 0.2,
      // .0125,
      curveSegments: 12
    }).center();
    super(textGeometry, new DiagramEditMaterial(color2));
  }
}
const IconDimensions = {
  ICON_SIZE_SMALL: 10,
  ICON_SIZE_MEDIUM: 18,
  ICON_PADDING: 4
};
const COLOR_SPACE_SVG = SRGBColorSpace$1;
class SVGLoader extends Loader {
  constructor(manager) {
    super(manager);
    this.defaultDPI = 90;
    this.defaultUnit = "px";
  }
  load(url, onLoad, onProgress, onError) {
    const scope = this;
    const loader = new FileLoader(scope.manager);
    loader.setPath(scope.path);
    loader.setRequestHeader(scope.requestHeader);
    loader.setWithCredentials(scope.withCredentials);
    loader.load(url, function(text) {
      try {
        onLoad(scope.parse(text));
      } catch (e) {
        if (onError) {
          onError(e);
        } else {
          console.error(e);
        }
        scope.manager.itemError(url);
      }
    }, onProgress, onError);
  }
  parse(text) {
    const scope = this;
    function parseNode(node, style) {
      if (node.nodeType !== 1) return;
      const transform = getNodeTransform(node);
      let isDefsNode = false;
      let path = null;
      switch (node.nodeName) {
        case "svg":
          style = parseStyle(node, style);
          break;
        case "style":
          parseCSSStylesheet(node);
          break;
        case "g":
          style = parseStyle(node, style);
          break;
        case "path":
          style = parseStyle(node, style);
          if (node.hasAttribute("d")) path = parsePathNode(node);
          break;
        case "rect":
          style = parseStyle(node, style);
          path = parseRectNode(node);
          break;
        case "polygon":
          style = parseStyle(node, style);
          path = parsePolygonNode(node);
          break;
        case "polyline":
          style = parseStyle(node, style);
          path = parsePolylineNode(node);
          break;
        case "circle":
          style = parseStyle(node, style);
          path = parseCircleNode(node);
          break;
        case "ellipse":
          style = parseStyle(node, style);
          path = parseEllipseNode(node);
          break;
        case "line":
          style = parseStyle(node, style);
          path = parseLineNode(node);
          break;
        case "defs":
          isDefsNode = true;
          break;
        case "use":
          style = parseStyle(node, style);
          const href = node.getAttributeNS("http://www.w3.org/1999/xlink", "href") || "";
          const usedNodeId = href.substring(1);
          const usedNode = node.viewportElement.getElementById(usedNodeId);
          if (usedNode) {
            parseNode(usedNode, style);
          } else {
            console.warn("SVGLoader: 'use node' references non-existent node id: " + usedNodeId);
          }
          break;
      }
      if (path) {
        if (style.fill !== void 0 && style.fill !== "none") {
          path.color.setStyle(style.fill, COLOR_SPACE_SVG);
        }
        transformPath(path, currentTransform);
        paths.push(path);
        path.userData = { node, style };
      }
      const childNodes = node.childNodes;
      for (let i = 0; i < childNodes.length; i++) {
        const node2 = childNodes[i];
        if (isDefsNode && node2.nodeName !== "style" && node2.nodeName !== "defs") {
          continue;
        }
        parseNode(node2, style);
      }
      if (transform) {
        transformStack.pop();
        if (transformStack.length > 0) {
          currentTransform.copy(transformStack[transformStack.length - 1]);
        } else {
          currentTransform.identity();
        }
      }
    }
    function parsePathNode(node) {
      const path = new ShapePath();
      const point = new Vector2$1();
      const control = new Vector2$1();
      const firstPoint = new Vector2$1();
      let isFirstPoint = true;
      let doSetFirstPoint = false;
      const d = node.getAttribute("d");
      if (d === "" || d === "none") return null;
      const commands = d.match(/[a-df-z][^a-df-z]*/ig);
      for (let i = 0, l = commands.length; i < l; i++) {
        const command = commands[i];
        const type = command.charAt(0);
        const data2 = command.slice(1).trim();
        if (isFirstPoint === true) {
          doSetFirstPoint = true;
          isFirstPoint = false;
        }
        let numbers;
        switch (type) {
          case "M":
            numbers = parseFloats(data2);
            for (let j = 0, jl = numbers.length; j < jl; j += 2) {
              point.x = numbers[j + 0];
              point.y = numbers[j + 1];
              control.x = point.x;
              control.y = point.y;
              if (j === 0) {
                path.moveTo(point.x, point.y);
              } else {
                path.lineTo(point.x, point.y);
              }
              if (j === 0) firstPoint.copy(point);
            }
            break;
          case "H":
            numbers = parseFloats(data2);
            for (let j = 0, jl = numbers.length; j < jl; j++) {
              point.x = numbers[j];
              control.x = point.x;
              control.y = point.y;
              path.lineTo(point.x, point.y);
              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);
            }
            break;
          case "V":
            numbers = parseFloats(data2);
            for (let j = 0, jl = numbers.length; j < jl; j++) {
              point.y = numbers[j];
              control.x = point.x;
              control.y = point.y;
              path.lineTo(point.x, point.y);
              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);
            }
            break;
          case "L":
            numbers = parseFloats(data2);
            for (let j = 0, jl = numbers.length; j < jl; j += 2) {
              point.x = numbers[j + 0];
              point.y = numbers[j + 1];
              control.x = point.x;
              control.y = point.y;
              path.lineTo(point.x, point.y);
              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);
            }
            break;
          case "C":
            numbers = parseFloats(data2);
            for (let j = 0, jl = numbers.length; j < jl; j += 6) {
              path.bezierCurveTo(
                numbers[j + 0],
                numbers[j + 1],
                numbers[j + 2],
                numbers[j + 3],
                numbers[j + 4],
                numbers[j + 5]
              );
              control.x = numbers[j + 2];
              control.y = numbers[j + 3];
              point.x = numbers[j + 4];
              point.y = numbers[j + 5];
              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);
            }
            break;
          case "S":
            numbers = parseFloats(data2);
            for (let j = 0, jl = numbers.length; j < jl; j += 4) {
              path.bezierCurveTo(
                getReflection(point.x, control.x),
                getReflection(point.y, control.y),
                numbers[j + 0],
                numbers[j + 1],
                numbers[j + 2],
                numbers[j + 3]
              );
              control.x = numbers[j + 0];
              control.y = numbers[j + 1];
              point.x = numbers[j + 2];
              point.y = numbers[j + 3];
              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);
            }
            break;
          case "Q":
            numbers = parseFloats(data2);
            for (let j = 0, jl = numbers.length; j < jl; j += 4) {
              path.quadraticCurveTo(
                numbers[j + 0],
                numbers[j + 1],
                numbers[j + 2],
                numbers[j + 3]
              );
              control.x = numbers[j + 0];
              control.y = numbers[j + 1];
              point.x = numbers[j + 2];
              point.y = numbers[j + 3];
              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);
            }
            break;
          case "T":
            numbers = parseFloats(data2);
            for (let j = 0, jl = numbers.length; j < jl; j += 2) {
              const rx = getReflection(point.x, control.x);
              const ry = getReflection(point.y, control.y);
              path.quadraticCurveTo(
                rx,
                ry,
                numbers[j + 0],
                numbers[j + 1]
              );
              control.x = rx;
              control.y = ry;
              point.x = numbers[j + 0];
              point.y = numbers[j + 1];
              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);
            }
            break;
          case "A":
            numbers = parseFloats(data2, [3, 4], 7);
            for (let j = 0, jl = numbers.length; j < jl; j += 7) {
              if (numbers[j + 5] == point.x && numbers[j + 6] == point.y) continue;
              const start = point.clone();
              point.x = numbers[j + 5];
              point.y = numbers[j + 6];
              control.x = point.x;
              control.y = point.y;
              parseArcCommand(
                path,
                numbers[j],
                numbers[j + 1],
                numbers[j + 2],
                numbers[j + 3],
                numbers[j + 4],
                start,
                point
              );
              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);
            }
            break;
          case "m":
            numbers = parseFloats(data2);
            for (let j = 0, jl = numbers.length; j < jl; j += 2) {
              point.x += numbers[j + 0];
              point.y += numbers[j + 1];
              control.x = point.x;
              control.y = point.y;
              if (j === 0) {
                path.moveTo(point.x, point.y);
              } else {
                path.lineTo(point.x, point.y);
              }
              if (j === 0) firstPoint.copy(point);
            }
            break;
          case "h":
            numbers = parseFloats(data2);
            for (let j = 0, jl = numbers.length; j < jl; j++) {
              point.x += numbers[j];
              control.x = point.x;
              control.y = point.y;
              path.lineTo(point.x, point.y);
              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);
            }
            break;
          case "v":
            numbers = parseFloats(data2);
            for (let j = 0, jl = numbers.length; j < jl; j++) {
              point.y += numbers[j];
              control.x = point.x;
              control.y = point.y;
              path.lineTo(point.x, point.y);
              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);
            }
            break;
          case "l":
            numbers = parseFloats(data2);
            for (let j = 0, jl = numbers.length; j < jl; j += 2) {
              point.x += numbers[j + 0];
              point.y += numbers[j + 1];
              control.x = point.x;
              control.y = point.y;
              path.lineTo(point.x, point.y);
              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);
            }
            break;
          case "c":
            numbers = parseFloats(data2);
            for (let j = 0, jl = numbers.length; j < jl; j += 6) {
              path.bezierCurveTo(
                point.x + numbers[j + 0],
                point.y + numbers[j + 1],
                point.x + numbers[j + 2],
                point.y + numbers[j + 3],
                point.x + numbers[j + 4],
                point.y + numbers[j + 5]
              );
              control.x = point.x + numbers[j + 2];
              control.y = point.y + numbers[j + 3];
              point.x += numbers[j + 4];
              point.y += numbers[j + 5];
              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);
            }
            break;
          case "s":
            numbers = parseFloats(data2);
            for (let j = 0, jl = numbers.length; j < jl; j += 4) {
              path.bezierCurveTo(
                getReflection(point.x, control.x),
                getReflection(point.y, control.y),
                point.x + numbers[j + 0],
                point.y + numbers[j + 1],
                point.x + numbers[j + 2],
                point.y + numbers[j + 3]
              );
              control.x = point.x + numbers[j + 0];
              control.y = point.y + numbers[j + 1];
              point.x += numbers[j + 2];
              point.y += numbers[j + 3];
              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);
            }
            break;
          case "q":
            numbers = parseFloats(data2);
            for (let j = 0, jl = numbers.length; j < jl; j += 4) {
              path.quadraticCurveTo(
                point.x + numbers[j + 0],
                point.y + numbers[j + 1],
                point.x + numbers[j + 2],
                point.y + numbers[j + 3]
              );
              control.x = point.x + numbers[j + 0];
              control.y = point.y + numbers[j + 1];
              point.x += numbers[j + 2];
              point.y += numbers[j + 3];
              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);
            }
            break;
          case "t":
            numbers = parseFloats(data2);
            for (let j = 0, jl = numbers.length; j < jl; j += 2) {
              const rx = getReflection(point.x, control.x);
              const ry = getReflection(point.y, control.y);
              path.quadraticCurveTo(
                rx,
                ry,
                point.x + numbers[j + 0],
                point.y + numbers[j + 1]
              );
              control.x = rx;
              control.y = ry;
              point.x = point.x + numbers[j + 0];
              point.y = point.y + numbers[j + 1];
              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);
            }
            break;
          case "a":
            numbers = parseFloats(data2, [3, 4], 7);
            for (let j = 0, jl = numbers.length; j < jl; j += 7) {
              if (numbers[j + 5] == 0 && numbers[j + 6] == 0) continue;
              const start = point.clone();
              point.x += numbers[j + 5];
              point.y += numbers[j + 6];
              control.x = point.x;
              control.y = point.y;
              parseArcCommand(
                path,
                numbers[j],
                numbers[j + 1],
                numbers[j + 2],
                numbers[j + 3],
                numbers[j + 4],
                start,
                point
              );
              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);
            }
            break;
          case "Z":
          case "z":
            path.currentPath.autoClose = true;
            if (path.currentPath.curves.length > 0) {
              point.copy(firstPoint);
              path.currentPath.currentPoint.copy(point);
              isFirstPoint = true;
            }
            break;
          default:
            console.warn(command);
        }
        doSetFirstPoint = false;
      }
      return path;
    }
    function parseCSSStylesheet(node) {
      if (!node.sheet || !node.sheet.cssRules || !node.sheet.cssRules.length) return;
      for (let i = 0; i < node.sheet.cssRules.length; i++) {
        const stylesheet = node.sheet.cssRules[i];
        if (stylesheet.type !== 1) continue;
        const selectorList = stylesheet.selectorText.split(/,/gm).filter(Boolean).map((i2) => i2.trim());
        for (let j = 0; j < selectorList.length; j++) {
          const definitions = Object.fromEntries(
            Object.entries(stylesheet.style).filter(([, v]) => v !== "")
          );
          stylesheets[selectorList[j]] = Object.assign(
            stylesheets[selectorList[j]] || {},
            definitions
          );
        }
      }
    }
    function parseArcCommand(path, rx, ry, x_axis_rotation, large_arc_flag, sweep_flag, start, end) {
      if (rx == 0 || ry == 0) {
        path.lineTo(end.x, end.y);
        return;
      }
      x_axis_rotation = x_axis_rotation * Math.PI / 180;
      rx = Math.abs(rx);
      ry = Math.abs(ry);
      const dx2 = (start.x - end.x) / 2;
      const dy2 = (start.y - end.y) / 2;
      const x1p = Math.cos(x_axis_rotation) * dx2 + Math.sin(x_axis_rotation) * dy2;
      const y1p = -Math.sin(x_axis_rotation) * dx2 + Math.cos(x_axis_rotation) * dy2;
      let rxs = rx * rx;
      let rys = ry * ry;
      const x1ps = x1p * x1p;
      const y1ps = y1p * y1p;
      const cr = x1ps / rxs + y1ps / rys;
      if (cr > 1) {
        const s = Math.sqrt(cr);
        rx = s * rx;
        ry = s * ry;
        rxs = rx * rx;
        rys = ry * ry;
      }
      const dq = rxs * y1ps + rys * x1ps;
      const pq = (rxs * rys - dq) / dq;
      let q = Math.sqrt(Math.max(0, pq));
      if (large_arc_flag === sweep_flag) q = -q;
      const cxp = q * rx * y1p / ry;
      const cyp = -q * ry * x1p / rx;
      const cx = Math.cos(x_axis_rotation) * cxp - Math.sin(x_axis_rotation) * cyp + (start.x + end.x) / 2;
      const cy = Math.sin(x_axis_rotation) * cxp + Math.cos(x_axis_rotation) * cyp + (start.y + end.y) / 2;
      const theta = svgAngle(1, 0, (x1p - cxp) / rx, (y1p - cyp) / ry);
      const delta = svgAngle((x1p - cxp) / rx, (y1p - cyp) / ry, (-x1p - cxp) / rx, (-y1p - cyp) / ry) % (Math.PI * 2);
      path.currentPath.absellipse(cx, cy, rx, ry, theta, theta + delta, sweep_flag === 0, x_axis_rotation);
    }
    function svgAngle(ux, uy, vx, vy) {
      const dot2 = ux * vx + uy * vy;
      const len = Math.sqrt(ux * ux + uy * uy) * Math.sqrt(vx * vx + vy * vy);
      let ang = Math.acos(Math.max(-1, Math.min(1, dot2 / len)));
      if (ux * vy - uy * vx < 0) ang = -ang;
      return ang;
    }
    function parseRectNode(node) {
      const x = parseFloatWithUnits(node.getAttribute("x") || 0);
      const y = parseFloatWithUnits(node.getAttribute("y") || 0);
      const rx = parseFloatWithUnits(node.getAttribute("rx") || node.getAttribute("ry") || 0);
      const ry = parseFloatWithUnits(node.getAttribute("ry") || node.getAttribute("rx") || 0);
      const w = parseFloatWithUnits(node.getAttribute("width"));
      const h = parseFloatWithUnits(node.getAttribute("height"));
      const bci = 1 - 0.551915024494;
      const path = new ShapePath();
      path.moveTo(x + rx, y);
      path.lineTo(x + w - rx, y);
      if (rx !== 0 || ry !== 0) {
        path.bezierCurveTo(
          x + w - rx * bci,
          y,
          x + w,
          y + ry * bci,
          x + w,
          y + ry
        );
      }
      path.lineTo(x + w, y + h - ry);
      if (rx !== 0 || ry !== 0) {
        path.bezierCurveTo(
          x + w,
          y + h - ry * bci,
          x + w - rx * bci,
          y + h,
          x + w - rx,
          y + h
        );
      }
      path.lineTo(x + rx, y + h);
      if (rx !== 0 || ry !== 0) {
        path.bezierCurveTo(
          x + rx * bci,
          y + h,
          x,
          y + h - ry * bci,
          x,
          y + h - ry
        );
      }
      path.lineTo(x, y + ry);
      if (rx !== 0 || ry !== 0) {
        path.bezierCurveTo(x, y + ry * bci, x + rx * bci, y, x + rx, y);
      }
      return path;
    }
    function parsePolygonNode(node) {
      function iterator(match, a, b) {
        const x = parseFloatWithUnits(a);
        const y = parseFloatWithUnits(b);
        if (index === 0) {
          path.moveTo(x, y);
        } else {
          path.lineTo(x, y);
        }
        index++;
      }
      const regex = /([+-]?\d*\.?\d+(?:e[+-]?\d+)?)(?:,|\s)([+-]?\d*\.?\d+(?:e[+-]?\d+)?)/g;
      const path = new ShapePath();
      let index = 0;
      node.getAttribute("points").replace(regex, iterator);
      path.currentPath.autoClose = true;
      return path;
    }
    function parsePolylineNode(node) {
      function iterator(match, a, b) {
        const x = parseFloatWithUnits(a);
        const y = parseFloatWithUnits(b);
        if (index === 0) {
          path.moveTo(x, y);
        } else {
          path.lineTo(x, y);
        }
        index++;
      }
      const regex = /([+-]?\d*\.?\d+(?:e[+-]?\d+)?)(?:,|\s)([+-]?\d*\.?\d+(?:e[+-]?\d+)?)/g;
      const path = new ShapePath();
      let index = 0;
      node.getAttribute("points").replace(regex, iterator);
      path.currentPath.autoClose = false;
      return path;
    }
    function parseCircleNode(node) {
      const x = parseFloatWithUnits(node.getAttribute("cx") || 0);
      const y = parseFloatWithUnits(node.getAttribute("cy") || 0);
      const r = parseFloatWithUnits(node.getAttribute("r") || 0);
      const subpath = new Path();
      subpath.absarc(x, y, r, 0, Math.PI * 2);
      const path = new ShapePath();
      path.subPaths.push(subpath);
      return path;
    }
    function parseEllipseNode(node) {
      const x = parseFloatWithUnits(node.getAttribute("cx") || 0);
      const y = parseFloatWithUnits(node.getAttribute("cy") || 0);
      const rx = parseFloatWithUnits(node.getAttribute("rx") || 0);
      const ry = parseFloatWithUnits(node.getAttribute("ry") || 0);
      const subpath = new Path();
      subpath.absellipse(x, y, rx, ry, 0, Math.PI * 2);
      const path = new ShapePath();
      path.subPaths.push(subpath);
      return path;
    }
    function parseLineNode(node) {
      const x1 = parseFloatWithUnits(node.getAttribute("x1") || 0);
      const y1 = parseFloatWithUnits(node.getAttribute("y1") || 0);
      const x2 = parseFloatWithUnits(node.getAttribute("x2") || 0);
      const y2 = parseFloatWithUnits(node.getAttribute("y2") || 0);
      const path = new ShapePath();
      path.moveTo(x1, y1);
      path.lineTo(x2, y2);
      path.currentPath.autoClose = false;
      return path;
    }
    function parseStyle(node, style) {
      style = Object.assign({}, style);
      let stylesheetStyles = {};
      if (node.hasAttribute("class")) {
        const classSelectors = node.getAttribute("class").split(/\s/).filter(Boolean).map((i) => i.trim());
        for (let i = 0; i < classSelectors.length; i++) {
          stylesheetStyles = Object.assign(stylesheetStyles, stylesheets["." + classSelectors[i]]);
        }
      }
      if (node.hasAttribute("id")) {
        stylesheetStyles = Object.assign(stylesheetStyles, stylesheets["#" + node.getAttribute("id")]);
      }
      function addStyle(svgName, jsName, adjustFunction) {
        if (adjustFunction === void 0) adjustFunction = function copy(v) {
          if (v.startsWith("url")) console.warn("SVGLoader: url access in attributes is not implemented.");
          return v;
        };
        if (node.hasAttribute(svgName)) style[jsName] = adjustFunction(node.getAttribute(svgName));
        if (stylesheetStyles[svgName]) style[jsName] = adjustFunction(stylesheetStyles[svgName]);
        if (node.style && node.style[svgName] !== "") style[jsName] = adjustFunction(node.style[svgName]);
      }
      function clamp2(v) {
        return Math.max(0, Math.min(1, parseFloatWithUnits(v)));
      }
      function positive(v) {
        return Math.max(0, parseFloatWithUnits(v));
      }
      addStyle("fill", "fill");
      addStyle("fill-opacity", "fillOpacity", clamp2);
      addStyle("fill-rule", "fillRule");
      addStyle("opacity", "opacity", clamp2);
      addStyle("stroke", "stroke");
      addStyle("stroke-opacity", "strokeOpacity", clamp2);
      addStyle("stroke-width", "strokeWidth", positive);
      addStyle("stroke-linejoin", "strokeLineJoin");
      addStyle("stroke-linecap", "strokeLineCap");
      addStyle("stroke-miterlimit", "strokeMiterLimit", positive);
      addStyle("visibility", "visibility");
      return style;
    }
    function getReflection(a, b) {
      return a - (b - a);
    }
    function parseFloats(input, flags, stride) {
      if (typeof input !== "string") {
        throw new TypeError("Invalid input: " + typeof input);
      }
      const RE = {
        WHITESPACE: /[ \t\r\n]/,
        DIGIT: /[\d]/,
        SIGN: /[-+]/,
        POINT: /\./,
        COMMA: /,/,
        EXP: /e/i,
        FLAGS: /[01]/
      };
      const SEP = 0;
      const INT = 1;
      const FLOAT = 2;
      const EXP = 3;
      let state = SEP;
      let seenComma = true;
      let number = "", exponent = "";
      const result = [];
      function throwSyntaxError(current2, i, partial) {
        const error2 = new SyntaxError('Unexpected character "' + current2 + '" at index ' + i + ".");
        error2.partial = partial;
        throw error2;
      }
      function newNumber() {
        if (number !== "") {
          if (exponent === "") result.push(Number(number));
          else result.push(Number(number) * Math.pow(10, Number(exponent)));
        }
        number = "";
        exponent = "";
      }
      let current;
      const length2 = input.length;
      for (let i = 0; i < length2; i++) {
        current = input[i];
        if (Array.isArray(flags) && flags.includes(result.length % stride) && RE.FLAGS.test(current)) {
          state = INT;
          number = current;
          newNumber();
          continue;
        }
        if (state === SEP) {
          if (RE.WHITESPACE.test(current)) {
            continue;
          }
          if (RE.DIGIT.test(current) || RE.SIGN.test(current)) {
            state = INT;
            number = current;
            continue;
          }
          if (RE.POINT.test(current)) {
            state = FLOAT;
            number = current;
            continue;
          }
          if (RE.COMMA.test(current)) {
            if (seenComma) {
              throwSyntaxError(current, i, result);
            }
            seenComma = true;
          }
        }
        if (state === INT) {
          if (RE.DIGIT.test(current)) {
            number += current;
            continue;
          }
          if (RE.POINT.test(current)) {
            number += current;
            state = FLOAT;
            continue;
          }
          if (RE.EXP.test(current)) {
            state = EXP;
            continue;
          }
          if (RE.SIGN.test(current) && number.length === 1 && RE.SIGN.test(number[0])) {
            throwSyntaxError(current, i, result);
          }
        }
        if (state === FLOAT) {
          if (RE.DIGIT.test(current)) {
            number += current;
            continue;
          }
          if (RE.EXP.test(current)) {
            state = EXP;
            continue;
          }
          if (RE.POINT.test(current) && number[number.length - 1] === ".") {
            throwSyntaxError(current, i, result);
          }
        }
        if (state === EXP) {
          if (RE.DIGIT.test(current)) {
            exponent += current;
            continue;
          }
          if (RE.SIGN.test(current)) {
            if (exponent === "") {
              exponent += current;
              continue;
            }
            if (exponent.length === 1 && RE.SIGN.test(exponent)) {
              throwSyntaxError(current, i, result);
            }
          }
        }
        if (RE.WHITESPACE.test(current)) {
          newNumber();
          state = SEP;
          seenComma = false;
        } else if (RE.COMMA.test(current)) {
          newNumber();
          state = SEP;
          seenComma = true;
        } else if (RE.SIGN.test(current)) {
          newNumber();
          state = INT;
          number = current;
        } else if (RE.POINT.test(current)) {
          newNumber();
          state = FLOAT;
          number = current;
        } else {
          throwSyntaxError(current, i, result);
        }
      }
      newNumber();
      return result;
    }
    const units = ["mm", "cm", "in", "pt", "pc", "px"];
    const unitConversion = {
      "mm": {
        "mm": 1,
        "cm": 0.1,
        "in": 1 / 25.4,
        "pt": 72 / 25.4,
        "pc": 6 / 25.4,
        "px": -1
      },
      "cm": {
        "mm": 10,
        "cm": 1,
        "in": 1 / 2.54,
        "pt": 72 / 2.54,
        "pc": 6 / 2.54,
        "px": -1
      },
      "in": {
        "mm": 25.4,
        "cm": 2.54,
        "in": 1,
        "pt": 72,
        "pc": 6,
        "px": -1
      },
      "pt": {
        "mm": 25.4 / 72,
        "cm": 2.54 / 72,
        "in": 1 / 72,
        "pt": 1,
        "pc": 6 / 72,
        "px": -1
      },
      "pc": {
        "mm": 25.4 / 6,
        "cm": 2.54 / 6,
        "in": 1 / 6,
        "pt": 72 / 6,
        "pc": 1,
        "px": -1
      },
      "px": {
        "px": 1
      }
    };
    function parseFloatWithUnits(string) {
      let theUnit = "px";
      if (typeof string === "string" || string instanceof String) {
        for (let i = 0, n = units.length; i < n; i++) {
          const u = units[i];
          if (string.endsWith(u)) {
            theUnit = u;
            string = string.substring(0, string.length - u.length);
            break;
          }
        }
      }
      let scale = void 0;
      if (theUnit === "px" && scope.defaultUnit !== "px") {
        scale = unitConversion["in"][scope.defaultUnit] / scope.defaultDPI;
      } else {
        scale = unitConversion[theUnit][scope.defaultUnit];
        if (scale < 0) {
          scale = unitConversion[theUnit]["in"] * scope.defaultDPI;
        }
      }
      return scale * parseFloat(string);
    }
    function getNodeTransform(node) {
      if (!(node.hasAttribute("transform") || node.nodeName === "use" && (node.hasAttribute("x") || node.hasAttribute("y")))) {
        return null;
      }
      const transform = parseNodeTransform(node);
      if (transformStack.length > 0) {
        transform.premultiply(transformStack[transformStack.length - 1]);
      }
      currentTransform.copy(transform);
      transformStack.push(transform);
      return transform;
    }
    function parseNodeTransform(node) {
      const transform = new Matrix3$1();
      const currentTransform2 = tempTransform0;
      if (node.nodeName === "use" && (node.hasAttribute("x") || node.hasAttribute("y"))) {
        const tx = parseFloatWithUnits(node.getAttribute("x"));
        const ty = parseFloatWithUnits(node.getAttribute("y"));
        transform.translate(tx, ty);
      }
      if (node.hasAttribute("transform")) {
        const transformsTexts = node.getAttribute("transform").split(")");
        for (let tIndex = transformsTexts.length - 1; tIndex >= 0; tIndex--) {
          const transformText = transformsTexts[tIndex].trim();
          if (transformText === "") continue;
          const openParPos = transformText.indexOf("(");
          const closeParPos = transformText.length;
          if (openParPos > 0 && openParPos < closeParPos) {
            const transformType = transformText.slice(0, openParPos);
            const array = parseFloats(transformText.slice(openParPos + 1));
            currentTransform2.identity();
            switch (transformType) {
              case "translate":
                if (array.length >= 1) {
                  const tx = array[0];
                  let ty = 0;
                  if (array.length >= 2) {
                    ty = array[1];
                  }
                  currentTransform2.translate(tx, ty);
                }
                break;
              case "rotate":
                if (array.length >= 1) {
                  let angle = 0;
                  let cx = 0;
                  let cy = 0;
                  angle = array[0] * Math.PI / 180;
                  if (array.length >= 3) {
                    cx = array[1];
                    cy = array[2];
                  }
                  tempTransform1.makeTranslation(-cx, -cy);
                  tempTransform2.makeRotation(angle);
                  tempTransform3.multiplyMatrices(tempTransform2, tempTransform1);
                  tempTransform1.makeTranslation(cx, cy);
                  currentTransform2.multiplyMatrices(tempTransform1, tempTransform3);
                }
                break;
              case "scale":
                if (array.length >= 1) {
                  const scaleX = array[0];
                  let scaleY = scaleX;
                  if (array.length >= 2) {
                    scaleY = array[1];
                  }
                  currentTransform2.scale(scaleX, scaleY);
                }
                break;
              case "skewX":
                if (array.length === 1) {
                  currentTransform2.set(
                    1,
                    Math.tan(array[0] * Math.PI / 180),
                    0,
                    0,
                    1,
                    0,
                    0,
                    0,
                    1
                  );
                }
                break;
              case "skewY":
                if (array.length === 1) {
                  currentTransform2.set(
                    1,
                    0,
                    0,
                    Math.tan(array[0] * Math.PI / 180),
                    1,
                    0,
                    0,
                    0,
                    1
                  );
                }
                break;
              case "matrix":
                if (array.length === 6) {
                  currentTransform2.set(
                    array[0],
                    array[2],
                    array[4],
                    array[1],
                    array[3],
                    array[5],
                    0,
                    0,
                    1
                  );
                }
                break;
            }
          }
          transform.premultiply(currentTransform2);
        }
      }
      return transform;
    }
    function transformPath(path, m) {
      function transfVec2(v2) {
        tempV3.set(v2.x, v2.y, 1).applyMatrix3(m);
        v2.set(tempV3.x, tempV3.y);
      }
      function transfEllipseGeneric(curve) {
        const a = curve.xRadius;
        const b = curve.yRadius;
        const cosTheta = Math.cos(curve.aRotation);
        const sinTheta = Math.sin(curve.aRotation);
        const v1 = new Vector3$1(a * cosTheta, a * sinTheta, 0);
        const v2 = new Vector3$1(-b * sinTheta, b * cosTheta, 0);
        const f1 = v1.applyMatrix3(m);
        const f2 = v2.applyMatrix3(m);
        const mF = tempTransform0.set(
          f1.x,
          f2.x,
          0,
          f1.y,
          f2.y,
          0,
          0,
          0,
          1
        );
        const mFInv = tempTransform1.copy(mF).invert();
        const mFInvT = tempTransform2.copy(mFInv).transpose();
        const mQ = mFInvT.multiply(mFInv);
        const mQe = mQ.elements;
        const ed = eigenDecomposition(mQe[0], mQe[1], mQe[4]);
        const rt1sqrt = Math.sqrt(ed.rt1);
        const rt2sqrt = Math.sqrt(ed.rt2);
        curve.xRadius = 1 / rt1sqrt;
        curve.yRadius = 1 / rt2sqrt;
        curve.aRotation = Math.atan2(ed.sn, ed.cs);
        const isFullEllipse = (curve.aEndAngle - curve.aStartAngle) % (2 * Math.PI) < Number.EPSILON;
        if (!isFullEllipse) {
          const mDsqrt = tempTransform1.set(
            rt1sqrt,
            0,
            0,
            0,
            rt2sqrt,
            0,
            0,
            0,
            1
          );
          const mRT = tempTransform2.set(
            ed.cs,
            ed.sn,
            0,
            -ed.sn,
            ed.cs,
            0,
            0,
            0,
            1
          );
          const mDRF = mDsqrt.multiply(mRT).multiply(mF);
          const transformAngle = (phi) => {
            const { x: cosR, y: sinR } = new Vector3$1(Math.cos(phi), Math.sin(phi), 0).applyMatrix3(mDRF);
            return Math.atan2(sinR, cosR);
          };
          curve.aStartAngle = transformAngle(curve.aStartAngle);
          curve.aEndAngle = transformAngle(curve.aEndAngle);
          if (isTransformFlipped(m)) {
            curve.aClockwise = !curve.aClockwise;
          }
        }
      }
      function transfEllipseNoSkew(curve) {
        const sx = getTransformScaleX(m);
        const sy = getTransformScaleY(m);
        curve.xRadius *= sx;
        curve.yRadius *= sy;
        const theta = sx > Number.EPSILON ? Math.atan2(m.elements[1], m.elements[0]) : Math.atan2(-m.elements[3], m.elements[4]);
        curve.aRotation += theta;
        if (isTransformFlipped(m)) {
          curve.aStartAngle *= -1;
          curve.aEndAngle *= -1;
          curve.aClockwise = !curve.aClockwise;
        }
      }
      const subPaths = path.subPaths;
      for (let i = 0, n = subPaths.length; i < n; i++) {
        const subPath = subPaths[i];
        const curves = subPath.curves;
        for (let j = 0; j < curves.length; j++) {
          const curve = curves[j];
          if (curve.isLineCurve) {
            transfVec2(curve.v1);
            transfVec2(curve.v2);
          } else if (curve.isCubicBezierCurve) {
            transfVec2(curve.v0);
            transfVec2(curve.v1);
            transfVec2(curve.v2);
            transfVec2(curve.v3);
          } else if (curve.isQuadraticBezierCurve) {
            transfVec2(curve.v0);
            transfVec2(curve.v1);
            transfVec2(curve.v2);
          } else if (curve.isEllipseCurve) {
            tempV2.set(curve.aX, curve.aY);
            transfVec2(tempV2);
            curve.aX = tempV2.x;
            curve.aY = tempV2.y;
            if (isTransformSkewed(m)) {
              transfEllipseGeneric(curve);
            } else {
              transfEllipseNoSkew(curve);
            }
          }
        }
      }
    }
    function isTransformFlipped(m) {
      const te = m.elements;
      return te[0] * te[4] - te[1] * te[3] < 0;
    }
    function isTransformSkewed(m) {
      const te = m.elements;
      const basisDot = te[0] * te[3] + te[1] * te[4];
      if (basisDot === 0) return false;
      const sx = getTransformScaleX(m);
      const sy = getTransformScaleY(m);
      return Math.abs(basisDot / (sx * sy)) > Number.EPSILON;
    }
    function getTransformScaleX(m) {
      const te = m.elements;
      return Math.sqrt(te[0] * te[0] + te[1] * te[1]);
    }
    function getTransformScaleY(m) {
      const te = m.elements;
      return Math.sqrt(te[3] * te[3] + te[4] * te[4]);
    }
    function eigenDecomposition(A, B, C) {
      let rt1, rt2, cs, sn, t;
      const sm = A + C;
      const df = A - C;
      const rt = Math.sqrt(df * df + 4 * B * B);
      if (sm > 0) {
        rt1 = 0.5 * (sm + rt);
        t = 1 / rt1;
        rt2 = A * t * C - B * t * B;
      } else if (sm < 0) {
        rt2 = 0.5 * (sm - rt);
      } else {
        rt1 = 0.5 * rt;
        rt2 = -0.5 * rt;
      }
      if (df > 0) {
        cs = df + rt;
      } else {
        cs = df - rt;
      }
      if (Math.abs(cs) > 2 * Math.abs(B)) {
        t = -2 * B / cs;
        sn = 1 / Math.sqrt(1 + t * t);
        cs = t * sn;
      } else if (Math.abs(B) === 0) {
        cs = 1;
        sn = 0;
      } else {
        t = -0.5 * cs / B;
        cs = 1 / Math.sqrt(1 + t * t);
        sn = t * cs;
      }
      if (df > 0) {
        t = cs;
        cs = -sn;
        sn = t;
      }
      return { rt1, rt2, cs, sn };
    }
    const paths = [];
    const stylesheets = {};
    const transformStack = [];
    const tempTransform0 = new Matrix3$1();
    const tempTransform1 = new Matrix3$1();
    const tempTransform2 = new Matrix3$1();
    const tempTransform3 = new Matrix3$1();
    const tempV2 = new Vector2$1();
    const tempV3 = new Vector3$1();
    const currentTransform = new Matrix3$1();
    const xml = new DOMParser().parseFromString(text, "image/svg+xml");
    parseNode(xml.documentElement, {
      fill: "#000",
      fillOpacity: 1,
      strokeOpacity: 1,
      strokeWidth: 1,
      strokeLineJoin: "miter",
      strokeLineCap: "butt",
      strokeMiterLimit: 4
    });
    const data = { paths, xml: xml.documentElement };
    return data;
  }
  static createShapes(shapePath) {
    const BIGNUMBER = 999999999;
    const IntersectionLocationType = {
      ORIGIN: 0,
      DESTINATION: 1,
      BETWEEN: 2,
      LEFT: 3,
      RIGHT: 4,
      BEHIND: 5,
      BEYOND: 6
    };
    const classifyResult = {
      loc: IntersectionLocationType.ORIGIN,
      t: 0
    };
    function findEdgeIntersection(a0, a1, b0, b1) {
      const x1 = a0.x;
      const x2 = a1.x;
      const x3 = b0.x;
      const x4 = b1.x;
      const y1 = a0.y;
      const y2 = a1.y;
      const y3 = b0.y;
      const y4 = b1.y;
      const nom1 = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3);
      const nom2 = (x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3);
      const denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
      const t1 = nom1 / denom;
      const t2 = nom2 / denom;
      if (denom === 0 && nom1 !== 0 || t1 <= 0 || t1 >= 1 || t2 < 0 || t2 > 1) {
        return null;
      } else if (nom1 === 0 && denom === 0) {
        for (let i = 0; i < 2; i++) {
          classifyPoint(i === 0 ? b0 : b1, a0, a1);
          if (classifyResult.loc == IntersectionLocationType.ORIGIN) {
            const point = i === 0 ? b0 : b1;
            return { x: point.x, y: point.y, t: classifyResult.t };
          } else if (classifyResult.loc == IntersectionLocationType.BETWEEN) {
            const x = +(x1 + classifyResult.t * (x2 - x1)).toPrecision(10);
            const y = +(y1 + classifyResult.t * (y2 - y1)).toPrecision(10);
            return { x, y, t: classifyResult.t };
          }
        }
        return null;
      } else {
        for (let i = 0; i < 2; i++) {
          classifyPoint(i === 0 ? b0 : b1, a0, a1);
          if (classifyResult.loc == IntersectionLocationType.ORIGIN) {
            const point = i === 0 ? b0 : b1;
            return { x: point.x, y: point.y, t: classifyResult.t };
          }
        }
        const x = +(x1 + t1 * (x2 - x1)).toPrecision(10);
        const y = +(y1 + t1 * (y2 - y1)).toPrecision(10);
        return { x, y, t: t1 };
      }
    }
    function classifyPoint(p, edgeStart, edgeEnd) {
      const ax = edgeEnd.x - edgeStart.x;
      const ay = edgeEnd.y - edgeStart.y;
      const bx = p.x - edgeStart.x;
      const by = p.y - edgeStart.y;
      const sa = ax * by - bx * ay;
      if (p.x === edgeStart.x && p.y === edgeStart.y) {
        classifyResult.loc = IntersectionLocationType.ORIGIN;
        classifyResult.t = 0;
        return;
      }
      if (p.x === edgeEnd.x && p.y === edgeEnd.y) {
        classifyResult.loc = IntersectionLocationType.DESTINATION;
        classifyResult.t = 1;
        return;
      }
      if (sa < -Number.EPSILON) {
        classifyResult.loc = IntersectionLocationType.LEFT;
        return;
      }
      if (sa > Number.EPSILON) {
        classifyResult.loc = IntersectionLocationType.RIGHT;
        return;
      }
      if (ax * bx < 0 || ay * by < 0) {
        classifyResult.loc = IntersectionLocationType.BEHIND;
        return;
      }
      if (Math.sqrt(ax * ax + ay * ay) < Math.sqrt(bx * bx + by * by)) {
        classifyResult.loc = IntersectionLocationType.BEYOND;
        return;
      }
      let t;
      if (ax !== 0) {
        t = bx / ax;
      } else {
        t = by / ay;
      }
      classifyResult.loc = IntersectionLocationType.BETWEEN;
      classifyResult.t = t;
    }
    function getIntersections(path1, path2) {
      const intersectionsRaw = [];
      const intersections = [];
      for (let index = 1; index < path1.length; index++) {
        const path1EdgeStart = path1[index - 1];
        const path1EdgeEnd = path1[index];
        for (let index2 = 1; index2 < path2.length; index2++) {
          const path2EdgeStart = path2[index2 - 1];
          const path2EdgeEnd = path2[index2];
          const intersection = findEdgeIntersection(path1EdgeStart, path1EdgeEnd, path2EdgeStart, path2EdgeEnd);
          if (intersection !== null && intersectionsRaw.find((i) => i.t <= intersection.t + Number.EPSILON && i.t >= intersection.t - Number.EPSILON) === void 0) {
            intersectionsRaw.push(intersection);
            intersections.push(new Vector2$1(intersection.x, intersection.y));
          }
        }
      }
      return intersections;
    }
    function getScanlineIntersections(scanline, boundingBox2, paths) {
      const center = new Vector2$1();
      boundingBox2.getCenter(center);
      const allIntersections = [];
      paths.forEach((path) => {
        if (path.boundingBox.containsPoint(center)) {
          const intersections = getIntersections(scanline, path.points);
          intersections.forEach((p) => {
            allIntersections.push({ identifier: path.identifier, isCW: path.isCW, point: p });
          });
        }
      });
      allIntersections.sort((i1, i2) => {
        return i1.point.x - i2.point.x;
      });
      return allIntersections;
    }
    function isHoleTo(simplePath, allPaths, scanlineMinX2, scanlineMaxX2, _fillRule) {
      if (_fillRule === null || _fillRule === void 0 || _fillRule === "") {
        _fillRule = "nonzero";
      }
      const centerBoundingBox = new Vector2$1();
      simplePath.boundingBox.getCenter(centerBoundingBox);
      const scanline = [new Vector2$1(scanlineMinX2, centerBoundingBox.y), new Vector2$1(scanlineMaxX2, centerBoundingBox.y)];
      const scanlineIntersections = getScanlineIntersections(scanline, simplePath.boundingBox, allPaths);
      scanlineIntersections.sort((i1, i2) => {
        return i1.point.x - i2.point.x;
      });
      const baseIntersections = [];
      const otherIntersections = [];
      scanlineIntersections.forEach((i2) => {
        if (i2.identifier === simplePath.identifier) {
          baseIntersections.push(i2);
        } else {
          otherIntersections.push(i2);
        }
      });
      const firstXOfPath = baseIntersections[0].point.x;
      const stack = [];
      let i = 0;
      while (i < otherIntersections.length && otherIntersections[i].point.x < firstXOfPath) {
        if (stack.length > 0 && stack[stack.length - 1] === otherIntersections[i].identifier) {
          stack.pop();
        } else {
          stack.push(otherIntersections[i].identifier);
        }
        i++;
      }
      stack.push(simplePath.identifier);
      if (_fillRule === "evenodd") {
        const isHole = stack.length % 2 === 0 ? true : false;
        const isHoleFor = stack[stack.length - 2];
        return { identifier: simplePath.identifier, isHole, for: isHoleFor };
      } else if (_fillRule === "nonzero") {
        let isHole = true;
        let isHoleFor = null;
        let lastCWValue = null;
        for (let i2 = 0; i2 < stack.length; i2++) {
          const identifier = stack[i2];
          if (isHole) {
            lastCWValue = allPaths[identifier].isCW;
            isHole = false;
            isHoleFor = identifier;
          } else if (lastCWValue !== allPaths[identifier].isCW) {
            lastCWValue = allPaths[identifier].isCW;
            isHole = true;
          }
        }
        return { identifier: simplePath.identifier, isHole, for: isHoleFor };
      } else {
        console.warn('fill-rule: "' + _fillRule + '" is currently not implemented.');
      }
    }
    let scanlineMinX = BIGNUMBER;
    let scanlineMaxX = -999999999;
    let simplePaths = shapePath.subPaths.map((p) => {
      const points = p.getPoints();
      let maxY = -999999999;
      let minY = BIGNUMBER;
      let maxX = -999999999;
      let minX = BIGNUMBER;
      for (let i = 0; i < points.length; i++) {
        const p2 = points[i];
        if (p2.y > maxY) {
          maxY = p2.y;
        }
        if (p2.y < minY) {
          minY = p2.y;
        }
        if (p2.x > maxX) {
          maxX = p2.x;
        }
        if (p2.x < minX) {
          minX = p2.x;
        }
      }
      if (scanlineMaxX <= maxX) {
        scanlineMaxX = maxX + 1;
      }
      if (scanlineMinX >= minX) {
        scanlineMinX = minX - 1;
      }
      return { curves: p.curves, points, isCW: ShapeUtils.isClockWise(points), identifier: -1, boundingBox: new Box2(new Vector2$1(minX, minY), new Vector2$1(maxX, maxY)) };
    });
    simplePaths = simplePaths.filter((sp) => sp.points.length > 1);
    for (let identifier = 0; identifier < simplePaths.length; identifier++) {
      simplePaths[identifier].identifier = identifier;
    }
    const isAHole = simplePaths.map((p) => isHoleTo(p, simplePaths, scanlineMinX, scanlineMaxX, shapePath.userData ? shapePath.userData.style.fillRule : void 0));
    const shapesToReturn = [];
    simplePaths.forEach((p) => {
      const amIAHole = isAHole[p.identifier];
      if (!amIAHole.isHole) {
        const shape = new Shape$1();
        shape.curves = p.curves;
        const holes = isAHole.filter((h) => h.isHole && h.for === p.identifier);
        holes.forEach((h) => {
          const hole = simplePaths[h.identifier];
          const path = new Path();
          path.curves = hole.curves;
          shape.holes.push(path);
        });
        shapesToReturn.push(shape);
      }
    });
    return shapesToReturn;
  }
  static getStrokeStyle(width, color2, lineJoin, lineCap, miterLimit) {
    width = width !== void 0 ? width : 1;
    color2 = color2 !== void 0 ? color2 : "#000";
    lineJoin = lineJoin !== void 0 ? lineJoin : "miter";
    lineCap = lineCap !== void 0 ? lineCap : "butt";
    miterLimit = miterLimit !== void 0 ? miterLimit : 4;
    return {
      strokeColor: color2,
      strokeWidth: width,
      strokeLineJoin: lineJoin,
      strokeLineCap: lineCap,
      strokeMiterLimit: miterLimit
    };
  }
  static pointsToStroke(points, style, arcDivisions, minDistance) {
    const vertices = [];
    const normals = [];
    const uvs = [];
    if (SVGLoader.pointsToStrokeWithBuffers(points, style, arcDivisions, minDistance, vertices, normals, uvs) === 0) {
      return null;
    }
    const geometry = new BufferGeometry();
    geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    geometry.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    geometry.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    return geometry;
  }
  static pointsToStrokeWithBuffers(points, style, arcDivisions, minDistance, vertices, normals, uvs, vertexOffset) {
    const tempV2_1 = new Vector2$1();
    const tempV2_2 = new Vector2$1();
    const tempV2_3 = new Vector2$1();
    const tempV2_4 = new Vector2$1();
    const tempV2_5 = new Vector2$1();
    const tempV2_6 = new Vector2$1();
    const tempV2_7 = new Vector2$1();
    const lastPointL = new Vector2$1();
    const lastPointR = new Vector2$1();
    const point0L = new Vector2$1();
    const point0R = new Vector2$1();
    const currentPointL = new Vector2$1();
    const currentPointR = new Vector2$1();
    const nextPointL = new Vector2$1();
    const nextPointR = new Vector2$1();
    const innerPoint = new Vector2$1();
    const outerPoint = new Vector2$1();
    arcDivisions = arcDivisions !== void 0 ? arcDivisions : 12;
    minDistance = minDistance !== void 0 ? minDistance : 1e-3;
    vertexOffset = vertexOffset !== void 0 ? vertexOffset : 0;
    points = removeDuplicatedPoints(points);
    const numPoints = points.length;
    if (numPoints < 2) return 0;
    const isClosed = points[0].equals(points[numPoints - 1]);
    let currentPoint;
    let previousPoint = points[0];
    let nextPoint;
    const strokeWidth2 = style.strokeWidth / 2;
    const deltaU = 1 / (numPoints - 1);
    let u0 = 0, u1;
    let innerSideModified;
    let joinIsOnLeftSide;
    let isMiter;
    let initialJoinIsOnLeftSide = false;
    let numVertices = 0;
    let currentCoordinate = vertexOffset * 3;
    let currentCoordinateUV = vertexOffset * 2;
    getNormal(points[0], points[1], tempV2_1).multiplyScalar(strokeWidth2);
    lastPointL.copy(points[0]).sub(tempV2_1);
    lastPointR.copy(points[0]).add(tempV2_1);
    point0L.copy(lastPointL);
    point0R.copy(lastPointR);
    for (let iPoint = 1; iPoint < numPoints; iPoint++) {
      currentPoint = points[iPoint];
      if (iPoint === numPoints - 1) {
        if (isClosed) {
          nextPoint = points[1];
        } else nextPoint = void 0;
      } else {
        nextPoint = points[iPoint + 1];
      }
      const normal1 = tempV2_1;
      getNormal(previousPoint, currentPoint, normal1);
      tempV2_3.copy(normal1).multiplyScalar(strokeWidth2);
      currentPointL.copy(currentPoint).sub(tempV2_3);
      currentPointR.copy(currentPoint).add(tempV2_3);
      u1 = u0 + deltaU;
      innerSideModified = false;
      if (nextPoint !== void 0) {
        getNormal(currentPoint, nextPoint, tempV2_2);
        tempV2_3.copy(tempV2_2).multiplyScalar(strokeWidth2);
        nextPointL.copy(currentPoint).sub(tempV2_3);
        nextPointR.copy(currentPoint).add(tempV2_3);
        joinIsOnLeftSide = true;
        tempV2_3.subVectors(nextPoint, previousPoint);
        if (normal1.dot(tempV2_3) < 0) {
          joinIsOnLeftSide = false;
        }
        if (iPoint === 1) initialJoinIsOnLeftSide = joinIsOnLeftSide;
        tempV2_3.subVectors(nextPoint, currentPoint);
        tempV2_3.normalize();
        const dot2 = Math.abs(normal1.dot(tempV2_3));
        if (dot2 > Number.EPSILON) {
          const miterSide = strokeWidth2 / dot2;
          tempV2_3.multiplyScalar(-miterSide);
          tempV2_4.subVectors(currentPoint, previousPoint);
          tempV2_5.copy(tempV2_4).setLength(miterSide).add(tempV2_3);
          innerPoint.copy(tempV2_5).negate();
          const miterLength2 = tempV2_5.length();
          const segmentLengthPrev = tempV2_4.length();
          tempV2_4.divideScalar(segmentLengthPrev);
          tempV2_6.subVectors(nextPoint, currentPoint);
          const segmentLengthNext = tempV2_6.length();
          tempV2_6.divideScalar(segmentLengthNext);
          if (tempV2_4.dot(innerPoint) < segmentLengthPrev && tempV2_6.dot(innerPoint) < segmentLengthNext) {
            innerSideModified = true;
          }
          outerPoint.copy(tempV2_5).add(currentPoint);
          innerPoint.add(currentPoint);
          isMiter = false;
          if (innerSideModified) {
            if (joinIsOnLeftSide) {
              nextPointR.copy(innerPoint);
              currentPointR.copy(innerPoint);
            } else {
              nextPointL.copy(innerPoint);
              currentPointL.copy(innerPoint);
            }
          } else {
            makeSegmentTriangles();
          }
          switch (style.strokeLineJoin) {
            case "bevel":
              makeSegmentWithBevelJoin(joinIsOnLeftSide, innerSideModified, u1);
              break;
            case "round":
              createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide, innerSideModified);
              if (joinIsOnLeftSide) {
                makeCircularSector(currentPoint, currentPointL, nextPointL, u1, 0);
              } else {
                makeCircularSector(currentPoint, nextPointR, currentPointR, u1, 1);
              }
              break;
            case "miter":
            case "miter-clip":
            default:
              const miterFraction = strokeWidth2 * style.strokeMiterLimit / miterLength2;
              if (miterFraction < 1) {
                if (style.strokeLineJoin !== "miter-clip") {
                  makeSegmentWithBevelJoin(joinIsOnLeftSide, innerSideModified, u1);
                  break;
                } else {
                  createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide, innerSideModified);
                  if (joinIsOnLeftSide) {
                    tempV2_6.subVectors(outerPoint, currentPointL).multiplyScalar(miterFraction).add(currentPointL);
                    tempV2_7.subVectors(outerPoint, nextPointL).multiplyScalar(miterFraction).add(nextPointL);
                    addVertex(currentPointL, u1, 0);
                    addVertex(tempV2_6, u1, 0);
                    addVertex(currentPoint, u1, 0.5);
                    addVertex(currentPoint, u1, 0.5);
                    addVertex(tempV2_6, u1, 0);
                    addVertex(tempV2_7, u1, 0);
                    addVertex(currentPoint, u1, 0.5);
                    addVertex(tempV2_7, u1, 0);
                    addVertex(nextPointL, u1, 0);
                  } else {
                    tempV2_6.subVectors(outerPoint, currentPointR).multiplyScalar(miterFraction).add(currentPointR);
                    tempV2_7.subVectors(outerPoint, nextPointR).multiplyScalar(miterFraction).add(nextPointR);
                    addVertex(currentPointR, u1, 1);
                    addVertex(tempV2_6, u1, 1);
                    addVertex(currentPoint, u1, 0.5);
                    addVertex(currentPoint, u1, 0.5);
                    addVertex(tempV2_6, u1, 1);
                    addVertex(tempV2_7, u1, 1);
                    addVertex(currentPoint, u1, 0.5);
                    addVertex(tempV2_7, u1, 1);
                    addVertex(nextPointR, u1, 1);
                  }
                }
              } else {
                if (innerSideModified) {
                  if (joinIsOnLeftSide) {
                    addVertex(lastPointR, u0, 1);
                    addVertex(lastPointL, u0, 0);
                    addVertex(outerPoint, u1, 0);
                    addVertex(lastPointR, u0, 1);
                    addVertex(outerPoint, u1, 0);
                    addVertex(innerPoint, u1, 1);
                  } else {
                    addVertex(lastPointR, u0, 1);
                    addVertex(lastPointL, u0, 0);
                    addVertex(outerPoint, u1, 1);
                    addVertex(lastPointL, u0, 0);
                    addVertex(innerPoint, u1, 0);
                    addVertex(outerPoint, u1, 1);
                  }
                  if (joinIsOnLeftSide) {
                    nextPointL.copy(outerPoint);
                  } else {
                    nextPointR.copy(outerPoint);
                  }
                } else {
                  if (joinIsOnLeftSide) {
                    addVertex(currentPointL, u1, 0);
                    addVertex(outerPoint, u1, 0);
                    addVertex(currentPoint, u1, 0.5);
                    addVertex(currentPoint, u1, 0.5);
                    addVertex(outerPoint, u1, 0);
                    addVertex(nextPointL, u1, 0);
                  } else {
                    addVertex(currentPointR, u1, 1);
                    addVertex(outerPoint, u1, 1);
                    addVertex(currentPoint, u1, 0.5);
                    addVertex(currentPoint, u1, 0.5);
                    addVertex(outerPoint, u1, 1);
                    addVertex(nextPointR, u1, 1);
                  }
                }
                isMiter = true;
              }
              break;
          }
        } else {
          makeSegmentTriangles();
        }
      } else {
        makeSegmentTriangles();
      }
      if (!isClosed && iPoint === numPoints - 1) {
        addCapGeometry(points[0], point0L, point0R, joinIsOnLeftSide, true, u0);
      }
      u0 = u1;
      previousPoint = currentPoint;
      lastPointL.copy(nextPointL);
      lastPointR.copy(nextPointR);
    }
    if (!isClosed) {
      addCapGeometry(currentPoint, currentPointL, currentPointR, joinIsOnLeftSide, false, u1);
    } else if (innerSideModified && vertices) {
      let lastOuter = outerPoint;
      let lastInner = innerPoint;
      if (initialJoinIsOnLeftSide !== joinIsOnLeftSide) {
        lastOuter = innerPoint;
        lastInner = outerPoint;
      }
      if (joinIsOnLeftSide) {
        if (isMiter || initialJoinIsOnLeftSide) {
          lastInner.toArray(vertices, 0 * 3);
          lastInner.toArray(vertices, 3 * 3);
          if (isMiter) {
            lastOuter.toArray(vertices, 1 * 3);
          }
        }
      } else {
        if (isMiter || !initialJoinIsOnLeftSide) {
          lastInner.toArray(vertices, 1 * 3);
          lastInner.toArray(vertices, 3 * 3);
          if (isMiter) {
            lastOuter.toArray(vertices, 0 * 3);
          }
        }
      }
    }
    return numVertices;
    function getNormal(p1, p2, result) {
      result.subVectors(p2, p1);
      return result.set(-result.y, result.x).normalize();
    }
    function addVertex(position, u, v) {
      if (vertices) {
        vertices[currentCoordinate] = position.x;
        vertices[currentCoordinate + 1] = position.y;
        vertices[currentCoordinate + 2] = 0;
        if (normals) {
          normals[currentCoordinate] = 0;
          normals[currentCoordinate + 1] = 0;
          normals[currentCoordinate + 2] = 1;
        }
        currentCoordinate += 3;
        if (uvs) {
          uvs[currentCoordinateUV] = u;
          uvs[currentCoordinateUV + 1] = v;
          currentCoordinateUV += 2;
        }
      }
      numVertices += 3;
    }
    function makeCircularSector(center, p1, p2, u, v) {
      tempV2_1.copy(p1).sub(center).normalize();
      tempV2_2.copy(p2).sub(center).normalize();
      let angle = Math.PI;
      const dot2 = tempV2_1.dot(tempV2_2);
      if (Math.abs(dot2) < 1) angle = Math.abs(Math.acos(dot2));
      angle /= arcDivisions;
      tempV2_3.copy(p1);
      for (let i = 0, il = arcDivisions - 1; i < il; i++) {
        tempV2_4.copy(tempV2_3).rotateAround(center, angle);
        addVertex(tempV2_3, u, v);
        addVertex(tempV2_4, u, v);
        addVertex(center, u, 0.5);
        tempV2_3.copy(tempV2_4);
      }
      addVertex(tempV2_4, u, v);
      addVertex(p2, u, v);
      addVertex(center, u, 0.5);
    }
    function makeSegmentTriangles() {
      addVertex(lastPointR, u0, 1);
      addVertex(lastPointL, u0, 0);
      addVertex(currentPointL, u1, 0);
      addVertex(lastPointR, u0, 1);
      addVertex(currentPointL, u1, 0);
      addVertex(currentPointR, u1, 1);
    }
    function makeSegmentWithBevelJoin(joinIsOnLeftSide2, innerSideModified2, u) {
      if (innerSideModified2) {
        if (joinIsOnLeftSide2) {
          addVertex(lastPointR, u0, 1);
          addVertex(lastPointL, u0, 0);
          addVertex(currentPointL, u1, 0);
          addVertex(lastPointR, u0, 1);
          addVertex(currentPointL, u1, 0);
          addVertex(innerPoint, u1, 1);
          addVertex(currentPointL, u, 0);
          addVertex(nextPointL, u, 0);
          addVertex(innerPoint, u, 0.5);
        } else {
          addVertex(lastPointR, u0, 1);
          addVertex(lastPointL, u0, 0);
          addVertex(currentPointR, u1, 1);
          addVertex(lastPointL, u0, 0);
          addVertex(innerPoint, u1, 0);
          addVertex(currentPointR, u1, 1);
          addVertex(currentPointR, u, 1);
          addVertex(innerPoint, u, 0);
          addVertex(nextPointR, u, 1);
        }
      } else {
        if (joinIsOnLeftSide2) {
          addVertex(currentPointL, u, 0);
          addVertex(nextPointL, u, 0);
          addVertex(currentPoint, u, 0.5);
        } else {
          addVertex(currentPointR, u, 1);
          addVertex(nextPointR, u, 0);
          addVertex(currentPoint, u, 0.5);
        }
      }
    }
    function createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide2, innerSideModified2) {
      if (innerSideModified2) {
        if (joinIsOnLeftSide2) {
          addVertex(lastPointR, u0, 1);
          addVertex(lastPointL, u0, 0);
          addVertex(currentPointL, u1, 0);
          addVertex(lastPointR, u0, 1);
          addVertex(currentPointL, u1, 0);
          addVertex(innerPoint, u1, 1);
          addVertex(currentPointL, u0, 0);
          addVertex(currentPoint, u1, 0.5);
          addVertex(innerPoint, u1, 1);
          addVertex(currentPoint, u1, 0.5);
          addVertex(nextPointL, u0, 0);
          addVertex(innerPoint, u1, 1);
        } else {
          addVertex(lastPointR, u0, 1);
          addVertex(lastPointL, u0, 0);
          addVertex(currentPointR, u1, 1);
          addVertex(lastPointL, u0, 0);
          addVertex(innerPoint, u1, 0);
          addVertex(currentPointR, u1, 1);
          addVertex(currentPointR, u0, 1);
          addVertex(innerPoint, u1, 0);
          addVertex(currentPoint, u1, 0.5);
          addVertex(currentPoint, u1, 0.5);
          addVertex(innerPoint, u1, 0);
          addVertex(nextPointR, u0, 1);
        }
      }
    }
    function addCapGeometry(center, p1, p2, joinIsOnLeftSide2, start, u) {
      switch (style.strokeLineCap) {
        case "round":
          if (start) {
            makeCircularSector(center, p2, p1, u, 0.5);
          } else {
            makeCircularSector(center, p1, p2, u, 0.5);
          }
          break;
        case "square":
          if (start) {
            tempV2_1.subVectors(p1, center);
            tempV2_2.set(tempV2_1.y, -tempV2_1.x);
            tempV2_3.addVectors(tempV2_1, tempV2_2).add(center);
            tempV2_4.subVectors(tempV2_2, tempV2_1).add(center);
            if (joinIsOnLeftSide2) {
              tempV2_3.toArray(vertices, 1 * 3);
              tempV2_4.toArray(vertices, 0 * 3);
              tempV2_4.toArray(vertices, 3 * 3);
            } else {
              tempV2_3.toArray(vertices, 1 * 3);
              uvs[3 * 2 + 1] === 1 ? tempV2_4.toArray(vertices, 3 * 3) : tempV2_3.toArray(vertices, 3 * 3);
              tempV2_4.toArray(vertices, 0 * 3);
            }
          } else {
            tempV2_1.subVectors(p2, center);
            tempV2_2.set(tempV2_1.y, -tempV2_1.x);
            tempV2_3.addVectors(tempV2_1, tempV2_2).add(center);
            tempV2_4.subVectors(tempV2_2, tempV2_1).add(center);
            const vl = vertices.length;
            if (joinIsOnLeftSide2) {
              tempV2_3.toArray(vertices, vl - 1 * 3);
              tempV2_4.toArray(vertices, vl - 2 * 3);
              tempV2_4.toArray(vertices, vl - 4 * 3);
            } else {
              tempV2_4.toArray(vertices, vl - 2 * 3);
              tempV2_3.toArray(vertices, vl - 1 * 3);
              tempV2_4.toArray(vertices, vl - 4 * 3);
            }
          }
          break;
      }
    }
    function removeDuplicatedPoints(points2) {
      let dupPoints = false;
      for (let i = 1, n = points2.length - 1; i < n; i++) {
        if (points2[i].distanceTo(points2[i + 1]) < minDistance) {
          dupPoints = true;
          break;
        }
      }
      if (!dupPoints) return points2;
      const newPoints = [];
      newPoints.push(points2[0]);
      for (let i = 1, n = points2.length - 1; i < n; i++) {
        if (points2[i].distanceTo(points2[i + 1]) >= minDistance) {
          newPoints.push(points2[i]);
        }
      }
      newPoints.push(points2[points2.length - 1]);
      return newPoints;
    }
  }
}
function mergeGeometries(geometries, useGroups = false) {
  const isIndexed = geometries[0].index !== null;
  const attributesUsed = new Set(Object.keys(geometries[0].attributes));
  const morphAttributesUsed = new Set(Object.keys(geometries[0].morphAttributes));
  const attributes = {};
  const morphAttributes = {};
  const morphTargetsRelative = geometries[0].morphTargetsRelative;
  const mergedGeometry = new BufferGeometry();
  let offset = 0;
  for (let i = 0; i < geometries.length; ++i) {
    const geometry = geometries[i];
    let attributesCount = 0;
    if (isIndexed !== (geometry.index !== null)) {
      console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + i + ". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.");
      return null;
    }
    for (const name in geometry.attributes) {
      if (!attributesUsed.has(name)) {
        console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + i + '. All geometries must have compatible attributes; make sure "' + name + '" attribute exists among all geometries, or in none of them.');
        return null;
      }
      if (attributes[name] === void 0) attributes[name] = [];
      attributes[name].push(geometry.attributes[name]);
      attributesCount++;
    }
    if (attributesCount !== attributesUsed.size) {
      console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + i + ". Make sure all geometries have the same number of attributes.");
      return null;
    }
    if (morphTargetsRelative !== geometry.morphTargetsRelative) {
      console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + i + ". .morphTargetsRelative must be consistent throughout all geometries.");
      return null;
    }
    for (const name in geometry.morphAttributes) {
      if (!morphAttributesUsed.has(name)) {
        console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + i + ".  .morphAttributes must be consistent throughout all geometries.");
        return null;
      }
      if (morphAttributes[name] === void 0) morphAttributes[name] = [];
      morphAttributes[name].push(geometry.morphAttributes[name]);
    }
    if (useGroups) {
      let count;
      if (isIndexed) {
        count = geometry.index.count;
      } else if (geometry.attributes.position !== void 0) {
        count = geometry.attributes.position.count;
      } else {
        console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + i + ". The geometry must have either an index or a position attribute");
        return null;
      }
      mergedGeometry.addGroup(offset, count, i);
      offset += count;
    }
  }
  if (isIndexed) {
    let indexOffset = 0;
    const mergedIndex = [];
    for (let i = 0; i < geometries.length; ++i) {
      const index = geometries[i].index;
      for (let j = 0; j < index.count; ++j) {
        mergedIndex.push(index.getX(j) + indexOffset);
      }
      indexOffset += geometries[i].attributes.position.count;
    }
    mergedGeometry.setIndex(mergedIndex);
  }
  for (const name in attributes) {
    const mergedAttribute = mergeAttributes(attributes[name]);
    if (!mergedAttribute) {
      console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the " + name + " attribute.");
      return null;
    }
    mergedGeometry.setAttribute(name, mergedAttribute);
  }
  for (const name in morphAttributes) {
    const numMorphTargets = morphAttributes[name][0].length;
    if (numMorphTargets === 0) break;
    mergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};
    mergedGeometry.morphAttributes[name] = [];
    for (let i = 0; i < numMorphTargets; ++i) {
      const morphAttributesToMerge = [];
      for (let j = 0; j < morphAttributes[name].length; ++j) {
        morphAttributesToMerge.push(morphAttributes[name][j][i]);
      }
      const mergedMorphAttribute = mergeAttributes(morphAttributesToMerge);
      if (!mergedMorphAttribute) {
        console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the " + name + " morphAttribute.");
        return null;
      }
      mergedGeometry.morphAttributes[name].push(mergedMorphAttribute);
    }
  }
  return mergedGeometry;
}
function mergeAttributes(attributes) {
  let TypedArray;
  let itemSize;
  let normalized;
  let gpuType = -1;
  let arrayLength = 0;
  for (let i = 0; i < attributes.length; ++i) {
    const attribute = attributes[i];
    if (TypedArray === void 0) TypedArray = attribute.array.constructor;
    if (TypedArray !== attribute.array.constructor) {
      console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.");
      return null;
    }
    if (itemSize === void 0) itemSize = attribute.itemSize;
    if (itemSize !== attribute.itemSize) {
      console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.");
      return null;
    }
    if (normalized === void 0) normalized = attribute.normalized;
    if (normalized !== attribute.normalized) {
      console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.");
      return null;
    }
    if (gpuType === -1) gpuType = attribute.gpuType;
    if (gpuType !== attribute.gpuType) {
      console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.gpuType must be consistent across matching attributes.");
      return null;
    }
    arrayLength += attribute.count * itemSize;
  }
  const array = new TypedArray(arrayLength);
  const result = new BufferAttribute$1(array, itemSize, normalized);
  let offset = 0;
  for (let i = 0; i < attributes.length; ++i) {
    const attribute = attributes[i];
    if (attribute.isInterleavedBufferAttribute) {
      const tupleOffset = offset / itemSize;
      for (let j = 0, l = attribute.count; j < l; j++) {
        for (let c = 0; c < itemSize; c++) {
          const value = attribute.getComponent(j, c);
          result.setComponent(j + tupleOffset, c, value);
        }
      }
    } else {
      array.set(attribute.array, offset);
    }
    offset += attribute.count * itemSize;
  }
  if (gpuType !== void 0) {
    result.gpuType = gpuType;
  }
  return result;
}
class IconShape extends Shape2 {
  static getGeometries(svgText, size) {
    let svgLoader = new SVGLoader();
    let data = svgLoader.parse(svgText);
    console.log("SVG data:", data);
    let iconGeometries = [];
    data.paths.forEach((path) => {
      const fillColor = path.userData.style.fill;
      if (fillColor !== void 0 && fillColor !== "none") {
        const shapes = SVGLoader.createShapes(path);
        shapes.forEach((shape) => {
          let geometry = new ShapeGeometry(shape);
          if (geometry.index !== null) {
            geometry = geometry.toNonIndexed();
          }
          iconGeometries.push(geometry);
        });
      }
      const strokeColor = path.userData.style.stroke;
      if (strokeColor !== void 0 && strokeColor !== "none") {
        path.subPaths.forEach((subPath) => {
          let geometry = SVGLoader.pointsToStroke(
            subPath.getPoints(),
            path.userData.style
          );
          if (geometry) {
            if (geometry.index !== null) {
              geometry = geometry.toNonIndexed();
            }
            iconGeometries.push(geometry);
          }
        });
      }
    });
    const iconGeometry = mergeGeometries(iconGeometries, false);
    iconGeometry.applyMatrix4(new Matrix4$1().makeRotationX(Math.PI));
    iconGeometry.computeBoundingBox();
    const boundingBox2 = iconGeometry.boundingBox;
    const maxDimension = Math.max(boundingBox2.max.x - boundingBox2.min.x, boundingBox2.max.y - boundingBox2.min.y);
    console.log("Icon bounding box maxDimension:", maxDimension);
    const scaleFactor = size / maxDimension;
    iconGeometry.computeBoundingSphere();
    const boundingSphere = iconGeometry.boundingSphere;
    console.log("Icon bounding sphere:", boundingSphere);
    iconGeometry.scale(scaleFactor, scaleFactor, 1);
    iconGeometry.center();
    return iconGeometry;
  }
  constructor(iconSVG, size = IconDimensions.ICON_SIZE_MEDIUM) {
    const color2 = Colors.ELEMENT_TEXT;
    const iconGeometry = IconShape.getGeometries(iconSVG, size);
    super(iconGeometry, new DiagramEditMaterial(color2));
    console.log("IconShape size:", this.getSize());
  }
}
class BarMaterial extends MeshPhongMaterial {
  constructor(color2) {
    super({
      color: color2,
      opacity: 0.5,
      transparent: true,
      shininess: 60,
      specular: 6710886,
      emissive: 4473924,
      emissiveIntensity: 0.6
    });
  }
}
const ExtrusionParameters = {
  steps: 2,
  depth: 5,
  // 200,
  bevelEnabled: true,
  bevelThickness: 0.025,
  // 1,
  bevelSize: 0.075,
  // 3,
  bevelOffset: 0,
  bevelSegments: 1
};
const ColorPalette = [
  new Color$1(16007990),
  // red
  new Color$1(15277667),
  // pink
  new Color$1(10233776),
  // purple
  new Color$1(6765239),
  // deep purple
  new Color$1(4149685),
  // indigo
  new Color$1(2201331),
  // blue
  new Color$1(240116),
  // light blue
  new Color$1(48340),
  // cyan
  new Color$1(38536),
  // teal
  new Color$1(5025616),
  // green
  new Color$1(9159498),
  // light green
  new Color$1(13491257),
  // lime
  new Color$1(16771899),
  // yellow
  new Color$1(16761095),
  // amber
  new Color$1(16750592),
  // orange
  new Color$1(16733986),
  // deep orange
  new Color$1(7951688),
  // brown
  new Color$1(10395294),
  // grey
  new Color$1(6323595)
  // blue grey
];
class ValueBarShape extends Shape2 {
  constructor(shape, height, color2) {
    if (!(shape instanceof Shape$1)) {
      throw new TypeError("shape must be an instance of THREE.Shape");
    }
    const barColor = color2 !== void 0 ? color2 : ColorPalette[Math.floor(Math.random() * ColorPalette.length)];
    const barHeight = height !== void 0 ? height : Math.floor(Math.random() * 10) + 1;
    const extrusionParameters = { ...ExtrusionParameters, depth: barHeight };
    var barGeometry = new ExtrudeGeometry(shape, extrusionParameters);
    super(barGeometry, new BarMaterial(barColor));
  }
  // draw(ctx, x, y, width) {
  //     ctx.fillRect(x, y - this.barHeight, width, this.barHeight);
  // }
}
const ConnectorDimensions = {
  CONNECTOR_LINE_WIDTH: 1,
  // .1, // (4 / 40),
  CONNECTOR_OUTER_RADIUS: 10,
  // .625, // (25 / 40),
  CONNECTOR_INNER_RADIUS: 8.5,
  // .525, // (21 / 40),
  CONNECTOR_ARROWHEAD_WIDTH: 6,
  // .375, // (15 / 40),
  CONNECTOR_ARROWHEAD_LENGTH: 14
  // .875 // (35 / 90),
};
class RoundedCornerOrthogonalConnectorShape extends Shape2 {
  constructor(connectorPoints) {
    const outerRadius = ConnectorDimensions.CONNECTOR_OUTER_RADIUS;
    const innerRadius = ConnectorDimensions.CONNECTOR_INNER_RADIUS;
    const lineWidth = ConnectorDimensions.CONNECTOR_LINE_WIDTH;
    const arrowheadWidth = ConnectorDimensions.CONNECTOR_ARROWHEAD_WIDTH;
    const arrowheadLength = ConnectorDimensions.CONNECTOR_ARROWHEAD_LENGTH;
    const width = lineWidth / 2;
    const color2 = Colors.ELEMENT_STROKE;
    const extrudeSettings = ExtrusionParameters$1;
    var connectorShape = new Shape$1();
    if (connectorPoints[0].y == connectorPoints[1].y && connectorPoints[0].x < connectorPoints[1].x) {
      connectorShape.moveTo(connectorPoints[0].x, connectorPoints[0].y + width);
      connectorShape.lineTo(connectorPoints[0].x, connectorPoints[0].y - width);
    }
    if (connectorPoints[0].y == connectorPoints[1].y && connectorPoints[0].x > connectorPoints[1].x) {
      connectorShape.moveTo(connectorPoints[0].x, connectorPoints[0].y - width);
      connectorShape.lineTo(connectorPoints[0].x, connectorPoints[0].y + width);
    }
    if (connectorPoints[0].x == connectorPoints[1].x && connectorPoints[0].y < connectorPoints[1].y) {
      connectorShape.moveTo(connectorPoints[0].x - width, connectorPoints[0].y);
      connectorShape.lineTo(connectorPoints[0].x + width, connectorPoints[0].y);
    }
    if (connectorPoints[0].x == connectorPoints[1].x && connectorPoints[0].y > connectorPoints[1].y) {
      connectorShape.moveTo(connectorPoints[0].x + width, connectorPoints[0].y);
      connectorShape.lineTo(connectorPoints[0].x - width, connectorPoints[0].y);
    }
    for (var i = 1; i < connectorPoints.length - 1; i++) {
      if (connectorPoints[i - 1].y == connectorPoints[i].y) {
        if (connectorPoints[i - 1].x < connectorPoints[i].x) {
          if (connectorPoints[i].y < connectorPoints[i + 1].y) {
            connectorShape.lineTo(connectorPoints[i].x + width - outerRadius, connectorPoints[i].y - width);
            connectorShape.quadraticCurveTo(
              connectorPoints[i].x + width,
              connectorPoints[i].y - width,
              connectorPoints[i].x + width,
              connectorPoints[i].y - width + outerRadius
            );
          } else {
            connectorShape.lineTo(connectorPoints[i].x - width - innerRadius, connectorPoints[i].y - width);
            connectorShape.quadraticCurveTo(
              connectorPoints[i].x - width,
              connectorPoints[i].y - width,
              connectorPoints[i].x - width,
              connectorPoints[i].y - width - innerRadius
            );
          }
        } else {
          if (connectorPoints[i].y < connectorPoints[i + 1].y) {
            connectorShape.lineTo(connectorPoints[i].x + width + innerRadius, connectorPoints[i].y + width);
            connectorShape.quadraticCurveTo(
              connectorPoints[i].x + width,
              connectorPoints[i].y + width,
              connectorPoints[i].x + width,
              connectorPoints[i].y + width + innerRadius
            );
          } else {
            connectorShape.lineTo(connectorPoints[i].x - width + outerRadius, connectorPoints[i].y + width);
            connectorShape.quadraticCurveTo(
              connectorPoints[i].x - width,
              connectorPoints[i].y - width,
              connectorPoints[i].x - width,
              connectorPoints[i].y + width - outerRadius
            );
          }
        }
      }
      if (connectorPoints[i - 1].x == connectorPoints[i].x) {
        if (connectorPoints[i - 1].y < connectorPoints[i].y) {
          if (connectorPoints[i].x < connectorPoints[i + 1].x) {
            connectorShape.lineTo(connectorPoints[i].x + width, connectorPoints[i].y - width - innerRadius);
            connectorShape.quadraticCurveTo(
              connectorPoints[i].x + width,
              connectorPoints[i].y - width,
              connectorPoints[i].x + width + innerRadius,
              connectorPoints[i].y - width
            );
          } else {
            connectorShape.lineTo(connectorPoints[i].x + width, connectorPoints[i].y + width - outerRadius);
            connectorShape.quadraticCurveTo(
              connectorPoints[i].x + width,
              connectorPoints[i].y + width,
              connectorPoints[i].x + width - outerRadius,
              connectorPoints[i].y + width
            );
          }
        } else {
          if (connectorPoints[i].x < connectorPoints[i + 1].x) {
            connectorShape.lineTo(connectorPoints[i].x - width, connectorPoints[i].y - width + outerRadius);
            connectorShape.quadraticCurveTo(
              connectorPoints[i].x - width,
              connectorPoints[i].y - width,
              connectorPoints[i].x - width + outerRadius,
              connectorPoints[i].y - width
            );
          } else {
            connectorShape.lineTo(connectorPoints[i].x - width, connectorPoints[i].y + width + innerRadius);
            connectorShape.quadraticCurveTo(
              connectorPoints[i].x - width,
              connectorPoints[i].y + width,
              connectorPoints[i].x - width - innerRadius,
              connectorPoints[i].y + width
            );
          }
        }
      }
    }
    if (connectorPoints[connectorPoints.length - 2].y == connectorPoints[connectorPoints.length - 1].y && connectorPoints[connectorPoints.length - 2].x < connectorPoints[connectorPoints.length - 1].x) {
      connectorShape.lineTo(
        connectorPoints[connectorPoints.length - 1].x - arrowheadLength,
        connectorPoints[connectorPoints.length - 1].y - width
      );
      connectorShape.lineTo(
        connectorPoints[connectorPoints.length - 1].x - arrowheadLength,
        connectorPoints[connectorPoints.length - 1].y - arrowheadWidth
      );
      connectorShape.lineTo(
        connectorPoints[connectorPoints.length - 1].x,
        connectorPoints[connectorPoints.length - 1].y
      );
      connectorShape.lineTo(
        connectorPoints[connectorPoints.length - 1].x - arrowheadLength,
        connectorPoints[connectorPoints.length - 1].y + arrowheadWidth
      );
      connectorShape.lineTo(
        connectorPoints[connectorPoints.length - 1].x - arrowheadLength,
        connectorPoints[connectorPoints.length - 1].y + width
      );
    }
    if (connectorPoints[connectorPoints.length - 2].y == connectorPoints[connectorPoints.length - 1].y && connectorPoints[connectorPoints.length - 2].x > connectorPoints[connectorPoints.length - 1].x) {
      connectorShape.lineTo(
        connectorPoints[connectorPoints.length - 1].x + arrowheadLength,
        connectorPoints[connectorPoints.length - 1].y + width
      );
      connectorShape.lineTo(
        connectorPoints[connectorPoints.length - 1].x + arrowheadLength,
        connectorPoints[connectorPoints.length - 1].y + arrowheadWidth
      );
      connectorShape.lineTo(
        connectorPoints[connectorPoints.length - 1].x,
        connectorPoints[connectorPoints.length - 1].y
      );
      connectorShape.lineTo(
        connectorPoints[connectorPoints.length - 1].x + arrowheadLength,
        connectorPoints[connectorPoints.length - 1].y - arrowheadWidth
      );
      connectorShape.lineTo(
        connectorPoints[connectorPoints.length - 1].x + arrowheadLength,
        connectorPoints[connectorPoints.length - 1].y - width
      );
    }
    if (connectorPoints[connectorPoints.length - 2].x == connectorPoints[connectorPoints.length - 1].x && connectorPoints[connectorPoints.length - 2].y < connectorPoints[connectorPoints.length - 1].y) {
      connectorShape.lineTo(
        connectorPoints[connectorPoints.length - 1].x + width,
        connectorPoints[connectorPoints.length - 1].y - arrowheadLength
      );
      connectorShape.lineTo(
        connectorPoints[connectorPoints.length - 1].x + arrowheadWidth,
        connectorPoints[connectorPoints.length - 1].y - arrowheadLength
      );
      connectorShape.lineTo(
        connectorPoints[connectorPoints.length - 1].x,
        connectorPoints[connectorPoints.length - 1].y
      );
      connectorShape.lineTo(
        connectorPoints[connectorPoints.length - 1].x - arrowheadWidth,
        connectorPoints[connectorPoints.length - 1].y - arrowheadLength
      );
      connectorShape.lineTo(
        connectorPoints[connectorPoints.length - 1].x - width,
        connectorPoints[connectorPoints.length - 1].y - arrowheadLength
      );
    }
    if (connectorPoints[connectorPoints.length - 2].x == connectorPoints[connectorPoints.length - 1].x && connectorPoints[connectorPoints.length - 2].y > connectorPoints[connectorPoints.length - 1].y) {
      connectorShape.lineTo(
        connectorPoints[connectorPoints.length - 1].x - width,
        connectorPoints[connectorPoints.length - 1].y + arrowheadLength * 32 / 35
      );
      connectorShape.lineTo(
        connectorPoints[connectorPoints.length - 1].x - arrowheadWidth,
        connectorPoints[connectorPoints.length - 1].y + arrowheadLength * 32 / 35
      );
      connectorShape.lineTo(
        connectorPoints[connectorPoints.length - 1].x,
        connectorPoints[connectorPoints.length - 1].y
      );
      connectorShape.lineTo(
        connectorPoints[connectorPoints.length - 1].x + arrowheadWidth,
        connectorPoints[connectorPoints.length - 1].y + arrowheadLength * 32 / 35
      );
      connectorShape.lineTo(
        connectorPoints[connectorPoints.length - 1].x + width,
        connectorPoints[connectorPoints.length - 1].y + arrowheadLength * 32 / 35
      );
    }
    for (var i = connectorPoints.length - 2; i > 0; i--) {
      if (connectorPoints[i + 1].y == connectorPoints[i].y) {
        if (connectorPoints[i + 1].x < connectorPoints[i].x) {
          if (connectorPoints[i].y < connectorPoints[i - 1].y) {
            connectorShape.lineTo(connectorPoints[i].x + width - innerRadius, connectorPoints[i].y - width);
            connectorShape.quadraticCurveTo(
              connectorPoints[i].x + width,
              connectorPoints[i].y - width,
              connectorPoints[i].x + width,
              connectorPoints[i].y - width + innerRadius
            );
          } else {
            connectorShape.lineTo(connectorPoints[i].x - width - innerRadius, connectorPoints[i].y - width);
            connectorShape.quadraticCurveTo(
              connectorPoints[i].x - width,
              connectorPoints[i].y - width,
              connectorPoints[i].x - width,
              connectorPoints[i].y - width - innerRadius
            );
          }
        } else {
          if (connectorPoints[i].y < connectorPoints[i - 1].y) {
            connectorShape.lineTo(connectorPoints[i].x + width + innerRadius, connectorPoints[i].y + width);
            connectorShape.quadraticCurveTo(
              connectorPoints[i].x + width,
              connectorPoints[i].y + width,
              connectorPoints[i].x + width,
              connectorPoints[i].y + width + innerRadius
            );
          } else {
            connectorShape.lineTo(connectorPoints[i].x - width + outerRadius, connectorPoints[i].y + width);
            connectorShape.quadraticCurveTo(
              connectorPoints[i].x - width,
              connectorPoints[i].y + width,
              connectorPoints[i].x - width,
              connectorPoints[i].y + width - outerRadius
            );
          }
        }
      }
      if (connectorPoints[i + 1].x == connectorPoints[i].x) {
        if (connectorPoints[i + 1].y < connectorPoints[i].y) {
          if (connectorPoints[i].x < connectorPoints[i - 1].x) {
            connectorShape.lineTo(connectorPoints[i].x + width, connectorPoints[i].y - width - innerRadius);
            connectorShape.quadraticCurveTo(
              connectorPoints[i].x + width,
              connectorPoints[i].y - width,
              connectorPoints[i].x + width + innerRadius,
              connectorPoints[i].y - width
            );
          } else {
            connectorShape.lineTo(connectorPoints[i].x + width, connectorPoints[i].y + width - outerRadius);
            connectorShape.quadraticCurveTo(
              connectorPoints[i].x + width,
              connectorPoints[i].y + width,
              connectorPoints[i].x + width - outerRadius,
              connectorPoints[i].y + width
            );
          }
        } else {
          if (connectorPoints[i].x < connectorPoints[i - 1].x) {
            connectorShape.lineTo(connectorPoints[i].x - width, connectorPoints[i].y - width + outerRadius);
            connectorShape.quadraticCurveTo(
              connectorPoints[i].x - width,
              connectorPoints[i].y - width,
              connectorPoints[i].x - width + outerRadius,
              connectorPoints[i].y - width
            );
          } else {
            connectorShape.lineTo(connectorPoints[i].x - width, connectorPoints[i].y + width + innerRadius);
            connectorShape.quadraticCurveTo(
              connectorPoints[i].x - width,
              connectorPoints[i].y + width,
              connectorPoints[i].x - width - innerRadius,
              connectorPoints[i].y + width
            );
          }
        }
      }
    }
    if (connectorPoints[0].y == connectorPoints[1].y && connectorPoints[0].x < connectorPoints[1].x) {
      connectorShape.lineTo(connectorPoints[0].x, connectorPoints[0].y + width);
    }
    if (connectorPoints[0].y == connectorPoints[1].y && connectorPoints[0].x > connectorPoints[1].x) {
      connectorShape.lineTo(connectorPoints[0].x, connectorPoints[0].y - width);
    }
    if (connectorPoints[0].x == connectorPoints[1].x && connectorPoints[0].y < connectorPoints[1].y) {
      connectorShape.lineTo(connectorPoints[0].x - width, connectorPoints[0].y);
    }
    if (connectorPoints[0].x == connectorPoints[1].x && connectorPoints[0].y > connectorPoints[1].y) {
      connectorShape.lineTo(connectorPoints[0].x + width, connectorPoints[0].y);
    }
    var connectorGeometry = new ExtrudeGeometry(connectorShape, extrudeSettings);
    super(connectorGeometry, new DiagramEditMaterial(color2));
  }
}
class Connector extends Mesh {
  constructor(elementId, shape = new RoundedCornerOrthogonalConnectorShape(), sourceElement = null, targetElement = null, sourcePoint = { x: 0, y: 0 }, targetPoint = { x: 2, y: 2 }, waypoints = [{ x: 0, y: 1 }, { x: 2, y: 1 }], properties = {}) {
    super(shape.geometry, shape.material);
    this.elementId = elementId;
    this.sourceElement = sourceElement;
    this.targetElement = targetElement;
    this.shape = shape;
    this.points = [sourcePoint, ...waypoints, targetPoint];
    this.properties = properties;
  }
  setDiagram(diagram) {
    this.diagram = diagram;
  }
  static determinePoints(sourcePoint, targetPoint, sourcePosition, targetPosition) {
    let waypoints = [];
    if (sourcePoint.x !== targetPoint.x && sourcePoint.y !== targetPoint.y) {
      if (sourcePosition.startsWith("W") || sourcePosition.startsWith("E")) {
        waypoints.push({ x: targetPoint.x, y: sourcePoint.y });
      }
      if (sourcePosition.startsWith("N") || sourcePosition.startsWith("S")) {
        waypoints.push({ x: sourcePoint.x, y: targetPoint.y });
      }
    }
    return [sourcePoint, ...waypoints, targetPoint];
  }
}
class Element extends Mesh {
  /**
   * Creates a new diagram element.
   * @param {string} elementId - Unique identifier for the element
   * @param {Shape} [shape=new BoxShape()] - Shape of the element
   * @param {Object} [positionXY={ x: 0, y: 0 }] - Initial position of the element
   * @param {number} positionXY.x - X coordinate
   * @param {number} positionXY.y - Y coordinate
   */
  constructor(elementId, shape = new BoxShape(), positionXY = { x: 0, y: 0 }) {
    super(shape.geometry, shape.material);
    this.elementId = elementId;
    this.type = shape.constructor.name;
    this.parameters = {};
    this.shape = shape;
    this.position.set(positionXY.x, positionXY.y, 0);
    this.width = this.getSize().x;
    this.height = this.getSize().y;
    this.texts = [];
    this.icons = [];
    this.valueBars = [];
  }
  /**
   * Sets the diagram context for this element.
   * @param {Diagram} diagram - The diagram this element belongs to
   */
  setDiagram(diagram) {
    this.diagram = diagram;
  }
  // ================================================================
  // Element placement methods
  // ================================================================
  /**
   * Gets the size of the element's bounding box.
   * @returns {THREE.Vector3} The size vector containing width, height, and depth
   */
  getSize() {
    const size = new Vector3$1();
    this.shape.geometry.computeBoundingBox();
    this.shape.geometry.boundingBox.getSize(size);
    return size;
  }
  /**
   * Positions the element and its decorations at the specified coordinates.
   * @param {Object} position - The position coordinates
   * @param {number} position.x - X coordinate
   * @param {number} position.y - Y coordinate
   * @param {number} [position.z] - Optional Z coordinate
   * @returns {Element} This element for method chaining
   */
  positionAt(position) {
    if (position.z !== void 0) {
      this.position.set(position.x, position.y, position.z);
    } else {
      this.position.set(position.x, position.y, 0);
    }
    this.texts.forEach((text) => {
      const offset = text.positionOffset;
      if (position.z !== void 0) {
        text.element.position.set(position.x + offset.x, position.y + offset.y, position.z + offset.z);
      } else {
        text.element.position.set(position.x + offset.x, position.y + offset.y, offset.z);
      }
    });
    this.icons.forEach((icon) => {
      const offset = icon.positionOffset;
      if (position.z !== void 0) {
        icon.element.position.set(position.x + offset.x, position.y + offset.y, position.z + offset.z);
      } else {
        icon.element.position.set(position.x + offset.x, position.y + offset.y, offset.z);
      }
    });
    this.valueBars.forEach((bar) => {
      const offset = bar.positionOffset;
      if (position.z !== void 0) {
        bar.element.position.set(position.x + offset.x, position.y + offset.y, position.z + offset.z);
      } else {
        bar.element.position.set(position.x + offset.x, position.y + offset.y, offset.z);
      }
    });
    return this;
  }
  /**
   * Sets the position of the element using individual coordinates.
   * @param {number} x - X coordinate
   * @param {number} y - Y coordinate
   * @param {number} z - Z coordinate
   * @returns {Element} This element for method chaining
   */
  setPosition(x, y, z) {
    const pos = new Vector3$1(x, y, z);
    this.positionAt(pos);
    return this;
  }
  /**
   * Gets the current position of the element.
   * @returns {THREE.Vector3} The position vector
   */
  getPosition() {
    return this.position;
  }
  /**
   * Positions this element to the right of another element.
   * @param {string} elementId - ID of the reference element
   * @returns {Element} This element for method chaining
   */
  positionRightOf(elementId) {
    const element2 = this.diagram.getElementById(elementId);
    const elementWidth = element2.getSize().x;
    const thisWidth = this.getSize().x;
    this.setPosition(
      element2.position.x + elementWidth / 2 + DiagramDimensions.DISTANCE_BETWEEN_ELEMENTS + thisWidth / 2,
      // x
      element2.position.y,
      // y
      0
    );
    return this;
  }
  /**
   * Positions this element to the left of another element.
   * @param {string} elementId - ID of the reference element
   * @returns {Element} This element for method chaining
   */
  positionLeftOf(elementId) {
    const element2 = this.diagram.getElementById(elementId);
    const elementWidth = element2.getSize().x;
    const thisWidth = this.getSize().x;
    this.setPosition(
      element2.position.x - elementWidth / 2 - DiagramDimensions.DISTANCE_BETWEEN_ELEMENTS - thisWidth / 2,
      // x
      element2.position.y,
      // y
      0
    );
    return this;
  }
  /**
   * Positions this element above another element.
   * @param {string} elementId - ID of the reference element
   * @returns {Element} This element for method chaining
   */
  positionUpOf(elementId) {
    const element2 = this.diagram.getElementById(elementId);
    const elementHeight = element2.getSize().y;
    const thisHeight = this.getSize().y;
    this.setPosition(
      element2.position.x,
      // x
      element2.position.y + elementHeight / 2 + DiagramDimensions.DISTANCE_BETWEEN_ELEMENTS + thisHeight / 2,
      // y
      0
    );
    return this;
  }
  /**
   * Positions this element below another element.
   * @param {string} elementId - ID of the reference element
   * @returns {Element} This element for method chaining
   */
  positionDownOf(elementId) {
    const element2 = this.diagram.getElementById(elementId);
    const elementHeight = element2.getSize().y;
    const thisHeight = this.getSize().y;
    this.setPosition(
      element2.position.x,
      // x
      element2.position.y - elementHeight / 2 - DiagramDimensions.DISTANCE_BETWEEN_ELEMENTS - thisHeight / 2,
      // y
      0
    );
    return this;
  }
  /**
   * Positions this element above and to the left of another element.
   * @param {string} elementId - ID of the reference element
   * @returns {Element} This element for method chaining
   */
  positionUpLeftOf(elementId) {
    const element2 = this.diagram.getElementById(elementId);
    const elementWidth = element2.getSize().x;
    const elementHeight = element2.getSize().y;
    const thisWidth = this.getSize().x;
    const thisHeight = this.getSize().y;
    this.setPosition(
      element2.position.x - elementWidth / 2 - DiagramDimensions.DISTANCE_BETWEEN_ELEMENTS - thisWidth / 2,
      // x
      element2.position.y + elementHeight / 2 + DiagramDimensions.DISTANCE_BETWEEN_ELEMENTS + thisHeight / 2,
      // y
      0
    );
    return this;
  }
  /**
   * Positions this element below and to the left of another element.
   * @param {string} elementId - ID of the reference element
   * @returns {Element} This element for method chaining
   */
  positionDownLeftOf(elementId) {
    const element2 = this.diagram.getElementById(elementId);
    const elementWidth = element2.getSize().x;
    const elementHeight = element2.getSize().y;
    const thisWidth = this.getSize().x;
    const thisHeight = this.getSize().y;
    this.setPosition(
      element2.position.x - elementWidth / 2 - DiagramDimensions.DISTANCE_BETWEEN_ELEMENTS - thisWidth / 2,
      // x
      element2.position.y - elementHeight / 2 - DiagramDimensions.DISTANCE_BETWEEN_ELEMENTS - thisHeight / 2,
      // y
      0
    );
    return this;
  }
  /**
   * Positions this element above and to the right of another element.
   * @param {string} elementId - ID of the reference element
   * @returns {Element} This element for method chaining
   */
  positionUpRightOf(elementId) {
    const element2 = this.diagram.getElementById(elementId);
    const elementWidth = element2.getSize().x;
    const elementHeight = element2.getSize().y;
    const thisWidth = this.getSize().x;
    const thisHeight = this.getSize().y;
    this.setPosition(
      element2.position.x + elementWidth / 2 + DiagramDimensions.DISTANCE_BETWEEN_ELEMENTS + thisWidth / 2,
      // x
      element2.position.y + elementHeight / 2 + DiagramDimensions.DISTANCE_BETWEEN_ELEMENTS + thisHeight / 2,
      // y
      0
    );
    return this;
  }
  /**
   * Positions this element below and to the right of another element.
   * @param {string} elementId - ID of the reference element
   * @returns {Element} This element for method chaining
   */
  positionDownRightOf(elementId) {
    const element2 = this.diagram.getElementById(elementId);
    const elementWidth = element2.getSize().x;
    const elementHeight = element2.getSize().y;
    const thisWidth = this.getSize().x;
    const thisHeight = this.getSize().y;
    this.setPosition(
      element2.position.x + elementWidth / 2 + DiagramDimensions.DISTANCE_BETWEEN_ELEMENTS + thisWidth / 2,
      // x
      element2.position.y - elementHeight / 2 - DiagramDimensions.DISTANCE_BETWEEN_ELEMENTS - thisHeight / 2,
      // y
      0
    );
    return this;
  }
  // =================================================================
  // Determine connecting points positions in geographical manner 
  // (N, S, E, W, NNE, NNW, NEE, NWW, SEE, SWW, SSE, SSW)
  // for connectors to connect to
  // ================================================================
  /**
   * Gets the north connection point of the element.
   * The point is positioned at the middle of the element's top edge.
   * @returns {THREE.Vector2} A 2D vector representing the north point coordinates
   *                         where x is the element's center x-coordinate
   *                         and y is the element's top edge y-coordinate
   */
  getNorthPoint() {
    return new Vector2$1(
      this.position.x,
      this.position.y + this.getSize().y / 2
    );
  }
  /**
   * Gets the south connection point of the element.
   * The point is positioned at the middle of the element's bottom edge.
   * @returns {THREE.Vector2} A 2D vector representing the south point coordinates
   *                         where x is the element's center x-coordinate
   *                         and y is the element's bottom edge y-coordinate
   */
  getSouthPoint() {
    return new Vector2$1(
      this.position.x,
      this.position.y - this.getSize().y / 2
    );
  }
  /**
   * Gets the east connection point of the element.
   * The point is positioned at the middle of the element's right edge.
   * @returns {THREE.Vector2} A 2D vector representing the east point coordinates
   *                         where x is the element's right edge x-coordinate
   *                         and y is the element's center y-coordinate
   */
  getEastPoint() {
    return new Vector2$1(
      this.position.x + this.getSize().x / 2,
      this.position.y
    );
  }
  /**
   * Gets the west connection point of the element.
   * The point is positioned at the middle of the element's left edge.
   * @returns {THREE.Vector2} A 2D vector representing the west point coordinates
   *                         where x is the element's left edge x-coordinate
   *                         and y is the element's center y-coordinate
   */
  getWestPoint() {
    return new Vector2$1(
      this.position.x - this.getSize().x / 2,
      this.position.y
    );
  }
  /**
   * Gets the north-east connection point of the element.
   * The point is positioned at the top-right corner of the element.
   * @returns {THREE.Vector2} A 2D vector representing the north-east point coordinates
   *                         where x is the element's right edge x-coordinate
   *                         and y is the element's top edge y-coordinate
   */
  getNorthEastPoint() {
    return new Vector2$1(
      this.position.x + this.getSize().x / 2,
      this.position.y + this.getSize().y / 2
    );
  }
  /**
   * Gets the north-west connection point of the element.
   * The point is positioned at the top-left corner of the element.
   * @returns {THREE.Vector2} A 2D vector representing the north-west point coordinates
   *                         where x is the element's left edge x-coordinate
   *                         and y is the element's top edge y-coordinate
   */
  getNorthWestPoint() {
    return new Vector2$1(
      this.position.x - this.getSize().x / 2,
      this.position.y + this.getSize().y / 2
    );
  }
  /**
   * Gets the south-east connection point of the element.
   * The point is positioned at the bottom-right corner of the element.
   * @returns {THREE.Vector2} A 2D vector representing the south-east point coordinates
   *                         where x is the element's right edge x-coordinate
   *                         and y is the element's bottom edge y-coordinate
   */
  getSouthEastPoint() {
    return new Vector2$1(
      this.position.x + this.getSize().x / 2,
      this.position.y - this.getSize().y / 2
    );
  }
  /**
   * Gets the south-west connection point of the element.
   * The point is positioned at the bottom-left corner of the element.
   * @returns {THREE.Vector2} A 2D vector representing the south-west point coordinates
   *                         where x is the element's left edge x-coordinate
   *                         and y is the element's bottom edge y-coordinate
   */
  getSouthWestPoint() {
    return new Vector2$1(
      this.position.x - this.getSize().x / 2,
      this.position.y - this.getSize().y / 2
    );
  }
  /**
   * Gets the north-north-east connection point of the element.
   * The point is positioned on the top edge, one-quarter of the width from the center towards the right.
   * @returns {THREE.Vector2} A 2D vector representing the north-north-east point coordinates
   *                         where x is the element's center x-coordinate plus one-quarter of the width
   *                         and y is the element's top edge y-coordinate
   */
  getNorthNorthEastPoint() {
    return new Vector2$1(
      this.position.x + this.getSize().x / 4,
      this.position.y + this.getSize().y / 2
    );
  }
  /**
   * Gets the north-north-west connection point of the element.
   * The point is positioned on the top edge, one-quarter of the width from the center towards the left.
   * @returns {THREE.Vector2} A 2D vector representing the north-north-west point coordinates
   *                         where x is the element's center x-coordinate minus one-quarter of the width
   *                         and y is the element's top edge y-coordinate
   */
  getNorthNorthWestPoint() {
    return new Vector2$1(
      this.position.x - this.getSize().x / 4,
      this.position.y + this.getSize().y / 2
    );
  }
  /**
   * Gets the north-east-east connection point of the element.
   * The point is positioned on the right edge, one-quarter of the height from the top.
   * @returns {THREE.Vector2} A 2D vector representing the north-east-east point coordinates
   * where x is the element's right edge x-coordinate
   * and y is the element's top edge y-coordinate plus one-quarter of the height
   */
  getNorthEastEastPoint() {
    return new Vector2$1(
      this.position.x + this.getSize().x / 2,
      this.position.y + this.getSize().y / 4
    );
  }
  /**
   * Gets the north-west-west connection point of the element.
   * The point is positioned on the left edge, one-quarter of the height from the top.
   * @returns {THREE.Vector2} A 2D vector representing the north-west-west point coordinates
   * where x is the element's left edge x-coordinate
   * and y is the element's top edge y-coordinate plus one-quarter of the height
   */
  getNorthWestWestPoint() {
    return new Vector2$1(
      this.position.x - this.getSize().x / 2,
      this.position.y + this.getSize().y / 4
    );
  }
  /**
   * Gets the south-south-east connection point of the element.
   * The point is positioned on the bottom edge, one-quarter of the width from the center towards the right.
   * @returns {THREE.Vector2} A 2D vector representing the south-south-east point coordinates
   * where x is the element's center x-coordinate plus one-quarter of the width
   * and y is the element's bottom edge y-coordinate
   */
  getSouthSouthEastPoint() {
    return new Vector2$1(
      this.position.x + this.getSize().x / 4,
      this.position.y - this.getSize().y / 2
    );
  }
  /**
   * Gets the south-south-west connection point of the element.
   * The point is positioned on the bottom edge, one-quarter of the width from the center towards the left.
   * @returns {THREE.Vector2} A 2D vector representing the south-south-west point coordinates
   * where x is the element's center x-coordinate minus one-quarter of the width
   * and y is the element's bottom edge y-coordinate
   */
  getSouthSouthWestPoint() {
    return new Vector2$1(
      this.position.x - this.getSize().x / 4,
      this.position.y - this.getSize().y / 2
    );
  }
  /**
   * Gets the south-east-east connection point of the element.
   * The point is positioned on the right edge, one-quarter of the height from the bottom.
   * @returns {THREE.Vector2} A 2D vector representing the south-east-east point coordinates
   * where x is the element's right edge x-coordinate
   * and y is the element's bottom edge y-coordinate plus one-quarter of the height
   */
  getSouthEastEastPoint() {
    return new Vector2$1(
      this.position.x + this.getSize().x / 2,
      this.position.y - this.getSize().y / 4
    );
  }
  /**
   * Gets the south-west-west connection point of the element.
   * The point is positioned on the left edge, one-quarter of the height from the bottom.
   * @returns {THREE.Vector2} A 2D vector representing the south-west-west point coordinates
   * where x is the element's left edge x-coordinate
   * and y is the element's bottom edge y-coordinate plus one-quarter of the height
   */
  getSouthWestWestPoint() {
    return new Vector2$1(
      this.position.x - this.getSize().x / 2,
      this.position.y - this.getSize().y / 4
    );
  }
  /**
   * Gets the position of a connection point on the element.
   * @param {string} position - Position identifier (N, S, E, W, NE, NW, etc.)
   * @returns {THREE.Vector2} The connection point coordinates
   * @throws {Error} If the position identifier is invalid
   */
  getPointPosition(position) {
    switch (position) {
      case "N":
      case "north":
        return this.getNorthPoint();
      case "S":
      case "south":
        return this.getSouthPoint();
      case "E":
      case "east":
        return this.getEastPoint();
      case "W":
      case "west":
        return this.getWestPoint();
      case "NE":
      case "northeast":
        return this.getNorthEastPoint();
      case "NW":
      case "northwest":
        return this.getNorthWestPoint();
      case "SE":
      case "southeast":
        return this.getSouthEastPoint();
      case "SW":
      case "southwest":
        return this.getSouthWestPoint();
      case "NNE":
      case "northnortheast":
        return this.getNorthNorthEastPoint();
      case "NNW":
      case "northnorthwest":
        return this.getNorthNorthWestPoint();
      case "NEE":
      case "northeast":
        return this.getNorthEastEastPoint();
      case "NWW":
      case "northwest":
        return this.getNorthWestWestPoint();
      case "SSE":
      case "southsoutheast":
        return this.getSouthSouthEastPoint();
      case "SSW":
      case "southsouthwest":
        return this.getSouthSouthWestPoint();
      case "SEE":
      case "southeast":
        return this.getSouthEastEastPoint();
      case "SWW":
      case "southwest":
        return this.getSouthWestWestPoint();
      default:
        throw new Error(`Unknown position: ${position}`);
    }
  }
  // ================================================================
  // Add Text methods
  // ================================================================
  /**
   * Adds text to the element.
   * @param {string} text - The text to add
   * @returns {Element} This element for method chaining
   */
  addText(text) {
    const textElement = new Element(this.elementId + "_text", new TextShape(text));
    this.diagram.addElement(textElement).positionAt(this.position);
    this.texts.push({ element: textElement, positionOffset: new Vector3$1(0, 0, 0) });
    return this;
  }
  /**
   * Adds wrapped text that fits within the element's bounds.
   * @param {string} text - The text to add and wrap
   * @returns {Element} This element for method chaining
   */
  addWrappedText(text) {
    if (!text) {
      console.warn("addWrappedText: text is null or undefined");
      return this;
    }
    let wrappedText = text.replace(/\s+/g, "\n");
    let wrappedTextElement = new Element(this.elementId + "_text", new TextShape(wrappedText));
    let candidateTextElement;
    while (true) {
      let words = wrappedText.split("\n");
      let minLength = Infinity;
      let minIndex = -1;
      for (let i = 0; i < words.length - 1; i++) {
        let combinedLength = words[i].length + words[i + 1].length;
        if (combinedLength < minLength) {
          minLength = combinedLength;
          minIndex = i;
        }
      }
      if (minIndex === -1) break;
      words[minIndex] = words[minIndex] + " " + words[minIndex + 1];
      words.splice(minIndex + 1, 1);
      wrappedText = words.join("\n");
      candidateTextElement = new Element(this.elementId + "_text", new TextShape(wrappedText));
      if (candidateTextElement.getSize().x <= this.getSize().x * 0.9) {
        wrappedTextElement = candidateTextElement;
      } else {
        break;
      }
    }
    this.diagram.addElement(wrappedTextElement).positionAt({ x: this.position.x, y: this.position.y, z: 3 });
    this.texts.push({ element: wrappedTextElement, positionOffset: new Vector3$1(0, 0, 3) });
    return this;
  }
  // ================================================================
  // Add icons methods
  // ================================================================
  /**
   * Gets the placeholder position for an icon at the top of the element.
   * The position is calculated by taking the element's top edge and offsetting it inward
   * by half the icon size plus padding.
   * @returns {THREE.Vector2} A 2D vector representing the placeholder coordinates
   *                         where x is the element's center x-coordinate
   *                         and y is the element's top edge y-coordinate minus (icon size/2 + padding)
   */
  getTopIconPlaceholder() {
    return new Vector2$1(
      this.position.x,
      this.position.y + this.getSize().y / 2 - IconDimensions.ICON_SIZE_SMALL / 2 - IconDimensions.ICON_PADDING
    );
  }
  /**
   * Gets the placeholder position for an icon at the bottom of the element.
   * The position is calculated by taking the element's bottom edge and offsetting it inward
   * by half the icon size plus padding.
   * @returns {THREE.Vector2} A 2D vector representing the placeholder coordinates
   *                         where x is the element's center x-coordinate
   *                         and y is the element's bottom edge y-coordinate plus (icon size/2 + padding)
   */
  getBottomIconPlaceholder() {
    return new Vector2$1(
      this.position.x,
      this.position.y - this.getSize().y / 2 + IconDimensions.ICON_SIZE_SMALL / 2 + IconDimensions.ICON_PADDING
    );
  }
  /**
   * Gets the placeholder position for an icon at the left of the element.
   * The position is calculated by taking the element's left edge and offsetting it inward
   * by half the icon size plus padding.
   * @returns {THREE.Vector2} A 2D vector representing the placeholder coordinates
   *                         where x is the element's left edge x-coordinate plus (icon size/2 + padding)
   *                         and y is the element's center y-coordinate
   */
  getLeftIconPlaceholder() {
    return new Vector2$1(
      this.position.x - this.getSize().x / 2 + IconDimensions.ICON_SIZE_SMALL / 2 + IconDimensions.ICON_PADDING,
      this.position.y
    );
  }
  /**
   * Gets the placeholder position for an icon at the right of the element.
   * The position is calculated by taking the element's right edge and offsetting it inward
   * by half the icon size plus padding.
   * @returns {THREE.Vector2} A 2D vector representing the placeholder coordinates
   *                         where x is the element's right edge x-coordinate minus (icon size/2 + padding)
   *                         and y is the element's center y-coordinate
   */
  getRightIconPlaceholder() {
    return new Vector2$1(
      this.position.x + this.getSize().x / 2 - IconDimensions.ICON_SIZE_SMALL / 2 - IconDimensions.ICON_PADDING,
      this.position.y
    );
  }
  /**
   * Gets the placeholder position for an icon at the top-left corner of the element.
   * The position is calculated by taking the element's top-left corner and offsetting it inward
   * by half the icon size plus padding along both axes.
   * @returns {THREE.Vector2} A 2D vector representing the placeholder coordinates
   *                         where x is the element's left edge x-coordinate plus (icon size/2 + padding)
   *                         and y is the element's top edge y-coordinate minus (icon size/2 + padding)
   */
  getTopLeftIconPlaceholder() {
    return new Vector2$1(
      this.position.x - this.getSize().x / 2 + IconDimensions.ICON_SIZE_SMALL / 2 + IconDimensions.ICON_PADDING,
      this.position.y + this.getSize().y / 2 - IconDimensions.ICON_SIZE_SMALL / 2 - IconDimensions.ICON_PADDING
    );
  }
  /**
   * Gets the placeholder position for an icon at the top-right corner of the element.
   * The position is calculated by taking the element's top-right corner and offsetting it inward
   * by half the icon size plus padding along both axes.
   * @returns {THREE.Vector2} A 2D vector representing the placeholder coordinates
   *                         where x is the element's right edge x-coordinate minus (icon size/2 + padding)
   *                         and y is the element's top edge y-coordinate minus (icon size/2 + padding)
   */
  getTopRightIconPlaceholder() {
    return new Vector2$1(
      this.position.x + this.getSize().x / 2 - IconDimensions.ICON_SIZE_SMALL / 2 - IconDimensions.ICON_PADDING,
      this.position.y + this.getSize().y / 2 - IconDimensions.ICON_SIZE_SMALL / 2 - IconDimensions.ICON_PADDING
    );
  }
  /**
   * Gets the placeholder position for an icon at the bottom-left corner of the element.
   * The position is calculated by taking the element's bottom-left corner and offsetting it inward
   * by half the icon size plus padding along both axes.
   * @returns {THREE.Vector2} A 2D vector representing the placeholder coordinates
   *                         where x is the element's left edge x-coordinate plus (icon size/2 + padding)
   *                         and y is the element's bottom edge y-coordinate plus (icon size/2 + padding)
   */
  getBottomLeftIconPlaceholder() {
    return new Vector2$1(
      this.position.x - this.getSize().x / 2 + IconDimensions.ICON_SIZE_SMALL / 2 + IconDimensions.ICON_PADDING,
      this.position.y - this.getSize().y / 2 + IconDimensions.ICON_SIZE_SMALL / 2 + IconDimensions.ICON_PADDING
    );
  }
  /**
   * Gets the placeholder position for an icon at the bottom-right corner of the element.
   * The position is calculated by taking the element's bottom-right corner and offsetting it inward
   * by half the icon size plus padding along both axes.
   * @returns {THREE.Vector2} A 2D vector representing the placeholder coordinates
   *                         where x is the element's right edge x-coordinate minus (icon size/2 + padding)
   *                         and y is the element's bottom edge y-coordinate plus (icon size/2 + padding)
   */
  getBottomRightIconPlaceholder() {
    return new Vector2$1(
      this.position.x + this.getSize().x / 2 - IconDimensions.ICON_SIZE_SMALL / 2 - IconDimensions.ICON_PADDING,
      this.position.y - this.getSize().y / 2 + IconDimensions.ICON_SIZE_SMALL / 2 + IconDimensions.ICON_PADDING
    );
  }
  /**
   * Gets the placeholder position for an icon at the center of the element.
   * The position is at the element's center.
   * @returns {THREE.Vector2} A 2D vector representing the placeholder coordinates
   *                         where x is the element's center x-coordinate
   *                         and y is the element's center y-coordinate
   */
  getCenterIconPlaceholder() {
    return new Vector2$1(this.position.x, this.position.y);
  }
  /**
   * Gets the position for an icon placeholder.
   * @param {string} position - Position identifier (top, bottom, left, right, etc.)
   * @returns {THREE.Vector2} The placeholder position
   * @throws {Error} If the position identifier is invalid
   */
  getIconPlaceholder(position) {
    switch (position) {
      case "top":
        return this.getTopIconPlaceholder();
      case "bottom":
        return this.getBottomIconPlaceholder();
      case "left":
        return this.getLeftIconPlaceholder();
      case "right":
        return this.getRightIconPlaceholder();
      case "top-left":
        return this.getTopLeftIconPlaceholder();
      case "top-right":
        return this.getTopRightIconPlaceholder();
      case "bottom-left":
        return this.getBottomLeftIconPlaceholder();
      case "bottom-right":
        return this.getBottomRightIconPlaceholder();
      case "center":
        return this.getCenterIconPlaceholder();
      default:
        throw new Error(`Unknown icon position: ${position}`);
    }
  }
  /**
   * Adds an icon to the element.
   * @param {string} icon - The icon identifier
   * @param {string} [placeholder='center'] - Position of the icon
   * @param {number} [size=IconDimensions.ICON_SIZE_MEDIUM] - Size of the icon
   * @returns {Element} This element for method chaining
   */
  addIcon(icon, placeholder = "center", size = IconDimensions.ICON_SIZE_MEDIUM) {
    let position;
    if (typeof placeholder === "string") {
      position = this.getIconPlaceholder(placeholder);
    }
    const iconElement = new Element(this.elementId + "_icon_placeholder", new IconShape(icon, size));
    this.diagram.addElement(iconElement).positionAt(position);
    this.icons.push({ element: iconElement, positionOffset: new Vector3$1(position.x - this.position.x, position.y - this.position.y, 0) });
    return this;
  }
  // ================================================================
  // Add Analysis methods
  // ================================================================
  /**
   * Adds a value bar for analysis mode.
   * @param {number} value - The value to represent (must be positive)
   * @returns {Element} This element for method chaining
   */
  addValueBar(value) {
    if (value < 0) {
      console.warn("valueBar: Value must be positive");
      return this;
    }
    this.parameters["value"] = value;
    console.log("valueBar added:", this);
    if (this.diagram.mode !== "ANALYZE") {
      console.warn("valueBar: Diagram mode is not ANALYZE");
      return this;
    }
    const barElement = new Element(this.elementId + "_bar", new ValueBarShape(this.shape.getOuterShape(), value));
    this.diagram.addElement(barElement).positionAt(this.position);
    this.valueBars.push({ element: barElement, positionOffset: new Vector3$1(0, 0, 0) });
    return this;
  }
  // ================================================================
  // Add connecting methods
  // ================================================================
  /**
   * Creates a connector from another element to this element.
   * @param {string} sourceElementId - ID of the source element
   * @param {string} sourcePosition - Connection point on the source element
   * @param {string} targetPosition - Connection point on this element
   * @returns {Element} This element for method chaining
   * @throws {Error} If the diagram is not set or source element is not found
   */
  connectFrom(sourceElementId, sourcePosition, targetPosition) {
    if (!this.diagram) {
      throw new Error("Diagram is not set for this element.");
    }
    const targetElement = this;
    const sourceElement = this.diagram.getElementById(sourceElementId);
    if (!sourceElement) {
      throw new Error(`Element with ID ${sourceElementId} not found.`);
    }
    const sourcePoint = sourceElement.getPointPosition(sourcePosition);
    const targetPoint = targetElement.getPointPosition(targetPosition);
    const points = Connector.determinePoints(sourcePoint, targetPoint, sourcePosition, targetPosition);
    this.diagram.addConnector(new Connector(
      `connector-${sourceElement.elementId}-${targetElement.elementId}`,
      new RoundedCornerOrthogonalConnectorShape(points)
    ));
    return this;
  }
}
const RoundedRectangleDimensions = {
  ACTIVITY_HORIZONTAL_SIZE: 100,
  ACTIVITY_VERTICAL_SIZE: 80,
  ACTIVITY_CORNER_RADIUS: 10,
  ACTIVITY_LINE_WIDTH: 1
};
const CircleDimensions = {
  EVENT_RADIUS: 18,
  START_EVENT_LINE_WIDTH: 1
};
const DiamondDimensions = {
  GATEWAY_DIAGONAL: 48,
  GATEWAY_LINE_WIDTH: 1
};
class CircleShape extends Shape2 {
  constructor(lineWidth = CircleDimensions.START_EVENT_LINE_WIDTH) {
    const eventRadius = CircleDimensions.EVENT_RADIUS;
    const color2 = Colors.ELEMENT_STROKE;
    const extrusionParameters = ExtrusionParameters$1;
    function circle(ctx, radius) {
      const centerX = 0;
      const centerY = 0;
      var controlPointDistance = radius * 0.552284749831;
      ctx.moveTo(centerX, centerY - radius);
      ctx.bezierCurveTo(
        centerX + controlPointDistance,
        centerY - radius,
        centerX + radius,
        centerY - controlPointDistance,
        centerX + radius,
        centerY
      );
      ctx.bezierCurveTo(
        centerX + radius,
        centerY + controlPointDistance,
        centerX + controlPointDistance,
        centerY + radius,
        centerX,
        centerY + radius
      );
      ctx.bezierCurveTo(
        centerX - controlPointDistance,
        centerY + radius,
        centerX - radius,
        centerY + controlPointDistance,
        centerX - radius,
        centerY
      );
      ctx.bezierCurveTo(
        centerX - radius,
        centerY - controlPointDistance,
        centerX - controlPointDistance,
        centerY - radius,
        centerX,
        centerY - radius
      );
    }
    var eventShape = new Shape$1();
    circle(eventShape, eventRadius);
    const outerShape = eventShape.clone();
    var eventHole = new Path();
    circle(eventHole, eventRadius - lineWidth);
    eventShape.holes.push(eventHole);
    var eventGeometry = new ExtrudeGeometry(eventShape, extrusionParameters);
    super(eventGeometry, new DiagramEditMaterial(color2));
    this.outerShape = outerShape;
  }
  getOuterShape() {
    return this.outerShape;
  }
}
class RoundedRectangleShape extends Shape2 {
  constructor() {
    const horizontalSize = RoundedRectangleDimensions.ACTIVITY_HORIZONTAL_SIZE;
    const verticalSize = RoundedRectangleDimensions.ACTIVITY_VERTICAL_SIZE;
    const lineWidth = RoundedRectangleDimensions.ACTIVITY_LINE_WIDTH;
    const cornerRadius = RoundedRectangleDimensions.ACTIVITY_CORNER_RADIUS;
    const outerRadius = cornerRadius;
    const innerRadius = cornerRadius - lineWidth;
    const color2 = Colors.ELEMENT_STROKE;
    const extrusionParameters = ExtrusionParameters$1;
    function roundedRect(ctx, width, height, radius) {
      const centerX = 0;
      const centerY = 0;
      var x = centerX - width / 2;
      var y = centerY - height / 2;
      ctx.moveTo(x + radius, y);
      ctx.lineTo(x + width - radius, y);
      ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
      ctx.lineTo(x + width, y + height - radius);
      ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
      ctx.lineTo(x + radius, y + height);
      ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
      ctx.lineTo(x, y + radius);
      ctx.quadraticCurveTo(x, y, x + radius, y);
    }
    var activityShape = new Shape$1();
    roundedRect(activityShape, horizontalSize, verticalSize, outerRadius);
    const outerShape = activityShape.clone();
    var activityHole = new Path();
    roundedRect(activityHole, horizontalSize - 2 * lineWidth, verticalSize - 2 * lineWidth, innerRadius);
    activityShape.holes.push(activityHole);
    var activityGeometry = new ExtrudeGeometry(activityShape, extrusionParameters);
    super(activityGeometry, new DiagramEditMaterial(color2));
    this.outerShape = outerShape;
  }
  getOuterShape() {
    return this.outerShape;
  }
}
class DiamondShape extends Shape2 {
  constructor() {
    const diagonal = DiamondDimensions.GATEWAY_DIAGONAL;
    const lineWidth = DiamondDimensions.GATEWAY_LINE_WIDTH;
    const color2 = Colors.ELEMENT_STROKE;
    const extrusionParameters = ExtrusionParameters$1;
    function diamond(ctx, verticalSize, horizontalSize) {
      const centerX = 0;
      const centerY = 0;
      ctx.moveTo(centerX - verticalSize / 2, centerY);
      ctx.lineTo(centerX, centerY - verticalSize / 2);
      ctx.lineTo(centerX + horizontalSize / 2, centerY);
      ctx.lineTo(centerX, centerY + verticalSize / 2);
      ctx.lineTo(centerX - horizontalSize / 2, centerY);
    }
    var gatewayShape = new Shape$1();
    diamond(gatewayShape, diagonal, diagonal);
    const outerShape = gatewayShape.clone();
    var gatewayHole = new Path();
    diamond(gatewayHole, diagonal - lineWidth * Math.sqrt(2) * 2, diagonal - lineWidth * Math.sqrt(2) * 2);
    gatewayShape.holes.push(gatewayHole);
    var gatewayGeometry = new ExtrudeGeometry(gatewayShape, extrusionParameters);
    super(gatewayGeometry, new DiagramEditMaterial(color2));
    this.outerShape = outerShape;
  }
  getOuterShape() {
    return this.outerShape;
  }
}
const manual = '<?xml version="1.0" encoding="UTF-8" standalone="no"?>\n<svg\n   xmlns:dc="http://purl.org/dc/elements/1.1/"\n   xmlns:cc="http://creativecommons.org/ns#"\n   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"\n   xmlns:svg="http://www.w3.org/2000/svg"\n   xmlns="http://www.w3.org/2000/svg"\n   version="1.1"\n   id="svg2"\n   viewBox="0 0 2000 2000"\n   height="2000"\n   width="2000">\n  <defs\n     id="defs4" />\n  <metadata\n     id="metadata7">\n    <rdf:RDF>\n      <cc:Work\n         rdf:about="">\n        <dc:format>image/svg+xml</dc:format>\n        <dc:type\n           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />\n        <dc:title></dc:title>\n        <cc:license\n           rdf:resource="https://github.com/bpmn-io/bpmn-font/blob/master/LICENSE" />\n        <dc:creator>\n          <cc:Agent>\n            <dc:title>Jörg Dotzki</dc:title>\n          </cc:Agent>\n        </dc:creator>\n        <dc:subject>\n          <rdf:Bag>\n            <rdf:li>BPMN</rdf:li>\n            <rdf:li>bpmn-io</rdf:li>\n            <rdf:li>bpmn.io</rdf:li>\n            <rdf:li>Font</rdf:li>\n          </rdf:Bag>\n        </dc:subject>\n      </cc:Work>\n    </rdf:RDF>\n  </metadata>\n  <g\n     transform="translate(0,947.63784)"\n     id="layer1">\n    <path\n       id="path4135"\n       transform="translate(0,-947.63784)"\n       d="M 919.37891 382.98828 C 897.07985 382.99534 876.42602 391.24619 858.8125 402.60352 L 858.7832 402.62109 L 858.75586 402.64062 C 764.06211 463.96011 439.8885 688.93075 368.62891 737.8418 L 368.62695 737.84375 L 368.625 737.84375 C 304.25376 782.03986 260.89214 848.74751 235.96289 927.7793 L 235.95898 927.79492 L 235.95508 927.80859 C 210.0027 1010.3241 213.33304 1100.2119 213.58398 1175.4941 L 213.58594 1175.5137 L 213.58594 1175.5332 C 213.84074 1232.2188 215.19212 1281.6884 229.89453 1341.6816 C 229.89553 1341.6866 229.89744 1341.692 229.89844 1341.6973 C 251.2713 1429.4993 292.66639 1493.0333 351.12891 1531.9824 C 409.58875 1570.9297 481.74302 1584.75 562.70312 1585 C 854.98652 1586.0972 1147.4442 1586.4897 1439.8848 1585 L 1439.9102 1585 L 1439.9355 1585 C 1472.1442 1584.7888 1502.8949 1571.2476 1522.0703 1547.3223 C 1541.2443 1523.3988 1549.087 1492.4573 1549.5 1458.5117 C 1549.7909 1435.7437 1546.5893 1414.2247 1539.1934 1395 L 1571.5684 1395 C 1603.0995 1395 1632.0021 1386.016 1652.7207 1367.084 C 1673.4323 1348.1584 1684.0251 1322.4631 1689.5293 1295.4043 L 1689.5293 1295.3965 C 1697.2116 1257.7567 1693.5837 1220.59 1678.6133 1189.4004 C 1711.5589 1186.7389 1740.6465 1174.2976 1759.3535 1151.4941 C 1780.3767 1125.8673 1786.5009 1093.2887 1786.6094 1058.7734 C 1786.7238 1022.74 1777.9802 988.35302 1757.7969 961.00781 C 1737.6137 933.6626 1704.0255 915.05176 1666.2305 914.99805 L 1666.2207 914.99805 L 1666.209 914.99805 C 1652.4498 914.98657 1640.0493 915.00635 1624.4277 914.99805 C 1631.9444 896.25389 1635.2488 875.17154 1635.1797 852.99219 L 1635.1797 852.93555 L 1635.1797 852.87891 C 1634.9519 817.10655 1625.9288 782.92541 1605.6445 755.75195 C 1585.3606 728.57897 1551.8364 709.9987 1514.0586 709.99805 C 1289.6388 709.11253 1067.8072 712.155 879.15625 711.20117 C 888.98683 701.31624 898.53379 691.67619 909.02734 681.24023 C 941.50862 648.93721 972.72655 618.49752 988.85352 597.62891 C 1027.4086 548.00648 1033.1613 480.77723 1000.7031 431.32422 C 983.59029 405.18088 958.49595 387.49228 931.55273 383.81055 C 928.18377 383.35019 924.8448 383.0899 921.54102 383.01172 L 921.54102 383.01367 C 920.81831 382.99657 920.09823 382.98805 919.37891 382.98828 z M 919.92578 453.01562 C 920.69385 453.02416 921.41106 453.07733 922.07422 453.16797 C 927.37949 453.89292 933.05983 455.78817 942.14453 469.67383 L 942.16211 469.69922 L 942.17773 469.72461 C 954.86945 489.05096 954.30896 528.02989 933.55469 554.7168 L 933.51953 554.76172 L 933.48438 554.80664 C 925.93786 564.57639 892.03049 599.42252 859.66602 631.60938 C 827.30154 663.79624 796.53208 693.50491 781.30859 712.05078 C 766.75168 729.78466 772.09283 744.6981 776.04102 754.0332 C 779.9892 763.3683 784.5057 774.26988 804.63867 779.05273 C 810.66655 780.48469 810.99854 780.07253 812.92773 780.20508 C 814.85693 780.33763 816.85106 780.42902 819.19531 780.51367 C 823.88381 780.68297 829.88273 780.81106 837.28906 780.91992 C 1063.754 782.29908 1287.7116 779.67931 1513.998 780 L 1514.0293 780 L 1514.0605 780 C 1531.2724 780 1540.6175 785.65704 1549.5527 797.62695 C 1558.482 809.58885 1565.0212 829.44025 1565.1816 853.2793 C 1565.2476 878.00948 1559.325 893.09925 1552.125 901.41211 C 1544.925 909.72493 1535.2797 914.9327 1514.6504 915 L 1030 915 L 1030 985 L 1514.7422 985 L 1514.791 985 C 1581.2694 985.0062 1616.3318 984.95843 1666.1543 985 C 1683.4616 985.02951 1692.6831 990.66165 1701.4785 1002.5781 C 1710.2778 1014.4998 1716.688 1034.4049 1716.6113 1058.5527 L 1716.6113 1058.5547 C 1716.5303 1084.3774 1711.2652 1099.7505 1705.2363 1107.0996 C 1699.2075 1114.4487 1690.5982 1119.8316 1665.7539 1120.002 C 1657.3241 1120.0598 1596.946 1120.0156 1571.8906 1120.0449 C 1571.4936 1120.0399 1571.105 1120.0032 1570.707 1120.002 C 1390.4805 1119.1514 1210.2524 1120 1030.0254 1120 L 1030 1120 L 1029.9746 1190 L 1030 1190 C 1030.043 1190 1412.5167 1190.2386 1571.3301 1190.0469 C 1591.0301 1190.326 1602.841 1198.2575 1612.2637 1213.6484 C 1621.8272 1229.2694 1626.5869 1253.7579 1620.9434 1281.4043 L 1620.9434 1281.418 L 1620.9434 1281.4316 C 1617.207 1299.8121 1611.5308 1309.9046 1605.5078 1315.4082 C 1599.4848 1320.9118 1591.1733 1325 1571.5742 1325 C 1391.0507 1324.9139 1210.5297 1324.5478 1030.0059 1325 L 1029.9141 1325 L 1030.0059 1395 L 1030.0977 1395 L 1439.4043 1395 L 1439.4199 1395 C 1454.127 1395.0958 1460.6667 1399.0084 1467.3809 1407.9766 C 1474.0951 1416.9447 1479.8203 1433.619 1479.5117 1457.6289 L 1479.5117 1457.6426 L 1479.5117 1457.6543 C 1479.2276 1481.0659 1473.56 1495.9259 1467.4551 1503.543 C 1461.3503 1511.16 1455.0501 1514.8999 1439.4824 1515.002 C 1147.359 1516.4898 855.12644 1516.0987 562.97266 1515.002 L 562.95898 1515.002 L 562.94727 1515.002 C 489.89431 1514.7789 432.49137 1502.0704 389.94727 1473.7266 C 347.39676 1445.3826 316.33958 1400.8581 297.9082 1325.1289 L 297.90039 1325.0996 L 297.89453 1325.0703 C 285.02432 1272.5777 283.83532 1231.06 283.58398 1175.2598 L 283.58398 1175.2188 C 283.32833 1098.6482 281.8595 1015.1692 302.73047 948.81055 C 324.12233 881.00932 358.71817 829.5583 408.24219 795.55469 L 408.24609 795.55273 C 480.37064 746.04796 806.47508 519.89392 896.74609 461.43359 L 896.75 461.43164 C 905.22608 455.9669 912.24926 453.64295 917.46875 453.12891 C 918.3388 453.04322 919.15772 453.00709 919.92578 453.01562 z "\n       style="color:#000000;font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;font-size:medium;line-height:normal;font-family:sans-serif;text-indent:0;text-align:start;text-decoration:none;text-decoration-line:none;text-decoration-style:solid;text-decoration-color:#000000;letter-spacing:normal;word-spacing:normal;text-transform:none;direction:ltr;block-progression:tb;writing-mode:lr-tb;baseline-shift:baseline;text-anchor:start;white-space:normal;clip-rule:nonzero;display:inline;overflow:visible;visibility:visible;opacity:1;isolation:auto;mix-blend-mode:normal;color-interpolation:sRGB;color-interpolation-filters:linearRGB;solid-color:#000000;solid-opacity:1;fill:#000000;fill-opacity:1;fill-rule:nonzero;stroke:none;stroke-width:70;stroke-linecap:round;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1;color-rendering:auto;image-rendering:auto;shape-rendering:auto;text-rendering:auto;enable-background:accumulate" />\n  </g>\n</svg>\n';
const user = '<?xml version="1.0" encoding="UTF-8" standalone="no"?>\n<svg\n   xmlns:dc="http://purl.org/dc/elements/1.1/"\n   xmlns:cc="http://creativecommons.org/ns#"\n   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"\n   xmlns:svg="http://www.w3.org/2000/svg"\n   xmlns="http://www.w3.org/2000/svg"\n   version="1.1"\n   id="svg2"\n   viewBox="0 0 2000 2000"\n   height="2000"\n   width="2000">\n  <defs\n     id="defs4" />\n  <metadata\n     id="metadata7">\n    <rdf:RDF>\n      <cc:Work\n         rdf:about="">\n        <dc:format>image/svg+xml</dc:format>\n        <dc:type\n           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />\n        <dc:title></dc:title>\n        <cc:license\n           rdf:resource="https://github.com/bpmn-io/bpmn-font/blob/master/LICENSE" />\n        <dc:creator>\n          <cc:Agent>\n            <dc:title>Jörg Dotzki</dc:title>\n          </cc:Agent>\n        </dc:creator>\n        <dc:subject>\n          <rdf:Bag>\n            <rdf:li>BPMN</rdf:li>\n            <rdf:li>bpmn-io</rdf:li>\n            <rdf:li>bpmn.io</rdf:li>\n            <rdf:li>Font</rdf:li>\n          </rdf:Bag>\n        </dc:subject>\n      </cc:Work>\n    </rdf:RDF>\n  </metadata>\n  <g\n     style="display:inline"\n     id="layer9">\n    <path\n       id="path8979-3"\n       d="M 991.75,365 C 814.47261,365 687.65259,501.28069 687.29688,656.51367 l 0,0.0449 0,0.043 c 0.0112,46.94485 12.71406,96.48986 32.56054,141.17774 14.33025,32.26709 32.14702,61.93151 53.85742,85.69531 C 644.68593,927.61788 493.52222,1000.2699 417.11719,1143.5293 L 413,1151.25 l 0,463.75 1157.5,0 0,-463.75 -4.1172,-7.7207 c -75.3061,-141.1989 -223.1988,-213.74978 -350.9805,-258.07618 62.3794,-63.43263 80.7808,-145.30578 80.8008,-228.85156 l 0,-0.043 0,-0.0449 C 1295.8474,501.2807 1169.0274,365 991.75,365 Z M 870.70898,530.29883 c 8.19443,0.0206 17.19117,0.29432 27.10938,0.8789 79.02308,4.65771 105.61894,18.88222 126.06254,32.37305 20.4435,13.49083 34.8553,26.33317 88.8828,27.9082 l 0.016,0 0.018,0 c 42.1017,-1.5748 62.3491,-9.0811 76.8691,-17.58398 5.8837,-3.44545 10.8241,-7.02722 15.8867,-10.44727 13.3814,28.68227 20.5671,60.38893 20.6485,93.20313 -0.028,93.43999 -16.0919,158.87652 -101.7676,212.42383 l 8.3809,63.16992 c 17.8327,5.41537 36.2658,11.35733 54.9746,17.87305 2.6128,10.90011 5.6316,25.19633 7.6621,40.39453 2.1271,15.92241 2.9637,32.48881 1.6523,44.92771 -1.3114,12.4389 -5.1734,19.1539 -5.8515,19.8321 -43.5469,43.5468 -120.8464,68.9433 -199.252,68.9433 -78.40557,0 -155.70507,-25.3965 -199.25195,-68.9433 -0.67811,-0.6782 -4.54017,-7.3932 -5.85157,-19.8321 -1.31139,-12.4389 -0.47481,-29.0053 1.65235,-44.92771 2.04162,-15.28211 5.08445,-29.66261 7.70703,-40.58399 18.52194,-6.44112 36.76978,-12.32071 54.42969,-17.68359 l 4.99609,-67.6875 c -4.068,-5.21708 -8.21297,-8.67324 -13.16016,-12.38477 -19.12128,-14.34532 -42.30994,-45.90379 -58.68945,-82.78515 -16.37367,-36.86821 -26.51791,-79.00946 -26.5332,-112.74414 0.10174,-40.44431 10.98577,-79.211 30.97656,-112.69727 3.57689,-1.33139 7.34871,-2.73853 11.58789,-4.13281 14.90781,-4.90324 35.33655,-9.58342 70.8457,-9.49414 z M 719.36133,979.85547 c -0.0629,0.45883 -0.13379,0.90664 -0.19531,1.36719 -2.58689,19.36354 -4.10696,40.44054 -1.88282,61.53714 2.22414,21.0966 7.79068,43.8102 25.96875,61.9882 62.04773,62.0478 155.95092,89.4473 248.74805,89.4473 92.7971,0 186.7003,-27.3995 248.748,-89.4473 18.1781,-18.178 23.7447,-40.8916 25.9688,-61.9882 2.2241,-21.0967 0.7041,-42.1736 -1.8828,-61.53714 -0.051,-0.38161 -0.1102,-0.75238 -0.1621,-1.13282 94.3337,41.36896 185.5148,100.61546 235.8281,189.07426 l 0,375.8359 -167.5,0 0,-265 -70,0 0,265 -544,0 0,-265 -70,0 0,265 -166,0 0,-375.8359 c 50.40811,-88.6256 141.83798,-147.9292 236.36133,-189.30863 z"\n       style="color:#000000;font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;font-size:medium;line-height:normal;font-family:sans-serif;text-indent:0;text-align:start;text-decoration:none;text-decoration-line:none;text-decoration-style:solid;text-decoration-color:#000000;letter-spacing:normal;word-spacing:normal;text-transform:none;direction:ltr;block-progression:tb;writing-mode:lr-tb;baseline-shift:baseline;text-anchor:start;white-space:normal;clip-rule:nonzero;display:inline;overflow:visible;visibility:visible;opacity:1;isolation:auto;mix-blend-mode:normal;color-interpolation:sRGB;color-interpolation-filters:linearRGB;solid-color:#000000;solid-opacity:1;fill:#000000;fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:70;stroke-linecap:round;stroke-linejoin:miter;stroke-miterlimit:2.29999995;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1;color-rendering:auto;image-rendering:auto;shape-rendering:auto;text-rendering:auto;enable-background:accumulate" />\n  </g>\n</svg>\n';
const script = '<?xml version="1.0" encoding="UTF-8" standalone="no"?>\n<svg\n   xmlns:dc="http://purl.org/dc/elements/1.1/"\n   xmlns:cc="http://creativecommons.org/ns#"\n   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"\n   xmlns:svg="http://www.w3.org/2000/svg"\n   xmlns="http://www.w3.org/2000/svg"\n   version="1.1"\n   id="svg2"\n   viewBox="0 0 2000 2000"\n   height="2000"\n   width="2000">\n  <defs\n     id="defs4" />\n  <metadata\n     id="metadata7">\n    <rdf:RDF>\n      <cc:Work\n         rdf:about="">\n        <dc:format>image/svg+xml</dc:format>\n        <dc:type\n           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />\n        <dc:title></dc:title>\n        <cc:license\n           rdf:resource="https://github.com/bpmn-io/bpmn-font/blob/master/LICENSE" />\n        <dc:creator>\n          <cc:Agent>\n            <dc:title>Jörg Dotzki</dc:title>\n          </cc:Agent>\n        </dc:creator>\n        <dc:subject>\n          <rdf:Bag>\n            <rdf:li>BPMN</rdf:li>\n            <rdf:li>bpmn-io</rdf:li>\n            <rdf:li>bpmn.io</rdf:li>\n            <rdf:li>Font</rdf:li>\n          </rdf:Bag>\n        </dc:subject>\n      </cc:Work>\n    </rdf:RDF>\n  </metadata>\n  <g\n     style="display:inline"\n     transform="translate(0,947.63784)"\n     id="layer1" />\n  <g\n     style="display:inline"\n     id="layer3">\n    <path\n       id="path7110"\n       d="M 759.41016 378 L 751.14844 382.9043 L 748.44922 384.50781 C 631.65776 453.72038 551.2844 517.18548 498.22852 579.16016 C 445.09916 641.22062 419.412 703.70808 418.68164 763.94727 C 417.22817 883.82775 505.65392 973.66586 584.10742 1054.0137 C 662.50124 1134.3003 732.43001 1210.0155 739.01172 1272.6777 C 742.36637 1304.6164 734.81689 1336.6966 699.99219 1380.6211 C 665.314 1424.3609 602.37552 1476.7493 501.75195 1535.4062 L 353.19336 1622 L 1270.0469 1622 L 1280.8965 1615.6875 L 1280.9082 1615.6777 C 1387.5436 1553.5161 1459.3849 1496.0867 1505.1621 1438.3477 C 1551.0758 1380.4366 1569.7557 1319.8482 1563.7812 1262.9688 C 1551.9436 1150.2668 1460.136 1068.1422 1382.9531 989.0957 C 1305.7103 909.98783 1243.1007 835.37489 1243.9531 765.07227 C 1244.3835 729.58122 1258.0249 689.98786 1301.1719 639.58789 C 1344.245 589.27401 1416.8675 530.40674 1528.2031 464.42969 L 1528.2031 464.42773 L 1674.0449 378 L 759.41016 378 z M 785.25195 470.91797 L 1349.8945 470.91797 C 1300.1653 507.99629 1260.8461 543.81554 1230.5879 579.16016 C 1177.4586 641.22061 1151.7714 703.70807 1151.041 763.94727 C 1149.5876 883.82876 1238.0176 973.66632 1316.4707 1054.0137 C 1394.8641 1134.2998 1464.7873 1210.0143 1471.3691 1272.6777 C 1474.7238 1304.6165 1467.1762 1336.6966 1432.3516 1380.6211 C 1398.9553 1422.7439 1338.8961 1473.0068 1244.5625 1529.082 L 678.47266 1529.082 C 717.74278 1498.4553 748.94092 1468.4466 772.80273 1438.3496 C 818.71647 1380.4385 837.39619 1319.8501 831.42188 1262.9707 C 819.58425 1150.2687 727.77664 1068.1442 650.59375 989.09766 C 573.35098 909.9898 510.74334 835.37687 511.5957 765.07422 C 512.02602 729.58325 525.66558 689.98982 568.8125 639.58984 C 610.43918 590.96566 680.08673 534.2435 785.25195 470.91797 z M 653.13086 629.39258 L 653.13086 672.3125 L 1094.5293 672.3125 L 1094.5293 629.39258 L 653.13086 629.39258 z M 636.72852 860.56836 L 636.72852 903.48633 L 1093.1133 903.48633 L 1093.1133 860.56836 L 636.72852 860.56836 z M 843.52344 1091.7383 L 843.52344 1134.6562 L 1285.5117 1134.6562 L 1285.5117 1091.7383 L 843.52344 1091.7383 z M 906.7207 1322.9121 L 906.7207 1365.8301 L 1364.707 1365.8301 L 1364.707 1322.9121 L 906.7207 1322.9121 z "\n       style="color:#000000;font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;font-size:medium;line-height:normal;font-family:sans-serif;text-indent:0;text-align:start;text-decoration:none;text-decoration-line:none;text-decoration-style:solid;text-decoration-color:#000000;letter-spacing:normal;word-spacing:normal;text-transform:none;direction:ltr;block-progression:tb;writing-mode:lr-tb;baseline-shift:baseline;text-anchor:start;white-space:normal;clip-rule:nonzero;display:inline;overflow:visible;visibility:visible;opacity:1;isolation:auto;mix-blend-mode:normal;color-interpolation:sRGB;color-interpolation-filters:linearRGB;solid-color:#000000;solid-opacity:1;fill:#000000;fill-opacity:1;fill-rule:nonzero;stroke:none;stroke-width:70;stroke-linecap:round;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1;color-rendering:auto;image-rendering:auto;shape-rendering:auto;text-rendering:auto;enable-background:accumulate" />\n  </g>\n</svg>\n';
const businessRule = '<?xml version="1.0" encoding="UTF-8" standalone="no"?>\n<!-- Created with Inkscape (http://www.inkscape.org/) -->\n\n<svg\n   xmlns:dc="http://purl.org/dc/elements/1.1/"\n   xmlns:cc="http://creativecommons.org/ns#"\n   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"\n   xmlns:svg="http://www.w3.org/2000/svg"\n   xmlns="http://www.w3.org/2000/svg"\n   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"\n   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"\n   width="2000"\n   height="2000"\n   viewBox="0 0 2000 2000"\n   id="svg2"\n   version="1.1"\n   inkscape:version="0.91 r"\n   sodipodi:docname="business-rule.svg">\n  <defs\n     id="defs4" />\n  <sodipodi:namedview\n     id="base"\n     pagecolor="#ffffff"\n     bordercolor="#666666"\n     borderopacity="1.0"\n     inkscape:pageopacity="0.0"\n     inkscape:pageshadow="2"\n     inkscape:zoom="0.45254834"\n     inkscape:cx="811.70031"\n     inkscape:cy="1077.9584"\n     inkscape:document-units="px"\n     inkscape:current-layer="layer1"\n     showgrid="true"\n     units="px"\n     showguides="false"\n     inkscape:window-width="1920"\n     inkscape:window-height="1028"\n     inkscape:window-x="0"\n     inkscape:window-y="0"\n     inkscape:window-maximized="1">\n    <inkscape:grid\n       type="xygrid"\n       id="grid4008"\n       empspacing="20"\n       dotted="false" />\n  </sodipodi:namedview>\n  <metadata\n     id="metadata7">\n    <rdf:RDF>\n      <cc:Work\n         rdf:about="">\n        <dc:format>image/svg+xml</dc:format>\n        <dc:type\n           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />\n        <dc:title />\n        <cc:license\n           rdf:resource="https://github.com/bpmn-io/bpmn-font/blob/master/LICENSE" />\n        <dc:creator>\n          <cc:Agent>\n            <dc:title>Jörg Dotzki</dc:title>\n          </cc:Agent>\n        </dc:creator>\n        <dc:subject>\n          <rdf:Bag>\n            <rdf:li>BPMN</rdf:li>\n            <rdf:li>bpmn-io</rdf:li>\n            <rdf:li>bpmn.io</rdf:li>\n            <rdf:li>Font</rdf:li>\n          </rdf:Bag>\n        </dc:subject>\n      </cc:Work>\n    </rdf:RDF>\n  </metadata>\n  <g\n     inkscape:label="Ebene 1"\n     inkscape:groupmode="layer"\n     id="layer1"\n     transform="translate(0,947.63784)">\n    <path\n       style="opacity:1;fill:#000000;fill-opacity:1;stroke:none;stroke-width:10;stroke-linecap:round;stroke-miterlimit:4;stroke-dasharray:none"\n       id="path4135"\n       d="m 212.27677,-529.63785 0,382.36913 1574.78513,0 0,-382.36913 z"\n       inkscape:connector-curvature="0"\n       sodipodi:nodetypes="ccccc" />\n    <path\n       style="opacity:1;fill:none;fill-opacity:0.28037385;stroke:#000000;stroke-width:70;stroke-linecap:round;stroke-miterlimit:4;stroke-dasharray:none"\n       d="m 213.10529,52.362159 0,-581.999999 1573.78941,0 0,581.999999 0,582.000001 -1186.8947,0 0,-790.394 0,790.394 -386.89471,0 0,-401.56446 1573.78941,0 -1573.78941,0 z"\n       id="rect4139"\n       inkscape:connector-curvature="0"\n       sodipodi:nodetypes="ccccccccccscc" />\n  </g>\n</svg>\n';
const service = '<?xml version="1.0" encoding="UTF-8" standalone="no"?>\n<svg\n   xmlns:dc="http://purl.org/dc/elements/1.1/"\n   xmlns:cc="http://creativecommons.org/ns#"\n   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"\n   xmlns:svg="http://www.w3.org/2000/svg"\n   xmlns="http://www.w3.org/2000/svg"\n   width="2000"\n   height="2000"\n   viewBox="0 0 2000 2000"\n   id="svg2"\n   version="1.1">\n  <defs\n     id="defs4" />\n  <metadata\n     id="metadata7">\n    <rdf:RDF>\n      <cc:Work\n         rdf:about="">\n        <dc:format>image/svg+xml</dc:format>\n        <dc:type\n           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />\n        <dc:title></dc:title>\n        <cc:license\n           rdf:resource="https://github.com/bpmn-io/bpmn-font/blob/master/LICENSE" />\n        <dc:creator>\n          <cc:Agent>\n            <dc:title>Jörg Dotzki</dc:title>\n          </cc:Agent>\n        </dc:creator>\n        <dc:subject>\n          <rdf:Bag>\n            <rdf:li>BPMN</rdf:li>\n            <rdf:li>bpmn-io</rdf:li>\n            <rdf:li>bpmn.io</rdf:li>\n            <rdf:li>Font</rdf:li>\n          </rdf:Bag>\n        </dc:subject>\n      </cc:Work>\n    </rdf:RDF>\n  </metadata>\n  <g\n     id="layer6"\n     style="display:inline">\n    <path\n       id="path4170"\n       d="M 825.74609 438.17383 C 825.69979 475.1723 825.7563 512.17163 825.85156 549.16992 C 794.29829 558.09661 765.46524 570.55412 738.23633 585.81445 L 658.6543 507.18945 L 509.84766 656.85742 L 589.42383 735.46875 C 574.05216 763.02029 562.04871 792.29945 553.67188 822.71094 L 440.94727 822.91602 L 440.94727 1033.7051 L 554.84961 1033.2949 C 565.26551 1074.5933 587.93422 1111.7201 610.51172 1144.918 L 610.51172 963.09375 L 510.94727 963.45117 L 510.94727 892.78906 L 610.01562 892.60938 L 615.57617 864.4375 C 623.68569 823.35291 639.74603 784.18805 662.82031 749.14453 L 678.60547 725.17188 L 609.00195 656.41016 L 659.0957 606.02539 L 728.82617 674.91797 L 752.55664 659.08203 C 788.8205 635.15649 828.48451 619.11851 868.03711 610.76562 L 895.99609 604.96094 L 895.74609 508.17578 L 967.71289 508.17578 L 967.15625 604.45703 L 995.58398 604.45703 L 1155.9902 604.45703 C 1138.2768 583.31338 1064.8698 555.79938 1037.4824 548.13281 L 1038.1172 438.17578 C 959.71716 438.17378 898.25174 438.18016 825.74609 438.17383 z M 1024.9043 639.83203 L 1025.1914 750.82422 C 993.63698 759.75091 964.80383 772.20673 937.57422 787.46875 L 857.99023 708.84375 L 709.18359 858.51172 L 788.76172 937.12305 C 773.38937 964.67608 761.38462 993.9543 753.00781 1024.3672 L 640.28516 1024.5703 L 640.28516 1235.3594 L 754.18555 1234.9512 C 763.15098 1266.2082 775.57969 1294.751 790.81055 1321.6973 L 709.31641 1402.873 L 859.78125 1550.752 L 940.98242 1469.9277 C 968.79672 1485.3724 998.3629 1497.3637 1029.0156 1505.709 L 1029.0684 1620.4219 C 1101.4601 1621.0557 1178.5354 1620.7292 1240.4043 1620.7227 L 1240.4043 1504.6523 C 1271.9821 1495.7485 1300.9053 1483.2014 1328.1406 1467.9473 L 1409.2754 1547.9434 L 1558.1797 1398.4629 L 1476.875 1318.3398 C 1492.282 1290.7142 1504.2874 1261.3861 1512.6738 1230.9414 L 1623.0527 1230.2598 L 1623.0527 1019.6738 L 1511.4355 1020.3535 C 1502.4631 989.06652 1490.2142 960.71674 1474.7812 933.5918 L 1551.9023 856.27344 L 1401.5215 708.14258 L 1324.5 785.42773 C 1296.7997 770.10877 1267.3537 758.14537 1236.8203 749.78906 L 1237.4531 639.83203 L 1024.9043 639.83203 z M 1095.084 709.83203 L 1167.0508 709.83203 L 1166.4961 806.11523 L 1194.9219 811.69336 C 1236.1943 819.79239 1275.7525 835.83275 1310.9375 858.76562 L 1334.7617 874.29492 L 1401.9785 806.84961 L 1452.5957 856.71094 L 1385.2852 924.19336 L 1401.4805 948.09961 C 1425.2452 983.9725 1441.0088 1022.7495 1449.9082 1062.6797 L 1455.7637 1090.6914 L 1553.0449 1090.0996 L 1553.0449 1160.6895 L 1456.3066 1161.2852 L 1450.75 1189.2969 C 1442.5902 1230.4276 1426.5649 1269.591 1403.4512 1304.6953 L 1387.6484 1328.7012 L 1458.9062 1398.9238 L 1408.8203 1449.2031 L 1337.5547 1378.9375 L 1313.8652 1394.6758 C 1277.59 1418.3823 1238.2406 1434.7985 1198.541 1442.8867 L 1170.3965 1448.5078 L 1170.3965 1550.7227 C 1151.1555 1550.7694 1130.1656 1550.7393 1099.0273 1550.6953 L 1098.9824 1449.2461 L 1070.7109 1443.7246 C 1029.3808 1435.6538 989.8877 1419.6871 954.76367 1396.6582 L 931.00977 1381.084 L 859.46875 1452.2949 L 808.84375 1402.5371 L 880.48438 1331.1758 L 864.13672 1307.1719 C 840.34989 1271.3777 824.61382 1232.5596 815.69922 1192.6758 L 809.84961 1164.75 L 710.28516 1165.1055 L 710.28516 1094.4453 L 809.35352 1094.2637 L 814.91406 1066.0957 C 823.02364 1025.0108 839.08423 985.84383 862.1582 950.80078 L 877.94336 926.82617 L 808.33789 858.06445 L 858.43164 807.67969 L 928.16406 876.57227 L 951.89453 860.73828 C 988.20439 836.96856 1026.7354 821.19689 1067.375 812.42383 L 1095.3359 806.61914 L 1095.084 709.83203 z M 1132.25 967.03516 C 1045.6031 967.03516 974.61133 1038.0288 974.61133 1124.6758 C 974.61133 1211.3228 1045.6031 1282.3125 1132.25 1282.3125 C 1218.8969 1282.3125 1289.8887 1211.3228 1289.8887 1124.6758 C 1289.8887 1038.0288 1218.8969 967.03516 1132.25 967.03516 z M 1132.25 1037.0352 C 1181.0662 1037.0352 1219.8887 1075.8597 1219.8887 1124.6758 C 1219.8887 1173.4919 1181.0662 1212.3125 1132.25 1212.3125 C 1083.4338 1212.3125 1044.6133 1173.4919 1044.6133 1124.6758 C 1044.6133 1075.8597 1083.4338 1037.0352 1132.25 1037.0352 z "\n       style="color:#000000;font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;font-size:medium;line-height:normal;font-family:sans-serif;text-indent:0;text-align:start;text-decoration:none;text-decoration-line:none;text-decoration-style:solid;text-decoration-color:#000000;letter-spacing:normal;word-spacing:normal;text-transform:none;direction:ltr;block-progression:tb;writing-mode:lr-tb;baseline-shift:baseline;text-anchor:start;white-space:normal;clip-rule:nonzero;display:inline;overflow:visible;visibility:visible;opacity:1;isolation:auto;mix-blend-mode:normal;color-interpolation:sRGB;color-interpolation-filters:linearRGB;solid-color:#000000;solid-opacity:1;fill:#000000;fill-opacity:1;fill-rule:nonzero;stroke:none;stroke-width:70;stroke-linecap:round;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1;color-rendering:auto;image-rendering:auto;shape-rendering:auto;text-rendering:auto;enable-background:accumulate" />\n  </g>\n  <g\n     id="layer1"\n     transform="translate(0,949.63784)"\n     style="display:inline">\n    <g\n       id="g4137"\n       transform="matrix(1.1161206,0,0,1.1161228,91.593841,25.188891)" />\n  </g>\n</svg>\n';
const send = '<?xml version="1.0" encoding="UTF-8" standalone="no"?>\n<!-- Created with Inkscape (http://www.inkscape.org/) -->\n\n<svg\n   xmlns:dc="http://purl.org/dc/elements/1.1/"\n   xmlns:cc="http://creativecommons.org/ns#"\n   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"\n   xmlns:svg="http://www.w3.org/2000/svg"\n   xmlns="http://www.w3.org/2000/svg"\n   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"\n   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"\n   width="2000"\n   height="2000"\n   viewBox="0 0 2000 2000"\n   id="svg2"\n   version="1.1"\n   inkscape:version="0.91 r"\n   sodipodi:docname="send.svg">\n  <defs\n     id="defs4" />\n  <sodipodi:namedview\n     id="base"\n     pagecolor="#ffffff"\n     bordercolor="#666666"\n     borderopacity="1.0"\n     inkscape:pageopacity="0.0"\n     inkscape:pageshadow="2"\n     inkscape:zoom="0.22627417"\n     inkscape:cx="1062.5989"\n     inkscape:cy="892.16496"\n     inkscape:document-units="px"\n     inkscape:current-layer="layer4"\n     showgrid="true"\n     units="px"\n     showguides="false"\n     inkscape:window-width="1920"\n     inkscape:window-height="1028"\n     inkscape:window-x="0"\n     inkscape:window-y="0"\n     inkscape:window-maximized="1"\n     inkscape:snap-grids="true"\n     inkscape:snap-object-midpoints="false">\n    <inkscape:grid\n       type="xygrid"\n       id="grid4008"\n       empspacing="20"\n       dotted="false" />\n  </sodipodi:namedview>\n  <metadata\n     id="metadata7">\n    <rdf:RDF>\n      <cc:Work\n         rdf:about="">\n        <dc:format>image/svg+xml</dc:format>\n        <dc:type\n           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />\n        <dc:title></dc:title>\n        <cc:license\n           rdf:resource="https://github.com/bpmn-io/bpmn-font/blob/master/LICENSE" />\n        <dc:creator>\n          <cc:Agent>\n            <dc:title>Jörg Dotzki</dc:title>\n          </cc:Agent>\n        </dc:creator>\n        <dc:subject>\n          <rdf:Bag>\n            <rdf:li>BPMN</rdf:li>\n            <rdf:li>bpmn-io</rdf:li>\n            <rdf:li>bpmn.io</rdf:li>\n            <rdf:li>Font</rdf:li>\n          </rdf:Bag>\n        </dc:subject>\n      </cc:Work>\n    </rdf:RDF>\n  </metadata>\n  <g\n     inkscape:groupmode="layer"\n     id="layer4"\n     inkscape:label="Ebene 1"\n     style="display:inline">\n    <path\n       style="color:#000000;clip-rule:nonzero;display:inline;overflow:visible;visibility:visible;opacity:1;isolation:auto;mix-blend-mode:normal;color-interpolation:sRGB;color-interpolation-filters:linearRGB;solid-color:#000000;solid-opacity:1;fill:#000000;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1;color-rendering:auto;image-rendering:auto;shape-rendering:auto;text-rendering:auto;enable-background:accumulate"\n       d="M 198 484 L 1000 938 L 1802 484 L 198 484 z M 200 652 L 200 1548 L 1804 1548 L 1804 652 L 1000 1100 L 200 652 z "\n       id="path6822" />\n  </g>\n</svg>\n';
const receive = '<?xml version="1.0" encoding="UTF-8" standalone="no"?>\n<svg\n   xmlns:dc="http://purl.org/dc/elements/1.1/"\n   xmlns:cc="http://creativecommons.org/ns#"\n   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"\n   xmlns:svg="http://www.w3.org/2000/svg"\n   xmlns="http://www.w3.org/2000/svg"\n   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"\n   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"\n   version="1.1"\n   id="svg2"\n   viewBox="0 0 2000 2000"\n   height="2000"\n   width="2000"\n   inkscape:version="0.91 r"\n   sodipodi:docname="receive.svg">\n  <sodipodi:namedview\n     pagecolor="#ffffff"\n     bordercolor="#666666"\n     borderopacity="1"\n     objecttolerance="10"\n     gridtolerance="10"\n     guidetolerance="10"\n     inkscape:pageopacity="0"\n     inkscape:pageshadow="2"\n     inkscape:window-width="1630"\n     inkscape:window-height="947"\n     id="namedview8"\n     showgrid="false"\n     inkscape:zoom="0.472"\n     inkscape:cx="864.05386"\n     inkscape:cy="948.4855"\n     inkscape:window-x="50"\n     inkscape:window-y="50"\n     inkscape:window-maximized="0"\n     inkscape:current-layer="layer2" />\n  <defs\n     id="defs4" />\n  <metadata\n     id="metadata7">\n    <rdf:RDF>\n      <cc:Work\n         rdf:about="">\n        <dc:format>image/svg+xml</dc:format>\n        <dc:type\n           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />\n        <dc:title></dc:title>\n        <cc:license\n           rdf:resource="https://github.com/bpmn-io/bpmn-font/blob/master/LICENSE" />\n        <dc:creator>\n          <cc:Agent>\n            <dc:title>Jörg Dotzki</dc:title>\n          </cc:Agent>\n        </dc:creator>\n        <dc:subject>\n          <rdf:Bag>\n            <rdf:li>BPMN</rdf:li>\n            <rdf:li>bpmn-io</rdf:li>\n            <rdf:li>bpmn.io</rdf:li>\n            <rdf:li>Font</rdf:li>\n          </rdf:Bag>\n        </dc:subject>\n      </cc:Work>\n    </rdf:RDF>\n  </metadata>\n  <g\n     style="display:inline"\n     id="layer2">\n    <g\n       id="g4251">\n      <path\n         id="path6159"\n         style="color:#000000;font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;font-size:medium;line-height:normal;font-family:sans-serif;text-indent:0;text-align:start;text-decoration:none;text-decoration-line:none;text-decoration-style:solid;text-decoration-color:#000000;letter-spacing:normal;word-spacing:normal;text-transform:none;direction:ltr;block-progression:tb;writing-mode:lr-tb;baseline-shift:baseline;text-anchor:start;white-space:normal;clip-rule:nonzero;display:inline;overflow:visible;visibility:visible;opacity:1;isolation:auto;mix-blend-mode:normal;color-interpolation:sRGB;color-interpolation-filters:linearRGB;solid-color:#000000;solid-opacity:1;fill:#000000;fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:70;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1;color-rendering:auto;image-rendering:auto;shape-rendering:auto;text-rendering:auto;enable-background:accumulate"\n         d="m 189,465 0,1070 1622,0 0,-1070 -1622,0 z M 356.88086,535 1643.1191,535 1000,958.10547 356.88086,535 Z M 259,554.39648 1000,1041.8945 1741,554.39648 1741,1465 l -1482,0 0,-910.60352 z" />\n    </g>\n  </g>\n</svg>\n';
const inclusive = '<?xml version="1.0" encoding="UTF-8" standalone="no"?>\n<!-- Created with Inkscape (http://www.inkscape.org/) -->\n\n<svg\n   width="13.758311mm"\n   height="13.758311mm"\n   viewBox="0 0 13.758311 13.758311"\n   version="1.1"\n   id="svg1"\n   inkscape:version="1.4 (e7c3feb1, 2024-10-09)"\n   sodipodi:docname="inclusive.svg"\n   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"\n   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"\n   xmlns="http://www.w3.org/2000/svg"\n   xmlns:svg="http://www.w3.org/2000/svg">\n  <sodipodi:namedview\n     id="namedview1"\n     pagecolor="#ffffff"\n     bordercolor="#000000"\n     borderopacity="0.25"\n     inkscape:showpageshadow="2"\n     inkscape:pageopacity="0.0"\n     inkscape:pagecheckerboard="0"\n     inkscape:deskcolor="#d1d1d1"\n     inkscape:document-units="mm"\n     inkscape:zoom="8.8470394"\n     inkscape:cx="30.349136"\n     inkscape:cy="27.636364"\n     inkscape:window-width="1104"\n     inkscape:window-height="784"\n     inkscape:window-x="0"\n     inkscape:window-y="38"\n     inkscape:window-maximized="0"\n     inkscape:current-layer="layer1" />\n  <defs\n     id="defs1" />\n  <g\n     inkscape:label="Layer 1"\n     inkscape:groupmode="layer"\n     id="layer1"\n     transform="translate(-101.73231,-141.68439)">\n    <path\n       style="display:inline;fill:#22242a;stroke-linecap:round;stroke-linejoin:round;stroke-width:0;stroke-dasharray:none;stroke:none"\n       d="m 25,10.75 c -7.855252,0 -14.25,6.394748 -14.25,14.25 0,7.855252 6.394748,14.25 14.25,14.25 7.855252,0 14.25,-6.394748 14.25,-14.25 0,-7.855252 -6.394748,-14.25 -14.25,-14.25 z m 0,2.5 c 6.504152,0 11.75,5.245848 11.75,11.75 0,6.504152 -5.245848,11.75 -11.75,11.75 -6.504152,0 -11.75,-5.245848 -11.75,-11.75 0,-6.504152 5.245848,-11.75 11.75,-11.75 z"\n       id="path2"\n       transform="matrix(0.26458333,0,0,0.26458333,101.99688,141.94896)" />\n    <rect\n       x="102.52605"\n       y="142.47813"\n       rx="1.0583333"\n       width="12.170834"\n       height="12.170834"\n       class="djs-outline"\n       style="fill:none;stroke-width:0.264583"\n       id="rect105" />\n  </g>\n</svg>\n';
const exclusive = '<?xml version="1.0" encoding="UTF-8" standalone="no"?>\n<!-- Created with Inkscape (http://www.inkscape.org/) -->\n\n<svg\n   width="13.758311mm"\n   height="13.758311mm"\n   viewBox="0 0 13.758311 13.758311"\n   version="1.1"\n   id="svg1"\n   inkscape:version="1.4 (e7c3feb1, 2024-10-09)"\n   sodipodi:docname="exclusive.svg"\n   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"\n   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"\n   xmlns="http://www.w3.org/2000/svg"\n   xmlns:svg="http://www.w3.org/2000/svg">\n  <sodipodi:namedview\n     id="namedview1"\n     pagecolor="#ffffff"\n     bordercolor="#000000"\n     borderopacity="0.25"\n     inkscape:showpageshadow="2"\n     inkscape:pageopacity="0.0"\n     inkscape:pagecheckerboard="0"\n     inkscape:deskcolor="#d1d1d1"\n     inkscape:document-units="mm"\n     inkscape:zoom="4.1672912"\n     inkscape:cx="41.63376"\n     inkscape:cy="36.714497"\n     inkscape:window-width="1104"\n     inkscape:window-height="719"\n     inkscape:window-x="0"\n     inkscape:window-y="38"\n     inkscape:window-maximized="0"\n     inkscape:current-layer="layer1" />\n  <defs\n     id="defs1" />\n  <g\n     inkscape:label="Layer 1"\n     inkscape:groupmode="layer"\n     id="layer1"\n     transform="translate(-101.7323,-141.68439)">\n    <path\n       style="display:inline;fill:#22242a;stroke-linecap:round;stroke-linejoin:round"\n       d="M 16,15 23.428571,24.714286 16,34.428571 h 3.428571 l 5.714286,-7.464228 5.714286,7.464228 h 3.428571 L 26.857143,24.714286 34.285714,15 H 30.857143 L 25.142857,22.464229 19.428571,15 Z"\n       id="path1"\n       transform="matrix(0.26458333,0,0,0.26458333,101.99687,141.94896)" />\n    <rect\n       x="102.52604"\n       y="142.47813"\n       rx="1.0583333"\n       width="12.170834"\n       height="12.170834"\n       class="djs-outline"\n       style="fill:none;stroke-width:0.264583"\n       id="rect108" />\n  </g>\n</svg>\n';
const parallel = '<?xml version="1.0" encoding="UTF-8" standalone="no"?>\n<!-- Created with Inkscape (http://www.inkscape.org/) -->\n\n<svg\n   width="13.758311mm"\n   height="13.758311mm"\n   viewBox="0 0 13.758311 13.758311"\n   version="1.1"\n   id="svg1"\n   inkscape:version="1.4 (e7c3feb1, 2024-10-09)"\n   sodipodi:docname="parallel.svg"\n   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"\n   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"\n   xmlns="http://www.w3.org/2000/svg"\n   xmlns:svg="http://www.w3.org/2000/svg">\n  <sodipodi:namedview\n     id="namedview1"\n     pagecolor="#ffffff"\n     bordercolor="#000000"\n     borderopacity="0.25"\n     inkscape:showpageshadow="2"\n     inkscape:pageopacity="0.0"\n     inkscape:pagecheckerboard="0"\n     inkscape:deskcolor="#d1d1d1"\n     inkscape:document-units="mm"\n     inkscape:zoom="2.5054948"\n     inkscape:cx="-2.1951752"\n     inkscape:cy="20.155699"\n     inkscape:window-width="1104"\n     inkscape:window-height="788"\n     inkscape:window-x="0"\n     inkscape:window-y="38"\n     inkscape:window-maximized="0"\n     inkscape:current-layer="layer1" />\n  <defs\n     id="defs1" />\n  <g\n     inkscape:label="Layer 1"\n     inkscape:groupmode="layer"\n     id="layer1"\n     transform="translate(-101.7323,-141.68439)">\n    <path\n       d="m 108.08229,144.59479 v 3.30729 h -3.3073 v 1.32292 h 3.3073 v 3.30729 h 1.32291 V 149.225 h 3.30729 v -1.32292 h -3.30729 v -3.30729 z"\n       style="fill:#22242a;stroke:#22242a;stroke-width:0.264583px;stroke-linecap:round;stroke-linejoin:round"\n       id="path109" />\n    <rect\n       x="102.52604"\n       y="142.47813"\n       rx="1.0583333"\n       width="12.170834"\n       height="12.170834"\n       class="djs-outline"\n       style="fill:none;stroke-width:0.264583"\n       id="rect111" />\n  </g>\n</svg>\n';
const eventBased = '<?xml version="1.0" encoding="UTF-8" standalone="no"?>\n<!-- Created with Inkscape (http://www.inkscape.org/) -->\n\n<svg\n   width="13.758311mm"\n   height="13.758311mm"\n   viewBox="0 0 13.758311 13.758311"\n   version="1.1"\n   id="svg1"\n   inkscape:version="1.4 (e7c3feb1, 2024-10-09)"\n   sodipodi:docname="event-based.svg"\n   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"\n   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"\n   xmlns="http://www.w3.org/2000/svg"\n   xmlns:svg="http://www.w3.org/2000/svg">\n  <sodipodi:namedview\n     id="namedview1"\n     pagecolor="#ffffff"\n     bordercolor="#000000"\n     borderopacity="0.25"\n     inkscape:showpageshadow="2"\n     inkscape:pageopacity="0.0"\n     inkscape:pagecheckerboard="0"\n     inkscape:deskcolor="#d1d1d1"\n     inkscape:document-units="mm"\n     inkscape:zoom="4.3759929"\n     inkscape:cx="21.36658"\n     inkscape:cy="26.16549"\n     inkscape:window-width="1104"\n     inkscape:window-height="786"\n     inkscape:window-x="0"\n     inkscape:window-y="38"\n     inkscape:window-maximized="0"\n     inkscape:current-layer="layer1" />\n  <defs\n     id="defs1" />\n  <g\n     inkscape:label="Layer 1"\n     inkscape:groupmode="layer"\n     id="layer1"\n     transform="translate(-1969.426,-2186.3844)">\n    <circle\n       cx="1976.3052"\n       cy="2193.2637"\n       r="3.96875"\n       style="fill:none;stroke:#22242a;stroke-width:0.264583px;stroke-linecap:round;stroke-linejoin:round"\n       id="circle112" />\n    <circle\n       cx="1976.3052"\n       cy="2193.2637"\n       r="3.175"\n       style="fill:none;stroke:#22242a;stroke-width:0.264583px;stroke-linecap:round;stroke-linejoin:round"\n       id="circle113" />\n    <path\n       d="m 1974.4531,2192.4698 1.9483,-1.2988 1.9483,1.2988 -0.6494,2.5978 h -2.5978 z"\n       style="fill:none;stroke:#22242a;stroke-width:0.529167px;stroke-linecap:round;stroke-linejoin:round"\n       id="path113" />\n    <rect\n       x="1970.2197"\n       y="2187.1782"\n       rx="1.0583333"\n       width="12.170834"\n       height="12.170834"\n       class="djs-outline"\n       style="fill:none;stroke-width:0.264583"\n       id="rect114" />\n  </g>\n</svg>\n';
const complex = '<?xml version="1.0" encoding="UTF-8" standalone="no"?>\n<!-- Created with Inkscape (http://www.inkscape.org/) -->\n\n<svg\n   width="13.758311mm"\n   height="13.758311mm"\n   viewBox="0 0 13.758311 13.758311"\n   version="1.1"\n   id="svg1"\n   inkscape:version="1.4 (e7c3feb1, 2024-10-09)"\n   sodipodi:docname="complex.svg"\n   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"\n   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"\n   xmlns="http://www.w3.org/2000/svg"\n   xmlns:svg="http://www.w3.org/2000/svg">\n  <sodipodi:namedview\n     id="namedview1"\n     pagecolor="#ffffff"\n     bordercolor="#000000"\n     borderopacity="0.25"\n     inkscape:showpageshadow="2"\n     inkscape:pageopacity="0.0"\n     inkscape:pagecheckerboard="0"\n     inkscape:deskcolor="#d1d1d1"\n     inkscape:document-units="mm"\n     inkscape:zoom="4.8390424"\n     inkscape:cx="39.987251"\n     inkscape:cy="19.218679"\n     inkscape:window-width="1104"\n     inkscape:window-height="827"\n     inkscape:window-x="0"\n     inkscape:window-y="38"\n     inkscape:window-maximized="0"\n     inkscape:current-layer="layer1" />\n  <defs\n     id="defs1" />\n  <g\n     inkscape:label="Layer 1"\n     inkscape:groupmode="layer"\n     id="layer1"\n     transform="translate(-101.73231,-141.68439)">\n    <g\n       id="path115"\n       style="fill:#22242a;fill-opacity:1;stroke:none;stroke-width:0;stroke-dasharray:none"\n       transform="matrix(0.26458333,0,0,0.26458333,-13.62604,-21.563537)">\n      <path\n         style="fill:#22242a;fill-opacity:1;stroke:none;stroke-width:0;stroke-linecap:round;stroke-linejoin:round;stroke-dasharray:none"\n         d="m 460,631 v 7.11679 l -5.01825,-5.01825 -3.10219,3.10219 5.01825,5.01825 h -7.11679 v 4.37956 h 7.11679 l -5.01825,5.01825 3.10219,3.10219 L 460,648.70073 v 7.11679 h 4.37956 v -7.11679 l 5.01825,5.01825 3.10219,-3.10219 -5.01825,-5.01825 h 7.11679 v -4.37956 h -7.11679 l 5.01825,-5.01825 -3.10219,-3.10219 -5.01825,5.01825 V 631 Z"\n         id="path211" />\n    </g>\n    <rect\n       x="102.52604"\n       y="142.47813"\n       rx="1.0583333"\n       width="12.170834"\n       height="12.170834"\n       class="djs-outline"\n       style="fill:none;stroke-width:0.264583"\n       id="rect117" />\n  </g>\n</svg>\n';
const compensation = '<?xml version="1.0" encoding="UTF-8" standalone="no"?>\n<!-- Created with Inkscape (http://www.inkscape.org/) -->\n\n<svg\n   width="5.0270739mm"\n   height="3.7041385mm"\n   viewBox="0 0 5.027074 3.7041386"\n   version="1.1"\n   id="svg1"\n   inkscape:version="1.4 (86a8ad7, 2024-10-11)"\n   sodipodi:docname="compensation.svg"\n   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"\n   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"\n   xmlns="http://www.w3.org/2000/svg"\n   xmlns:svg="http://www.w3.org/2000/svg">\n  <sodipodi:namedview\n     id="namedview1"\n     pagecolor="#505050"\n     bordercolor="#eeeeee"\n     borderopacity="1"\n     inkscape:showpageshadow="0"\n     inkscape:pageopacity="0"\n     inkscape:pagecheckerboard="0"\n     inkscape:deskcolor="#505050"\n     inkscape:document-units="mm"\n     inkscape:zoom="8.1336326"\n     inkscape:cx="34.547909"\n     inkscape:cy="4.3645935"\n     inkscape:window-width="2560"\n     inkscape:window-height="1009"\n     inkscape:window-x="-8"\n     inkscape:window-y="-8"\n     inkscape:window-maximized="1"\n     inkscape:current-layer="layer1" />\n  <defs\n     id="defs1" />\n  <g\n     inkscape:label="Layer 1"\n     inkscape:groupmode="layer"\n     id="layer1"\n     transform="translate(-29.347596,-154.91356)">\n    <path\n       d="m 29.479878,156.76563 2.38125,-1.71979 v 3.43958 z m 2.460625,-0.10583 2.301875,-1.61396 v 3.43958 l -2.301875,-1.61396 z"\n       style="fill:#22242a;stroke:#22242a;stroke-width:0.264583px;stroke-linecap:round;stroke-linejoin:round"\n       id="path37" />\n  </g>\n</svg>\n';
const conditional = '<?xml version="1.0" encoding="UTF-8" standalone="no"?>\n<!-- Created with Inkscape (http://www.inkscape.org/) -->\n\n<svg\n   width="4.1010432mm"\n   height="5.0270829mm"\n   viewBox="0 0 4.1010433 5.0270831"\n   version="1.1"\n   id="svg1"\n   inkscape:version="1.4 (86a8ad7, 2024-10-11)"\n   sodipodi:docname="conditional.svg"\n   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"\n   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"\n   xmlns="http://www.w3.org/2000/svg"\n   xmlns:svg="http://www.w3.org/2000/svg">\n  <sodipodi:namedview\n     id="namedview1"\n     pagecolor="#505050"\n     bordercolor="#eeeeee"\n     borderopacity="1"\n     inkscape:showpageshadow="0"\n     inkscape:pageopacity="0"\n     inkscape:pagecheckerboard="0"\n     inkscape:deskcolor="#505050"\n     inkscape:document-units="mm"\n     inkscape:zoom="8.1336326"\n     inkscape:cx="2.3359796"\n     inkscape:cy="13.216727"\n     inkscape:window-width="2560"\n     inkscape:window-height="1009"\n     inkscape:window-x="-8"\n     inkscape:window-y="-8"\n     inkscape:window-maximized="1"\n     inkscape:current-layer="layer1" />\n  <defs\n     id="defs1" />\n  <g\n     inkscape:label="Layer 1"\n     inkscape:groupmode="layer"\n     id="layer1"\n     transform="translate(-156.23646,-112.58021)">\n    <path\n       d="m 156.36875,112.7125 h 3.83646 v 4.7625 h -3.83646 z m 0.52917,0.79375 h 2.77813 M 156.89792,114.3 h 2.77813 m -2.77813,0.79375 h 2.77813 m -2.77813,0.79375 h 2.77813 m -2.77813,0.79375 h 2.77813 m -2.77813,0.79375 h 2.77813"\n       style="fill:none;stroke:#22242a;stroke-width:0.264583px;stroke-linecap:round;stroke-linejoin:round"\n       id="path22" />\n  </g>\n</svg>\n';
const error = '<?xml version="1.0" encoding="UTF-8" standalone="no"?>\n<!-- Created with Inkscape (http://www.inkscape.org/) -->\n\n<svg\n   width="5.5032949mm"\n   height="5.2628441mm"\n   viewBox="0 0 5.5032951 5.2628442"\n   version="1.1"\n   id="svg1"\n   inkscape:version="1.4 (86a8ad7, 2024-10-11)"\n   sodipodi:docname="error.svg"\n   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"\n   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"\n   xmlns="http://www.w3.org/2000/svg"\n   xmlns:svg="http://www.w3.org/2000/svg">\n  <sodipodi:namedview\n     id="namedview1"\n     pagecolor="#505050"\n     bordercolor="#eeeeee"\n     borderopacity="1"\n     inkscape:showpageshadow="0"\n     inkscape:pageopacity="0"\n     inkscape:pagecheckerboard="0"\n     inkscape:deskcolor="#505050"\n     inkscape:document-units="mm"\n     inkscape:zoom="11.502694"\n     inkscape:cx="40.859995"\n     inkscape:cy="8.737084"\n     inkscape:window-width="2560"\n     inkscape:window-height="1009"\n     inkscape:window-x="-8"\n     inkscape:window-y="-8"\n     inkscape:window-maximized="1"\n     inkscape:current-layer="layer1" />\n  <defs\n     id="defs1" />\n  <g\n     inkscape:label="Layer 1"\n     inkscape:groupmode="layer"\n     id="layer1"\n     transform="translate(24.288738,-155.33712)">\n    <path\n       d="m -24.156455,160.46768 0.02474,-0.007 1.941829,-2.54284 2.028561,2.37229 1.243621,-4.82082 -1.553289,3.08242 -1.931353,-2.53613 z"\n       style="fill:#22242a;stroke:#22242a;stroke-width:0.264583px;stroke-linecap:round;stroke-linejoin:round"\n       id="path34" />\n  </g>\n</svg>\n';
const escalation = '<?xml version="1.0" encoding="UTF-8" standalone="no"?>\n<!-- Created with Inkscape (http://www.inkscape.org/) -->\n\n<svg\n   width="4.4978838mm"\n   height="5.5561948mm"\n   viewBox="0 0 4.4978839 5.5561949"\n   version="1.1"\n   id="svg1"\n   inkscape:version="1.4 (86a8ad7, 2024-10-11)"\n   sodipodi:docname="escalation.svg"\n   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"\n   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"\n   xmlns="http://www.w3.org/2000/svg"\n   xmlns:svg="http://www.w3.org/2000/svg">\n  <sodipodi:namedview\n     id="namedview1"\n     pagecolor="#505050"\n     bordercolor="#eeeeee"\n     borderopacity="1"\n     inkscape:showpageshadow="0"\n     inkscape:pageopacity="0"\n     inkscape:pagecheckerboard="0"\n     inkscape:deskcolor="#505050"\n     inkscape:document-units="mm"\n     inkscape:zoom="11.502694"\n     inkscape:cx="11.040892"\n     inkscape:cy="10.910488"\n     inkscape:window-width="2560"\n     inkscape:window-height="1009"\n     inkscape:window-x="-8"\n     inkscape:window-y="-8"\n     inkscape:window-maximized="1"\n     inkscape:current-layer="layer1" />\n  <defs\n     id="defs1" />\n  <g\n     inkscape:label="Layer 1"\n     inkscape:groupmode="layer"\n     id="layer1"\n     transform="translate(-152.92918,-91.334188)">\n    <path\n       d="m 155.17812,91.466457 2.11667,5.291667 -2.11667,-1.852084 -2.11667,1.852084 z"\n       style="fill:#22242a;stroke:#22242a;stroke-width:0.264583px;stroke-linecap:round;stroke-linejoin:round"\n       id="path31" />\n  </g>\n</svg>\n';
const intermediate = '<?xml version="1.0" encoding="UTF-8" standalone="no"?>\n<!-- Created with Inkscape (http://www.inkscape.org/) -->\n\n<svg\n   width="8.3343754mm"\n   height="8.3343754mm"\n   viewBox="0 0 8.3343756 8.3343756"\n   version="1.1"\n   id="svg1"\n   inkscape:version="1.4 (86a8ad7, 2024-10-11)"\n   sodipodi:docname="intermediate.svg"\n   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"\n   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"\n   xmlns="http://www.w3.org/2000/svg"\n   xmlns:svg="http://www.w3.org/2000/svg">\n  <sodipodi:namedview\n     id="namedview1"\n     pagecolor="#505050"\n     bordercolor="#eeeeee"\n     borderopacity="1"\n     inkscape:showpageshadow="0"\n     inkscape:pageopacity="0"\n     inkscape:pagecheckerboard="0"\n     inkscape:deskcolor="#505050"\n     inkscape:document-units="mm"\n     inkscape:zoom="16.267265"\n     inkscape:cx="12.663468"\n     inkscape:cy="14.35398"\n     inkscape:window-width="2560"\n     inkscape:window-height="1009"\n     inkscape:window-x="-8"\n     inkscape:window-y="-8"\n     inkscape:window-maximized="1"\n     inkscape:current-layer="layer1" />\n  <defs\n     id="defs1" />\n  <g\n     inkscape:label="Layer 1"\n     inkscape:groupmode="layer"\n     id="layer1"\n     transform="translate(207.23489,-211.8651)">\n    <circle\n       cx="-203.0677"\n       cy="216.03229"\n       r="3.96875"\n       style="fill:none;stroke:#22242a;stroke-width:0.396875px;stroke-linecap:round;stroke-linejoin:round"\n       id="circle50" />\n  </g>\n</svg>\n';
const intermediateCompensation = '<?xml version="1.0" encoding="UTF-8" standalone="no"?>\n<!-- Created with Inkscape (http://www.inkscape.org/) -->\n\n<svg\n   width="8.3343754mm"\n   height="8.3343754mm"\n   viewBox="0 0 8.3343756 8.3343756"\n   version="1.1"\n   id="svg1"\n   inkscape:version="1.4 (86a8ad7, 2024-10-11)"\n   sodipodi:docname="intermediate-compensation.svg"\n   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"\n   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"\n   xmlns="http://www.w3.org/2000/svg"\n   xmlns:svg="http://www.w3.org/2000/svg">\n  <sodipodi:namedview\n     id="namedview1"\n     pagecolor="#505050"\n     bordercolor="#eeeeee"\n     borderopacity="1"\n     inkscape:showpageshadow="0"\n     inkscape:pageopacity="0"\n     inkscape:pagecheckerboard="0"\n     inkscape:deskcolor="#505050"\n     inkscape:document-units="mm"\n     inkscape:zoom="11.502694"\n     inkscape:cx="55.46527"\n     inkscape:cy="20.212657"\n     inkscape:window-width="2560"\n     inkscape:window-height="1009"\n     inkscape:window-x="-8"\n     inkscape:window-y="-8"\n     inkscape:window-maximized="1"\n     inkscape:current-layer="layer1" />\n  <defs\n     id="defs1" />\n  <g\n     inkscape:label="Layer 1"\n     inkscape:groupmode="layer"\n     id="layer1"\n     transform="translate(69.65157,-208.95468)">\n    <circle\n       cx="-65.484383"\n       cy="213.12187"\n       r="3.96875"\n       style="fill:none;stroke:#22242a;stroke-width:0.396875px;stroke-linecap:round;stroke-linejoin:round"\n       id="circle87" />\n    <path\n       d="m -68.151379,213.12187 2.38125,-1.71979 v 3.43958 z m 2.460625,-0.10583 2.301875,-1.61396 v 3.43958 l -2.301875,-1.61396 z"\n       style="fill:#22242a;stroke:#22242a;stroke-width:0.264583px;stroke-linecap:round;stroke-linejoin:round"\n       id="path87" />\n  </g>\n</svg>\n';
const intermediateConditional = '<?xml version="1.0" encoding="UTF-8" standalone="no"?>\n<!-- Created with Inkscape (http://www.inkscape.org/) -->\n\n<svg\n   width="8.3343754mm"\n   height="8.3343754mm"\n   viewBox="0 0 8.3343756 8.3343756"\n   version="1.1"\n   id="svg1"\n   inkscape:version="1.4 (86a8ad7, 2024-10-11)"\n   sodipodi:docname="intermediate-conditional.svg"\n   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"\n   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"\n   xmlns="http://www.w3.org/2000/svg"\n   xmlns:svg="http://www.w3.org/2000/svg">\n  <sodipodi:namedview\n     id="namedview1"\n     pagecolor="#505050"\n     bordercolor="#eeeeee"\n     borderopacity="1"\n     inkscape:showpageshadow="0"\n     inkscape:pageopacity="0"\n     inkscape:pagecheckerboard="0"\n     inkscape:deskcolor="#505050"\n     inkscape:document-units="mm"\n     inkscape:zoom="11.502694"\n     inkscape:cx="17.561104"\n     inkscape:cy="19.864912"\n     inkscape:window-width="2560"\n     inkscape:window-height="1009"\n     inkscape:window-x="-8"\n     inkscape:window-y="-8"\n     inkscape:window-maximized="1"\n     inkscape:current-layer="layer1" />\n  <defs\n     id="defs1" />\n  <g\n     inkscape:label="Layer 1"\n     inkscape:groupmode="layer"\n     id="layer1"\n     transform="translate(-91.215099,-208.95468)">\n    <circle\n       cx="95.382286"\n       cy="213.12187"\n       r="3.96875"\n       style="fill:none;stroke:#22242a;stroke-width:0.396875px;stroke-linecap:round;stroke-linejoin:round"\n       id="circle78" />\n    <path\n       d="m 93.397914,210.60833 h 3.836458 v 4.7625 h -3.836458 z m 0.529167,0.79375 h 2.778125 m -2.778125,0.79375 h 2.778125 m -2.778125,0.79375 h 2.778125 m -2.778125,0.79375 h 2.778125 m -2.778125,0.79375 h 2.778125 m -2.778125,0.79375 h 2.778125"\n       style="fill:none;stroke:#22242a;stroke-width:0.264583px;stroke-linecap:round;stroke-linejoin:round"\n       id="path78" />\n  </g>\n</svg>\n';
const intermediateEscalation = '<?xml version="1.0" encoding="UTF-8" standalone="no"?>\n<!-- Created with Inkscape (http://www.inkscape.org/) -->\n\n<svg\n   width="8.3343754mm"\n   height="8.3343754mm"\n   viewBox="0 0 8.3343756 8.3343756"\n   version="1.1"\n   id="svg1"\n   inkscape:version="1.4 (86a8ad7, 2024-10-11)"\n   sodipodi:docname="intermediate-escalation.svg"\n   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"\n   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"\n   xmlns="http://www.w3.org/2000/svg"\n   xmlns:svg="http://www.w3.org/2000/svg">\n  <sodipodi:namedview\n     id="namedview1"\n     pagecolor="#505050"\n     bordercolor="#eeeeee"\n     borderopacity="1"\n     inkscape:showpageshadow="0"\n     inkscape:pageopacity="0"\n     inkscape:pagecheckerboard="0"\n     inkscape:deskcolor="#505050"\n     inkscape:document-units="mm"\n     inkscape:zoom="11.502694"\n     inkscape:cx="-12.779615"\n     inkscape:cy="20.386529"\n     inkscape:window-width="2560"\n     inkscape:window-height="1009"\n     inkscape:window-x="-8"\n     inkscape:window-y="-8"\n     inkscape:window-maximized="1"\n     inkscape:current-layer="layer1" />\n  <defs\n     id="defs1" />\n  <g\n     inkscape:label="Layer 1"\n     inkscape:groupmode="layer"\n     id="layer1"\n     transform="translate(-371.14427,-181.43802)">\n    <circle\n       cx="375.31146"\n       cy="185.60521"\n       r="3.96875"\n       style="fill:none;stroke:#22242a;stroke-width:0.396875px;stroke-linecap:round;stroke-linejoin:round"\n       id="circle75" />\n    <path\n       d="m 375.31146,182.74771 2.11667,5.29167 -2.11667,-1.85209 -2.11667,1.85209 z"\n       style="fill:#22242a;stroke:#22242a;stroke-width:0.264583px;stroke-linecap:round;stroke-linejoin:round"\n       id="path75" />\n  </g>\n</svg>\n';
const intermediateLinkCatch = '<?xml version="1.0" encoding="UTF-8" standalone="no"?>\n<!-- Created with Inkscape (http://www.inkscape.org/) -->\n\n<svg\n   width="8.3343754mm"\n   height="8.3343754mm"\n   viewBox="0 0 8.3343756 8.3343756"\n   version="1.1"\n   id="svg1"\n   inkscape:version="1.4 (86a8ad7, 2024-10-11)"\n   sodipodi:docname="intermediate-link-catch.svg"\n   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"\n   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"\n   xmlns="http://www.w3.org/2000/svg"\n   xmlns:svg="http://www.w3.org/2000/svg">\n  <sodipodi:namedview\n     id="namedview1"\n     pagecolor="#505050"\n     bordercolor="#eeeeee"\n     borderopacity="1"\n     inkscape:showpageshadow="0"\n     inkscape:pageopacity="0"\n     inkscape:pagecheckerboard="0"\n     inkscape:deskcolor="#505050"\n     inkscape:document-units="mm"\n     inkscape:zoom="11.502694"\n     inkscape:cx="-16.343997"\n     inkscape:cy="17.778444"\n     inkscape:window-width="2560"\n     inkscape:window-height="1009"\n     inkscape:window-x="-8"\n     inkscape:window-y="-8"\n     inkscape:window-maximized="1"\n     inkscape:current-layer="layer1" />\n  <defs\n     id="defs1" />\n  <g\n     inkscape:label="Layer 1"\n     inkscape:groupmode="layer"\n     id="layer1"\n     transform="translate(-235.14843,-194.93177)">\n    <circle\n       cx="239.31561"\n       cy="199.09895"\n       r="3.96875"\n       style="fill:none;stroke:#22242a;stroke-width:0.396875px;stroke-linecap:round;stroke-linejoin:round"\n       id="circle81" />\n    <path\n       d="m 239.98237,196.84153 v 1.17409 h -3.57188 v 1.78594 h 3.57188 v 1.17409 l 2.60449,-2.06706 z"\n       style="fill:none;stroke:#22242a;stroke-width:0.264583px;stroke-linecap:round;stroke-linejoin:round"\n       id="path81" />\n  </g>\n</svg>\n';
const intermediateLinkThrow = '<?xml version="1.0" encoding="UTF-8" standalone="no"?>\n<!-- Created with Inkscape (http://www.inkscape.org/) -->\n\n<svg\n   width="8.3343754mm"\n   height="8.3343754mm"\n   viewBox="0 0 8.3343756 8.3343756"\n   version="1.1"\n   id="svg1"\n   inkscape:version="1.4 (86a8ad7, 2024-10-11)"\n   sodipodi:docname="intermediate-link-throw.svg"\n   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"\n   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"\n   xmlns="http://www.w3.org/2000/svg"\n   xmlns:svg="http://www.w3.org/2000/svg">\n  <sodipodi:namedview\n     id="namedview1"\n     pagecolor="#505050"\n     bordercolor="#eeeeee"\n     borderopacity="1"\n     inkscape:showpageshadow="0"\n     inkscape:pageopacity="0"\n     inkscape:pagecheckerboard="0"\n     inkscape:deskcolor="#505050"\n     inkscape:document-units="mm"\n     inkscape:zoom="11.502694"\n     inkscape:cx="32.687996"\n     inkscape:cy="14.127126"\n     inkscape:window-width="2560"\n     inkscape:window-height="1009"\n     inkscape:window-x="-8"\n     inkscape:window-y="-8"\n     inkscape:window-maximized="1"\n     inkscape:current-layer="layer1" />\n  <defs\n     id="defs1" />\n  <g\n     inkscape:label="Layer 1"\n     inkscape:groupmode="layer"\n     id="layer1"\n     transform="translate(119.65781,-208.95468)">\n    <circle\n       cx="-115.49062"\n       cy="213.12187"\n       r="3.96875"\n       style="fill:none;stroke:#22242a;stroke-width:0.396875px;stroke-linecap:round;stroke-linejoin:round"\n       id="circle84" />\n    <path\n       d="m -114.82387,210.86444 v 1.17409 h -3.57188 v 1.78594 h 3.57188 v 1.17409 l 2.60449,-2.06706 z"\n       style="fill:#22242a;stroke:#22242a;stroke-width:0.264583px;stroke-linecap:round;stroke-linejoin:round"\n       id="path84" />\n  </g>\n</svg>\n';
const intermediateReceive = '<?xml version="1.0" encoding="UTF-8" standalone="no"?>\n<!-- Created with Inkscape (http://www.inkscape.org/) -->\n\n<svg\n   width="8.3343754mm"\n   height="8.3343754mm"\n   viewBox="0 0 8.3343756 8.3343756"\n   version="1.1"\n   id="svg1"\n   inkscape:version="1.4 (86a8ad7, 2024-10-11)"\n   sodipodi:docname="intermediate-receive.svg"\n   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"\n   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"\n   xmlns="http://www.w3.org/2000/svg"\n   xmlns:svg="http://www.w3.org/2000/svg">\n  <sodipodi:namedview\n     id="namedview1"\n     pagecolor="#505050"\n     bordercolor="#eeeeee"\n     borderopacity="1"\n     inkscape:showpageshadow="0"\n     inkscape:pageopacity="0"\n     inkscape:pagecheckerboard="0"\n     inkscape:deskcolor="#505050"\n     inkscape:document-units="mm"\n     inkscape:zoom="11.502694"\n     inkscape:cx="21.386294"\n     inkscape:cy="10.301934"\n     inkscape:window-width="2560"\n     inkscape:window-height="1009"\n     inkscape:window-x="-8"\n     inkscape:window-y="-8"\n     inkscape:window-maximized="1"\n     inkscape:current-layer="layer1" />\n  <defs\n     id="defs1" />\n  <g\n     inkscape:label="Layer 1"\n     inkscape:groupmode="layer"\n     id="layer1"\n     transform="translate(-75.075519,-224.82968)">\n    <circle\n       cx="79.242706"\n       cy="228.99687"\n       r="3.96875"\n       style="fill:none;stroke:#22242a;stroke-width:0.396875px;stroke-linecap:round;stroke-linejoin:round"\n       id="circle53" />\n    <path\n       d="m 76.718582,227.23474 v 3.33375 h 5.000625 v -3.33375 z m 0,0 2.500312,1.42875 2.500313,-1.42875"\n       style="fill:none;stroke:#22242a;stroke-width:0.264583px;stroke-linecap:round;stroke-linejoin:round"\n       id="path53" />\n  </g>\n</svg>\n';
const intermediateSend = '<?xml version="1.0" encoding="UTF-8" standalone="no"?>\n<!-- Created with Inkscape (http://www.inkscape.org/) -->\n\n<svg\n   width="8.3343754mm"\n   height="8.3343754mm"\n   viewBox="0 0 8.3343756 8.3343756"\n   version="1.1"\n   id="svg1"\n   inkscape:version="1.4 (86a8ad7, 2024-10-11)"\n   sodipodi:docname="intermediate-send.svg"\n   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"\n   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"\n   xmlns="http://www.w3.org/2000/svg"\n   xmlns:svg="http://www.w3.org/2000/svg">\n  <sodipodi:namedview\n     id="namedview1"\n     pagecolor="#505050"\n     bordercolor="#eeeeee"\n     borderopacity="1"\n     inkscape:showpageshadow="0"\n     inkscape:pageopacity="0"\n     inkscape:pagecheckerboard="0"\n     inkscape:deskcolor="#505050"\n     inkscape:document-units="mm"\n     inkscape:zoom="16"\n     inkscape:cx="-5.25"\n     inkscape:cy="14.84375"\n     inkscape:window-width="2560"\n     inkscape:window-height="1009"\n     inkscape:window-x="-8"\n     inkscape:window-y="-8"\n     inkscape:window-maximized="1"\n     inkscape:current-layer="path56" />\n  <defs\n     id="defs1" />\n  <g\n     inkscape:label="Layer 1"\n     inkscape:groupmode="layer"\n     id="layer1"\n     transform="translate(-232.76718,-160.00678)">\n    <circle\n       cx="236.93437"\n       cy="164.17397"\n       r="3.96875"\n       style="fill:none;stroke:#22242a;stroke-width:0.396875px;stroke-linecap:round;stroke-linejoin:round"\n       id="circle56" />\n    <g\n       id="path56">\n      <path\n         style="fill:none;stroke-linecap:round;stroke-linejoin:round;stroke:none"\n         d="m 234.41024,162.41183 v 3.33375 h 5.00063 v -3.33375 z m 0,0 2.50032,1.42875"\n         id="path1"\n         sodipodi:nodetypes="ccccccc" />\n      <g\n         id="g4"\n         transform="translate(201.87036,-55.570754)">\n        <path\n           d="m 32.666222,218.20322 v 2.97242 h 4.736145 v -2.97242 l -2.302701,1.31413 a 0.13230472,0.13230472 0 0 1 -0.130742,0 z"\n           style="baseline-shift:baseline;display:inline;overflow:visible;vector-effect:none;fill:#22242a;fill-opacity:1;stroke-linecap:round;stroke-linejoin:round;enable-background:accumulate;stop-color:#000000;stop-opacity:1"\n           id="path4" />\n        <path\n           d="m 33.033125,218.10761 1.999878,1.14257 2.001945,-1.14257 z"\n           style="baseline-shift:baseline;display:inline;overflow:visible;vector-effect:none;fill:#22242a;fill-opacity:1;stroke-linecap:round;stroke-linejoin:round;enable-background:accumulate;stop-color:#000000;stop-opacity:1"\n           id="path3" />\n      </g>\n    </g>\n  </g>\n</svg>\n';
const intermediateSignalCatch = '<?xml version="1.0" encoding="UTF-8" standalone="no"?>\n<!-- Created with Inkscape (http://www.inkscape.org/) -->\n\n<svg\n   width="8.3343754mm"\n   height="8.3343754mm"\n   viewBox="0 0 8.3343756 8.3343756"\n   version="1.1"\n   id="svg1"\n   inkscape:version="1.4 (86a8ad7, 2024-10-11)"\n   sodipodi:docname="intermediate-signal-catch.svg"\n   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"\n   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"\n   xmlns="http://www.w3.org/2000/svg"\n   xmlns:svg="http://www.w3.org/2000/svg">\n  <sodipodi:namedview\n     id="namedview1"\n     pagecolor="#505050"\n     bordercolor="#eeeeee"\n     borderopacity="1"\n     inkscape:showpageshadow="0"\n     inkscape:pageopacity="0"\n     inkscape:pagecheckerboard="0"\n     inkscape:deskcolor="#505050"\n     inkscape:document-units="mm"\n     inkscape:zoom="11.502694"\n     inkscape:cx="40.164504"\n     inkscape:cy="13.083891"\n     inkscape:window-width="2560"\n     inkscape:window-height="1009"\n     inkscape:window-x="-8"\n     inkscape:window-y="-8"\n     inkscape:window-maximized="1"\n     inkscape:current-layer="layer1" />\n  <defs\n     id="defs1" />\n  <g\n     inkscape:label="Layer 1"\n     inkscape:groupmode="layer"\n     id="layer1"\n     transform="translate(-0.19843645,-215.30468)">\n    <circle\n       cx="4.365624"\n       cy="219.47186"\n       r="3.96875"\n       style="fill:none;stroke:#22242a;stroke-width:0.396875px;stroke-linecap:round;stroke-linejoin:round"\n       id="circle90" />\n    <path\n       d="m 4.3656239,216.61437 2.38125,4.28625 h -4.7625 z"\n       style="fill:none;stroke:#22242a;stroke-width:0.264583px;stroke-linecap:round;stroke-linejoin:round"\n       id="path90" />\n  </g>\n</svg>\n';
const intermediateSignalThrow = '<?xml version="1.0" encoding="UTF-8" standalone="no"?>\n<!-- Created with Inkscape (http://www.inkscape.org/) -->\n\n<svg\n   width="8.3343754mm"\n   height="8.3343754mm"\n   viewBox="0 0 8.3343756 8.3343756"\n   version="1.1"\n   id="svg1"\n   inkscape:version="1.4 (86a8ad7, 2024-10-11)"\n   sodipodi:docname="intermediate-signal-throw.svg"\n   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"\n   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"\n   xmlns="http://www.w3.org/2000/svg"\n   xmlns:svg="http://www.w3.org/2000/svg">\n  <sodipodi:namedview\n     id="namedview1"\n     pagecolor="#505050"\n     bordercolor="#eeeeee"\n     borderopacity="1"\n     inkscape:showpageshadow="0"\n     inkscape:pageopacity="0"\n     inkscape:pagecheckerboard="0"\n     inkscape:deskcolor="#505050"\n     inkscape:document-units="mm"\n     inkscape:zoom="8.1336326"\n     inkscape:cx="32.334876"\n     inkscape:cy="-6.7005731"\n     inkscape:window-width="2560"\n     inkscape:window-height="1009"\n     inkscape:window-x="-8"\n     inkscape:window-y="-8"\n     inkscape:window-maximized="1"\n     inkscape:current-layer="layer1" />\n  <defs\n     id="defs1" />\n  <g\n     inkscape:label="Layer 1"\n     inkscape:groupmode="layer"\n     id="layer1"\n     transform="translate(-53.115108,-210.80677)">\n    <circle\n       cx="57.282295"\n       cy="214.97395"\n       r="3.96875"\n       style="fill:none;stroke:#22242a;stroke-width:0.396875px;stroke-linecap:round;stroke-linejoin:round"\n       id="circle93" />\n    <path\n       d="m 57.282297,212.11646 2.38125,4.28625 h -4.7625 z"\n       style="fill:#22242a;stroke:#22242a;stroke-width:0.264583px;stroke-linecap:round;stroke-linejoin:round"\n       id="path93" />\n  </g>\n</svg>\n';
const intermediateTimer = '<?xml version="1.0" encoding="UTF-8" standalone="no"?>\n<!-- Created with Inkscape (http://www.inkscape.org/) -->\n\n<svg\n   width="8.3343754mm"\n   height="8.3343754mm"\n   viewBox="0 0 8.3343756 8.3343756"\n   version="1.1"\n   id="svg1"\n   inkscape:version="1.4 (86a8ad7, 2024-10-11)"\n   sodipodi:docname="intermediate-timer.svg"\n   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"\n   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"\n   xmlns="http://www.w3.org/2000/svg"\n   xmlns:svg="http://www.w3.org/2000/svg">\n  <sodipodi:namedview\n     id="namedview1"\n     pagecolor="#505050"\n     bordercolor="#eeeeee"\n     borderopacity="1"\n     inkscape:showpageshadow="0"\n     inkscape:pageopacity="0"\n     inkscape:pagecheckerboard="0"\n     inkscape:deskcolor="#505050"\n     inkscape:document-units="mm"\n     inkscape:zoom="11.502694"\n     inkscape:cx="25.298421"\n     inkscape:cy="14.561806"\n     inkscape:window-width="2560"\n     inkscape:window-height="1009"\n     inkscape:window-x="-8"\n     inkscape:window-y="-8"\n     inkscape:window-maximized="1"\n     inkscape:current-layer="layer1" />\n  <defs\n     id="defs1" />\n  <g\n     inkscape:label="Layer 1"\n     inkscape:groupmode="layer"\n     id="layer1"\n     transform="translate(28.111983,-209.21927)">\n    <circle\n       cx="-23.944796"\n       cy="213.38646"\n       r="3.96875"\n       style="fill:none;stroke:#22242a;stroke-width:0.396875px;stroke-linecap:round;stroke-linejoin:round"\n       id="circle59" />\n    <circle\n       cx="-23.944796"\n       cy="213.38646"\n       r="2.9104166"\n       style="fill:none;stroke:#22242a;stroke-width:0.529167px;stroke-linecap:round;stroke-linejoin:round"\n       id="circle60" />\n    <path\n       d="m -23.944795,213.38646 0.595312,-1.98438 m -0.595312,1.98438 1.389062,0.39687"\n       style="fill:none;stroke:#22242a;stroke-width:0.529167px;stroke-linecap:round;stroke-linejoin:round"\n       id="path60" />\n    <path\n       d="m -23.944795,213.38646 m 0,1.98437 v 0.59532"\n       style="fill:none;stroke:#22242a;stroke-width:0.264583px;stroke-linecap:round;stroke-linejoin:round"\n       id="path61" />\n    <path\n       d="m -23.944795,213.38646 m -0.992187,1.71852 -0.297657,0.51555"\n       style="fill:none;stroke:#22242a;stroke-width:0.264583px;stroke-linecap:round;stroke-linejoin:round"\n       id="path62" />\n    <path\n       d="m -23.944795,213.38646 m -1.718519,0.99218 -0.515556,0.29766"\n       style="fill:none;stroke:#22242a;stroke-width:0.264583px;stroke-linecap:round;stroke-linejoin:round"\n       id="path63" />\n    <path\n       d="m -23.944795,213.38646 m -1.984375,0 h -0.595312"\n       style="fill:none;stroke:#22242a;stroke-width:0.264583px;stroke-linecap:round;stroke-linejoin:round"\n       id="path64" />\n    <path\n       d="m -23.944795,213.38646 m -1.718519,-0.99219 -0.515556,-0.29766"\n       style="fill:none;stroke:#22242a;stroke-width:0.264583px;stroke-linecap:round;stroke-linejoin:round"\n       id="path65" />\n    <path\n       d="m -23.944795,213.38646 m -0.992187,-1.71852 -0.297657,-0.51555"\n       style="fill:none;stroke:#22242a;stroke-width:0.264583px;stroke-linecap:round;stroke-linejoin:round"\n       id="path66" />\n    <path\n       d="m -23.944795,213.38646 m 0,-1.98437 v -0.59532"\n       style="fill:none;stroke:#22242a;stroke-width:0.264583px;stroke-linecap:round;stroke-linejoin:round"\n       id="path67" />\n    <path\n       d="m -23.944795,213.38646 m 0.992187,-1.71852 0.297657,-0.51555"\n       style="fill:none;stroke:#22242a;stroke-width:0.264583px;stroke-linecap:round;stroke-linejoin:round"\n       id="path68" />\n    <path\n       d="m -23.944795,213.38646 m 1.718519,-0.99218 0.515556,-0.29766"\n       style="fill:none;stroke:#22242a;stroke-width:0.264583px;stroke-linecap:round;stroke-linejoin:round"\n       id="path69" />\n    <path\n       d="m -23.944795,213.38646 m 1.984375,0 h 0.595312"\n       style="fill:none;stroke:#22242a;stroke-width:0.264583px;stroke-linecap:round;stroke-linejoin:round"\n       id="path70" />\n    <path\n       d="m -23.944795,213.38646 m 1.718519,0.99219 0.515556,0.29766"\n       style="fill:none;stroke:#22242a;stroke-width:0.264583px;stroke-linecap:round;stroke-linejoin:round"\n       id="path71" />\n    <path\n       d="m -23.944795,213.38646 m 0.992187,1.71852 0.297657,0.51555"\n       style="fill:none;stroke:#22242a;stroke-width:0.264583px;stroke-linecap:round;stroke-linejoin:round"\n       id="path72" />\n  </g>\n</svg>\n';
const messageEnd = '<?xml version="1.0" encoding="UTF-8" standalone="no"?>\n<!-- Created with Inkscape (http://www.inkscape.org/) -->\n\n<svg\n   width="13.49375mm"\n   height="13.49375mm"\n   viewBox="0 0 13.49375 13.49375"\n   version="1.1"\n   id="svg1"\n   inkscape:version="1.4 (86a8ad7, 2024-10-11)"\n   sodipodi:docname="message-end.svg"\n   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"\n   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"\n   xmlns="http://www.w3.org/2000/svg"\n   xmlns:svg="http://www.w3.org/2000/svg">\n  <sodipodi:namedview\n     id="namedview1"\n     pagecolor="#505050"\n     bordercolor="#eeeeee"\n     borderopacity="1"\n     inkscape:showpageshadow="0"\n     inkscape:pageopacity="0"\n     inkscape:pagecheckerboard="0"\n     inkscape:deskcolor="#505050"\n     inkscape:document-units="mm"\n     inkscape:zoom="32.53453"\n     inkscape:cx="25.972405"\n     inkscape:cy="22.453067"\n     inkscape:window-width="2560"\n     inkscape:window-height="1009"\n     inkscape:window-x="-8"\n     inkscape:window-y="-8"\n     inkscape:window-maximized="1"\n     inkscape:current-layer="layer1" />\n  <defs\n     id="defs1" />\n  <g\n     inkscape:label="Layer 1"\n     inkscape:groupmode="layer"\n     id="layer1"\n     transform="translate(-28.310416,-212.98958)">\n    <g\n       id="g4">\n      <path\n         d="m 32.666222,218.20322 v 2.97242 h 4.736145 v -2.97242 l -2.302701,1.31413 a 0.13230472,0.13230472 0 0 1 -0.130742,0 z"\n         style="baseline-shift:baseline;display:inline;overflow:visible;vector-effect:none;fill:#22242a;stroke-linecap:round;stroke-linejoin:round;enable-background:accumulate;stop-color:#000000;stop-opacity:1;fill-opacity:1"\n         id="path4" />\n      <path\n         d="m 33.033125,218.10761 1.999878,1.14257 2.001945,-1.14257 z"\n         style="baseline-shift:baseline;display:inline;overflow:visible;vector-effect:none;fill:#22242a;stroke-linecap:round;stroke-linejoin:round;enable-background:accumulate;stop-color:#000000;stop-opacity:1;fill-opacity:1"\n         id="path3" />\n    </g>\n  </g>\n</svg>\n';
const messageStart = '<?xml version="1.0" encoding="UTF-8" standalone="no"?>\n<!-- Created with Inkscape (http://www.inkscape.org/) -->\n\n<svg\n   width="5.2652082mm"\n   height="3.5983334mm"\n   viewBox="0 0 5.2652084 3.5983335"\n   version="1.1"\n   id="svg1"\n   inkscape:version="1.4 (86a8ad7, 2024-10-11)"\n   sodipodi:docname="message-start.svg"\n   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"\n   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"\n   xmlns="http://www.w3.org/2000/svg"\n   xmlns:svg="http://www.w3.org/2000/svg">\n  <sodipodi:namedview\n     id="namedview1"\n     pagecolor="#505050"\n     bordercolor="#eeeeee"\n     borderopacity="1"\n     inkscape:showpageshadow="0"\n     inkscape:pageopacity="0"\n     inkscape:pagecheckerboard="0"\n     inkscape:deskcolor="#505050"\n     inkscape:document-units="mm"\n     inkscape:zoom="11.502694"\n     inkscape:cx="23.559698"\n     inkscape:cy="12.21453"\n     inkscape:window-width="2560"\n     inkscape:window-height="1009"\n     inkscape:window-x="-8"\n     inkscape:window-y="-8"\n     inkscape:window-maximized="1"\n     inkscape:current-layer="svg1" />\n  <defs\n     id="defs1" />\n  <path\n     d="M 0.13229166,0.13229167 V 3.4660416 H 5.1329166 V 0.13229166 Z m 0,0 L 2.6326041,1.5610416 5.1329166,0.13229167"\n     style="fill:none;stroke:#22242a;stroke-width:0.264583px;stroke-linecap:round;stroke-linejoin:round"\n     id="path4" />\n</svg>\n';
const signalEnd = '<?xml version="1.0" encoding="UTF-8" standalone="no"?>\n<!-- Created with Inkscape (http://www.inkscape.org/) -->\n\n<svg\n   width="5.0270643mm"\n   height="4.5508189mm"\n   viewBox="0 0 5.0270645 4.550819"\n   version="1.1"\n   id="svg1"\n   inkscape:version="1.4 (86a8ad7, 2024-10-11)"\n   sodipodi:docname="signal-end.svg"\n   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"\n   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"\n   xmlns="http://www.w3.org/2000/svg"\n   xmlns:svg="http://www.w3.org/2000/svg">\n  <sodipodi:namedview\n     id="namedview1"\n     pagecolor="#505050"\n     bordercolor="#eeeeee"\n     borderopacity="1"\n     inkscape:showpageshadow="0"\n     inkscape:pageopacity="0"\n     inkscape:pagecheckerboard="0"\n     inkscape:deskcolor="#505050"\n     inkscape:document-units="mm"\n     inkscape:zoom="11.502694"\n     inkscape:cx="11.562509"\n     inkscape:cy="10.128063"\n     inkscape:window-width="2560"\n     inkscape:window-height="1009"\n     inkscape:window-x="-8"\n     inkscape:window-y="-8"\n     inkscape:window-maximized="1"\n     inkscape:current-layer="layer1" />\n  <defs\n     id="defs1" />\n  <g\n     inkscape:label="Layer 1"\n     inkscape:groupmode="layer"\n     id="layer1"\n     transform="translate(-93.92709,-150.86543)">\n    <path\n       d="m 96.440622,150.99771 2.38125,4.28625 h -4.7625 z"\n       style="fill:#22242a;stroke:#22242a;stroke-width:0.264583px;stroke-linecap:round;stroke-linejoin:round"\n       id="path43" />\n  </g>\n</svg>\n';
const signalStart = '<?xml version="1.0" encoding="UTF-8" standalone="no"?>\n<!-- Created with Inkscape (http://www.inkscape.org/) -->\n\n<svg\n   width="5.0270643mm"\n   height="4.5508189mm"\n   viewBox="0 0 5.0270645 4.550819"\n   version="1.1"\n   id="svg1"\n   inkscape:version="1.4 (86a8ad7, 2024-10-11)"\n   sodipodi:docname="signal-start.svg"\n   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"\n   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"\n   xmlns="http://www.w3.org/2000/svg"\n   xmlns:svg="http://www.w3.org/2000/svg">\n  <sodipodi:namedview\n     id="namedview1"\n     pagecolor="#505050"\n     bordercolor="#eeeeee"\n     borderopacity="1"\n     inkscape:showpageshadow="0"\n     inkscape:pageopacity="0"\n     inkscape:pagecheckerboard="0"\n     inkscape:deskcolor="#505050"\n     inkscape:document-units="mm"\n     inkscape:zoom="8.1336326"\n     inkscape:cx="3.31955"\n     inkscape:cy="27.72439"\n     inkscape:window-width="2560"\n     inkscape:window-height="1009"\n     inkscape:window-x="-8"\n     inkscape:window-y="-8"\n     inkscape:window-maximized="1"\n     inkscape:current-layer="layer1" />\n  <defs\n     id="defs1" />\n  <g\n     inkscape:label="Layer 1"\n     inkscape:groupmode="layer"\n     id="layer1"\n     transform="translate(-122.5021,-95.038348)">\n    <path\n       d="m 125.01563,95.170625 2.38125,4.28625 h -4.7625 z"\n       style="fill:none;stroke:#22242a;stroke-width:0.264583px;stroke-linecap:round;stroke-linejoin:round"\n       id="path40" />\n  </g>\n</svg>\n';
const terminate = '<?xml version="1.0" encoding="UTF-8" standalone="no"?>\n<!-- Created with Inkscape (http://www.inkscape.org/) -->\n\n<svg\n   width="6.3499966mm"\n   height="6.3499966mm"\n   viewBox="0 0 6.3499967 6.3499967"\n   version="1.1"\n   id="svg1"\n   inkscape:version="1.4 (86a8ad7, 2024-10-11)"\n   sodipodi:docname="terminate.svg"\n   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"\n   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"\n   xmlns="http://www.w3.org/2000/svg"\n   xmlns:svg="http://www.w3.org/2000/svg">\n  <sodipodi:namedview\n     id="namedview1"\n     pagecolor="#505050"\n     bordercolor="#eeeeee"\n     borderopacity="1"\n     inkscape:showpageshadow="0"\n     inkscape:pageopacity="0"\n     inkscape:pagecheckerboard="0"\n     inkscape:deskcolor="#505050"\n     inkscape:document-units="mm"\n     inkscape:zoom="16.267265"\n     inkscape:cx="0.67620462"\n     inkscape:cy="9.6820208"\n     inkscape:window-width="2560"\n     inkscape:window-height="1009"\n     inkscape:window-x="-8"\n     inkscape:window-y="-8"\n     inkscape:window-maximized="1"\n     inkscape:current-layer="layer1" />\n  <defs\n     id="defs1" />\n  <g\n     inkscape:label="Layer 1"\n     inkscape:groupmode="layer"\n     id="layer1"\n     transform="translate(-148.82811,-151.73855)">\n    <circle\n       cx="152.00311"\n       cy="154.91354"\n       r="2.6458333"\n       style="fill:#22242a;stroke:#22242a;stroke-width:1.05833px;stroke-linecap:round;stroke-linejoin:round"\n       id="circle47" />\n  </g>\n</svg>\n';
const timer = '<?xml version="1.0" encoding="UTF-8" standalone="no"?>\n<!-- Created with Inkscape (http://www.inkscape.org/) -->\n\n<svg\n   width="6.3499999mm"\n   height="6.3499999mm"\n   viewBox="0 0 6.3500001 6.3500001"\n   version="1.1"\n   id="svg1"\n   inkscape:version="1.4 (86a8ad7, 2024-10-11)"\n   sodipodi:docname="timer.svg"\n   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"\n   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"\n   xmlns="http://www.w3.org/2000/svg"\n   xmlns:svg="http://www.w3.org/2000/svg">\n  <sodipodi:namedview\n     id="namedview1"\n     pagecolor="#505050"\n     bordercolor="#eeeeee"\n     borderopacity="1"\n     inkscape:showpageshadow="0"\n     inkscape:pageopacity="0"\n     inkscape:pagecheckerboard="0"\n     inkscape:deskcolor="#505050"\n     inkscape:document-units="mm"\n     inkscape:zoom="11.502694"\n     inkscape:cx="-3.2166378"\n     inkscape:cy="17.169891"\n     inkscape:window-width="2560"\n     inkscape:window-height="1009"\n     inkscape:window-x="-8"\n     inkscape:window-y="-8"\n     inkscape:window-maximized="1"\n     inkscape:current-layer="layer1" />\n  <defs\n     id="defs1" />\n  <g\n     inkscape:label="Layer 1"\n     inkscape:groupmode="layer"\n     id="layer1"\n     transform="translate(-129.24896,-55.430208)">\n    <g\n       id="g1">\n      <circle\n         cx="132.42397"\n         cy="58.605209"\n         r="2.9104166"\n         style="fill:none;stroke:#22242a;stroke-width:0.529167px;stroke-linecap:round;stroke-linejoin:round"\n         id="circle8" />\n      <path\n         d="m 132.42396,58.605208 0.59531,-1.984375 m -0.59531,1.984375 1.38906,0.396875"\n         style="fill:none;stroke:#22242a;stroke-width:0.529167px;stroke-linecap:round;stroke-linejoin:round"\n         id="path8" />\n      <path\n         d="m 132.42396,58.605208 m 0,1.984375 v 0.595312"\n         style="fill:none;stroke:#22242a;stroke-width:0.264583px;stroke-linecap:round;stroke-linejoin:round"\n         id="path9" />\n      <path\n         d="m 132.42396,58.605208 m -0.99219,1.718519 -0.29766,0.515556"\n         style="fill:none;stroke:#22242a;stroke-width:0.264583px;stroke-linecap:round;stroke-linejoin:round"\n         id="path10" />\n      <path\n         d="m 132.42396,58.605208 m -1.71852,0.992188 -0.51555,0.297656"\n         style="fill:none;stroke:#22242a;stroke-width:0.264583px;stroke-linecap:round;stroke-linejoin:round"\n         id="path11" />\n      <path\n         d="m 132.42396,58.605208 m -1.98437,0 h -0.59532"\n         style="fill:none;stroke:#22242a;stroke-width:0.264583px;stroke-linecap:round;stroke-linejoin:round"\n         id="path12" />\n      <path\n         d="m 132.42396,58.605208 m -1.71852,-0.992187 -0.51555,-0.297657"\n         style="fill:none;stroke:#22242a;stroke-width:0.264583px;stroke-linecap:round;stroke-linejoin:round"\n         id="path13" />\n      <path\n         d="m 132.42396,58.605208 m -0.99218,-1.718519 -0.29766,-0.515556"\n         style="fill:none;stroke:#22242a;stroke-width:0.264583px;stroke-linecap:round;stroke-linejoin:round"\n         id="path14" />\n      <path\n         d="m 132.42396,58.605208 m 0,-1.984375 v -0.595312"\n         style="fill:none;stroke:#22242a;stroke-width:0.264583px;stroke-linecap:round;stroke-linejoin:round"\n         id="path15" />\n      <path\n         d="m 132.42396,58.605208 m 0.99219,-1.718519 0.29766,-0.515556"\n         style="fill:none;stroke:#22242a;stroke-width:0.264583px;stroke-linecap:round;stroke-linejoin:round"\n         id="path16" />\n      <path\n         d="m 132.42396,58.605208 m 1.71852,-0.992187 0.51555,-0.297657"\n         style="fill:none;stroke:#22242a;stroke-width:0.264583px;stroke-linecap:round;stroke-linejoin:round"\n         id="path17" />\n      <path\n         d="m 132.42396,58.605208 m 1.98437,0 h 0.59532"\n         style="fill:none;stroke:#22242a;stroke-width:0.264583px;stroke-linecap:round;stroke-linejoin:round"\n         id="path18" />\n      <path\n         d="m 132.42396,58.605208 m 1.71852,0.992188 0.51555,0.297656"\n         style="fill:none;stroke:#22242a;stroke-width:0.264583px;stroke-linecap:round;stroke-linejoin:round"\n         id="path19" />\n      <path\n         d="m 132.42396,58.605208 m 0.99218,1.718519 0.29766,0.515556"\n         style="fill:none;stroke:#22242a;stroke-width:0.264583px;stroke-linecap:round;stroke-linejoin:round"\n         id="path20" />\n    </g>\n  </g>\n</svg>\n';
var Tween = { exports: {} };
var hasRequiredTween;
function requireTween() {
  if (hasRequiredTween) return Tween.exports;
  hasRequiredTween = 1;
  (function(module, exports) {
    var TWEEN2 = TWEEN2 || /* @__PURE__ */ function() {
      var _tweens = [];
      return {
        getAll: function() {
          return _tweens;
        },
        removeAll: function() {
          _tweens = [];
        },
        add: function(tween) {
          _tweens.push(tween);
        },
        remove: function(tween) {
          var i = _tweens.indexOf(tween);
          if (i !== -1) {
            _tweens.splice(i, 1);
          }
        },
        update: function(time, preserve) {
          if (_tweens.length === 0) {
            return false;
          }
          var i = 0;
          time = time !== void 0 ? time : TWEEN2.now();
          while (i < _tweens.length) {
            if (_tweens[i].update(time) || preserve) {
              i++;
            } else {
              _tweens.splice(i, 1);
            }
          }
          return true;
        }
      };
    }();
    if (typeof window === "undefined" && typeof process !== "undefined") {
      TWEEN2.now = function() {
        var time = process.hrtime();
        return time[0] * 1e3 + time[1] / 1e6;
      };
    } else if (typeof window !== "undefined" && window.performance !== void 0 && window.performance.now !== void 0) {
      TWEEN2.now = window.performance.now.bind(window.performance);
    } else if (Date.now !== void 0) {
      TWEEN2.now = Date.now;
    } else {
      TWEEN2.now = function() {
        return (/* @__PURE__ */ new Date()).getTime();
      };
    }
    TWEEN2.Tween = function(object) {
      var _object = object;
      var _valuesStart = {};
      var _valuesEnd = {};
      var _valuesStartRepeat = {};
      var _duration = 1e3;
      var _repeat = 0;
      var _repeatDelayTime;
      var _yoyo = false;
      var _isPlaying = false;
      var _delayTime = 0;
      var _startTime = null;
      var _easingFunction = TWEEN2.Easing.Linear.None;
      var _interpolationFunction = TWEEN2.Interpolation.Linear;
      var _chainedTweens = [];
      var _onStartCallback = null;
      var _onStartCallbackFired = false;
      var _onUpdateCallback = null;
      var _onCompleteCallback = null;
      var _onStopCallback = null;
      this.to = function(properties, duration) {
        _valuesEnd = properties;
        if (duration !== void 0) {
          _duration = duration;
        }
        return this;
      };
      this.start = function(time) {
        TWEEN2.add(this);
        _isPlaying = true;
        _onStartCallbackFired = false;
        _startTime = time !== void 0 ? time : TWEEN2.now();
        _startTime += _delayTime;
        for (var property2 in _valuesEnd) {
          if (_valuesEnd[property2] instanceof Array) {
            if (_valuesEnd[property2].length === 0) {
              continue;
            }
            _valuesEnd[property2] = [_object[property2]].concat(_valuesEnd[property2]);
          }
          if (_object[property2] === void 0) {
            continue;
          }
          _valuesStart[property2] = _object[property2];
          if (_valuesStart[property2] instanceof Array === false) {
            _valuesStart[property2] *= 1;
          }
          _valuesStartRepeat[property2] = _valuesStart[property2] || 0;
        }
        return this;
      };
      this.stop = function() {
        if (!_isPlaying) {
          return this;
        }
        TWEEN2.remove(this);
        _isPlaying = false;
        if (_onStopCallback !== null) {
          _onStopCallback.call(_object, _object);
        }
        this.stopChainedTweens();
        return this;
      };
      this.end = function() {
        this.update(_startTime + _duration);
        return this;
      };
      this.stopChainedTweens = function() {
        for (var i = 0, numChainedTweens = _chainedTweens.length; i < numChainedTweens; i++) {
          _chainedTweens[i].stop();
        }
      };
      this.delay = function(amount) {
        _delayTime = amount;
        return this;
      };
      this.repeat = function(times) {
        _repeat = times;
        return this;
      };
      this.repeatDelay = function(amount) {
        _repeatDelayTime = amount;
        return this;
      };
      this.yoyo = function(yoyo) {
        _yoyo = yoyo;
        return this;
      };
      this.easing = function(easing) {
        _easingFunction = easing;
        return this;
      };
      this.interpolation = function(interpolation) {
        _interpolationFunction = interpolation;
        return this;
      };
      this.chain = function() {
        _chainedTweens = arguments;
        return this;
      };
      this.onStart = function(callback) {
        _onStartCallback = callback;
        return this;
      };
      this.onUpdate = function(callback) {
        _onUpdateCallback = callback;
        return this;
      };
      this.onComplete = function(callback) {
        _onCompleteCallback = callback;
        return this;
      };
      this.onStop = function(callback) {
        _onStopCallback = callback;
        return this;
      };
      this.update = function(time) {
        var property2;
        var elapsed;
        var value;
        if (time < _startTime) {
          return true;
        }
        if (_onStartCallbackFired === false) {
          if (_onStartCallback !== null) {
            _onStartCallback.call(_object, _object);
          }
          _onStartCallbackFired = true;
        }
        elapsed = (time - _startTime) / _duration;
        elapsed = elapsed > 1 ? 1 : elapsed;
        value = _easingFunction(elapsed);
        for (property2 in _valuesEnd) {
          if (_valuesStart[property2] === void 0) {
            continue;
          }
          var start = _valuesStart[property2] || 0;
          var end = _valuesEnd[property2];
          if (end instanceof Array) {
            _object[property2] = _interpolationFunction(end, value);
          } else {
            if (typeof end === "string") {
              if (end.charAt(0) === "+" || end.charAt(0) === "-") {
                end = start + parseFloat(end);
              } else {
                end = parseFloat(end);
              }
            }
            if (typeof end === "number") {
              _object[property2] = start + (end - start) * value;
            }
          }
        }
        if (_onUpdateCallback !== null) {
          _onUpdateCallback.call(_object, value);
        }
        if (elapsed === 1) {
          if (_repeat > 0) {
            if (isFinite(_repeat)) {
              _repeat--;
            }
            for (property2 in _valuesStartRepeat) {
              if (typeof _valuesEnd[property2] === "string") {
                _valuesStartRepeat[property2] = _valuesStartRepeat[property2] + parseFloat(_valuesEnd[property2]);
              }
              if (_yoyo) {
                var tmp2 = _valuesStartRepeat[property2];
                _valuesStartRepeat[property2] = _valuesEnd[property2];
                _valuesEnd[property2] = tmp2;
              }
              _valuesStart[property2] = _valuesStartRepeat[property2];
            }
            if (_repeatDelayTime !== void 0) {
              _startTime = time + _repeatDelayTime;
            } else {
              _startTime = time + _delayTime;
            }
            return true;
          } else {
            if (_onCompleteCallback !== null) {
              _onCompleteCallback.call(_object, _object);
            }
            for (var i = 0, numChainedTweens = _chainedTweens.length; i < numChainedTweens; i++) {
              _chainedTweens[i].start(_startTime + _duration);
            }
            return false;
          }
        }
        return true;
      };
    };
    TWEEN2.Easing = {
      Linear: {
        None: function(k) {
          return k;
        }
      },
      Quadratic: {
        In: function(k) {
          return k * k;
        },
        Out: function(k) {
          return k * (2 - k);
        },
        InOut: function(k) {
          if ((k *= 2) < 1) {
            return 0.5 * k * k;
          }
          return -0.5 * (--k * (k - 2) - 1);
        }
      },
      Cubic: {
        In: function(k) {
          return k * k * k;
        },
        Out: function(k) {
          return --k * k * k + 1;
        },
        InOut: function(k) {
          if ((k *= 2) < 1) {
            return 0.5 * k * k * k;
          }
          return 0.5 * ((k -= 2) * k * k + 2);
        }
      },
      Quartic: {
        In: function(k) {
          return k * k * k * k;
        },
        Out: function(k) {
          return 1 - --k * k * k * k;
        },
        InOut: function(k) {
          if ((k *= 2) < 1) {
            return 0.5 * k * k * k * k;
          }
          return -0.5 * ((k -= 2) * k * k * k - 2);
        }
      },
      Quintic: {
        In: function(k) {
          return k * k * k * k * k;
        },
        Out: function(k) {
          return --k * k * k * k * k + 1;
        },
        InOut: function(k) {
          if ((k *= 2) < 1) {
            return 0.5 * k * k * k * k * k;
          }
          return 0.5 * ((k -= 2) * k * k * k * k + 2);
        }
      },
      Sinusoidal: {
        In: function(k) {
          return 1 - Math.cos(k * Math.PI / 2);
        },
        Out: function(k) {
          return Math.sin(k * Math.PI / 2);
        },
        InOut: function(k) {
          return 0.5 * (1 - Math.cos(Math.PI * k));
        }
      },
      Exponential: {
        In: function(k) {
          return k === 0 ? 0 : Math.pow(1024, k - 1);
        },
        Out: function(k) {
          return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);
        },
        InOut: function(k) {
          if (k === 0) {
            return 0;
          }
          if (k === 1) {
            return 1;
          }
          if ((k *= 2) < 1) {
            return 0.5 * Math.pow(1024, k - 1);
          }
          return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);
        }
      },
      Circular: {
        In: function(k) {
          return 1 - Math.sqrt(1 - k * k);
        },
        Out: function(k) {
          return Math.sqrt(1 - --k * k);
        },
        InOut: function(k) {
          if ((k *= 2) < 1) {
            return -0.5 * (Math.sqrt(1 - k * k) - 1);
          }
          return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);
        }
      },
      Elastic: {
        In: function(k) {
          if (k === 0) {
            return 0;
          }
          if (k === 1) {
            return 1;
          }
          return -Math.pow(2, 10 * (k - 1)) * Math.sin((k - 1.1) * 5 * Math.PI);
        },
        Out: function(k) {
          if (k === 0) {
            return 0;
          }
          if (k === 1) {
            return 1;
          }
          return Math.pow(2, -10 * k) * Math.sin((k - 0.1) * 5 * Math.PI) + 1;
        },
        InOut: function(k) {
          if (k === 0) {
            return 0;
          }
          if (k === 1) {
            return 1;
          }
          k *= 2;
          if (k < 1) {
            return -0.5 * Math.pow(2, 10 * (k - 1)) * Math.sin((k - 1.1) * 5 * Math.PI);
          }
          return 0.5 * Math.pow(2, -10 * (k - 1)) * Math.sin((k - 1.1) * 5 * Math.PI) + 1;
        }
      },
      Back: {
        In: function(k) {
          var s = 1.70158;
          return k * k * ((s + 1) * k - s);
        },
        Out: function(k) {
          var s = 1.70158;
          return --k * k * ((s + 1) * k + s) + 1;
        },
        InOut: function(k) {
          var s = 1.70158 * 1.525;
          if ((k *= 2) < 1) {
            return 0.5 * (k * k * ((s + 1) * k - s));
          }
          return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);
        }
      },
      Bounce: {
        In: function(k) {
          return 1 - TWEEN2.Easing.Bounce.Out(1 - k);
        },
        Out: function(k) {
          if (k < 1 / 2.75) {
            return 7.5625 * k * k;
          } else if (k < 2 / 2.75) {
            return 7.5625 * (k -= 1.5 / 2.75) * k + 0.75;
          } else if (k < 2.5 / 2.75) {
            return 7.5625 * (k -= 2.25 / 2.75) * k + 0.9375;
          } else {
            return 7.5625 * (k -= 2.625 / 2.75) * k + 0.984375;
          }
        },
        InOut: function(k) {
          if (k < 0.5) {
            return TWEEN2.Easing.Bounce.In(k * 2) * 0.5;
          }
          return TWEEN2.Easing.Bounce.Out(k * 2 - 1) * 0.5 + 0.5;
        }
      }
    };
    TWEEN2.Interpolation = {
      Linear: function(v, k) {
        var m = v.length - 1;
        var f = m * k;
        var i = Math.floor(f);
        var fn = TWEEN2.Interpolation.Utils.Linear;
        if (k < 0) {
          return fn(v[0], v[1], f);
        }
        if (k > 1) {
          return fn(v[m], v[m - 1], m - f);
        }
        return fn(v[i], v[i + 1 > m ? m : i + 1], f - i);
      },
      Bezier: function(v, k) {
        var b = 0;
        var n = v.length - 1;
        var pw = Math.pow;
        var bn = TWEEN2.Interpolation.Utils.Bernstein;
        for (var i = 0; i <= n; i++) {
          b += pw(1 - k, n - i) * pw(k, i) * v[i] * bn(n, i);
        }
        return b;
      },
      CatmullRom: function(v, k) {
        var m = v.length - 1;
        var f = m * k;
        var i = Math.floor(f);
        var fn = TWEEN2.Interpolation.Utils.CatmullRom;
        if (v[0] === v[m]) {
          if (k < 0) {
            i = Math.floor(f = m * (1 + k));
          }
          return fn(v[(i - 1 + m) % m], v[i], v[(i + 1) % m], v[(i + 2) % m], f - i);
        } else {
          if (k < 0) {
            return v[0] - (fn(v[0], v[0], v[1], v[1], -f) - v[0]);
          }
          if (k > 1) {
            return v[m] - (fn(v[m], v[m], v[m - 1], v[m - 1], f - m) - v[m]);
          }
          return fn(v[i ? i - 1 : 0], v[i], v[m < i + 1 ? m : i + 1], v[m < i + 2 ? m : i + 2], f - i);
        }
      },
      Utils: {
        Linear: function(p0, p1, t) {
          return (p1 - p0) * t + p0;
        },
        Bernstein: function(n, i) {
          var fc = TWEEN2.Interpolation.Utils.Factorial;
          return fc(n) / fc(i) / fc(n - i);
        },
        Factorial: /* @__PURE__ */ function() {
          var a = [1];
          return function(n) {
            var s = 1;
            if (a[n]) {
              return a[n];
            }
            for (var i = n; i > 1; i--) {
              s *= i;
            }
            a[n] = s;
            return s;
          };
        }(),
        CatmullRom: function(p0, p1, p2, p3, t) {
          var v0 = (p2 - p0) * 0.5;
          var v1 = (p3 - p1) * 0.5;
          var t2 = t * t;
          var t3 = t * t2;
          return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
        }
      }
    };
    (function(root) {
      {
        module.exports = TWEEN2;
      }
    })();
  })(Tween);
  return Tween.exports;
}
requireTween();
class BpmnDiagram extends Diagram {
  constructor(container) {
    super(container);
  }
  // --------------------------------------------------
  // BPMN Diagram Dimensions
  // --------------------------------------------------
  static get Dimensions() {
    return {
      DISTANCE_BETWEEN_ELEMENTS: DiagramDimensions.DISTANCE_BETWEEN_ELEMENTS,
      START_EVENT_LINE_WIDTH: 1,
      END_EVENT_LINE_WIDTH: 2.4,
      ICON_SIZE_SMALL: 10,
      ICON_SIZE_MEDIUM: 18,
      ICON_SIZE_LARGE: 30
    };
  }
  // --------------------------------------------------
  // Add BPMN Elements
  // --------------------------------------------------
  // Start Events
  addStartEvent(elementId) {
    return this.addElement(new Element(elementId, new CircleShape()));
  }
  addMessageStartEvent(elementId) {
    return this.addElement(new Element(elementId, new CircleShape())).addIcon(messageStart, "center", BpmnDiagram.Dimensions.ICON_SIZE_MEDIUM);
  }
  addTimerStartEvent(elementId) {
    return this.addElement(new Element(elementId, new CircleShape())).addIcon(timer, "center", BpmnDiagram.Dimensions.ICON_SIZE_LARGE);
  }
  addConditionalStartEvent(elementId) {
    return this.addElement(new Element(elementId, new CircleShape())).addIcon(conditional, "center", BpmnDiagram.Dimensions.ICON_SIZE_MEDIUM);
  }
  addSignalStartEvent(elementId) {
    return this.addElement(new Element(elementId, new CircleShape())).addIcon(signalStart, "center", BpmnDiagram.Dimensions.ICON_SIZE_MEDIUM);
  }
  // Intermediate Events
  addIntermediateEvent(elementId) {
    return this.addElement(new Element(elementId, new CircleShape())).addIcon(intermediate, "center", BpmnDiagram.Dimensions.ICON_SIZE_LARGE);
  }
  addIntermediateMessageCatchEvent(elementId) {
    return this.addElement(new Element(elementId, new CircleShape())).addIcon(intermediateReceive, "center", BpmnDiagram.Dimensions.ICON_SIZE_LARGE);
  }
  addIntermediateMessageThrowEvent(elementId) {
    return this.addElement(new Element(elementId, new CircleShape())).addIcon(intermediateSend, "center", BpmnDiagram.Dimensions.ICON_SIZE_LARGE);
  }
  addIntermediateTimerEvent(elementId) {
    return this.addElement(new Element(elementId, new CircleShape())).addIcon(intermediateTimer, "center", BpmnDiagram.Dimensions.ICON_SIZE_LARGE);
  }
  addIntermediateEscalationEvent(elementId) {
    return this.addElement(new Element(elementId, new CircleShape())).addIcon(intermediateEscalation, "center", BpmnDiagram.Dimensions.ICON_SIZE_LARGE);
  }
  addIntermediateConditionalEvent(elementId) {
    return this.addElement(new Element(elementId, new CircleShape())).addIcon(intermediateConditional, "center", BpmnDiagram.Dimensions.ICON_SIZE_LARGE);
  }
  addIntermediateLinkCatchEvent(elementId) {
    return this.addElement(new Element(elementId, new CircleShape())).addIcon(intermediateLinkCatch, "center", BpmnDiagram.Dimensions.ICON_SIZE_LARGE);
  }
  addIntermediateLinkThrowEvent(elementId) {
    return this.addElement(new Element(elementId, new CircleShape())).addIcon(intermediateLinkThrow, "center", BpmnDiagram.Dimensions.ICON_SIZE_LARGE);
  }
  addIntermediateCompensationEvent(elementId) {
    return this.addElement(new Element(elementId, new CircleShape())).addIcon(intermediateCompensation, "center", BpmnDiagram.Dimensions.ICON_SIZE_LARGE);
  }
  addIntermediateSignalCatchEvent(elementId) {
    return this.addElement(new Element(elementId, new CircleShape())).addIcon(intermediateSignalCatch, "center", BpmnDiagram.Dimensions.ICON_SIZE_LARGE);
  }
  addIntermediateSignalThrowEvent(elementId) {
    return this.addElement(new Element(elementId, new CircleShape())).addIcon(intermediateSignalThrow, "center", BpmnDiagram.Dimensions.ICON_SIZE_LARGE);
  }
  // End Events
  addEndEvent(elementId) {
    return this.addElement(new Element(elementId, new CircleShape(BpmnDiagram.Dimensions.END_EVENT_LINE_WIDTH)));
  }
  addMessageEndEvent(elementId) {
    return this.addElement(new Element(elementId, new CircleShape(BpmnDiagram.Dimensions.END_EVENT_LINE_WIDTH))).addIcon(messageEnd, "center", BpmnDiagram.Dimensions.ICON_SIZE_MEDIUM);
  }
  addEscalationEndEvent(elementId) {
    return this.addElement(new Element(elementId, new CircleShape(BpmnDiagram.Dimensions.END_EVENT_LINE_WIDTH))).addIcon(escalation, "center", BpmnDiagram.Dimensions.ICON_SIZE_MEDIUM);
  }
  addErrorEndEvent(elementId) {
    return this.addElement(new Element(elementId, new CircleShape(BpmnDiagram.Dimensions.END_EVENT_LINE_WIDTH))).addIcon(error, "center", BpmnDiagram.Dimensions.ICON_SIZE_MEDIUM);
  }
  addCompensateEndEvent(elementId) {
    return this.addElement(new Element(elementId, new CircleShape(BpmnDiagram.Dimensions.END_EVENT_LINE_WIDTH))).addIcon(compensation, "center", BpmnDiagram.Dimensions.ICON_SIZE_MEDIUM);
  }
  addSignalEndEvent(elementId) {
    return this.addElement(new Element(elementId, new CircleShape(BpmnDiagram.Dimensions.END_EVENT_LINE_WIDTH))).addIcon(signalEnd, "center", BpmnDiagram.Dimensions.ICON_SIZE_MEDIUM);
  }
  addTerminateEndEvent(elementId) {
    return this.addElement(new Element(elementId, new CircleShape(BpmnDiagram.Dimensions.END_EVENT_LINE_WIDTH))).addIcon(terminate, "center", BpmnDiagram.Dimensions.ICON_SIZE_MEDIUM);
  }
  // Tasks
  addTask(elementId) {
    return this.addElement(new Element(elementId, new RoundedRectangleShape()));
  }
  addManualTask(elementId) {
    return this.addElement(new Element(elementId, new RoundedRectangleShape())).addIcon(manual, "top-left", BpmnDiagram.Dimensions.ICON_SIZE_SMALL);
  }
  addUserTask(elementId) {
    return this.addElement(new Element(elementId, new RoundedRectangleShape())).addIcon(user, "top-left", BpmnDiagram.Dimensions.ICON_SIZE_SMALL);
  }
  addScriptTask(elementId) {
    return this.addElement(new Element(elementId, new RoundedRectangleShape())).addIcon(script, "top-left", BpmnDiagram.Dimensions.ICON_SIZE_SMALL);
  }
  addBusinessRuleTask(elementId) {
    return this.addElement(new Element(elementId, new RoundedRectangleShape())).addIcon(businessRule, "top-left", BpmnDiagram.Dimensions.ICON_SIZE_SMALL);
  }
  addServiceTask(elementId) {
    return this.addElement(new Element(elementId, new RoundedRectangleShape())).addIcon(service, "top-left", BpmnDiagram.Dimensions.ICON_SIZE_SMALL);
  }
  addSendTask(elementId) {
    return this.addElement(new Element(elementId, new RoundedRectangleShape())).addIcon(send, "top-left", BpmnDiagram.Dimensions.ICON_SIZE_SMALL);
  }
  addReceiveTask(elementId) {
    return this.addElement(new Element(elementId, new RoundedRectangleShape())).addIcon(receive, "top-left", BpmnDiagram.Dimensions.ICON_SIZE_SMALL);
  }
  // Gateways
  addGateway(elementId) {
    return this.addExclusiveGateway(elementId);
  }
  addInclusiveGateway(elementId) {
    return this.addElement(new Element(elementId, new DiamondShape())).addIcon(inclusive, "center", BpmnDiagram.Dimensions.ICON_SIZE_LARGE);
  }
  addExclusiveGateway(elementId) {
    return this.addElement(new Element(elementId, new DiamondShape())).addIcon(exclusive, "center", BpmnDiagram.Dimensions.ICON_SIZE_MEDIUM);
  }
  addParallelGateway(elementId) {
    return this.addElement(new Element(elementId, new DiamondShape())).addIcon(parallel, "center", BpmnDiagram.Dimensions.ICON_SIZE_LARGE);
  }
  addEventBasedGateway(elementId) {
    return this.addElement(new Element(elementId, new DiamondShape())).addIcon(eventBased, "center", BpmnDiagram.Dimensions.ICON_SIZE_LARGE);
  }
  addComplexGateway(elementId) {
    return this.addElement(new Element(elementId, new DiamondShape())).addIcon(complex, "center", BpmnDiagram.Dimensions.ICON_SIZE_MEDIUM);
  }
  // --------------------------------------------------
  // Add BPMN Connectors
  // --------------------------------------------------
  addFlowConnector(elementId, points) {
    return this.addConnector(new Connector(elementId, new RoundedCornerOrthogonalConnectorShape(points)));
  }
  // --------------------------------------------------
  // Import BPMN Diagram from .bpmn file (XML)
  // --------------------------------------------------
  import(file) {
    if (!file) {
      console.error("No file provided for import.");
      return;
    }
    const reader = new FileReader();
    reader.onload = (event) => {
      if (file.name.endsWith(".bpmn")) {
        const parser = new DOMParser();
        const xmlDoc = parser.parseFromString(event.target.result, "text/xml");
        console.log(xmlDoc);
        this.buildDiagram(xmlDoc);
      } else {
        console.warn("File format not supported.");
      }
    };
    reader.readAsText(file);
  }
  buildDiagram(xmlDoc) {
    const bpmnNamespace = "http://www.omg.org/spec/BPMN/20100524/MODEL";
    const bpmndiNamespace = "http://www.omg.org/spec/BPMN/20100524/DI";
    const dcNamespace = "http://www.omg.org/spec/DD/20100524/DC";
    const diNamespace = "http://www.omg.org/spec/DD/20100524/DI";
    const startEvents = xmlDoc.getElementsByTagNameNS(bpmnNamespace, "startEvent");
    for (let i = 0; i < startEvents.length; i++) {
      const startEventId = startEvents[i].getAttribute("id");
      console.log("startEventId:", startEventId);
      const name = startEvents[i].getElementsByTagNameNS(bpmnNamespace, "name");
      console.log("name:", name);
      const incoming = startEvents[i].getElementsByTagNameNS(bpmnNamespace, "incoming");
      console.log("incoming:", incoming);
      for (let j = 0; j < incoming.length; j++) {
        console.log("incoming:", incoming[j].textContent);
      }
      const outgoing = startEvents[i].getElementsByTagNameNS(bpmnNamespace, "outgoing");
      console.log("outgoing:", outgoing);
      for (let j = 0; j < outgoing.length; j++) {
        console.log("outgoing:", outgoing[j].textContent);
      }
      if (startEvents[i].getElementsByTagNameNS(bpmnNamespace, "messageEventDefinition").length > 0) {
        this.addMessageStartEvent(startEventId);
      } else if (startEvents[i].getElementsByTagNameNS(bpmnNamespace, "timerEventDefinition").length > 0) {
        this.addTimerStartEvent(startEventId);
      } else if (startEvents[i].getElementsByTagNameNS(bpmnNamespace, "conditionalEventDefinition").length > 0) {
        this.addConditionalStartEvent(startEventId);
      } else if (startEvents[i].getElementsByTagNameNS(bpmnNamespace, "signalEventDefinition").length > 0) {
        this.addSignalStartEvent(startEventId);
      } else {
        this.addStartEvent(startEventId);
      }
    }
    const endEvents = xmlDoc.getElementsByTagNameNS(bpmnNamespace, "endEvent");
    for (let i = 0; i < endEvents.length; i++) {
      const endEventId = endEvents[i].getAttribute("id");
      console.log("endEventId:", endEventId);
      const name = endEvents[i].getElementsByTagNameNS(bpmnNamespace, "name");
      console.log("name:", name);
      const incoming = endEvents[i].getElementsByTagNameNS(bpmnNamespace, "incoming");
      console.log("incoming:", incoming);
      for (let j = 0; j < incoming.length; j++) {
        console.log("incoming:", incoming[j].textContent);
      }
      const outgoing = endEvents[i].getElementsByTagNameNS(bpmnNamespace, "outgoing");
      console.log("outgoing:", outgoing);
      for (let j = 0; j < outgoing.length; j++) {
        console.log("outgoing:", outgoing[j].textContent);
      }
      if (endEvents[i].getElementsByTagNameNS(bpmnNamespace, "messageEventDefinition").length > 0) {
        this.addMessageEndEvent(endEventId);
      } else if (endEvents[i].getElementsByTagNameNS(bpmnNamespace, "escalationEventDefinition").length > 0) {
        this.addEscalationEndEvent(endEventId);
      } else if (endEvents[i].getElementsByTagNameNS(bpmnNamespace, "errorEventDefinition").length > 0) {
        this.addErrorEndEvent(endEventId);
      } else if (endEvents[i].getElementsByTagNameNS(bpmnNamespace, "compensateEventDefinition").length > 0) {
        this.addCompensateEndEvent(endEventId);
      } else if (endEvents[i].getElementsByTagNameNS(bpmnNamespace, "signalEventDefinition").length > 0) {
        this.addSignalEndEvent(endEventId);
      } else if (endEvents[i].getElementsByTagNameNS(bpmnNamespace, "terminateEventDefinition").length > 0) {
        this.addTerminateEndEvent(endEventId);
      } else {
        this.addEndEvent(endEventId);
      }
    }
    const intermediateCatchEvents = xmlDoc.getElementsByTagNameNS(bpmnNamespace, "intermediateCatchEvent");
    for (let i = 0; i < intermediateCatchEvents.length; i++) {
      const intermediateCatchEventId = intermediateCatchEvents[i].getAttribute("id");
      console.log("intermediateCatchEventId:", intermediateCatchEventId);
      const name = intermediateCatchEvents[i].getElementsByTagNameNS(bpmnNamespace, "name");
      console.log("name:", name);
      const incoming = intermediateCatchEvents[i].getElementsByTagNameNS(bpmnNamespace, "incoming");
      console.log("incoming:", incoming);
      for (let j = 0; j < incoming.length; j++) {
        console.log("incoming:", incoming[j].textContent);
      }
      const outgoing = intermediateCatchEvents[i].getElementsByTagNameNS(bpmnNamespace, "outgoing");
      console.log("outgoing:", outgoing);
      for (let j = 0; j < outgoing.length; j++) {
        console.log("outgoing:", outgoing[j].textContent);
      }
      if (intermediateCatchEvents[i].getElementsByTagNameNS(bpmnNamespace, "messageEventDefinition").length > 0) {
        this.addIntermediateMessageCatchEvent(intermediateCatchEventId);
      } else if (intermediateCatchEvents[i].getElementsByTagNameNS(bpmnNamespace, "timerEventDefinition").length > 0) {
        this.addIntermediateTimerEvent(intermediateCatchEventId);
      } else if (intermediateCatchEvents[i].getElementsByTagNameNS(bpmnNamespace, "conditionalEventDefinition").length > 0) {
        this.addIntermediateConditionalEvent(intermediateCatchEventId);
      } else if (intermediateCatchEvents[i].getElementsByTagNameNS(bpmnNamespace, "linkEventDefinition").length > 0) {
        this.addIntermediateLinkCatchEvent(intermediateCatchEventId);
      } else if (intermediateCatchEvents[i].getElementsByTagNameNS(bpmnNamespace, "signalEventDefinition").length > 0) {
        this.addIntermediateSignalCatchEvent(intermediateCatchEventId);
      } else {
        this.addIntermediateEvent(intermediateCatchEventId);
      }
    }
    const intermediateThrowEvents = xmlDoc.getElementsByTagNameNS(bpmnNamespace, "intermediateThrowEvent");
    for (let i = 0; i < intermediateThrowEvents.length; i++) {
      const intermediateThrowEventId = intermediateThrowEvents[i].getAttribute("id");
      console.log("intermediateThrowEventId:", intermediateThrowEventId);
      const name = intermediateThrowEvents[i].getElementsByTagNameNS(bpmnNamespace, "name");
      console.log("name:", name);
      const incoming = intermediateThrowEvents[i].getElementsByTagNameNS(bpmnNamespace, "incoming");
      console.log("incoming:", incoming);
      for (let j = 0; j < incoming.length; j++) {
        console.log("incoming:", incoming[j].textContent);
      }
      const outgoing = intermediateThrowEvents[i].getElementsByTagNameNS(bpmnNamespace, "outgoing");
      console.log("outgoing:", outgoing);
      for (let j = 0; j < outgoing.length; j++) {
        console.log("outgoing:", outgoing[j].textContent);
      }
      if (intermediateThrowEvents[i].getElementsByTagNameNS(bpmnNamespace, "messageEventDefinition").length > 0) {
        this.addIntermediateMessageThrowEvent(intermediateThrowEventId);
      } else if (intermediateThrowEvents[i].getElementsByTagNameNS(bpmnNamespace, "escalationEventDefinition").length > 0) {
        this.addIntermediateEscalationEvent(intermediateThrowEventId);
      } else if (intermediateThrowEvents[i].getElementsByTagNameNS(bpmnNamespace, "linkEventDefinition").length > 0) {
        this.addIntermediateLinkThrowEvent(intermediateThrowEventId);
      } else if (intermediateThrowEvents[i].getElementsByTagNameNS(bpmnNamespace, "compensateEventDefinition").length > 0) {
        this.addIntermediateCompensationEvent(intermediateThrowEventId);
      } else if (intermediateThrowEvents[i].getElementsByTagNameNS(bpmnNamespace, "signalEventDefinition").length > 0) {
        this.addIntermediateSignalThrowEvent(intermediateThrowEventId);
      } else {
        this.addIntermediateEvent(intermediateThrowEventId);
      }
    }
    const tasks = xmlDoc.getElementsByTagNameNS(bpmnNamespace, "task");
    for (let i = 0; i < tasks.length; i++) {
      const taskId = tasks[i].getAttribute("id");
      console.log("taskId:", taskId);
      const name = tasks[i].getAttribute("name");
      console.log("name:", name);
      const incoming = tasks[i].getElementsByTagNameNS(bpmnNamespace, "incoming");
      console.log("incoming:", incoming);
      for (let j = 0; j < incoming.length; j++) {
        console.log("incoming:", incoming[j].textContent);
      }
      const outgoing = tasks[i].getElementsByTagNameNS(bpmnNamespace, "outgoing");
      console.log("outgoing:", outgoing);
      for (let j = 0; j < outgoing.length; j++) {
        console.log("outgoing:", outgoing[j].textContent);
      }
      this.addTask(taskId).addWrappedText(name);
    }
    const manualTasks = xmlDoc.getElementsByTagNameNS(bpmnNamespace, "manualTask");
    for (let i = 0; i < manualTasks.length; i++) {
      const manualTaskId = manualTasks[i].getAttribute("id");
      console.log("manualTaskId:", manualTaskId);
      const name = manualTasks[i].getAttribute("name");
      console.log("name:", name);
      const incoming = manualTasks[i].getElementsByTagNameNS(bpmnNamespace, "incoming");
      console.log("incoming:", incoming);
      for (let j = 0; j < incoming.length; j++) {
        console.log("incoming:", incoming[j].textContent);
      }
      const outgoing = manualTasks[i].getElementsByTagNameNS(bpmnNamespace, "outgoing");
      console.log("outgoing:", outgoing);
      for (let j = 0; j < outgoing.length; j++) {
        console.log("outgoing:", outgoing[j].textContent);
      }
      this.addManualTask(manualTaskId).addWrappedText(name);
    }
    const userTasks = xmlDoc.getElementsByTagNameNS(bpmnNamespace, "userTask");
    for (let i = 0; i < userTasks.length; i++) {
      const userTaskId = userTasks[i].getAttribute("id");
      console.log("userTaskId:", userTaskId);
      const name = userTasks[i].getAttribute("name");
      console.log("name:", name);
      const incoming = userTasks[i].getElementsByTagNameNS(bpmnNamespace, "incoming");
      console.log("incoming:", incoming);
      for (let j = 0; j < incoming.length; j++) {
        console.log("incoming:", incoming[j].textContent);
      }
      const outgoing = userTasks[i].getElementsByTagNameNS(bpmnNamespace, "outgoing");
      console.log("outgoing:", outgoing);
      for (let j = 0; j < outgoing.length; j++) {
        console.log("outgoing:", outgoing[j].textContent);
      }
      this.addUserTask(userTaskId).addWrappedText(name);
    }
    const scriptTasks = xmlDoc.getElementsByTagNameNS(bpmnNamespace, "scriptTask");
    for (let i = 0; i < scriptTasks.length; i++) {
      const scriptTaskId = scriptTasks[i].getAttribute("id");
      console.log("scriptTaskId:", scriptTaskId);
      const name = scriptTasks[i].getAttribute("name");
      console.log("name:", name);
      const incoming = scriptTasks[i].getElementsByTagNameNS(bpmnNamespace, "incoming");
      console.log("incoming:", incoming);
      for (let j = 0; j < incoming.length; j++) {
        console.log("incoming:", incoming[j].textContent);
      }
      const outgoing = scriptTasks[i].getElementsByTagNameNS(bpmnNamespace, "outgoing");
      console.log("outgoing:", outgoing);
      for (let j = 0; j < outgoing.length; j++) {
        console.log("outgoing:", outgoing[j].textContent);
      }
      this.addScriptTask(scriptTaskId).addWrappedText(name);
    }
    const businessRuleTasks = xmlDoc.getElementsByTagNameNS(bpmnNamespace, "businessRuleTask");
    for (let i = 0; i < businessRuleTasks.length; i++) {
      const businessRuleTaskId = businessRuleTasks[i].getAttribute("id");
      console.log("businessRuleTaskId:", businessRuleTaskId);
      const name = businessRuleTasks[i].getAttribute("name");
      console.log("name:", name);
      const incoming = businessRuleTasks[i].getElementsByTagNameNS(bpmnNamespace, "incoming");
      console.log("incoming:", incoming);
      for (let j = 0; j < incoming.length; j++) {
        console.log("incoming:", incoming[j].textContent);
      }
      const outgoing = businessRuleTasks[i].getElementsByTagNameNS(bpmnNamespace, "outgoing");
      console.log("outgoing:", outgoing);
      for (let j = 0; j < outgoing.length; j++) {
        console.log("outgoing:", outgoing[j].textContent);
      }
      this.addBusinessRuleTask(businessRuleTaskId).addWrappedText(name);
    }
    const serviceTasks = xmlDoc.getElementsByTagNameNS(bpmnNamespace, "serviceTask");
    for (let i = 0; i < serviceTasks.length; i++) {
      const serviceTaskId = serviceTasks[i].getAttribute("id");
      console.log("serviceTaskId:", serviceTaskId);
      const name = serviceTasks[i].getAttribute("name");
      console.log("name:", name);
      const incoming = serviceTasks[i].getElementsByTagNameNS(bpmnNamespace, "incoming");
      console.log("incoming:", incoming);
      for (let j = 0; j < incoming.length; j++) {
        console.log("incoming:", incoming[j].textContent);
      }
      const outgoing = serviceTasks[i].getElementsByTagNameNS(bpmnNamespace, "outgoing");
      console.log("outgoing:", outgoing);
      for (let j = 0; j < outgoing.length; j++) {
        console.log("outgoing:", outgoing[j].textContent);
      }
      this.addServiceTask(serviceTaskId).addWrappedText(name);
    }
    const sendTasks = xmlDoc.getElementsByTagNameNS(bpmnNamespace, "sendTask");
    for (let i = 0; i < sendTasks.length; i++) {
      const sendTaskId = sendTasks[i].getAttribute("id");
      console.log("sendTaskId:", sendTaskId);
      const name = sendTasks[i].getAttribute("name");
      console.log("name:", name);
      const incoming = sendTasks[i].getElementsByTagNameNS(bpmnNamespace, "incoming");
      console.log("incoming:", incoming);
      for (let j = 0; j < incoming.length; j++) {
        console.log("incoming:", incoming[j].textContent);
      }
      const outgoing = sendTasks[i].getElementsByTagNameNS(bpmnNamespace, "outgoing");
      console.log("outgoing:", outgoing);
      for (let j = 0; j < outgoing.length; j++) {
        console.log("outgoing:", outgoing[j].textContent);
      }
      this.addSendTask(sendTaskId).addWrappedText(name);
    }
    const receiveTasks = xmlDoc.getElementsByTagNameNS(bpmnNamespace, "receiveTask");
    for (let i = 0; i < receiveTasks.length; i++) {
      const receiveTaskId = receiveTasks[i].getAttribute("id");
      console.log("receiveTaskId:", receiveTaskId);
      const name = receiveTasks[i].getAttribute("name");
      console.log("name:", name);
      const incoming = receiveTasks[i].getElementsByTagNameNS(bpmnNamespace, "incoming");
      console.log("incoming:", incoming);
      for (let j = 0; j < incoming.length; j++) {
        console.log("incoming:", incoming[j].textContent);
      }
      const outgoing = receiveTasks[i].getElementsByTagNameNS(bpmnNamespace, "outgoing");
      console.log("outgoing:", outgoing);
      for (let j = 0; j < outgoing.length; j++) {
        console.log("outgoing:", outgoing[j].textContent);
      }
      this.addReceiveTask(receiveTaskId).addWrappedText(name);
    }
    const inclusiveGateways = xmlDoc.getElementsByTagNameNS(bpmnNamespace, "inclusiveGateway");
    for (let i = 0; i < inclusiveGateways.length; i++) {
      const gatewayId = inclusiveGateways[i].getAttribute("id");
      console.log("gatewayId:", gatewayId);
      const name = inclusiveGateways[i].getAttribute("name");
      console.log("name:", name);
      const incoming = inclusiveGateways[i].getElementsByTagNameNS(bpmnNamespace, "incoming");
      console.log("incoming:", incoming);
      for (let j = 0; j < incoming.length; j++) {
        console.log("incoming:", incoming[j].textContent);
      }
      const outgoing = inclusiveGateways[i].getElementsByTagNameNS(bpmnNamespace, "outgoing");
      console.log("outgoing:", outgoing);
      for (let j = 0; j < outgoing.length; j++) {
        console.log("outgoing:", outgoing[j].textContent);
      }
      this.addInclusiveGateway(gatewayId);
    }
    const exclusiveGateways = xmlDoc.getElementsByTagNameNS(bpmnNamespace, "exclusiveGateway");
    for (let i = 0; i < exclusiveGateways.length; i++) {
      const gatewayId = exclusiveGateways[i].getAttribute("id");
      console.log("gatewayId:", gatewayId);
      const name = exclusiveGateways[i].getAttribute("name");
      console.log("name:", name);
      const incoming = exclusiveGateways[i].getElementsByTagNameNS(bpmnNamespace, "incoming");
      console.log("incoming:", incoming);
      for (let j = 0; j < incoming.length; j++) {
        console.log("incoming:", incoming[j].textContent);
      }
      const outgoing = exclusiveGateways[i].getElementsByTagNameNS(bpmnNamespace, "outgoing");
      console.log("outgoing:", outgoing);
      for (let j = 0; j < outgoing.length; j++) {
        console.log("outgoing:", outgoing[j].textContent);
      }
      this.addExclusiveGateway(gatewayId);
    }
    const parallelGateways = xmlDoc.getElementsByTagNameNS(bpmnNamespace, "parallelGateway");
    for (let i = 0; i < parallelGateways.length; i++) {
      const gatewayId = parallelGateways[i].getAttribute("id");
      console.log("gatewayId:", gatewayId);
      const name = parallelGateways[i].getAttribute("name");
      console.log("name:", name);
      const incoming = parallelGateways[i].getElementsByTagNameNS(bpmnNamespace, "incoming");
      console.log("incoming:", incoming);
      for (let j = 0; j < incoming.length; j++) {
        console.log("incoming:", incoming[j].textContent);
      }
      const outgoing = parallelGateways[i].getElementsByTagNameNS(bpmnNamespace, "outgoing");
      console.log("outgoing:", outgoing);
      for (let j = 0; j < outgoing.length; j++) {
        console.log("outgoing:", outgoing[j].textContent);
      }
      this.addParallelGateway(gatewayId);
    }
    const eventBasedGateways = xmlDoc.getElementsByTagNameNS(bpmnNamespace, "eventBasedGateway");
    for (let i = 0; i < eventBasedGateways.length; i++) {
      const gatewayId = eventBasedGateways[i].getAttribute("id");
      console.log("gatewayId:", gatewayId);
      const name = eventBasedGateways[i].getAttribute("name");
      console.log("name:", name);
      const incoming = eventBasedGateways[i].getElementsByTagNameNS(bpmnNamespace, "incoming");
      console.log("incoming:", incoming);
      for (let j = 0; j < incoming.length; j++) {
        console.log("incoming:", incoming[j].textContent);
      }
      const outgoing = eventBasedGateways[i].getElementsByTagNameNS(bpmnNamespace, "outgoing");
      console.log("outgoing:", outgoing);
      for (let j = 0; j < outgoing.length; j++) {
        console.log("outgoing:", outgoing[j].textContent);
      }
      this.addEventBasedGateway(gatewayId);
    }
    const complexGateways = xmlDoc.getElementsByTagNameNS(bpmnNamespace, "complexGateway");
    for (let i = 0; i < complexGateways.length; i++) {
      const gatewayId = complexGateways[i].getAttribute("id");
      console.log("gatewayId:", gatewayId);
      const name = complexGateways[i].getAttribute("name");
      console.log("name:", name);
      const incoming = complexGateways[i].getElementsByTagNameNS(bpmnNamespace, "incoming");
      console.log("incoming:", incoming);
      for (let j = 0; j < incoming.length; j++) {
        console.log("incoming:", incoming[j].textContent);
      }
      const outgoing = complexGateways[i].getElementsByTagNameNS(bpmnNamespace, "outgoing");
      console.log("outgoing:", outgoing);
      for (let j = 0; j < outgoing.length; j++) {
        console.log("outgoing:", outgoing[j].textContent);
      }
      this.addComplexGateway(gatewayId);
    }
    const sequenceFlows = xmlDoc.getElementsByTagNameNS(bpmnNamespace, "sequenceFlow");
    for (let i = 0; i < sequenceFlows.length; i++) {
      const sequenceFlowId = sequenceFlows[i].getAttribute("id");
      console.log("sequenceFlowId:", sequenceFlowId);
      const name = sequenceFlows[i].getAttribute("name");
      console.log("name:", name);
      const sourceRef = sequenceFlows[i].getAttribute("sourceRef");
      console.log("sourceRef:", sourceRef);
      const targetRef = sequenceFlows[i].getAttribute("targetRef");
      console.log("targetRef:", targetRef);
    }
    const bpmnShapes = xmlDoc.getElementsByTagNameNS(bpmndiNamespace, "BPMNShape");
    for (let i = 0; i < bpmnShapes.length; i++) {
      const bpmnShape = bpmnShapes[i];
      const bpmnShapeId = bpmnShape.getAttribute("id");
      const bpmnElementId = bpmnShape.getAttribute("bpmnElement");
      const bounds = bpmnShape.getElementsByTagNameNS(dcNamespace, "Bounds")[0];
      if (bounds) {
        const x = parseFloat(bounds.getAttribute("x"));
        const y = parseFloat(bounds.getAttribute("y")) * -1;
        const width = parseFloat(bounds.getAttribute("width"));
        const height = parseFloat(bounds.getAttribute("height"));
        console.log(`BPMNShape: ${bpmnShapeId}, ${bpmnElementId}, x: ${x}, y: ${y}, width: ${width}, height: ${height}`);
        const position = new Vector3$1(x + width / 2, y - height / 2, 0);
        const element2 = this.getElementById(bpmnElementId);
        if (element2) {
          element2.positionAt(position);
        } else {
          console.warn(`Element with id ${bpmnElementId} not found.`);
        }
        let labelX, labelY, labelWidth, labelHeight;
        const bpmnLabel = bpmnShape.getElementsByTagNameNS(bpmndiNamespace, "BPMNLabel");
        if (bpmnLabel.length > 0) {
          const labelBounds = bpmnLabel[0].getElementsByTagNameNS(dcNamespace, "Bounds")[0];
          if (labelBounds) {
            labelX = parseFloat(labelBounds.getAttribute("x"));
            labelY = parseFloat(labelBounds.getAttribute("y")) * -1;
            labelWidth = parseFloat(labelBounds.getAttribute("width"));
            labelHeight = parseFloat(labelBounds.getAttribute("height"));
            console.log(`Label position (Shape): x: ${labelX}, y: ${labelY}, width: ${labelWidth}, height: ${labelHeight}`);
            const bpmnElement = xmlDoc.getElementById(bpmnElementId);
            const bpmnElementName = bpmnElement.getAttribute("name");
            console.log(`bpmnElementName: ${bpmnElementName}`);
            if (bpmnElementName) {
              const labelPosition = new Vector3$1(labelX + labelWidth / 2, labelY - labelHeight / 2, 0);
              this.addElement(new Element("t1", new TextShape(bpmnElementName))).positionAt(labelPosition);
            }
          }
        }
      }
    }
    const bpmnEdges = xmlDoc.getElementsByTagNameNS(bpmndiNamespace, "BPMNEdge");
    for (let i = 0; i < bpmnEdges.length; i++) {
      const bpmnEdge = bpmnEdges[i];
      const bpmnEdgeId = bpmnEdge.getAttribute("id");
      const bpmnElementId = bpmnEdge.getAttribute("bpmnElement");
      const sequenceFlow = Array.from(sequenceFlows).find((flow) => flow.getAttribute("id") === bpmnElementId);
      const sequenceFlowName = sequenceFlow ? sequenceFlow.getAttribute("name") : null;
      const waypoints = bpmnEdge.getElementsByTagNameNS(diNamespace, "waypoint");
      const connectorPoints = [];
      for (let j = 0; j < waypoints.length; j++) {
        const waypoint = waypoints[j];
        const x = parseFloat(waypoint.getAttribute("x"));
        const y = parseFloat(waypoint.getAttribute("y")) * -1;
        connectorPoints.push(new Vector2$1(x, y));
        console.log(`BPMNEdge: ${bpmnElementId}, x: ${x}, y: ${y}`);
      }
      console.log("connectorPoints:", connectorPoints);
      this.addConnector(this.addFlowConnector(bpmnEdgeId, connectorPoints));
      let labelX, labelY, labelWidth, labelHeight;
      const bpmnLabel = bpmnEdge.getElementsByTagNameNS(bpmndiNamespace, "BPMNLabel");
      if (bpmnLabel.length > 0) {
        const labelBounds = bpmnLabel[0].getElementsByTagNameNS(dcNamespace, "Bounds")[0];
        if (labelBounds) {
          labelX = parseFloat(labelBounds.getAttribute("x"));
          labelY = parseFloat(labelBounds.getAttribute("y")) * -1;
          labelWidth = parseFloat(labelBounds.getAttribute("width"));
          labelHeight = parseFloat(labelBounds.getAttribute("height"));
          console.log(`Label position: x: ${labelX}, y: ${labelY}, width: ${labelWidth}, height: ${labelHeight}`);
        }
      }
      if (sequenceFlowName) {
        const labelPosition = new Vector3$1(labelX + labelWidth / 2, labelY - labelHeight / 2, 0);
        this.addElement(new Element("t1", new TextShape(sequenceFlowName))).positionAt(labelPosition);
      }
    }
    this.arrange();
  }
}
export {
  BpmnDiagram
};
//# sourceMappingURL=bpmn-diagram.es.js.map
