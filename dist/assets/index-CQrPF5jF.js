import{S as _,a as P,E as D,b as C,D as O,h as T,B as F,C as L,c as W,d as x}from"./index-DvipbwNp.js";class q extends _{constructor(t=60,r=16758605){const s=new P,e=t/2;s.moveTo(e*.5,e*.6),s.quadraticCurveTo(e*.8,e*.7,e*.9,e*.15),s.quadraticCurveTo(e*.95,e*-.4,e*.65,e*-.7),s.quadraticCurveTo(e*.2,e*-.9,e*-.4,e*-.65),s.quadraticCurveTo(e*-.85,e*-.45,e*-.8,e*.05),s.quadraticCurveTo(e*-.7,e*.65,e*-.25,e*.75),s.quadraticCurveTo(e*.15,e*.85,e*.5,e*.6);const p=C,E=new D(s,p),i=new O(r);super(E,i),this.width=t,this.height=t}}class A extends _{constructor(t=T.OUTER_RADIUS,r=T.INNER_RADIUS,s=T.NUM_POINTS,e=T.LINE_WIDTH,p=T.CURVE_SEGMENTS){const E=L.ELEMENT_STROKE,i={...C,curveSegments:p};let l=e;i.bevelEnabled&&i.bevelSize>0&&(l=e+2*i.bevelSize);function M(o,n,f){if(o<=0||n<=0||o<=n)return null;const a=new P,h=-Math.PI/2,m=Math.PI*2/f;a.moveTo(o*Math.cos(h),o*Math.sin(h));for(let u=0;u<f;u++){const g=u*m+h;a.lineTo(o*Math.cos(g),o*Math.sin(g));const v=g+m/2;a.lineTo(n*Math.cos(v),n*Math.sin(v))}return a.closePath(),a}const d=M(t,r,s);if(!d){const o=new F(.1,.1,.1),n=new O(L.ELEMENT_SELECTED_FILL);super(o,n),this.name="StarShape_Error";return}const N=d.clone();if(l>0&&l<t){const o=t-l,n=r*(o/t);if(o>0&&n>0&&o>n){const f=M(o,n,s);f&&d.holes.push(f)}}const c=new D(d,i),S=new O(E);super(c,S),this.outerShape=N,this.shapeOuterRadius=t,this.shapeInnerRadius=r,this.shapeNumPoints=s,this.shapeLineWidth=e,this.shapeGeometricLineWidthForHole=l,this.shapeCurveSegments=p,this.shapeDepth=i.depth||C.depth,this.name="StarShape"}getOuterShape(){return this.outerShape}updateDimensions(t,r,s,e,p,E){const i=t||this.shapeOuterRadius,l=r||this.shapeInnerRadius,M=s||this.shapeNumPoints,d=e!==void 0?e:this.shapeLineWidth,N=p!==void 0?p:this.shapeCurveSegments;let c={...C,curveSegments:N};E?c={...c,...E}:this.geometry.parameters&&this.geometry.parameters.options&&(c={...this.geometry.parameters.options,curveSegments:N});let S=d;c.bevelEnabled&&c.bevelSize>0&&(S=d+2*c.bevelSize);function o(a,h,m){if(a<=0||h<=0||a<=h)return null;const u=new P,g=-Math.PI/2,v=Math.PI*2/m;u.moveTo(a*Math.cos(g),a*Math.sin(g));for(let y=0;y<m;y++){const I=y*v+g;u.lineTo(a*Math.cos(I),a*Math.sin(I));const w=I+v/2;u.lineTo(h*Math.cos(w),h*Math.sin(w))}return u.closePath(),u}const n=o(i,l,M);if(!n)return;const f=n.clone();if(S>0&&S<i){const a=i-S,h=l*(a/i);if(a>0&&h>0&&a>h){const m=o(a,h,M);m&&n.holes.push(m)}}this.outerShape=f,this.geometry&&this.geometry.dispose(),this.geometry=new D(n,c),this.shapeOuterRadius=i,this.shapeInnerRadius=l,this.shapeNumPoints=M,this.shapeLineWidth=d,this.shapeGeometricLineWidthForHole=S,this.shapeCurveSegments=N,this.shapeDepth=c.depth||C.depth}updateColor(t){this.material&&this.material.color&&typeof this.material.color.set=="function"?this.material.color.set(t):this.material&&this.material.uniforms&&this.material.uniforms.color&&this.material.uniforms.color.value.set(t)}}class B extends W{constructor(t){super(t),console.log("MyCustomNotationDiagram initialized!")}addMyCustomNode(t,r="Custom Node"){const s=new x(t,new q);return this.addElement(s),r&&s.addWrappedText(r),s}addCustomStarNode(t,r="Star Node"){const s=new x(t,new A);return this.addElement(s),r&&s.addWrappedText(r),s}dispose(){super.dispose()}}const H=b=>{var t=new B(b);return t.addCustomStarNode("node1","Star"),t.addMyCustomNode("node2","Blob").positionRightOf("node1").connectFrom("node1","E","W"),t.addMyCustomNode("node3","Blob 2").positionDownOf("node1").connectFrom("node1","S","N"),t.arrange(),t.fitScreen(),t};export{H as default};
