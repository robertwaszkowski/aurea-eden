import{S as _,a as P,E as D,b as C,D as O,i as T,j as F,C as L,c as W,d as x}from"./index-CM9RPQMB.js";class q extends _{constructor(t=60,s=16758605){const a=new P,e=t/2;a.moveTo(e*.5,e*.6),a.quadraticCurveTo(e*.8,e*.7,e*.9,e*.15),a.quadraticCurveTo(e*.95,e*-.4,e*.65,e*-.7),a.quadraticCurveTo(e*.2,e*-.9,e*-.4,e*-.65),a.quadraticCurveTo(e*-.85,e*-.45,e*-.8,e*.05),a.quadraticCurveTo(e*-.7,e*.65,e*-.25,e*.75),a.quadraticCurveTo(e*.15,e*.85,e*.5,e*.6);const p=C,E=new D(a,p),i=new O(s);super(E,i),this.width=t,this.height=t}}class A extends _{constructor(t=T.OUTER_RADIUS,s=T.INNER_RADIUS,a=T.NUM_POINTS,e=T.LINE_WIDTH,p=T.CURVE_SEGMENTS){const E=L.ELEMENT_STROKE,i={...C,curveSegments:p};let l=e;i.bevelEnabled&&i.bevelSize>0&&(l=e+2*i.bevelSize);function M(n,r,f){if(n<=0||r<=0||n<=r)return null;const o=new P,h=-Math.PI/2,m=Math.PI*2/f;o.moveTo(n*Math.cos(h),n*Math.sin(h));for(let u=0;u<f;u++){const g=u*m+h;o.lineTo(n*Math.cos(g),n*Math.sin(g));const v=g+m/2;o.lineTo(r*Math.cos(v),r*Math.sin(v))}return o.closePath(),o}const d=M(t,s,a);if(!d){const n=new F(.1,.1,.1),r=new O(L.ELEMENT_SELECTED_FILL);super(n,r),this.name="StarShape_Error";return}const N=d.clone();if(l>0&&l<t){const n=t-l,r=s*(n/t);if(n>0&&r>0&&n>r){const f=M(n,r,a);f&&d.holes.push(f)}}const c=new D(d,i),S=new O(E);super(c,S),this.outerShape=N,this.shapeOuterRadius=t,this.shapeInnerRadius=s,this.shapeNumPoints=a,this.shapeLineWidth=e,this.shapeGeometricLineWidthForHole=l,this.shapeCurveSegments=p,this.shapeDepth=i.depth||C.depth,this.name="StarShape"}getOuterShape(){return this.outerShape}updateDimensions(t,s,a,e,p,E){const i=t||this.shapeOuterRadius,l=s||this.shapeInnerRadius,M=a||this.shapeNumPoints,d=e!==void 0?e:this.shapeLineWidth,N=p!==void 0?p:this.shapeCurveSegments;let c={...C,curveSegments:N};E?c={...c,...E}:this.geometry.parameters&&this.geometry.parameters.options&&(c={...this.geometry.parameters.options,curveSegments:N});let S=d;c.bevelEnabled&&c.bevelSize>0&&(S=d+2*c.bevelSize);function n(o,h,m){if(o<=0||h<=0||o<=h)return null;const u=new P,g=-Math.PI/2,v=Math.PI*2/m;u.moveTo(o*Math.cos(g),o*Math.sin(g));for(let y=0;y<m;y++){const I=y*v+g;u.lineTo(o*Math.cos(I),o*Math.sin(I));const w=I+v/2;u.lineTo(h*Math.cos(w),h*Math.sin(w))}return u.closePath(),u}const r=n(i,l,M);if(!r)return;const f=r.clone();if(S>0&&S<i){const o=i-S,h=l*(o/i);if(o>0&&h>0&&o>h){const m=n(o,h,M);m&&r.holes.push(m)}}this.outerShape=f,this.geometry&&this.geometry.dispose(),this.geometry=new D(r,c),this.shapeOuterRadius=i,this.shapeInnerRadius=l,this.shapeNumPoints=M,this.shapeLineWidth=d,this.shapeGeometricLineWidthForHole=S,this.shapeCurveSegments=N,this.shapeDepth=c.depth||C.depth}updateColor(t){this.material&&this.material.color&&typeof this.material.color.set=="function"?this.material.color.set(t):this.material&&this.material.uniforms&&this.material.uniforms.color&&this.material.uniforms.color.value.set(t)}}class G extends W{constructor(t,s={}){super(t,s),console.log("MyCustomNotationDiagram initialized!")}addMyCustomNode(t,s="Custom Node"){const a=new x(t,new q);return this.addElement(a),s&&a.addWrappedText(s),a}addCustomStarNode(t,s="Star Node"){const a=new x(t,new A);return this.addElement(a),s&&a.addWrappedText(s),a}dispose(){super.dispose()}}const H=(b,t={})=>{var s=new G(b,t);return s.addCustomStarNode("node1","Star"),s.addMyCustomNode("node2","Blob").positionRightOf("node1").connectFrom("node1","E","W"),s.addMyCustomNode("node3","Blob 2").positionDownOf("node1").connectFrom("node1","S","N"),s.arrange(),s.fitScreen(),s};export{H as default};
