import{S as e,a as t,E as s,b as o,D as a,c as i,B as n,C as r,d as h,e as u}from"./BasicShapeConstants-Bg88hVVq.js";class d extends e{constructor(e=60,i=16758605){const n=new t,r=e/2;n.moveTo(.5*r,.6*r),n.quadraticCurveTo(.8*r,.7*r,.9*r,.15*r),n.quadraticCurveTo(.95*r,-.4*r,.65*r,-.7*r),n.quadraticCurveTo(.2*r,-.9*r,-.4*r,-.65*r),n.quadraticCurveTo(-.85*r,-.45*r,-.8*r,.05*r),n.quadraticCurveTo(-.7*r,.65*r,-.25*r,.75*r),n.quadraticCurveTo(.15*r,.85*r,.5*r,.6*r);super(new s(n,o),new a(i)),this.width=e,this.height=e}}class c extends e{constructor(e=i.OUTER_RADIUS,h=i.INNER_RADIUS,u=i.NUM_POINTS,d=i.LINE_WIDTH,c=i.CURVE_SEGMENTS){const p=r.ELEMENT_STROKE,l={...o,curveSegments:c};let m=d;function S(e,s,o){if(e<=0||s<=0||e<=s)return null;const a=new t,i=-Math.PI/2,n=2*Math.PI/o;a.moveTo(e*Math.cos(i),e*Math.sin(i));for(let t=0;t<o;t++){const o=t*n+i;a.lineTo(e*Math.cos(o),e*Math.sin(o));const r=o+n/2;a.lineTo(s*Math.cos(r),s*Math.sin(r))}return a.closePath(),a}l.bevelEnabled&&l.bevelSize>0&&(m=d+2*l.bevelSize);const v=S(e,h,u);if(!v){return super(new n(.1,.1,.1),new a(r.ELEMENT_SELECTED_FILL)),void(this.name="StarShape_Error")}const M=v.clone();if(m>0&&m<e){const t=e-m,s=h*(t/e);if(t>0&&s>0&&t>s){const e=S(t,s,u);e&&v.holes.push(e)}}super(new s(v,l),new a(p)),this.outerShape=M,this.shapeOuterRadius=e,this.shapeInnerRadius=h,this.shapeNumPoints=u,this.shapeLineWidth=d,this.shapeGeometricLineWidthForHole=m,this.shapeCurveSegments=c,this.shapeDepth=l.depth||o.depth,this.name="StarShape"}getOuterShape(){return this.outerShape}updateDimensions(e,a,i,n,r,h){const u=e||this.shapeOuterRadius,d=a||this.shapeInnerRadius,c=i||this.shapeNumPoints,p=void 0!==n?n:this.shapeLineWidth,l=void 0!==r?r:this.shapeCurveSegments;let m={...o,curveSegments:l};h?m={...m,...h}:this.geometry.parameters&&this.geometry.parameters.options&&(m={...this.geometry.parameters.options,curveSegments:l});let S=p;function v(e,s,o){if(e<=0||s<=0||e<=s)return null;const a=new t,i=-Math.PI/2,n=2*Math.PI/o;a.moveTo(e*Math.cos(i),e*Math.sin(i));for(let t=0;t<o;t++){const o=t*n+i;a.lineTo(e*Math.cos(o),e*Math.sin(o));const r=o+n/2;a.lineTo(s*Math.cos(r),s*Math.sin(r))}return a.closePath(),a}m.bevelEnabled&&m.bevelSize>0&&(S=p+2*m.bevelSize);const M=v(u,d,c);if(!M)return;const E=M.clone();if(S>0&&S<u){const e=u-S,t=d*(e/u);if(e>0&&t>0&&e>t){const s=v(e,t,c);s&&M.holes.push(s)}}this.outerShape=E,this.geometry&&this.geometry.dispose(),this.geometry=new s(M,m),this.shapeOuterRadius=u,this.shapeInnerRadius=d,this.shapeNumPoints=c,this.shapeLineWidth=p,this.shapeGeometricLineWidthForHole=S,this.shapeCurveSegments=l,this.shapeDepth=m.depth||o.depth}updateColor(e){this.material&&this.material.color&&"function"==typeof this.material.color.set?this.material.color.set(e):this.material&&this.material.uniforms&&this.material.uniforms.color&&this.material.uniforms.color.value.set(e)}}class p extends h{constructor(e){super(e),console.log("MyCustomNotationDiagram initialized!")}addMyCustomNode(e,t="Custom Node"){const s=new u(e,new d);return this.addElement(s),t&&s.addWrappedText(t),s}addCustomStarNode(e,t="Star Node"){const s=new u(e,new c);return this.addElement(s),t&&s.addWrappedText(t),s}dispose(){super.dispose()}}const l=e=>{var t=new p(e);return t.addCustomStarNode("node1","Star"),t.addMyCustomNode("node2","Blob").positionRightOf("node1").connectFrom("node1","E","W"),t.addMyCustomNode("node3","Blob 2").positionDownOf("node1").connectFrom("node1","S","N"),t.arrange(),t.fitScreen(),t};export{l as default};
