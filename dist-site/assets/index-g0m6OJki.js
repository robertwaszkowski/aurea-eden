import{S as e,a as t,E as s,b as o,D as i,i as a,j as n,C as r,c as h,d}from"./index-N8b5nZgQ.js";class u extends e{constructor(e=60,a=16758605){const n=new t,r=e/2;n.moveTo(.5*r,.6*r),n.quadraticCurveTo(.8*r,.7*r,.9*r,.15*r),n.quadraticCurveTo(.95*r,-.4*r,.65*r,-.7*r),n.quadraticCurveTo(.2*r,-.9*r,-.4*r,-.65*r),n.quadraticCurveTo(-.85*r,-.45*r,-.8*r,.05*r),n.quadraticCurveTo(-.7*r,.65*r,-.25*r,.75*r),n.quadraticCurveTo(.15*r,.85*r,.5*r,.6*r);super(new s(n,o),new i(a)),this.width=e,this.height=e}}class c extends e{constructor(e=a.OUTER_RADIUS,h=a.INNER_RADIUS,d=a.NUM_POINTS,u=a.LINE_WIDTH,c=a.CURVE_SEGMENTS){const p=r.ELEMENT_STROKE,l={...o,curveSegments:c};let m=u;function S(e,s,o){if(e<=0||s<=0||e<=s)return null;const i=new t,a=-Math.PI/2,n=2*Math.PI/o;i.moveTo(e*Math.cos(a),e*Math.sin(a));for(let t=0;t<o;t++){const o=t*n+a;i.lineTo(e*Math.cos(o),e*Math.sin(o));const r=o+n/2;i.lineTo(s*Math.cos(r),s*Math.sin(r))}return i.closePath(),i}l.bevelEnabled&&l.bevelSize>0&&(m=u+2*l.bevelSize);const v=S(e,h,d);if(!v){return super(new n(.1,.1,.1),new i(r.ELEMENT_SELECTED_FILL)),void(this.name="StarShape_Error")}const M=v.clone();if(m>0&&m<e){const t=e-m,s=h*(t/e);if(t>0&&s>0&&t>s){const e=S(t,s,d);e&&v.holes.push(e)}}super(new s(v,l),new i(p)),this.outerShape=M,this.shapeOuterRadius=e,this.shapeInnerRadius=h,this.shapeNumPoints=d,this.shapeLineWidth=u,this.shapeGeometricLineWidthForHole=m,this.shapeCurveSegments=c,this.shapeDepth=l.depth||o.depth,this.name="StarShape"}getOuterShape(){return this.outerShape}updateDimensions(e,i,a,n,r,h){const d=e||this.shapeOuterRadius,u=i||this.shapeInnerRadius,c=a||this.shapeNumPoints,p=void 0!==n?n:this.shapeLineWidth,l=void 0!==r?r:this.shapeCurveSegments;let m={...o,curveSegments:l};h?m={...m,...h}:this.geometry.parameters&&this.geometry.parameters.options&&(m={...this.geometry.parameters.options,curveSegments:l});let S=p;function v(e,s,o){if(e<=0||s<=0||e<=s)return null;const i=new t,a=-Math.PI/2,n=2*Math.PI/o;i.moveTo(e*Math.cos(a),e*Math.sin(a));for(let t=0;t<o;t++){const o=t*n+a;i.lineTo(e*Math.cos(o),e*Math.sin(o));const r=o+n/2;i.lineTo(s*Math.cos(r),s*Math.sin(r))}return i.closePath(),i}m.bevelEnabled&&m.bevelSize>0&&(S=p+2*m.bevelSize);const M=v(d,u,c);if(!M)return;const E=M.clone();if(S>0&&S<d){const e=d-S,t=u*(e/d);if(e>0&&t>0&&e>t){const s=v(e,t,c);s&&M.holes.push(s)}}this.outerShape=E,this.geometry&&this.geometry.dispose(),this.geometry=new s(M,m),this.shapeOuterRadius=d,this.shapeInnerRadius=u,this.shapeNumPoints=c,this.shapeLineWidth=p,this.shapeGeometricLineWidthForHole=S,this.shapeCurveSegments=l,this.shapeDepth=m.depth||o.depth}updateColor(e){this.material&&this.material.color&&"function"==typeof this.material.color.set?this.material.color.set(e):this.material&&this.material.uniforms&&this.material.uniforms.color&&this.material.uniforms.color.value.set(e)}}class p extends h{constructor(e,t={}){super(e,t),console.log("MyCustomNotationDiagram initialized!")}addMyCustomNode(e,t="Custom Node"){const s=new d(e,new u);return this.addElement(s),t&&s.addWrappedText(t),s}addCustomStarNode(e,t="Star Node"){const s=new d(e,new c);return this.addElement(s),t&&s.addWrappedText(t),s}dispose(){super.dispose()}}const l=(e,t={})=>{var s=new p(e,t);return s.addCustomStarNode("node1","Star"),s.addMyCustomNode("node2","Blob").positionRightOf("node1").connectFrom("node1","E","W"),s.addMyCustomNode("node3","Blob 2").positionDownOf("node1").connectFrom("node1","S","N"),s.arrange(),s.fitScreen(),s};export{l as default};
